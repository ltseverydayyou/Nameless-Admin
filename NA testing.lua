--[[


─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
─██████████████─██████████████─██████████████─██████████████────██████████████───██████──██████─██████████─██████─────────████████████───
─██░░░░░░░░░░██─██░░░░░░░░░░██─██░░░░░░░░░░██─██░░░░░░░░░░██────██░░░░░░░░░░██───██░░██──██░░██─██░░░░░░██─██░░██─────────██░░░░░░░░████─
─██████░░██████─██░░██████████─██░░██████████─██████░░██████────██░░██████░░██───██░░██──██░░██─████░░████─██░░██─────────██░░████░░░░██─
─────██░░██─────██░░██─────────██░░██─────────────██░░██────────██░░██──██░░██───██░░██──██░░██───██░░██───██░░██─────────██░░██──██░░██─
─────██░░██─────██░░██████████─██░░██████████─────██░░██────────██░░██████░░████─██░░██──██░░██───██░░██───██░░██─────────██░░██──██░░██─
─────██░░██─────██░░░░░░░░░░██─██░░░░░░░░░░██─────██░░██────────██░░░░░░░░░░░░██─██░░██──██░░██───██░░██───██░░██─────────██░░██──██░░██─
─────██░░██─────██░░██████████─██████████░░██─────██░░██────────██░░████████░░██─██░░██──██░░██───██░░██───██░░██─────────██░░██──██░░██─
─────██░░██─────██░░██─────────────────██░░██─────██░░██────────██░░██────██░░██─██░░██──██░░██───██░░██───██░░██─────────██░░██──██░░██─
─────██░░██─────██░░██████████─██████████░░██─────██░░██────────██░░████████░░██─██░░██████░░██─████░░████─██░░██████████─██░░████░░░░██─
─────██░░██─────██░░░░░░░░░░██─██░░░░░░░░░░██─────██░░██────────██░░░░░░░░░░░░██─██░░░░░░░░░░██─██░░░░░░██─██░░░░░░░░░░██─██░░░░░░░░████─
─────██████─────██████████████─██████████████─────██████────────████████████████─██████████████─██████████─██████████████─████████████───
─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────


]]

if getgenv().ltseverydayyou_NA~=nil then return end
pcall(function() getgenv().ltseverydayyou_NA=true; getgenv().NATestingVer=true; getgenv().NAverify="Haryas Admin Is SKIDDED AS FUCK"; end)

NAbegin=tick()
CMDAUTOFILL = {}

local NAmanage={}

Lower    = string.lower
Sub      = string.sub
GSub     = string.gsub
Find     = string.find
Match    = string.match
Format   = string.format

Unpack   = table.unpack
Insert   = table.insert
Concat   = table.concat
Discover = table.find

Spawn    = task.spawn
Delay    = task.delay
Wait     = task.wait
Defer    = task.defer

local Notify = nil
local Window = nil
local Popup  = nil

local TAB_ALL = "All"
local TAB_GENERAL = "General"
local TAB_INTEGRATIONS = "Integrations"
local TAB_INTERFACE = "Interface"
local TAB_FFLAGS = "FFlags"
local TAB_USER_BUTTONS = "User Buttons"
local TAB_LOGGING = "Logging"
local TAB_ESP = "ESP"
local TAB_CHAT = "Chat"
local TAB_CHARACTER = "Character"
local TAB_KEYBINDS = "Keybinds"
local TAB_COMMAND_KEYBINDS = "Command Keybinds"
local TAB_BASIC_INFO = "Basic Info"
local TAB_ROBLOX_DATA = "Roblox Data"
local TAB_ADMIN_INFO = "Admin Info"
local opt

local LoadstringCommandAliases = {
	loadstring = true;
	ls = true;
	lstring = true;
	loads = true;
	execute = true;
};

local NA_SRV = setmetatable({}, {
	__index = function(self, name)
		local Reference = cloneref and type(cloneref) == "function" and cloneref or function(ref) return ref end
		local ok, svc = pcall(function()
			return Reference(game:GetService(name))
		end)
		if ok and svc then
			rawset(self, name, svc)
			return svc
		end
	end
})

function SafeGetService(name)
	return NA_SRV[name]
end

NAmanage.waitForPlay=function()
	local function ready()
		local ok, playersSvc = pcall(game.GetService, game, "Players")
		if not ok or not playersSvc then
			return nil
		end
		local localPlayer = playersSvc.LocalPlayer
		if not localPlayer or not localPlayer.Parent then
			return nil
		end
		local placeId = tonumber(game.PlaceId) or 0
		local gameId = tonumber(game.GameId) or 0
		if placeId == 0 and gameId == 0 then
			return nil
		end
		return localPlayer
	end

	local function safeReady()
		local ok, result = pcall(ready)
		if ok then
			return result
		else
			return nil
		end
	end

	local localPlayer = safeReady()
	if localPlayer then
		return localPlayer
	end

	while not localPlayer do
		Wait(0.1)
		localPlayer = safeReady()
	end

	return localPlayer
end

NAmanage.waitForPlay() -- avoid running in the App Shell before a real place loads

local SpawnCall=function(pp)Spawn(function() pcall(pp) end)end -- idk why but solara just fucked up when executing scripts (this is a sort of a fix ig)

local mainName = 'Nameless Admin'
local testingName = 'NA Testing'
local adminName = 'NA'

NAmanage.syncNameGlobals=function()
	local env = (getgenv and getgenv()) or _G
	if not env then
		return
	end
	env.mainName = mainName
	env.testingName = testingName
	env.adminName = adminName
end

pcall(NAmanage.syncNameGlobals)

local connections = {}
NAlib = NAlib or {}

NAlib.connect = function(name, connection)
	connections[name] = connections[name] or {}
	Insert(connections[name], connection)
	return connection
end

NAlib.disconnect = function(name)
	if connections[name] then
		for _, conn in ipairs(connections[name]) do
			conn:Disconnect()
		end
		connections[name] = nil
	end
end

NAlib.isConnected = function(name)
	return connections[name] ~= nil
end

NAlib.isProperty = function(inst, prop)
	local s, r = pcall(function() return inst[prop] end)
	if not s then return nil end
	return r
end

NAlib.setProperty = function(inst, prop, v)
	local s, _ = pcall(function() inst[prop] = v end)
	return s
end

local HttpService = SafeGetService('HttpService');
local Players = SafeGetService("Players");
local UserInputService = SafeGetService("UserInputService");
local TweenService = SafeGetService("TweenService");
local RunService = SafeGetService("RunService");
local ContextActionService = SafeGetService("ContextActionService");
local TeleportService = SafeGetService("TeleportService");
local Lighting = SafeGetService("Lighting");
local ReplicatedStorage = SafeGetService("ReplicatedStorage");
local COREGUI = SafeGetService("CoreGui");
local SoundService = SafeGetService("SoundService");
local TextChatService = SafeGetService("TextChatService");
local TextService = SafeGetService("TextService");
local StarterGui = SafeGetService("StarterGui");
local ContentProvider = SafeGetService("ContentProvider");
local LocalizationService = SafeGetService("LocalizationService");
local MarketplaceService = SafeGetService("MarketplaceService");
local GuiService = SafeGetService("GuiService");

NAStuff = NAStuff or {}
NAStuff.CmdBar2 = NAStuff.CmdBar2 or {
	defaultWidth = 340;
	defaultHeight = 78;
	minWidth = 200;
	maxWidth = 800;
	minHeight = 70;
	maxHeight = 160;
	topHeight = 26;
	bodyOffsetY = 34;
	bodyBottomPadding = 8;
	bodyMinHeight = 24;
}

function NAmanage.CmdBar2ClampValue(value, minValue, maxValue, fallback)
	local numberValue = tonumber(value)
	if not numberValue then
		return fallback
	end
	numberValue = math.floor(numberValue + 0.5)
	if numberValue < minValue then
		return minValue
	elseif numberValue > maxValue then
		return maxValue
	end
	return numberValue
end

function NAmanage.CmdBar2ComputeBodyHeight(totalHeight)
	local cfg = NAStuff.CmdBar2 or {}
	local available = totalHeight - (cfg.bodyOffsetY or 0) - (cfg.bodyBottomPadding or 0)
	if available < (cfg.bodyMinHeight or 0) then
		return cfg.bodyMinHeight or 0
	end
	return available
end

local CustomFunctionSupport = isfile and isfolder and writefile and readfile and listfiles and appendfile;
local FileSupport = isfile and isfolder and writefile and readfile and makefolder;

local IsOnMobile=(function()
	local platform=UserInputService:GetPlatform()
	if platform==Enum.Platform.IOS or platform==Enum.Platform.Android or platform==Enum.Platform.AndroidTV or platform==Enum.Platform.Chromecast or platform==Enum.Platform.MetaOS then
		return true
	end
	if platform==Enum.Platform.None then
		return UserInputService.TouchEnabled and not (UserInputService.KeyboardEnabled or UserInputService.MouseEnabled)
	end
	return false
end)()
local IsOnPC=(function()
	local platform=UserInputService:GetPlatform()
	if platform==Enum.Platform.Windows or platform==Enum.Platform.OSX or platform==Enum.Platform.Linux or platform==Enum.Platform.SteamOS or platform==Enum.Platform.UWP or platform==Enum.Platform.DOS or platform==Enum.Platform.BeOS then
		return true
	end
	if platform==Enum.Platform.None then
		return UserInputService.KeyboardEnabled or UserInputService.MouseEnabled
	end
	return false
end)()

--[[ Character helpers ]]--
NA_GRAB_BODY = (function()
	local T = {};
	local _cache = _rp_cache or setmetatable({}, {
		__mode = "k"
	});
	local overrideModel = nil;
	local overrideConn = nil;
	local selectingOverride = false;
	local setOverrideModel;
	local pickOverrideModel;
	local function asChar(obj)
		if not obj or typeof(obj) ~= "Instance" then
			return nil;
		end;
		if obj:IsA("Player") then
			return obj.Character;
		end;
		if obj:IsA("Model") then
			return obj;
		end;
		return nil;
	end;
	local function firstPart(model)
		for _, d in ipairs(model:GetDescendants()) do
			if d:IsA("BasePart") then
				return d;
			end;
		end;
		return nil;
	end;
	setOverrideModel = function(model)
		if overrideConn then
			overrideConn:Disconnect();
			overrideConn = nil;
		end;
		overrideModel = model;
		if model then
			overrideConn = model.AncestryChanged:Connect(function(_, parent)
				if not parent then
					if overrideConn then
						overrideConn:Disconnect();
						overrideConn = nil;
					end;
					overrideModel = nil;
					selectingOverride = false;
					if Players and Players.LocalPlayer and workspace then
						local lp = Players.LocalPlayer;
						local cur = lp.Character;
						if cur and cur.Parent and (not cur:IsDescendantOf(workspace)) then
							Spawn(function()
								pickOverrideModel();
							end);
						end;
					end;
				end;
			end);
		end;
	end;
	pickOverrideModel = function(force)
		if selectingOverride then
			return overrideModel;
		end;
		if not (Window and Players and Players.LocalPlayer and workspace) then
			return overrideModel;
		end;
		local lp = Players.LocalPlayer;
		local cur = lp.Character;
		if not cur then
			return overrideModel;
		end;
		if not force and cur:IsDescendantOf(workspace) then
			return overrideModel;
		end;
		selectingOverride = true;
		local btns = {};
		local cands = {};
		local seen = {};
		for _, plr in ipairs(Players:GetPlayers()) do
			local ch = plr.Character;
			if ch and ch:IsDescendantOf(workspace) and (not seen[ch]) then
				seen[ch] = true;
				Insert(cands, ch);
			end;
		end;
		for _, inst in ipairs(workspace:GetDescendants()) do
			if inst:IsA("Model") and CheckIfNPC and CheckIfNPC(inst) and (not seen[inst]) then
				seen[inst] = true;
				Insert(cands, inst);
			end;
		end;
		local nCnt = {};
		for i = 1, #cands do
			local m = cands[i];
			local n = m.Name;
			nCnt[n] = (nCnt[n] or 0) + 1;
		end;
		local nUse = {};
		local done = false;
		local function fin()
			if done then
				return;
			end;
			done = true;
			selectingOverride = false;
		end;
		if #cands == 0 then
			Insert(btns, {
				Text = "No characters found",
				Callback = function()
					setOverrideModel(nil);
					fin();
				end
			});
		else
			for i = 1, #cands do
				local m = cands[i];
				local n = m.Name;
				local suffix = "";
				if nCnt[n] and nCnt[n] > 1 then
					nUse[n] = (nUse[n] or 0) + 1;
					suffix = " (" .. nUse[n] .. ")";
				end;
				Insert(btns, {
					Text = n .. suffix,
					Callback = function()
						setOverrideModel(m);
						fin();
					end
				});
			end;
		end;
		Insert(btns, {
			Text = "Cancel",
			Callback = function()
				setOverrideModel(nil);
				fin();
			end
		});
		Window({
			WindowTitle = "Select Character",
			Duration = nil,
			Text = "Choose a character or NPC model",
			Buttons = btns
		});
		return overrideModel;
	end;
	local function rebuild(model, rec)
		rec.head = nil;
		rec.root = nil;
		rec.torso = nil;
		rec.humanoid = nil;
		if not model then
			rec.dirty = false;
			return rec;
		end;
		for _, inst in ipairs(model:GetDescendants()) do
			if inst:IsA("Humanoid") or inst:IsA("AnimationController") then
				rec.humanoid = rec.humanoid or inst;
			elseif inst:IsA("BasePart") then
				local name = inst.Name:lower();
				if name:find("root") then
					rec.root = rec.root or inst;
				elseif name:find("torso") then
					rec.torso = rec.torso or inst;
				elseif name:find("head") then
					rec.head = rec.head or inst;
				end;
			end;
		end;
		rec.dirty = false;
	end;
	local function ensure(obj)
		local model = asChar(obj);
		if obj == Players.LocalPlayer then
			if overrideModel then
				model = overrideModel;
			elseif model and model.Parent and (not model:IsDescendantOf(workspace)) then
				model = pickOverrideModel(true) or model;
			end;
		elseif not model then
			model = overrideModel;
		end;
		if not model then
			return nil;
		end;
		local rec = _cache[model];
		if not rec then
			rec = {
				dirty = true
			};
			_cache[model] = rec;
			rec.a = model.DescendantAdded:Connect(function()
				rec.dirty = true;
			end);
			rec.r = model.DescendantRemoving:Connect(function()
				rec.dirty = true;
			end);
			rec.c = model.AncestryChanged:Connect(function(_, parent)
				if not parent then
					if rec.a then
						rec.a:Disconnect();
					end;
					if rec.r then
						rec.r:Disconnect();
					end;
					if rec.c then
						rec.c:Disconnect();
					end;
					_cache[model] = nil;
				end;
			end);
		end;
		if rec.dirty or rec.humanoid and rec.humanoid.Parent == nil then
			rebuild(model, rec);
		end;
		return rec, model;
	end;
	T.ensure = ensure;
	T.firstPart = firstPart;
	T.asChar = asChar;
	T.pickOverride = function()
		selectingOverride = false;
		setOverrideModel(nil);
		return pickOverrideModel(true);
	end;
	return T;
end)();

function getRoot(char)
	local rec, model = NA_GRAB_BODY.ensure(char)
	if not rec then return nil end
	return rec.root or (model and NA_GRAB_BODY.firstPart(model)) or nil
end

function getTorso(char)
	local rec, model = NA_GRAB_BODY.ensure(char)
	if not rec then return nil end
	return rec.torso or (model and NA_GRAB_BODY.firstPart(model)) or nil
end

function getHead(char)
	local rec, model = NA_GRAB_BODY.ensure(char)
	if not rec then return nil end
	return rec.head or (model and NA_GRAB_BODY.firstPart(model)) or nil
end

function getChar()
	local plr = Players.LocalPlayer
	if not plr then return nil end
	local rec, model = NA_GRAB_BODY.ensure(plr)
	return model
end

function getPlrChar(plr)
	return NA_GRAB_BODY.asChar(plr)
end

function getBp()
	local plr = Players.LocalPlayer
	return plr and plr:FindFirstChildOfClass("Backpack") or nil
end

function getHum(char, waitSeconds)
	local target

	if char then
		target = NA_GRAB_BODY.asChar(char) or char
	else
		local plr = Players.LocalPlayer
		if plr then
			target = plr.Character
		end
	end

	if not target then
		return nil
	end

	local hum = target:FindFirstChildOfClass("Humanoid") or target:FindFirstChildOfClass("AnimationController")
	if hum then
		return hum
	end

	local timeout = tonumber(waitSeconds)
	if not timeout or timeout <= 0 then
		local rec = NA_GRAB_BODY.ensure(target)
		return rec and rec.humanoid or nil
	end

	timeout = math.max(0, timeout)
	local deadline = os.clock() + timeout

	local function findHumanoid()
		return target:FindFirstChildOfClass("Humanoid") or target:FindFirstChildOfClass("AnimationController")
	end

	while not hum and os.clock() < deadline do
		Wait(0.05)
		hum = findHumanoid()
	end

	if hum then
		return hum
	end

	local rec = NA_GRAB_BODY.ensure(target)
	return rec and rec.humanoid or nil
end

function getPlrHum(plr)
	return getHum(plr)
end

function IsR15(plr)
	plr=(plr or Players.LocalPlayer)
	if plr then
		local h=getPlrHum(plr)
		if h and h.RigType==Enum.HumanoidRigType.R15 then return true end
	end
	return false
end

function IsR6(plr)
	plr=(plr or Players.LocalPlayer)
	if plr then
		local h=getPlrHum(plr)
		if h and h.RigType==Enum.HumanoidRigType.R6 then return true end
	end
	return false
end

Foreach = function(Table, Func, Loop)
	for Index, Value in next, Table do
		pcall(function()
			if Loop and typeof(Value) == 'table' then
				for Index2, Value2 in next, Value do
					Func(Index2, Value2)
				end
			else
				Func(Index, Value)
			end
		end)
	end
end

CheckIfNPC = function(character)
	if not (character and character:IsA("Model")) then
		return false
	end
	local function isPlayerModel(model)
		if not Players then
			return false
		end
		local okPlr, plr = pcall(function()
			return Players:GetPlayerFromCharacter(model)
		end)
		if okPlr and plr then
			return true
		end
		for _, p in ipairs(Players:GetPlayers()) do
			local ch = p.Character
			if ch and (model == ch or model:IsDescendantOf(ch) or ch:IsDescendantOf(model)) then
				return true
			end
		end
		return false
	end

	local humanoid = character:FindFirstChildOfClass("Humanoid")
	if not humanoid then
		return false
	end
	if isPlayerModel(character) then
		return false
	end
	return true
end

NAmanage.IsValidESPModel = function(model, allowNPC)
	if not (model and model:IsA("Model")) then
		return false
	end
	if not model.Parent or not workspace or not model:IsDescendantOf(workspace) then
		return false
	end
	local hum = model:FindFirstChildOfClass("Humanoid")
	if not hum or hum.Health <= 0 or hum.Parent == nil then
		return false
	end
	local root = getRoot(model)
	if not root or root.Parent == nil then
		return false
	end
	if allowNPC then
		return true
	end
	local okPlr, plr = pcall(function()
		return Players:GetPlayerFromCharacter(model)
	end)
	return okPlr and plr ~= nil
end

FindInTable = function(tbl,val)
	if tbl==nil then return false end
	for _,v in pairs(tbl) do
		if v==val then return true end
	end
	return false
end

updateCanvasSize = function(frame, scale)
	local layout = frame:FindFirstChildOfClass("UIListLayout")
	if layout then
		if scale then
			local adjustedHeight = layout.AbsoluteContentSize.Y / scale
			frame.CanvasSize = UDim2.new(0, 0, 0, adjustedHeight)
		else
			frame.CanvasSize = UDim2.new(0, 0, 0, layout.AbsoluteContentSize.Y)
		end
	end
end

NAmanage.CreateNAFreecam=function()
	local module = {}

	local pi = math.pi
	local clamp = math.clamp
	local exp = math.exp
	local rad = math.rad
	local sqrt = math.sqrt
	local tan = math.tan

	local Camera = workspace.CurrentCamera
	local ContextActionService = SafeGetService("ContextActionService")

	workspace:GetPropertyChangedSignal("CurrentCamera"):Connect(function()
		if workspace.CurrentCamera then
			Camera = workspace.CurrentCamera
		end
	end)

	local Spring = {} do
		Spring.__index = Spring

		function Spring.new(freq, pos)
			local self = setmetatable({}, Spring)
			self.f = freq
			self.p = pos
			self.v = pos*0
			return self
		end

		function Spring:Update(dt, goal)
			local f = self.f*2*pi
			local p0 = self.p
			local v0 = self.v

			local offset = goal - p0
			local decay = exp(-f*dt)

			local p1 = goal + (v0*dt - offset*(f*dt + 1))*decay
			local v1 = (f*dt*(offset*f - v0) + v0)*decay

			self.p = p1
			self.v = v1

			return p1
		end

		function Spring:SetFreq(freq)
			self.f = freq
		end

		function Spring:Reset(pos)
			self.p = pos
			self.v = pos*0
		end
	end

	local cameraPos = Vector3.new()
	local cameraRot = Vector2.new()
	local cameraFov = 70

	local velSpring = Spring.new(1.5, Vector3.new())
	local panSpring = Spring.new(1.0, Vector2.new())
	local fovSpring = Spring.new(4.0, 0)

	local NAV_GAIN = Vector3.new(1, 1, 1)*64
	local PAN_GAIN = Vector2.new(0.75, 1)*8
	local FOV_GAIN = 300
	local PITCH_LIMIT = rad(90)

	local DEFAULT_FPS = 60
	local PAN_MOUSE_SPEED = Vector2.new(1, 1)*(pi/64)
	local PAN_MOUSE_SPEED_DT = PAN_MOUSE_SPEED/DEFAULT_FPS
	local FOV_WHEEL_SPEED = 1.0
	local FOV_WHEEL_SPEED_DT = FOV_WHEEL_SPEED/DEFAULT_FPS

	local NAV_ADJ_SPEED = 0.75
	local NAV_MIN_SPEED = 0.01
	local NAV_MAX_SPEED = 4.0
	local NAV_SHIFT_MUL = 0.25

	local keyboard = {
		[Enum.KeyCode.W] = 0,
		[Enum.KeyCode.A] = 0,
		[Enum.KeyCode.S] = 0,
		[Enum.KeyCode.D] = 0,
		[Enum.KeyCode.Q] = 0,
		[Enum.KeyCode.E] = 0,
		[Enum.KeyCode.Up] = 0,
		[Enum.KeyCode.Down] = 0,
	}

	local mouse = {
		Delta = Vector2.new(),
		MouseWheel = 0,
	}

	local navSpeed = 1

	local function zeroInput()
		for key in pairs(keyboard) do
			keyboard[key] = 0
		end
		mouse.Delta = Vector2.new()
		mouse.MouseWheel = 0
	end

	local capturing = false
	local touchConnection = nil

	local function onKeypress(_, inputState, input)
		if input.KeyCode and keyboard[input.KeyCode] ~= nil then
			if inputState == Enum.UserInputState.Begin then
				keyboard[input.KeyCode] = 1
			elseif inputState == Enum.UserInputState.End then
				keyboard[input.KeyCode] = 0
			end
			return Enum.ContextActionResult.Sink
		end
		return Enum.ContextActionResult.Pass
	end

	local function onMousePan(_, inputState, input)
		if inputState == Enum.UserInputState.Change then
			local delta = input.Delta
			mouse.Delta = Vector2.new(-delta.Y, -delta.X)
		end
		return Enum.ContextActionResult.Sink
	end

	local function onTouchPan(_, inputState, input)
		if inputState == Enum.UserInputState.Change then
			local delta = input.Delta
			mouse.Delta = Vector2.new(-delta.Y, -delta.X)
		end
		return Enum.ContextActionResult.Pass
	end

	local function onMouseWheel(_, inputState, input)
		if inputState == Enum.UserInputState.Change then
			mouse.MouseWheel = -input.Position.Z
		end
		return Enum.ContextActionResult.Sink
	end

	local function inputVel(dt)
		if not IsOnMobile then
			navSpeed = clamp(navSpeed + dt*(keyboard[Enum.KeyCode.Up] - keyboard[Enum.KeyCode.Down])*NAV_ADJ_SPEED, NAV_MIN_SPEED, NAV_MAX_SPEED)
		end

		local move = Vector3.new()

		if IsOnMobile and typeof(GetCustomMoveVector) == "function" then
			local ok, vec = pcall(GetCustomMoveVector)
			if ok and vec and vec.Magnitude > 0 then
				move = vec
			end
		else
			move = Vector3.new(
				(keyboard[Enum.KeyCode.D] - keyboard[Enum.KeyCode.A]),
				(keyboard[Enum.KeyCode.E] - keyboard[Enum.KeyCode.Q]),
				-(keyboard[Enum.KeyCode.W] - keyboard[Enum.KeyCode.S])
			)
		end

		local shift = UserInputService:IsKeyDown(Enum.KeyCode.LeftShift) or UserInputService:IsKeyDown(Enum.KeyCode.RightShift)

		return move*(navSpeed*(shift and NAV_SHIFT_MUL or 1))
	end

	local function inputPan(dt)
		local kMouse = mouse.Delta*PAN_MOUSE_SPEED
		if dt > 0 then
			kMouse = (mouse.Delta/dt)*PAN_MOUSE_SPEED_DT
		end
		mouse.Delta = Vector2.new()
		return kMouse
	end

	local function inputFov(dt)
		local kMouse = mouse.MouseWheel*FOV_WHEEL_SPEED
		if dt > 0 then
			kMouse = (mouse.MouseWheel/dt)*FOV_WHEEL_SPEED_DT
		end
		mouse.MouseWheel = 0
		return kMouse
	end

	local enabled = false
	local storedState = {}

	local function stepFreecam(dt)
		if not Camera then
			return
		end

		local vel = velSpring:Update(dt, inputVel(dt))
		local pan = panSpring:Update(dt, inputPan(dt))
		local fovStep = fovSpring:Update(dt, inputFov(dt))

		local zoomFactor = sqrt(tan(rad(70/2))/tan(rad(cameraFov/2)))
		cameraFov = clamp(cameraFov + fovStep*FOV_GAIN*(dt/zoomFactor), 1, 120)

		cameraRot = cameraRot + pan*PAN_GAIN*(dt/zoomFactor)
		cameraRot = Vector2.new(clamp(cameraRot.X, -PITCH_LIMIT, PITCH_LIMIT), cameraRot.Y%(2*pi))

		local cf = CFrame.new(cameraPos)*CFrame.fromOrientation(cameraRot.X, cameraRot.Y, 0)*CFrame.new(vel*NAV_GAIN*dt)

		cameraPos = cf.Position

		Camera.CFrame = cf
		Camera.Focus = cf
		Camera.FieldOfView = cameraFov
	end

	function module.Start(initialSpeed)
		if enabled or not Camera then
			return
		end

		enabled = true

		if initialSpeed ~= nil then
			local scaled = tonumber(initialSpeed)
			if scaled then
				navSpeed = clamp(scaled, NAV_MIN_SPEED, NAV_MAX_SPEED)
			end
		end

		storedState.cameraType = Camera.CameraType
		storedState.cameraCFrame = Camera.CFrame
		storedState.cameraFocus = Camera.Focus
		storedState.cameraFov = Camera.FieldOfView
		storedState.mouseIconEnabled = UserInputService.MouseIconEnabled
		storedState.mouseBehavior = UserInputService.MouseBehavior

		local cframe = Camera.CFrame
		local x, y, _ = cframe:ToOrientation()
		cameraPos = cframe.Position
		cameraRot = Vector2.new(x, y)
		cameraFov = Camera.FieldOfView

		velSpring:Reset(Vector3.new())
		panSpring:Reset(Vector2.new())
		fovSpring:Reset(0)

		Camera.CameraType = Enum.CameraType.Scriptable
		UserInputService.MouseIconEnabled = false
		UserInputService.MouseBehavior = Enum.MouseBehavior.LockCenter

		if not capturing and ContextActionService then
			capturing = true
			ContextActionService:BindActionAtPriority("NA_FreecamKeyboard", onKeypress, false, Enum.ContextActionPriority.High.Value,
				Enum.KeyCode.W, Enum.KeyCode.A, Enum.KeyCode.S, Enum.KeyCode.D,
				Enum.KeyCode.Q, Enum.KeyCode.E,
				Enum.KeyCode.Up, Enum.KeyCode.Down
			)
			ContextActionService:BindActionAtPriority("NA_FreecamMousePan", onMousePan, false, Enum.ContextActionPriority.High.Value, Enum.UserInputType.MouseMovement)
			ContextActionService:BindActionAtPriority("NA_FreecamMouseWheel", onMouseWheel, false, Enum.ContextActionPriority.High.Value, Enum.UserInputType.MouseWheel)
		end

		if IsOnMobile and not touchConnection then
			touchConnection = UserInputService.InputChanged:Connect(function(input, gameProcessed)
				if input.UserInputType ~= Enum.UserInputType.Touch then
					return
				end
				if gameProcessed then
					return
				end
				if input.UserInputState ~= Enum.UserInputState.Change then
					return
				end
				local delta = input.Delta
				mouse.Delta = Vector2.new(-delta.Y, -delta.X)
			end)
		end

		RunService:BindToRenderStep("NA_Freecam", Enum.RenderPriority.Camera.Value, stepFreecam)
	end

	function module.Stop()
		if not enabled then
			return
		end

		enabled = false
		RunService:UnbindFromRenderStep("NA_Freecam")

		if capturing and ContextActionService then
			capturing = false
			ContextActionService:UnbindAction("NA_FreecamKeyboard")
			ContextActionService:UnbindAction("NA_FreecamMousePan")
			ContextActionService:UnbindAction("NA_FreecamMouseWheel")
		end

		if touchConnection then
			touchConnection:Disconnect()
			touchConnection = nil
		end

		zeroInput()

		if Camera and storedState.cameraType then
			Camera.CameraType = storedState.cameraType
			Camera.CFrame = storedState.cameraCFrame
			Camera.Focus = storedState.cameraFocus
			Camera.FieldOfView = storedState.cameraFov
		end

		if storedState.mouseIconEnabled ~= nil then
			UserInputService.MouseIconEnabled = storedState.mouseIconEnabled
		end
		if storedState.mouseBehavior ~= nil then
			local behavior = storedState.mouseBehavior
			if behavior == Enum.MouseBehavior.LockCenter then
				behavior = Enum.MouseBehavior.Default
			end
			UserInputService.MouseBehavior = behavior
		end
	end

	function module.SetSpeed(newSpeed)
		local scaled = tonumber(newSpeed)
		if scaled then
			navSpeed = clamp(scaled, NAV_MIN_SPEED, NAV_MAX_SPEED)
		end
	end

	function module.Toggle(initialSpeed)
		if enabled then
			module.Stop()
		else
			module.Start(initialSpeed)
		end
	end

	function module.IsEnabled()
		return enabled
	end

	local FREECAM_MACRO_KEYS = { Enum.KeyCode.LeftShift, Enum.KeyCode.P }

	local function checkMacro()
		for i = 1, #FREECAM_MACRO_KEYS - 1 do
			if not UserInputService:IsKeyDown(FREECAM_MACRO_KEYS[i]) then
				return
			end
		end

		if _G.NAFreecamKeybindEnabled ~= true then
			return
		end

		module.Toggle()
	end

	if ContextActionService then
		ContextActionService:BindActionAtPriority("NA_FreecamToggleKey", function(_, state, input)
			if state == Enum.UserInputState.Begin and input.KeyCode == FREECAM_MACRO_KEYS[#FREECAM_MACRO_KEYS] then
				checkMacro()
			end
			return Enum.ContextActionResult.Pass
		end, false, Enum.ContextActionPriority.Low.Value, FREECAM_MACRO_KEYS[#FREECAM_MACRO_KEYS])
	end

	return module
end

local NAFreecam = NAmanage.CreateNAFreecam()

--[[ legacy NAFreecam implementation (disabled)
local NAFreecam = {}
do
	local pi = math.pi
	local clamp = math.clamp
	local exp = math.exp
	local rad = math.rad
	local sqrt = math.sqrt
	local tan = math.tan

	local Workspace = workspace
	local Camera = Workspace.CurrentCamera
	local ContextActionService = SafeGetService("ContextActionService")

	Workspace:GetPropertyChangedSignal("CurrentCamera"):Connect(function()
		if Workspace.CurrentCamera then
			Camera = Workspace.CurrentCamera
		end
	end)

	local Spring = {} do
		Spring.__index = Spring

		function Spring.new(freq, pos)
			local self = setmetatable({}, Spring)
			self.f = freq
			self.p = pos
			self.v = pos*0
			return self
		end

		function Spring:Update(dt, goal)
			local f = self.f*2*pi
			local p0 = self.p
			local v0 = self.v

			local offset = goal - p0
			local decay = exp(-f*dt)

			local p1 = goal + (v0*dt - offset*(f*dt + 1))*decay
			local v1 = (f*dt*(offset*f - v0) + v0)*decay

			self.p = p1
			self.v = v1

			return p1
		end

		function Spring:SetFreq(freq)
			self.f = freq
		end

		function Spring:Reset(pos)
			self.p = pos
			self.v = pos*0
		end
	end

	local cameraPos = Vector3.new()
	local cameraRot = Vector2.new()
	local cameraFov = 70

	local velSpring = Spring.new(1.5, Vector3.new())
	local panSpring = Spring.new(1.0, Vector2.new())
	local fovSpring = Spring.new(4.0, 0)

	local NAV_GAIN = Vector3.new(1, 1, 1)*64
	local PAN_GAIN = Vector2.new(0.75, 1)*8
	local FOV_GAIN = 300
	local PITCH_LIMIT = rad(90)

	local DEFAULT_FPS = 60
	local PAN_MOUSE_SPEED = Vector2.new(1, 1)*(pi/64)
	local PAN_MOUSE_SPEED_DT = PAN_MOUSE_SPEED/DEFAULT_FPS
	local FOV_WHEEL_SPEED = 1.0
	local FOV_WHEEL_SPEED_DT = FOV_WHEEL_SPEED/DEFAULT_FPS

	local NAV_ADJ_SPEED = 0.75
	local NAV_MIN_SPEED = 0.01
	local NAV_MAX_SPEED = 4.0
	local NAV_SHIFT_MUL = 0.25

	local keyboard = {
		[Enum.KeyCode.W] = 0,
		[Enum.KeyCode.A] = 0,
		[Enum.KeyCode.S] = 0,
		[Enum.KeyCode.D] = 0,
		[Enum.KeyCode.Q] = 0,
		[Enum.KeyCode.E] = 0,
		[Enum.KeyCode.Up] = 0,
		[Enum.KeyCode.Down] = 0,
	}

	local mouse = {
		Delta = Vector2.new(),
		MouseWheel = 0,
	}

	local navSpeed = 1

	local function zeroInput()
		for key in pairs(keyboard) do
			keyboard[key] = 0
		end
		mouse.Delta = Vector2.new()
		mouse.MouseWheel = 0
	end

	local capturing = false

	local function onKeypress(_, inputState, input)
		if input.KeyCode and keyboard[input.KeyCode] ~= nil then
			if inputState == Enum.UserInputState.Begin then
				keyboard[input.KeyCode] = 1
			elseif inputState == Enum.UserInputState.End then
				keyboard[input.KeyCode] = 0
			end
			return Enum.ContextActionResult.Sink
		end
		return Enum.ContextActionResult.Pass
	end

	local function onMousePan(_, inputState, input)
		if inputState == Enum.UserInputState.Change then
			local delta = input.Delta
			mouse.Delta = Vector2.new(-delta.Y, -delta.X)
		end
		return Enum.ContextActionResult.Sink
	end

	local function onMouseWheel(_, inputState, input)
		if inputState == Enum.UserInputState.Change then
			mouse.MouseWheel = input.Position.Z
		end
		return Enum.ContextActionResult.Sink
	end

	local function inputVel(dt)
		navSpeed = clamp(navSpeed + dt*(keyboard[Enum.KeyCode.Up] - keyboard[Enum.KeyCode.Down])*NAV_ADJ_SPEED, NAV_MIN_SPEED, NAV_MAX_SPEED)

		local kKeyboard = Vector3.new(
			(keyboard[Enum.KeyCode.D] - keyboard[Enum.KeyCode.A]),
			(keyboard[Enum.KeyCode.E] - keyboard[Enum.KeyCode.Q]),
			-(keyboard[Enum.KeyCode.W] - keyboard[Enum.KeyCode.S])
		)

		local shift = UserInputService:IsKeyDown(Enum.KeyCode.LeftShift) or UserInputService:IsKeyDown(Enum.KeyCode.RightShift)

		return kKeyboard*(navSpeed*(shift and NAV_SHIFT_MUL or 1))
	end

	local function inputPan(dt)
		local kMouse = mouse.Delta*PAN_MOUSE_SPEED
		if dt > 0 then
			kMouse = (mouse.Delta/dt)*PAN_MOUSE_SPEED_DT
		end
		mouse.Delta = Vector2.new()
		return kMouse
	end

	local function inputFov(dt)
		local kMouse = mouse.MouseWheel*FOV_WHEEL_SPEED
		if dt > 0 then
			kMouse = (mouse.MouseWheel/dt)*FOV_WHEEL_SPEED_DT
		end
		mouse.MouseWheel = 0
		return kMouse
	end

	local enabled = false
	local storedState = {}

	local function stepFreecam(dt)
		if not Camera then
			return
		end

		local vel = velSpring:Update(dt, inputVel(dt))
		local pan = panSpring:Update(dt, inputPan(dt))
		local fovStep = fovSpring:Update(dt, inputFov(dt))

		local zoomFactor = sqrt(tan(rad(70/2))/tan(rad(cameraFov/2)))
		cameraFov = clamp(cameraFov + fovStep*FOV_GAIN*(dt/zoomFactor), 1, 120)

		cameraRot = cameraRot + pan*PAN_GAIN*(dt/zoomFactor)
		cameraRot = Vector2.new(clamp(cameraRot.X, -PITCH_LIMIT, PITCH_LIMIT), cameraRot.Y%(2*pi))

		local cf = CFrame.new(cameraPos)*CFrame.fromOrientation(cameraRot.X, cameraRot.Y, 0)*CFrame.new(vel*NAV_GAIN*dt)

		cameraPos = cf.Position

		Camera.CFrame = cf
		Camera.Focus = cf
		Camera.FieldOfView = cameraFov
	end

	function NAFreecam.Start(initialSpeed)
		if enabled or not Camera then
			return
		end

		enabled = true

		if initialSpeed ~= nil then
			local scaled = tonumber(initialSpeed)
			if scaled then
				navSpeed = clamp(scaled, NAV_MIN_SPEED, NAV_MAX_SPEED)
			end
		end

		storedState.cameraType = Camera.CameraType
		storedState.cameraCFrame = Camera.CFrame
		storedState.cameraFocus = Camera.Focus
		storedState.cameraFov = Camera.FieldOfView
		storedState.mouseIconEnabled = UserInputService.MouseIconEnabled
		storedState.mouseBehavior = UserInputService.MouseBehavior

		local cframe = Camera.CFrame
		local x, y, _ = cframe:ToOrientation()
		cameraPos = cframe.Position
		cameraRot = Vector2.new(x, y)
		cameraFov = Camera.FieldOfView

		velSpring:Reset(Vector3.new())
		panSpring:Reset(Vector2.new())
		fovSpring:Reset(0)

		Camera.CameraType = Enum.CameraType.Scriptable
		UserInputService.MouseIconEnabled = false
		UserInputService.MouseBehavior = Enum.MouseBehavior.LockCenter

		if not capturing and ContextActionService then
			capturing = true
			ContextActionService:BindActionAtPriority("NA_FreecamKeyboard", onKeypress, false, Enum.ContextActionPriority.High.Value,
				Enum.KeyCode.W, Enum.KeyCode.A, Enum.KeyCode.S, Enum.KeyCode.D,
				Enum.KeyCode.Q, Enum.KeyCode.E,
				Enum.KeyCode.Up, Enum.KeyCode.Down
			)
			ContextActionService:BindActionAtPriority("NA_FreecamMousePan", onMousePan, false, Enum.ContextActionPriority.High.Value, Enum.UserInputType.MouseMovement)
			ContextActionService:BindActionAtPriority("NA_FreecamMouseWheel", onMouseWheel, false, Enum.ContextActionPriority.High.Value, Enum.UserInputType.MouseWheel)
		end

		RunService:BindToRenderStep("NA_Freecam", Enum.RenderPriority.Camera.Value, stepFreecam)
	end

	function NAFreecam.Stop()
		if not enabled then
			return
		end

		enabled = false
		RunService:UnbindFromRenderStep("NA_Freecam")

		if capturing and ContextActionService then
			capturing = false
			ContextActionService:UnbindAction("NA_FreecamKeyboard")
			ContextActionService:UnbindAction("NA_FreecamMousePan")
			ContextActionService:UnbindAction("NA_FreecamMouseWheel")
		end

		zeroInput()

		if Camera and storedState.cameraType then
			Camera.CameraType = storedState.cameraType
			Camera.CFrame = storedState.cameraCFrame
			Camera.Focus = storedState.cameraFocus
			Camera.FieldOfView = storedState.cameraFov
		end

		if storedState.mouseIconEnabled ~= nil then
			UserInputService.MouseIconEnabled = storedState.mouseIconEnabled
		end
		if storedState.mouseBehavior ~= nil then
			UserInputService.MouseBehavior = storedState.mouseBehavior
		end
	end

	function NAFreecam.Toggle(initialSpeed)
		if enabled then
			NAFreecam.Stop()
		else
			NAFreecam.Start(initialSpeed)
		end
	end

	function NAFreecam.IsEnabled()
		return enabled
	end
end
]]

local originalIO = {}

originalIO.captureIO=function(name)
	local fn = rawget(_G, name)
	if type(fn) == "function" then
		originalIO[name] = fn
	end
end

if not originalIO.__captured then
	originalIO.__captured = true
	originalIO.captureIO('readfile')
	originalIO.captureIO('writefile')
	originalIO.captureIO('appendfile')
	originalIO.captureIO('listfiles')
	originalIO.captureIO('makefolder')
	originalIO.captureIO('delfile')
	originalIO.captureIO('delfolder')
	originalIO.captureIO('isfile')
	originalIO.captureIO('isfolder')
end

originalIO.pathVariants=function(path)
	if type(path) ~= "string" then
		return { path }
	end
	if path:match('^[%w_]+://') then
		return { path }
	end
	local variants, seen = {}, {}
	local function add(value)
		if type(value) == "string" and value ~= "" and not seen[value] then
			seen[value] = true
			Insert(variants, value)
		end
	end
	add(path)
	add(path:gsub('\\+', '\\'))
	add(path:gsub('//+', '/'))
	add(path:gsub('/', '\\'))
	add(path:gsub('\\', '/'))
	local trimmed = path:gsub('^%.[/\]+', '')
	if trimmed ~= path then
		add(trimmed)
		add(trimmed:gsub('/', '\\'))
		add(trimmed:gsub('\\', '/'))
	end
	return variants
end

originalIO.resolveWithListfiles=function(target)
	local lf = originalIO.listfiles
	if type(lf) ~= "function" then
		return nil
	end
	local dir, filename = target:match('^(.*)[/\\]([^/\\]+)$')
	if not dir or filename == '' then
		return nil
	end
	local dirVariants = originalIO.pathVariants(dir)
	local results = {}
	local lowered = filename:lower()
	for _, candidateDir in ipairs(dirVariants) do
		local ok, entries = pcall(lf, candidateDir)
		if ok and type(entries) == "table" then
			for _, entry in ipairs(entries) do
				local name = entry:match('([^/\\]+)$')
				if name and name:lower() == lowered then
					Insert(results, entry)
				end
			end
		end
	end
	if #results > 0 then
		return results
	end
	return nil
end

if identifyexecutor and (identifyexecutor():lower()=="solara" or identifyexecutor():lower()=="xeno") then
	if not getgenv()["__NA_SOLARA_PATH_FIX__"] then
		getgenv()["__NA_SOLARA_PATH_FIX__"] = true

		local function wrapWithFallback(fn, returnsBool, allowListResolve)
			if type(fn) ~= "function" then
				return nil
			end
			return function(path, ...)
				if type(path) ~= "string" then
					local ok, result = pcall(fn, path, ...)
					if ok then
						return result
					end
					if returnsBool then
						return false
					end
					error(result)
				end

				for _, candidate in ipairs(originalIO.pathVariants(path)) do
					local ok, result = pcall(fn, candidate, ...)
					if ok then
						return result
					end
				end

				if allowListResolve then
					local resolved = originalIO.resolveWithListfiles(path)
					if resolved then
						for _, candidate in ipairs(resolved) do
							local ok, result = pcall(fn, candidate, ...)
							if ok then
								return result
							end
						end
					end
				end

				if returnsBool then
					return false
				end
				error(("failed to access %s"):format(path))
			end
		end

		if originalIO.readfile then
			readfile = wrapWithFallback(originalIO.readfile, false, true)
		end
		if originalIO.writefile then
			writefile = wrapWithFallback(originalIO.writefile, false, true)
		end
		if originalIO.appendfile then
			appendfile = wrapWithFallback(originalIO.appendfile, false, true)
		end
		if originalIO.listfiles then
			listfiles = wrapWithFallback(originalIO.listfiles, false, false)
		end
		if originalIO.makefolder then
			makefolder = wrapWithFallback(originalIO.makefolder, false, true)
		end
		if originalIO.delfile then
			delfile = wrapWithFallback(originalIO.delfile, false, true)
		end
		if originalIO.delfolder then
			delfolder = wrapWithFallback(originalIO.delfolder, false, true)
		end
		if originalIO.isfile then
			isfile = wrapWithFallback(originalIO.isfile, true, true)
		end
		if originalIO.isfolder then
			isfolder = wrapWithFallback(originalIO.isfolder, true, true)
		end
	end
end

local Waypoints = {}
local Bindings = Bindings or {}
local CommandKeybinds = CommandKeybinds or {}
local CommandKeybindOptions = CommandKeybindOptions or {}
local NAStuff = {
	CmdBar2 = (NAStuff and NAStuff.CmdBar2) or {
		defaultWidth = 340;
		defaultHeight = 78;
		minWidth = 200;
		maxWidth = 800;
		minHeight = 70;
		maxHeight = 160;
		topHeight = 26;
		bodyOffsetY = 34;
		bodyBottomPadding = 8;
		bodyMinHeight = 24;
	};
	NAICONMAIN = nil;
	NASCREENGUI = nil; --Getmodel("rbxassetid://140418556029404")
	NAjson = nil;
	nuhuhNotifs = true;
	dmNotificationsEnabled = true;
	KeybindConnection = nil;
	ForceAdminRainbow = true;
	AutoExecEnabled = true;
	UserButtonsAutoLoad = true;
	CmdBar2AutoRun = false;
	CmdIntegrationAutoRun = false;
	CmdIntegrationLoaded = false;
	CmdIntegrationLastSource = nil;
	tweenSpeed = 1;
	FreecamSpeed = 5;
	originalDesc = nil;
	currentDesc = nil;
	AutoChar = nil;
	BlockedRemotes = {};
	touchESPList = {};
	proximityESPList = {};
	clickESPList = {};
	siteESPList = {};
	vehicleSiteESPList = {};
	unanchoredESPList = {};
	collisiontrueESPList = {};
	collisionfalseESPList = {};
	espTriggers = {};
	espNameLists = { exact = {}, partial = {} };
	espNameTriggers = {};
	nameESPPartLists = { exact = {}, partial = {} };
	ESP_RenderMode = "BoxHandleAdornment";
	ESP_LabelTextSize = 12;
	ESP_LabelTextScaled = false;
	ESP_LabelStrokeTransparency = 0.5;
	ESP_UseCustomColor = false;
	ESP_CustomColor = Color3.new(1, 1, 1);
	ESP_OutlineTransparency = 0;
	ESP_ShowPartDistance = false;
	ESP_LocatorEnabled = false;
	ESP_LocatorSize = 26;
	ESP_LocatorShowText = false;
	ESP_LocatorTextSize = 14;
	ESP_LastExactPart = "";
	ESP_LastPartialPart = "";
	ESP_LastFolderName = "";
	ESP_LocatorGui = nil;
	ESP_LocatorArrows = {};
	ESP_ModelList = {};
	ESP_ModelIndex = 1;
	ESP_MaxPerStep = 32;
	ESP_FolderMode = "parts";
	NPC_ESP_MaxDist = 400;
	NPC_ESP_MaxCount = 200;
	NPC_ESP_ShowLabels = true;
	NPC_ESP_LabelMaxDistance = 600;
	partESPColors = setmetatable({}, { __mode = "k" });
	partESPGlassOriginal = setmetatable({}, { __mode = "k" });
	partESPGlassCount = setmetatable({}, { __mode = "k" });
	partESPEntries = setmetatable({}, { __mode = "k" });
	partESPVisualMap = setmetatable({}, { __mode = "k" });
	nameESPExclusions = { exact = {}, partial = {} };
	TopbarGlassTransparency = 0.12;
	TopbarStrokeTransparency = 0.15;
	SideSwipeWidth = 80;
	SideSwipeHandleTransparency = 0.72;
	Integrations = {
		webhook = {
			url = "";
			urls = { main = "" };
			enableJoinLeave = false;
			enableChat = false;
			enableCommands = false;
			minInterval = 2;
			lastSent = 0;
		};
		health = {
			endpoints = {};
		};
		notes = {
			last = "";
		};
		rpc = {
			useCustom = false;
			details = "";
			state = "";
		};
	};
	NIL_SENTINEL = {};
	RemoteBlockMode = "fakeok";
	RemoteFakeReturn = true;
	BlockedEventSaved = {};
	BlockedInvokeSaved = {};
	BlockedRemoteModes = {};
	BlockedRemoteReturns = {};
	BlockedSignals = {};
	RemoteFakeReturn = true;
	AntiKickMode = "fakeok";
	AntiKickHooked = false;
	AntiKickOrig = {namecall=nil,index=nil,newindex=nil,kicks={}};
	AntiTeleportMode = "fakeok";
	AntiTeleportHooked = false;
	AntiTeleportOrig = {namecall=nil,index=nil,newindex=nil,funcs={}};
	SYNC_TAG = "ANIM_SYNC";
	CORE_FOLDERS = {idle=true,walk=true,run=true,jump=true,fall=true,climb=true,swim=true,swimidle=true,toolnone=true,toolslash=true,toollunge=true};
	SavedDefaultMap = nil;
	Sync_AnimatePrevDisabled = nil;
	MIMIC_TAG = "MIMIC_SYNC";
	Mimic_AnimatePrevDisabled = nil;
	mimic_uid = 0;
	ChatSettings = {
		customEnabled = false;
		coreGuiChat = true;
		window = {
			enabled = true;
			font = "rbxasset://fonts/families/BuilderSans.json";
			textSize = 16;
			textColor = {235,235,235};
			strokeColor = {0,0,0};
			strokeTransparency = 0.5;
			textTransparency = 0;
			backgroundColor = {25,27,29};
			backgroundTransparency = 0.2;
		};
		tabs = {
			enabled = false;
			font = "rbxasset://fonts/families/BuilderSans.json";
			textSize = 18;
			backgroundColor = {25,27,29};
			backgroundTransparency = 0;
			textTransparency = 0;
			textColor = {255,255,255};
			selectedTextColor = {170,255,170};
			unselectedTextColor = {200,200,200};
		};
		input = {
			enabled = true;
			autocomplete = true;
			font = "rbxasset://fonts/families/BuilderSans.json";
			keyCode = "Slash";
			textSize = 16;
			textColor = {255,255,255};
			strokeColor = {0,0,0};
			strokeTransparency = 0.5;
			backgroundColor = {25,27,29};
			backgroundTransparency = 0.2;
			targetGeneral = false;
		};
		bubbles = {
			enabled = true; -- ENABLED IT SINCE YOU CAN'T STOP CRYING ABOUT IT
			maxDistance = 100;
			minimizeDistance = 20;
			textSize = 14;
			textColor = {255,255,255};
			textTransparency = 0;
			spacing = 4;
			backgroundColor = {25,27,29};
			backgroundTransparency = 0.1;
			maxBubbles = 3;
			bubbleDuration = 15;
			tailVisible = true;
		};
	};
	ChatSettingsTemplate = nil;
	ChatSettingsDefaults = nil;
	ChatCustomizationActive = nil;
	ChatSettingsCustomBackup = nil;
	IconInvisible = false;
	IconLocked = false;
	_prefetchedRemotes = {};
	AutoExecBlockedCommands = {
		exit = true;
		rejoin = true;
		rj = true;
		serverhop = true;
		shop = true;
		smallserverhop = true;
		sshop = true;
		pingserverhop = true;
		pshop = true;
		saw = true;
	};
	NASettingsSchema = nil;
	NASettingsData = nil;
	elementOriginalParent = setmetatable({}, { __mode = "k" });
	_lastCommand = nil;
	_prevCommand = nil;
	_removeAdsLoop = nil;
	resizeVerticalAsset = nil;
	resizeHorizontalAsset = nil;
	resizeDiagonal1Asset = nil;
	resizeDiagonal2Asset = nil;
	defaultCmdClear = nil;
	autofillSelecting = false;
	cmdFocusGuardUntil = 0;
	autofillRefocusGuard = 0;
}
local interactTbl = { click = {}; proxy = {}; touch = {}; }
local Notification = nil
local inviteLink = "https://discord.gg/zzjYhtMGFD"
local prefixCheck = ";"
opt={
	prefix=prefixCheck;
	NAupdDate='unknown'; --month,day,year
	githubUrl = '';
	loader='';
	NAUILOADER='';
	NAAUTOSCALER=nil;
	cmdIntegrationUrl = "https://raw.githubusercontent.com/lxte/cmd/main/main.lua";
	cmdIntegrationFallbackUrl = "https://raw.githubusercontent.com/lxte/cmd/main/testing-main.lua";
	NAREQUEST = request or http_request or (syn and syn.request) or (http and http.request) or (fluxus and fluxus.request) or function() end;
	queueteleport=(syn and syn.queue_on_teleport) or queue_on_teleport or (fluxus and fluxus.queue_on_teleport) or function() end;
	hiddenprop=(sethiddenproperty or set_hidden_property or set_hidden_prop) or function() end;
	ctrlModule = nil;
	currentTagText = "Tag";
	currentTagColor = Color3.fromRGB(0, 255, 170);
	currentTagRGB = false;
	chatTranslateEnabled = true;
	chatTranslateTarget = "en";
	--saveTag = false;
}
local cmd={}
NAmanage.btCount = 0

NAmanage.btGetExecutorInfo=function(forceRefresh)
	if forceRefresh or not NAmanage._btExecutorInfo then
		local execName = "Unknown"
		local execVersion = "Unknown"

		if type(identifyexecutor) == "function" then
			local ok, name, version = pcall(identifyexecutor)
			if ok then
				if type(name) == "string" and name ~= "" then
					execName = name
				elseif name ~= nil then
					execName = tostring(name)
				end

				if type(version) == "string" and version ~= "" then
					execVersion = version
				elseif version ~= nil then
					execVersion = tostring(version)
				end
			end
		end

		NAmanage._btExecutorInfo = {
			name = execName;
			version = execVersion;
		}
	end

	return NAmanage._btExecutorInfo
end

NAmanage.btEnabled=function()
	if type(NAmanage._btOverride) == "boolean" then
		return NAmanage._btOverride
	end
	if NAmanage.NASettingsGet then
		local value = NAmanage.NASettingsGet("bloxtrapRPC")
		if type(value) == "boolean" then
			return value
		end
	end
	if NAStuff and typeof(NAStuff.NASettingsData) == "table" then
		local stored = NAStuff.NASettingsData.bloxtrapRPC
		if type(stored) == "boolean" then
			return stored
		end
	end
	return false
end

NAmanage.btSetEnabled=function(value)
	NAmanage._btOverride = value == true
	if NAmanage.NASettingsSet then
		NAmanage.NASettingsSet("bloxtrapRPC", value == true)
	end
end

NAmanage.InitializeIntegration=function()
	local integ = NAStuff.Integrations or {}
	integ.webhook = integ.webhook or {}
	integ.webhook.urls = integ.webhook.urls or {}
	integ.webhook.urls.main = integ.webhook.urls.main or integ.webhook.url or integ.webhook.urls.all or ""
	integ.webhook.urls.all = integ.webhook.urls.all or integ.webhook.url or ""
	integ.webhook.urls.joinleave = integ.webhook.urls.joinleave or ""
	integ.webhook.urls.chat = integ.webhook.urls.chat or ""
	integ.webhook.urls.commands = integ.webhook.urls.commands or ""
	integ.webhook.useAll = integ.webhook.useAll == true
	integ.webhook.url = integ.webhook.urls.all
	integ.webhook.enableJoinLeave = integ.webhook.enableJoinLeave == true
	integ.webhook.enableChat = integ.webhook.enableChat == true
	integ.webhook.enableCommands = integ.webhook.enableCommands == true
	integ.webhook.minInterval = tonumber(integ.webhook.minInterval) or 2
	integ.webhook.lastSent = type(integ.webhook.lastSent) == "number" and integ.webhook.lastSent or 0
	integ.health = integ.health or { endpoints = {} }
	integ.health.endpoints = integ.health.endpoints or {}
	integ.notes = integ.notes or { last = "" }
	integ.notes.last = integ.notes.last or ""
	integ.rpc = integ.rpc or {}
	integ.rpc.useCustom = integ.rpc.useCustom == true
	integ.rpc.details = integ.rpc.details or ""
	integ.rpc.state = integ.rpc.state or ""

	if NAmanage.NASettingsGet then
		local clampNum = NAmanage.clampNumber or function(v, lo, hi, fallback)
			local n = tonumber(v)
			if not n then return fallback end
			if lo and n < lo then n = lo end
			if hi and n > hi then n = hi end
			return n
		end
		local function asBool(v) return v == true end
		local function asString(v) return type(v) == "string" and v or "" end

		local function readUrl(key, fallback)
			local value = asString(NAmanage.NASettingsGet(key))
			if value ~= "" then
				return value
			end
			return fallback
		end

		integ.webhook.urls.main = readUrl("integrationWebhookUrlMain", integ.webhook.urls.main)
		integ.webhook.urls.all = readUrl("integrationWebhookUrlAll", integ.webhook.urls.all)
		integ.webhook.urls.joinleave = readUrl("integrationWebhookUrlJoinLeave", integ.webhook.urls.joinleave)
		integ.webhook.urls.chat = readUrl("integrationWebhookUrlChat", integ.webhook.urls.chat)
		integ.webhook.urls.commands = readUrl("integrationWebhookUrlCommands", integ.webhook.urls.commands)
		if integ.webhook.urls.all == "" then
			local legacy = asString(NAmanage.NASettingsGet("integrationWebhookUrl"))
			if legacy ~= "" then
				integ.webhook.urls.all = legacy
			end
		end
		integ.webhook.url = integ.webhook.urls.all

		local useAllSaved = NAmanage.NASettingsGet("integrationWebhookUseAll")
		if type(useAllSaved) == "boolean" then
			integ.webhook.useAll = useAllSaved
		end

		integ.webhook.enableJoinLeave = NAmanage.NASettingsGet("integrationWebhookJoinLeave") == true or integ.webhook.enableJoinLeave
		integ.webhook.enableChat = NAmanage.NASettingsGet("integrationWebhookChat") == true or integ.webhook.enableChat
		integ.webhook.enableCommands = NAmanage.NASettingsGet("integrationWebhookCommands") == true or integ.webhook.enableCommands
		integ.webhook.minInterval = clampNum(NAmanage.NASettingsGet("integrationWebhookInterval"), 0, 120, integ.webhook.minInterval)

		local storedEndpoints = NAmanage.NASettingsGet("integrationHealthEndpoints")
		if type(storedEndpoints) == "table" then
			integ.health.endpoints = {}
			for i = 1, math.min(#storedEndpoints, 3) do
				if type(storedEndpoints[i]) == "string" and storedEndpoints[i] ~= "" then
					integ.health.endpoints[i] = storedEndpoints[i]
				end
			end
		elseif type(storedEndpoints) == "string" and storedEndpoints ~= "" then
			integ.health.endpoints = { storedEndpoints }
		end

		local noteVal = NAmanage.NASettingsGet("integrationNotesLast")
		if type(noteVal) == "string" then
			integ.notes.last = noteVal
		end

		integ.rpc.useCustom = NAmanage.NASettingsGet("integrationRpcUseCustom") == true or integ.rpc.useCustom
		local rpcDetails = NAmanage.NASettingsGet("integrationRpcDetails")
		local rpcState = NAmanage.NASettingsGet("integrationRpcState")
		if type(rpcDetails) == "string" then integ.rpc.details = rpcDetails end
		if type(rpcState) == "string" then integ.rpc.state = rpcState end
	end

	NAStuff.Integrations = integ
end
NAmanage.InitializeIntegration()

NAmanage.btSend=function(command, data)
	if not NAmanage.btEnabled() then
		return
	end

	local payload = {
		command = command;
		data = data;
	}

	local ok, encoded = pcall(function()
		return HttpService:JSONEncode(payload)
	end)

	if ok and encoded then
		encoded = encoded:gsub('("assetId"%s*:%s*)([-%d%.eE%+]+)', function(prefix, numeric)
			local numberValue = tonumber(numeric)
			if numberValue then
				return prefix..Format('%.0f', numberValue)
			end
			return prefix..numeric
		end)
		print("[BloxstrapRPC] "..encoded)
	end
end

NAmanage.btUpdate=function(details, state)
	if not NAmanage.btEnabled() then
		return
	end

	local versionHover = (NAStuff and NAStuff.NAjson and NAStuff.NAjson.ver) or "Nameless Admin"
	local count = NAmanage.btCount or 0
	local cfgRPC = (NAStuff.Integrations and NAStuff.Integrations.rpc) or {}
	local placeLabel = placeName and placeName() or "Game"
	local function applyTemplate(text, fallback)
		local src = (text ~= nil and text ~= "") and text or fallback
		if type(src) ~= "string" then
			src = tostring(src)
		end
		return (src or ""):gsub("{cmds}", tostring(count))
			:gsub("{game}", tostring(placeLabel))
	end

	local displayDetails = details or adminName or "Nameless Admin"
	if cfgRPC.useCustom and cfgRPC.details and cfgRPC.details ~= "" then
		displayDetails = applyTemplate(cfgRPC.details, displayDetails)
	end
	if type(displayDetails) ~= "string" then
		displayDetails = tostring(displayDetails)
	end
	local baseState = state

	if baseState == nil then
		if count > 0 then
			baseState = "cmds ran: "..tostring(count)
		else
			baseState = "Idle"
		end
	end
	if cfgRPC.useCustom and cfgRPC.state and cfgRPC.state ~= "" then
		baseState = applyTemplate(cfgRPC.state, baseState)
	end
	if type(baseState) ~= "string" then
		baseState = tostring(baseState)
	end

	local execInfo = NAmanage.btGetExecutorInfo()
	local execNameLabel = execInfo and execInfo.name or "Unknown"
	if execNameLabel == "" then
		execNameLabel = "Unknown"
	end
	execNameLabel = tostring(execNameLabel)
	local execLabel = execNameLabel

	local displayState = Format("%s | Executor: %s", baseState, execLabel)

	local largeAsset = 86994583496114
	local smallAsset = placeIconAssetId and placeIconAssetId() or nil
	if smallAsset == 0 then
		smallAsset = nil
	end
	local smallHover = placeName and placeName() or nil
	if not smallAsset then
		smallAsset = 13409122839
		if not smallHover or smallHover == "" or smallHover == "unknown" then
			smallHover = "v1.0"
		end
	end

	NAmanage.btSend("SetRichPresence", {
		details = displayDetails;
		state = displayState;
		largeImage = {
			assetId = largeAsset;
			hoverText = tostring(versionHover);
		};
		smallImage = smallAsset and {
			assetId = smallAsset;
			hoverText = tostring(smallHover or "Game");
		} or nil;
	})
end

NAmanage.btBump=function()
	NAmanage.btCount = (NAmanage.btCount or 0) + 1
	NAmanage.btUpdate()
end

Defer(function()
	NAmanage.btUpdate()
end)

NAmanage.loadCmdIntegration=function(opts)
	opts = opts or {}

	local function fetchFile(path)
		if not (FileSupport and type(isfile) == "function" and isfile(path)) then
			return nil, nil, "file not found"
		end
		local ok, raw = pcall(readfile, path)
		if ok and type(raw) == "string" and raw ~= "" then
			return raw, "file:"..path
		end
		return nil, nil, Format("unable to read %s", tostring(path))
	end

	local function fetchUrl(url)
		if type(url) ~= "string" or url == "" then
			return nil, nil, "invalid url"
		end

		local request = opt and opt.NAREQUEST
		if type(request) == "function" then
			local ok, response = pcall(request, {
				Url = url;
				Method = "GET";
				Timeout = 10;
				FollowRedirects = true;
				SslVerify = false;
			})
			if ok and response then
				local body = response.Body or response.body or response.Data or response.data or response.Text or response.text or response.Content or response.content or response[1]
				if type(body) == "string" and body ~= "" then
					return body, url
				end
			end
		end

		local ok, body = pcall(function()
			return game:HttpGet(url)
		end)
		if ok and type(body) == "string" and body ~= "" then
			return body, url
		end

		return nil, nil, "request failed"
	end

	if NAStuff.CmdIntegrationLoading then
		return false, "Cmd is already loading"
	end
	if NAStuff.CmdIntegrationLoaded then
		if not opts.silent and type(DebugNotif) == "function" then
			DebugNotif("Cmd is already loaded.", 2)
		end
		return true, NAStuff.CmdIntegrationLastSource
	end

	local sources = {}

	local function pushFile(path)
		if FileSupport and type(isfile) == "function" and path and path ~= "" and isfile(path) then
			Insert(sources, { kind = "file", value = path })
		end
	end

	pushFile(opts.path)
	pushFile("cmd/main.lua")
	pushFile("Cmd/main.lua")

	local function pushUrl(url)
		if url and url ~= "" then
			Insert(sources, { kind = "url", value = url })
		end
	end

	pushUrl(opts.url)
	pushUrl(opt.cmdIntegrationUrl)
	pushUrl(opt.cmdIntegrationFallbackUrl)

	local raw, sourceLabel
	local lastError

	for _, src in ipairs(sources) do
		if src.kind == "file" then
			raw, sourceLabel, lastError = fetchFile(src.value)
		else
			raw, sourceLabel, lastError = fetchUrl(src.value)
		end
		if raw and raw ~= "" then
			break
		end
	end

	if not raw or raw == "" then
		return false, lastError or "unable to fetch Cmd script"
	end

	local bridgeSuffix = [[
;local _g=(getgenv and getgenv()) or _G
;local function _cmdList()
	local out={}
	if type(Commands)=="table" then
		for n,d in pairs(Commands) do
			local aliases={}
			if type(d)=="table" and type(d[1])=="table" then
				for _,a in ipairs(d[1]) do
					aliases[#aliases+1]=tostring(a)
				end
			end
			local desc=""
			if type(d)=="table" then
				local ds=d[2]
				if type(ds)=="table" then
					desc=ds[1] or ""
				elseif type(ds)=="string" then
					desc=ds
				end
			end
			out[#out+1]={name=tostring(n),aliases=aliases,desc=desc}
		end
	end
	return out
end
;local _b={parse=(Command and Command.Parse),run=(Command and Command.Run),prefix=(Settings and Settings.Prefix),list=_cmdList}
;if _g then _g.CmdIntegrationBridge=_b end
;return _b]]
	raw = raw..bridgeSuffix

	local chunk, compileErr = loadstring(raw, "CmdIntegration")
	if not chunk then
		return false, compileErr or "compile error"
	end

	NAStuff.CmdIntegrationLoading = true
	local ok, result = pcall(chunk)
	NAStuff.CmdIntegrationLoading = false

	if not ok then
		return false, result
	end

	NAStuff.CmdIntegrationLoaded = true
	NAStuff.CmdIntegrationLastSource = sourceLabel
	local bridge = result or (getgenv and getgenv().CmdIntegrationBridge)
	if type(bridge) == "table" then
		NAStuff.CmdIntegrationBridge = bridge
		if type(bridge.prefix) == "string" and bridge.prefix ~= "" then
			NAStuff.CmdIntegrationPrefix = bridge.prefix
		end
		if type(bridge.list) == "function" then
			local okList, list = pcall(bridge.list)
			if okList and type(list) == "table" then
				NAStuff.CmdIntegrationCommands = list
			else
				NAStuff.CmdIntegrationCommands = nil
			end
		end
	end

	if NAgui and NAgui.loadCMDS then
		pcall(NAgui.loadCMDS)
	end

	if not opts.silent and type(DoNotif) == "function" then
		local label = sourceLabel or "Cmd"
		DoNotif("Cmd loaded", 3)
	end

	return true, sourceLabel
end

NAmanage._naIsCmdCommandEntry=function(data)
	return type(data) == "table"
		and type(data[1]) == "table"
		and type(data[5]) == "function"
end

NAmanage._naIsCmdCommandsTable=function(tbl)
	if type(tbl) ~= "table" then
		return false
	end
	local seen = 0
	for key, value in pairs(tbl) do
		if type(key) ~= "string" then
			return false
		end
		if NAmanage._naIsCmdCommandEntry(value) then
			seen += 1
			if seen >= 3 then
				return true
			end
		end
	end
	return seen > 0
end

NAmanage.detectCmdManualLoad=function(opts)
	opts = opts or {}

	local function warnSafe(msg)
		if opts.silent then return end
		if type(warn) == "function" then
			warn("[NA Cmd detect] "..tostring(msg))
		end
	end

	local ok, result, label = pcall(function()
		if NAStuff.CmdIntegrationLoaded and NAStuff.CmdIntegrationBridge then
			return true, "already-loaded"
		end

		local existingBridge = (getgenv and getgenv().CmdIntegrationBridge) or nil
		if type(existingBridge) == "table" and type(existingBridge.parse) == "function" then
			NAStuff.CmdIntegrationBridge = existingBridge
			NAStuff.CmdIntegrationLoaded = true
			NAStuff.CmdIntegrationLastSource = "manual-bridge"
			if type(existingBridge.prefix) == "string" and existingBridge.prefix ~= "" then
				NAStuff.CmdIntegrationPrefix = existingBridge.prefix
			end
			if type(existingBridge.list) == "function" then
				local okList, list = pcall(existingBridge.list)
				if okList and type(list) == "table" then
					NAStuff.CmdIntegrationCommands = list
				end
			end
			return true, "manual-bridge"
		end

		local commandsTable
		local commandModule
		local settingsTable

		local env = (getgenv and getgenv()) or _G or {}
		if not commandsTable and NAmanage._naIsCmdCommandsTable(env.Commands) then
			commandsTable = env.Commands
		end
		if not commandModule and type(env.Command) == "table" and type(env.Command.Parse) == "function" and type(env.Command.Run) == "function" then
			commandModule = env.Command
		end
		if not settingsTable and type(env.Settings) == "table" and type(rawget(env.Settings, "Prefix")) == "string" and type(rawget(env.Settings, "ChatPrefix")) == "string" then
			settingsTable = env.Settings
		end

		if type(getgc) ~= "function" then
			if commandsTable and commandModule then else
				return false, "introspection-unavailable"
			end
		end

		if type(getgc) == "function" then
			for _, obj in ipairs(getgc(true)) do
				if type(obj) == "table" then
					if not commandsTable and NAmanage._naIsCmdCommandsTable(obj) then
						commandsTable = obj
					end
					if not commandModule and type(rawget(obj, "Parse")) == "function" and type(rawget(obj, "Run")) == "function" then
						commandModule = obj
					end
					if not settingsTable and type(rawget(obj, "Prefix")) == "string" and type(rawget(obj, "ChatPrefix")) == "string" then
						settingsTable = obj
					end
				end
				if commandsTable and commandModule and settingsTable then
					break
				end
			end
		end

		if (not commandsTable or not commandModule) and type(debug) == "table" and type(debug.getupvalue) == "function" then
			if commandModule and type(commandModule.Parse) == "function" then
				local idx = 1
				while true do
					local name, val = debug.getupvalue(commandModule.Parse, idx)
					if not name then break end
					if not commandsTable and NAmanage._naIsCmdCommandsTable(val) then
						commandsTable = val
					end
					if not settingsTable and type(val) == "table" and type(rawget(val, "Prefix")) == "string" and type(rawget(val, "ChatPrefix")) == "string" then
						settingsTable = val
					end
					idx += 1
				end
			end
		end

		if not commandsTable or not commandModule then
			return false, "cmd-not-found"
		end

		local function buildList()
			local out = {}
			for name, data in pairs(commandsTable) do
				local aliases = {}
				if type(data[1]) == "table" then
					for _, a in ipairs(data[1]) do
						local aa = tostring(a or "")
						if aa ~= "" then
							Insert(aliases, aa)
						end
					end
				end
				local desc = ""
				if type(data[2]) == "table" then
					desc = data[2][1] or data[2][2] or ""
				elseif type(data[2]) == "string" then
					desc = data[2]
				end
				out[#out + 1] = { name = tostring(name), aliases = aliases, desc = desc }
			end
			table.sort(out, function(a, b)
				return tostring(a.name) < tostring(b.name)
			end)
			return out
		end

		local prefix = (settingsTable and settingsTable.Prefix) or ";"
		local bridge = {
			parse = function(ignoreNotifs, line)
				return commandModule.Parse(ignoreNotifs, line)
			end;
			run = commandModule.Run;
			prefix = prefix;
			list = buildList;
		}

		NAStuff.CmdIntegrationBridge = bridge
		if type(prefix) == "string" and prefix ~= "" then
			NAStuff.CmdIntegrationPrefix = prefix
		end
		local okList, list = pcall(buildList)
		if okList and type(list) == "table" then
			NAStuff.CmdIntegrationCommands = list
		end
		NAStuff.CmdIntegrationLoaded = true
		NAStuff.CmdIntegrationLastSource = "manual-detect"

		if not opts.silent and NAgui and NAgui.loadCMDS then
			pcall(NAgui.loadCMDS)
		end

		return true, "manual-detect"
	end)

	if not ok then
		warnSafe(result)
		return false, "manual-detect-error"
	end
	return result, label
end

NAmanage.resolveTweenDuration=function(scale)
	local base = tonumber(NAStuff.tweenSpeed) or 1
	if base <= 0 then
		base = 1
	end
	scale = tonumber(scale) or 1
	if scale <= 0 then
		scale = 1
	end
	return math.max(0.05, base * scale)
end
NAmanage._loaderStatus = NAmanage._loaderStatus or {}

NAmanage.loaderWarn=function(label, detail)
	warn(Format('[%s loader] %s: %s', adminName, label, detail))
end

function NAmanage.waitForScreenGui(timeoutSeconds)
	timeoutSeconds = timeoutSeconds or 5
	local deadline = tick() + timeoutSeconds
	repeat
		local gui = NAStuff.NASCREENGUI
		if gui and gui.Parent then
			return gui
		end
		Wait(0.1)
	until tick() >= deadline
	return nil
end

function NAmanage.runLoader(label, callback, opts)
	opts = opts or {}
	local attempts = opts.retries or 3
	local delay = opts.delay or 0.35
	local retryOnFalse = opts.retryOnFalse
	local requireGui = opts.requiresGui
	local guiTimeout = opts.guiTimeout or 5

	if requireGui and not NAmanage.waitForScreenGui(guiTimeout) then
		NAmanage.loaderWarn(label, 'aborted: interface not ready')
		return false
	end

	local lastErr
	for attempt = 1, attempts do
		local ok, result = pcall(callback)
		if ok and (result ~= false or not retryOnFalse) then
			NAmanage._loaderStatus[label] = true
			return true, result
		end

		if ok then
			lastErr = 'callback returned false'
			if retryOnFalse then
				NAmanage.loaderWarn(label, Format('attempt %d/%d returned false', attempt, attempts))
			end
		else
			lastErr = result
			NAmanage.loaderWarn(label, Format('attempt %d/%d failed: %s', attempt, attempts, tostring(result)))
		end

		if attempt < attempts then
			Wait(delay)
			if requireGui then
				local gui = NAmanage.waitForScreenGui(guiTimeout)
				if not gui then
					break
				end
			end
		end
	end

	if opts.onFailure then
		pcall(opts.onFailure, lastErr)
	end
	NAmanage._loaderStatus[label] = false
	return false
end

NAmanage.clampNumber=function(value, minValue, maxValue, fallback)
	local n = tonumber(value)
	if n == nil then return fallback end
	if minValue and n < minValue then n = minValue end
	if maxValue and n > maxValue then n = maxValue end
	return n
end

NAmanage.SendIntegrationWebhook=function(kind, content)
	local cfg = NAStuff.Integrations and NAStuff.Integrations.webhook
	if not (cfg and content and content ~= "") then
		return false, "missing config"
	end
	local urlsCfg = cfg.urls or {}
	local dedupe = {}
	local targets = {}
	local function addUrl(url)
		if type(url) ~= "string" then
			return
		end
		local trimmed = url:match("^%s*(.-)%s*$")
		if trimmed ~= "" and not dedupe[trimmed] then
			dedupe[trimmed] = true
			Insert(targets, trimmed)
		end
	end
	local kindKey = nil
	local fallbackUrl = urlsCfg.all or cfg.url
	if kind == "joinleave" then
		kindKey = "joinleave"
	elseif kind == "chat" then
		kindKey = "chat"
	elseif kind == "command" or kind == "commands" then
		kindKey = "commands"
	elseif kind == "main" or kind == "message" or kind == "msg" then
		kindKey = "main"
		fallbackUrl = urlsCfg.main or fallbackUrl
	elseif urlsCfg.main and kind == nil then
		fallbackUrl = urlsCfg.main
	end
	if kindKey and urlsCfg[kindKey] then
		addUrl(urlsCfg[kindKey])
	end
	if kind == "test" then
		addUrl(urlsCfg.joinleave)
		addUrl(urlsCfg.chat)
		addUrl(urlsCfg.commands)
		addUrl(urlsCfg.main)
	end
	if cfg.useAll or #targets == 0 or kind == "test" then
		addUrl(fallbackUrl)
	end
	if #targets == 0 then
		return false, "missing config"
	end
	local now = tick()
	local minInt = NAmanage.clampNumber(cfg.minInterval, 0, 60, 2) or 2
	if cfg.lastSent and (now - cfg.lastSent) < minInt then
		return false, "rate-limited"
	end
	local payloadData
	if type(content) == "table" then
		payloadData = content
	else
		payloadData = { content = content }
	end
	local payload = HttpService:JSONEncode(payloadData)
	local sentCount = 0
	local lastErr = nil
	for _, url in ipairs(targets) do
		local ok, res = pcall(function()
			if opt and type(opt.NAREQUEST) == "function" then
				return opt.NAREQUEST({
					Url = url;
					Method = "POST";
					Headers = { ["Content-Type"] = "application/json" };
					Body = payload;
				})
			else
				return HttpService:PostAsync(url, payload, Enum.HttpContentType.ApplicationJson, false)
			end
		end)
		if ok then
			sentCount = sentCount + 1
		else
			lastErr = res
		end
	end
	if sentCount > 0 then
		cfg.lastSent = now
		return true
	end
	return false, lastErr
end

NAmanage.WebhookJoinLeave=function(plr, action)
	local cfg = NAStuff.Integrations and NAStuff.Integrations.webhook
	if not (cfg and cfg.enableJoinLeave) then return end
	local username = nameChecker and nameChecker(plr) or (plr and plr.Name) or "Player"
	local actLabel = action == "leave" and "left" or "joined"
	local jobId = tostring(game.JobId or "")
	local placeId = tostring(game.PlaceId or "")
	local color = action == "leave" and 16711680 or 65280
	local payload = {
		content = "",
		embeds = {
			{
				title = "Join/Leave Log",
				description = Format("%s has %s.", username, actLabel),
				color = color,
				fields = {
					{
						name = "Place / Job",
						value = Format("PlaceId: ```%s``` | JobId: ```%s```", placeId, jobId),
						inline = false,
					},
				},
			},
		},
	}
	NAmanage.SendIntegrationWebhook("joinleave", payload)
end

NAmanage.WebhookChat=function(plr, msg)
	local cfg = NAStuff.Integrations and NAStuff.Integrations.webhook
	if not (cfg and cfg.enableChat) then return end
	local username = nameChecker and nameChecker(plr) or (plr and plr.Name) or "Player"
	local text = Format("[Chat] %s: %s", username, tostring(msg or ""))
	NAmanage.SendIntegrationWebhook("chat", text)
end

NAmanage.WebhookCommand=function(rawArgs)
	local cfg = NAStuff.Integrations and NAStuff.Integrations.webhook
	if not (cfg and cfg.enableCommands) then return end
	if type(rawArgs) ~= "table" or #rawArgs == 0 then return end
	local playerName = nameChecker and nameChecker(Players and Players.LocalPlayer) or (Players and Players.LocalPlayer and Players.LocalPlayer.Name) or "LocalPlayer"
	local line = Concat(rawArgs, " ")
	local text = Format("[Command] ran: %s", line)
	NAmanage.SendIntegrationWebhook("command", text)
end

NAmanage.HealthPing=function(url)
	if type(url) ~= "string" or url == "" then
		return false, "missing url"
	end
	local start = os.clock()
	local ok, res = pcall(function()
		if opt and type(opt.NAREQUEST) == "function" then
			return opt.NAREQUEST({ Url = url, Method = "GET", Timeout = 5, FollowRedirects = true })
		else
			return HttpService:GetAsync(url)
		end
	end)
	local elapsed = os.clock() - start
	if ok then
		return true, elapsed
	end
	return false, res or "error", elapsed
end

NAmanage.HealthPingAll=function()
	local eps = (NAStuff.Integrations and NAStuff.Integrations.health and NAStuff.Integrations.health.endpoints) or {}
	local results = {}
	for idx, url in ipairs(eps) do
		if url and url ~= "" then
			local ok, info, elapsed = NAmanage.HealthPing(url)
			if ok then
				Insert(results, Format("#%d OK (%.2fs)", idx, tonumber(info) or elapsed or 0))
			else
				local errText = tostring(info or "error")
				Insert(results, Format("#%d FAIL: %s", idx, errText))
			end
		end
	end
	return results
end

NAmanage.ComposeServerNote=function(note)
	local parts = {}
	local jobId = tostring(game.JobId or "")
	local placeId = tostring(game.PlaceId or "")
	Insert(parts, "PlaceId: "..placeId)
	if jobId and jobId ~= "" then
		Insert(parts, "JobId: "..jobId)
	end
	local serverCount = Players and Players.NumPlayers or nil
	if serverCount then
		local max = Players.MaxPlayers or "?"
		Insert(parts, Format("Players: %s/%s", serverCount, max))
	end
	if note and note ~= "" then
		Insert(parts, "Note: "..note)
	end
	return Concat(parts, " | ")
end

function NAmanage.scheduleLoader(label, callback, opts)
	Spawn(function()
		NAmanage.runLoader(label, callback, opts)
	end)
end

local searchIndex = {}
local cmds
local defaultBarCommands = { "settings", "commands", "cmdloop", "adonisbypass", "discord" }
local shouldShowDefaultAutofill = false
local prevVisible, results = {}, {}
local lastSearchText, gen = "", 0
local searchInputTarget
local aliasExactCache, aliasPrefixCache = {}, {}
local savedExactCache, savedPrefixCache = {}, {}

NAmanage.defaultCommandMatches=function(entry, target)
	if not (entry and target) then
		return false
	end
	if entry.lowerName == target then
		return true
	end
	if entry.extraAliases then
		for _, alias in ipairs(entry.extraAliases) do
			if alias and Lower(alias) == target then
				return true
			end
		end
	end
	local baseLower = entry.name and Lower(entry.name) or nil
	if baseLower then
		local commandData = cmds.Commands[baseLower]
		local aliasData = cmds.Aliases[target]
		if commandData and aliasData and commandData == aliasData then
			return true
		end
		local savedAliasTarget = cmds.NASAVEDALIASES[target]
		if savedAliasTarget and Lower(savedAliasTarget) == baseLower then
			return true
		end
	end
	return false
end
local NAImageAssets = {
	Icon = "NAnew.png";
	nilsongamer99 = "nilsongamer99.png";
	Sheet = "sheet.png";
	Inlet = "Inlet.png";
	Stud = "oldStud.png";
	bk = "SkyBk.png";
	dn = "SkyDn.png";
	ft = "SkyFt.png";
	lf = "SkyLf.png";
	rt = "SkyRt.png";
	up = "SkyUp.png";
	ResizeVertical = "Vertical16x16.png";
	ResizeHorizontal = "Horizontal16x16.png";
	ResizeDiagonal1 = "Diagonal116x16.png";
	ResizeDiagonal2 = "Diagonal216x16.png";
}
NAStuff._rf = NAStuff._rf or readfile
NAStuff._wf = NAStuff._wf or writefile
NAStuff._iff = NAStuff._iff or isfile
NAStuff._df = NAStuff._df or delfile

NAStuff.dotBad = NAStuff.dotBad or false

NAmanage.stripExt=function(p)
    if type(p) ~= "string" then
        return p
    end
    return (p:gsub("([^/]+)%.[^/]+$", "%1"))
end

NAmanage.isInvalidPathErr=function(e)
    return type(e) == "string" and e:find("Invalid path", 1, true) ~= nil
end

if type(NAStuff._wf) == "function" then
    getgenv().writefile = function(p, data, ...)
        if type(p) ~= "string" then
            return NAStuff._wf(p, data, ...)
        end

        local pNoExt = NAmanage.stripExt(p)
        local ok, err = pcall(NAStuff._wf, p, data, ...)
        if ok then
            NAStuff.dotBad = false
            return
        end

        if pNoExt ~= p and NAmanage.isInvalidPathErr(err) then
            local ok2, err2 = pcall(NAStuff._wf, pNoExt, data, ...)
            if ok2 then
                NAStuff.dotBad = true
                return
            end
            error(err2 or err)
        end

        error(err)
    end
end

if type(NAStuff._rf) == "function" then
    getgenv().readfile = function(p, ...)
        if type(p) ~= "string" then
            return NAStuff._rf(p, ...)
        end

        local pNoExt = NAmanage.stripExt(p)
        local ok, res = pcall(NAStuff._rf, p, ...)
        if ok and res ~= nil then
            NAStuff.dotBad = false
            return res
        end

        if pNoExt ~= p then
            local ok2, res2 = pcall(NAStuff._rf, pNoExt, ...)
            if ok2 then
                NAStuff.dotBad = true
                return res2
            end
        end

        return nil
    end
end

if type(NAStuff._iff) == "function" then
    getgenv().isfile = function(p, ...)
        if type(p) ~= "string" then
            local ok, res = pcall(NAStuff._iff, p, ...)
            return ok and res or false
        end

        local pNoExt = NAmanage.stripExt(p)

        local ok, res = pcall(NAStuff._iff, p, ...)
        if ok and res then
            return true
        end

        if pNoExt ~= p then
            local ok2, res2 = pcall(NAStuff._iff, pNoExt, ...)
            if ok2 and res2 then
                NAStuff.dotBad = true
                return true
            end
        end

        return false
    end
end

if type(NAStuff._df) == "function" then
    getgenv().delfile = function(p, ...)
        if type(p) ~= "string" then
            return NAStuff._df(p, ...)
        end

        local pNoExt = NAmanage.stripExt(p)

        local ok, err = pcall(NAStuff._df, p, ...)
        if ok then
            NAStuff.dotBad = false
            return
        end

        if pNoExt ~= p and NAmanage.isInvalidPathErr(err) then
            local ok2, err2 = pcall(NAStuff._df, pNoExt, ...)
            if ok2 then
                NAStuff.dotBad = true
                return
            end
            error(err2 or err)
        end

        error(err)
    end
end
local NAfiles = {
	NAFILEPATH = "Nameless-Admin";
	NAWAYPOINTFILEPATH = "Nameless-Admin/Waypoints";
	NAPLUGINFILEPATH = "Nameless-Admin/Plugins";
	NAIYPLUGINFILEPATH = "Nameless-Admin/PluginsIY";
	NAASSETSFILEPATH = "Nameless-Admin/Assets";
	NAMAINSETTINGSPATH = "Nameless-Admin/Settings.json";
	NAPREFIXPATH = "Nameless-Admin/Prefix.txt";
	NABUTTONSIZEPATH = "Nameless-Admin/ButtonSize.txt";
	NAUISIZEPATH = "Nameless-Admin/UIScale.txt";
	NAQOTPATH = "Nameless-Admin/QueueOnTeleport.txt";
	NAALIASPATH = "Nameless-Admin/Aliases.json";
	NAUSERBUTTONSPATH = "Nameless-Admin/UserButtons.json";
	NAAUTOEXECPATH = "Nameless-Admin/AutoExecCommands.json";
	NAPREDICTIONPATH = "Nameless-Admin/Prediction.txt";
	NASTROKETHINGY = "Nameless-Admin/NAUIStroker.txt";
	NAJOINLEAVE = "Nameless-Admin/JoinLeave.json";
	NAJOINLEAVELOG = "Nameless-Admin/JoinLeaveLog.txt";
	NACHATLOGS = "Nameless-Admin/ChatLogs.txt";
	NATOPBAR = "Nameless-Admin/TopBarApp.txt";
	NANOTIFSTOGGLE = "Nameless-Admin/NotifsTgl.txt";
	NABINDERS = "Nameless-Admin/Binders.json";
	NAESPSETTINGSPATH = "Nameless-Admin/ESPSettings.json";
	NATOPBARMODE = "Nameless-Admin/TopbarMode.txt";
	NATEXTCHATSETTINGSPATH = "Nameless-Admin/TextChatSettings.json";
	NACUSTOMFONTPATH = "Nameless-Admin/CustomFont";
	NACUSTOMICONPATH = "Nameless-Admin/CustomIcon";
	NACOMMANDKEYBINDS = "Nameless-Admin/CommandKeybinds.json";
	NAFFLAGSPATH = "Nameless-Admin/NAFFlags.json";
}
NAmanage.newCornerStore=function()
	return {}
end

NAmanage.initCornerEditor=function(coreGui, HUI)
	if not (coreGui and NAgui) then
		return
	end

	local CE = {
		path = NAfiles.NAFILEPATH.."/corner_editor.json",
		default = {
			enabled = false,
			radius = 10,
			targetCoreGui = true,
			targetPlayerGui = false,
			targetBillboardGui = false,
			targetSurfaceGui = false,
		},
		cg = coreGui,
		store = NAmanage.newCornerStore(),
		watchers = {},
		guiRootWatchers = {},
		guiRootSeen = setmetatable({}, { __mode = "k" }),
		restoring = false,
	}

	local data = {
		enabled = CE.default.enabled,
		radius = CE.default.radius,
		targetCoreGui = CE.default.targetCoreGui,
		targetPlayerGui = CE.default.targetPlayerGui,
		targetBillboardGui = CE.default.targetBillboardGui,
		targetSurfaceGui = CE.default.targetSurfaceGui,
	}
	if FileSupport then
		if not isfile(CE.path) then
			writefile(CE.path, HttpService:JSONEncode(CE.default))
		end
		local okRead, raw = pcall(readfile, CE.path)
		if okRead and type(raw) == "string" then
			local okDecode, decoded = pcall(HttpService.JSONDecode, HttpService, raw)
			if okDecode and type(decoded) == "table" then
				data.enabled = decoded.enabled == true
				local parsedRadius = tonumber(decoded.radius)
				if parsedRadius then
					data.radius = parsedRadius
				end
				if type(decoded.targetCoreGui) == "boolean" then
					data.targetCoreGui = decoded.targetCoreGui
				end
				if type(decoded.targetPlayerGui) == "boolean" then
					data.targetPlayerGui = decoded.targetPlayerGui
				end
				if type(decoded.targetBillboardGui) == "boolean" then
					data.targetBillboardGui = decoded.targetBillboardGui
				end
				if type(decoded.targetSurfaceGui) == "boolean" then
					data.targetSurfaceGui = decoded.targetSurfaceGui
				end
			end
		end
	end
	data.radius = math.clamp(data.radius, 0, 64)
	CE.data = data

	local function getPlayerGui()
		local lp = Players and Players.LocalPlayer
		if not lp then
			return nil
		end
		return lp:FindFirstChildOfClass("PlayerGui") or lp:FindFirstChild("PlayerGui")
	end

	local function getCRad()
		return UDim.new(0, math.clamp(tonumber(CE.data.radius) or CE.default.radius, 0, 64))
	end

	local function isCTgt(o)
		if not (o and o:IsA("UICorner")) then
			return false
		end
		if HUI and o:IsDescendantOf(HUI) then
			return false
		end
		return true
	end

	local function getCTgts()
		local containers = {}
		if CE.data.targetCoreGui and CE.cg then
			containers[#containers + 1] = CE.cg
		end
		if CE.data.targetPlayerGui then
			local pg = getPlayerGui()
			if pg then
				containers[#containers + 1] = pg
			end
		end
		local world = workspace
		if CE.data.targetBillboardGui and world and world.GetDescendants then
			for _, inst in ipairs(world:GetDescendants()) do
				if inst:IsA("BillboardGui") then
					containers[#containers + 1] = inst
				end
			end
		end
		if CE.data.targetSurfaceGui and world and world.GetDescendants then
			for _, inst in ipairs(world:GetDescendants()) do
				if inst:IsA("SurfaceGui") then
					containers[#containers + 1] = inst
				end
			end
		end
		return containers
	end

	local function getCBB(o)
		if not (CE.data.targetBillboardGui and typeof(o) == "Instance") then
			return nil
		end
		if o:IsA("BillboardGui") then
			return o
		end
		local ok, ancestor = pcall(function()
			return o:FindFirstAncestorOfClass("BillboardGui")
		end)
		if ok then
			return ancestor
		end
		return nil
	end

	local function getCSurf(o)
		if not (CE.data.targetSurfaceGui and typeof(o) == "Instance") then
			return nil
		end
		if o:IsA("SurfaceGui") then
			return o
		end
		local ok, ancestor = pcall(function()
			return o:FindFirstAncestorOfClass("SurfaceGui")
		end)
		if ok then
			return ancestor
		end
		return nil
	end

	local function stopCWat(target)
		local watcher = CE.watchers[target]
		if not watcher then
			return
		end
		if watcher.change then
			watcher.change:Disconnect()
		end
		if watcher.ancestry then
			watcher.ancestry:Disconnect()
		end
		CE.watchers[target] = nil
	end

	local function setCWat(target)
		if not target or CE.watchers[target] then
			return
		end
		local watcher = {}
		watcher.change = target:GetPropertyChangedSignal("CornerRadius"):Connect(function()
			if CE.restoring or not CE.data.enabled then
				return
			end
			local desired = getCRad()
			if target.CornerRadius ~= desired then
				pcall(function()
					target.CornerRadius = desired
				end)
			end
		end)
		watcher.ancestry = target.AncestryChanged:Connect(function(obj)
			if not obj.Parent then
				stopCWat(obj)
				CE.store[obj] = nil
			end
		end)
		CE.watchers[target] = watcher
	end

	local function setCorner(o)
		if not isCTgt(o) then
			return
		end
		local info = CE.store[o]
		if not info then
			info = { original = o.CornerRadius }
			CE.store[o] = info
		end
		o.CornerRadius = getCRad()
		setCWat(o)
	end

	local function clearGuiRootWatchers()
		for root, conns in pairs(CE.guiRootWatchers) do
			if conns.desc then conns.desc:Disconnect() end
			if conns.anc then conns.anc:Disconnect() end
			CE.guiRootWatchers[root] = nil
		end
		CE.guiRootSeen = setmetatable({}, { __mode = "k" })
	end

	local function resetCorn()
		CE.restoring = true
		for corner, info in pairs(CE.store) do
			if corner and info and info.original then
				pcall(function()
					corner.CornerRadius = info.original
				end)
			end
			stopCWat(corner)
		end
		CE.restoring = false
		CE.store = NAmanage.newCornerStore()
		CE.watchers = {}
		clearGuiRootWatchers()
	end

	local function applyCornersIn(container)
		if not container then
			return
		end
		if container:IsA("UICorner") then
			setCorner(container)
		end
		for _, d in ipairs(container:GetDescendants()) do
			if d:IsA("UICorner") then
				setCorner(d)
			end
		end
	end

	local watchGuiRoot

	local function applyCorn()
		if not CE.data.enabled then
			return
		end
		for _, container in ipairs(getCTgts()) do
			applyCornersIn(container)
			if container:IsA("BillboardGui") or container:IsA("SurfaceGui") then
				CE.guiRootSeen[container] = true
				watchGuiRoot(container)
			end
		end
	end

	local function saveCData()
		if FileSupport then
			writefile(CE.path, HttpService:JSONEncode(CE.data))
		end
	end

	local function onCDesc(o)
		if CE.data.enabled and o:IsA("UICorner") then
			setCorner(o)
		end
	end

	function watchGuiRoot(root)
		if not root or CE.guiRootWatchers[root] then
			return
		end
		local conns = {}
		conns.desc = root.DescendantAdded:Connect(function(d)
			if CE.data.enabled and d:IsA("UICorner") then
				setCorner(d)
			end
		end)
		conns.anc = root.AncestryChanged:Connect(function(obj, parent)
			if parent == nil then
				if CE.guiRootWatchers[root] then
					if conns.desc then conns.desc:Disconnect() end
					if conns.anc then conns.anc:Disconnect() end
					CE.guiRootWatchers[root] = nil
				end
				CE.guiRootSeen[root] = nil
			end
		end)
		CE.guiRootWatchers[root] = conns
	end

	local function onCBB(o)
		if not CE.data.enabled then
			return
		end
		if not o:IsA("BillboardGui") then
			return
		end
		local root = getCBB(o)
		if not root then
			return
		end
		if not CE.guiRootSeen[root] then
			CE.guiRootSeen[root] = true
			applyCornersIn(root)
		end
		if o:IsA("UICorner") then
			setCorner(o)
		end
		watchGuiRoot(root)
	end

	local function onCSurf(o)
		if not CE.data.enabled then
			return
		end
		if not o:IsA("SurfaceGui") then
			return
		end
		local root = getCSurf(o)
		if not root then
			return
		end
		if not CE.guiRootSeen[root] then
			CE.guiRootSeen[root] = true
			applyCornersIn(root)
		end
		if o:IsA("UICorner") then
			setCorner(o)
		end
		watchGuiRoot(root)
	end

	local function syncCConn()
		NAlib.disconnect("CornerEditor")
		if CE.data.targetCoreGui and CE.cg then
			NAlib.connect("CornerEditor", CE.cg.DescendantAdded:Connect(onCDesc))
		end

		NAlib.disconnect("CornerEditor_PlayerGui")
		local pg = CE.data.targetPlayerGui and getPlayerGui()
		if pg then
			NAlib.connect("CornerEditor_PlayerGui", pg.DescendantAdded:Connect(onCDesc))
		end

		local world = workspace
		NAlib.disconnect("CornerEditor_Billboard")
		if CE.data.targetBillboardGui and world then
			NAlib.connect("CornerEditor_Billboard", world.DescendantAdded:Connect(onCBB))
		end

		NAlib.disconnect("CornerEditor_Surface")
		if CE.data.targetSurfaceGui and world then
			NAlib.connect("CornerEditor_Surface", world.DescendantAdded:Connect(onCSurf))
		end
	end

	local function monCPGui()
		local lp = Players and Players.LocalPlayer
		if not lp then
			return
		end
		NAlib.disconnect("CornerEditor_PlayerGuiAdded")
		NAlib.connect("CornerEditor_PlayerGuiAdded", lp.ChildAdded:Connect(function(child)
			if child:IsA("PlayerGui") then
				syncCConn()
				if CE.data.enabled then
					applyCorn()
				end
			end
		end))
		NAlib.disconnect("CornerEditor_PlayerGuiRemoved")
		NAlib.connect("CornerEditor_PlayerGuiRemoved", lp.ChildRemoved:Connect(function(child)
			if child:IsA("PlayerGui") then
				syncCConn()
			end
		end))
	end

	local function setCTgt(field, value)
		if CE.data[field] == value then
			return
		end
		CE.data[field] = value
		saveCData()
		syncCConn()
		if CE.data.enabled then
			resetCorn()
			applyCorn()
		end
	end

	syncCConn()
	monCPGui()
	if CE.data.enabled then
		applyCorn()
	end

	local FontEditor
	local persistFontData
	local persistFontData

	local function newFontStore()
		return {}
	end

	local FontChoices = {}
	local CustomFontChoices = {}
	local FontChoiceIndex = {}
	local FontExts = {
		[".ttf"] = true,
		[".otf"] = true,
		[".ttc"] = true,
		[".otc"] = true,
		[".woff"] = true,
		[".woff2"] = true,
		[".fon"] = true,
		[".fnt"] = true,
		[".pfb"] = true,
		[".pfa"] = true,
		[".dfont"] = true,
		[".eot"] = true,
	}
	local NAFontSrc = {
		list = "https://api.github.com/repos/ltseverydayyou/uuuuuuu/contents/NAfonts?ref=main",
		raw = "https://raw.githubusercontent.com/ltseverydayyou/uuuuuuu/main/NAfonts/",
	}

	local function clearFontChoices()
		FontChoices = {}
		CustomFontChoices = {}
		FontChoiceIndex = {}
	end

	local function addFontChoice(choice)
		if not choice or not choice.key then
			return
		end
		FontChoices[#FontChoices + 1] = choice
		FontChoiceIndex[choice.key] = choice
		if choice.kind == "custom" then
			CustomFontChoices[#CustomFontChoices + 1] = choice
		end
	end

	local function enforceCustomCycleAvailability()
		if FontEditor.data.useCustomCycle and #CustomFontChoices == 0 then
			FontEditor.data.useCustomCycle = false
			persistFontData()
		end
	end

	local function getActiveFontChoices()
		if FontEditor.data.useCustomCycle and #CustomFontChoices > 0 then
			return CustomFontChoices
		end
		return FontChoices
	end

	local function ensureCustomFontFolder()
		if isDelta then
			return false, "Custom font files are disabled on this executor."
		end
		if not FileSupport then
			return false, "File support is required for custom fonts."
		end
		if type(FontEditor.customDir) ~= "string" or FontEditor.customDir == "" then
			return false, "Custom font directory is not configured."
		end
		if type(isfolder) == "function" then
			local exists = false
			local ok, res = pcall(isfolder, FontEditor.customDir)
			if ok then
				exists = res
			end
			if not exists then
				if type(makefolder) ~= "function" then
					return false, "\"makefolder\" is required for custom fonts."
				end
				local okMk, err = pcall(makefolder, FontEditor.customDir)
				if not okMk then
					return false, err or "Unable to create custom font directory."
				end
			end
		end
		return true
	end

	local function getCustomFontCount()
		return type(FontEditor.customFonts) == "table" and #FontEditor.customFonts or 0
	end

	local function hasCustomFonts()
		return getCustomFontCount() > 0
	end

	local function formatCustomFontStatus()
		local count = getCustomFontCount()
		if count == 0 then
			return "No custom fonts installed"
		end
		if count == 1 then
			return "1 custom font installed"
		end
		return Format("%d custom fonts installed", count)
	end

	local function preprocessFontUrl(url)
		if type(url) ~= "string" then
			return nil
		end
		local trimmed = url:match("^%s*(.-)%s*$") or ""
		if trimmed == "" then
			return nil
		end
		trimmed = trimmed:gsub(" ", "%%20")
		local qPos = trimmed:find("%?")
		local base = qPos and trimmed:sub(1, qPos - 1) or trimmed
		return trimmed, base
	end

	local function normalizeGitHubPath(path)
		if type(path) ~= "string" then
			return ""
		end
		local cleaned = path:gsub("^/+", "")
		cleaned = cleaned:gsub("/+$", "")
		return cleaned
	end

	local function encodeGitHubPath(path)
		local normalized = normalizeGitHubPath(path or "")
		if normalized == "" then
			return ""
		end
		local segments = {}
		for segment in normalized:gmatch("[^/]+") do
			segments[#segments + 1] = HttpService:UrlEncode(segment)
		end
		return Concat(segments, "/")
	end

	local function parseGitHubFolderUrl(baseUrl, originalUrl)
		if type(baseUrl) ~= "string" or baseUrl == "" then
			return nil
		end
		local owner, repo, kind, rest = baseUrl:match("^https?://github.com/([^/]+)/([^/]+)/([^/]+)/?(.*)$")
		if owner and repo and kind then
			if kind == "tree" then
				local sanitizedRest = rest or ""
				if sanitizedRest:sub(1, 11) == "refs/heads/" then
					sanitizedRest = sanitizedRest:sub(12)
				elseif sanitizedRest:sub(1, 10) == "refs/tags/" then
					sanitizedRest = sanitizedRest:sub(11)
				end
				local branch, path = sanitizedRest:match("^([^/]+)/(.*)$")
				if not branch then
					branch = sanitizedRest ~= "" and sanitizedRest or "main"
					path = ""
				end
				branch = branch:gsub("%%2[Ff]", "/")
				path = (path and path:gsub("%%2[Ff]", "/")) or ""
				return {
					owner = owner,
					repo = repo,
					branch = branch,
					path = normalizeGitHubPath(path),
					originalUrl = originalUrl or baseUrl,
				}
			end
			return nil
		end
		local ownerOnly, repoOnly = baseUrl:match("^https?://github.com/([^/]+)/([^/?#]+)$")
		if ownerOnly and repoOnly then
			return {
				owner = ownerOnly,
				repo = repoOnly:gsub("%.git$", ""),
				branch = "main",
				path = "",
				originalUrl = originalUrl or baseUrl,
			}
		end
		return nil
	end

	local GitHubFolderLimits = {
		depth = 4,
		total = 40,
	}

	local function fetchGitHubFolderContents(info, relativePath)
		if type(info) ~= "table" or type(info.owner) ~= "string" or type(info.repo) ~= "string" then
			return false, "Invalid GitHub folder reference."
		end
		local branch = info.branch ~= "" and info.branch or "main"
		local baseUrl = Format("https://api.github.com/repos/%s/%s/contents", info.owner, info.repo)
		local encodedPath = encodeGitHubPath(relativePath or "")
		if encodedPath ~= "" then
			baseUrl = baseUrl.."/"..encodedPath
		end
		baseUrl = baseUrl.."?ref="..HttpService:UrlEncode(branch)
		local ok, raw = pcall(function()
			return game:HttpGet(baseUrl)
		end)
		if not (ok and type(raw) == "string" and raw ~= "") then
			return false, raw or "Unable to fetch GitHub folder contents."
		end
		local okDecode, decoded = pcall(HttpService.JSONDecode, HttpService, raw)
		if not (okDecode and type(decoded) == "table") then
			return false, "Invalid GitHub folder response."
		end
		if type(decoded.message) == "string" and decoded.message ~= "" then
			return false, decoded.message
		end
		return true, decoded
	end

	local function normalizeCustomFontUrl(url)
		local trimmed, noQuery = preprocessFontUrl(url)
		if not trimmed then
			return nil
		end
		local owner, repo, kind, rest = noQuery:match("^https?://github.com/([^/]+)/([^/]+)/([^/]+)/(.+)$")
		if owner and repo and kind and rest then
			local sanitizedRest = rest
			if sanitizedRest:sub(1, 11) == "refs/heads/" then
				sanitizedRest = sanitizedRest:sub(12)
			elseif sanitizedRest:sub(1, 10) == "refs/tags/" then
				sanitizedRest = sanitizedRest:sub(11)
			end
			local branch, path = sanitizedRest:match("^([^/]+)/(.+)$")
			if branch and path then
				branch = branch:gsub("%%2[Ff]", "/")
				path = path:gsub("%%2[Ff]", "/")
				if kind == "blob" or kind == "raw" then
					return Format("https://raw.githubusercontent.com/%s/%s/%s/%s", owner, repo, branch, path)
				end
			end
		end
		local directRaw = noQuery:match("^https?://raw%.githubusercontent%.com/.+")
		if directRaw then
			return trimmed
		end
		return trimmed
	end

	local function sanitizeFileName(name)
		if type(name) ~= "string" then
			return nil
		end
		local trimmed = name:match("^%s*(.-)%s*$") or ""
		local sanitized = trimmed:gsub("[^%w%._%-]", "_")
		sanitized = sanitized:gsub("_+", "_")
		sanitized = sanitized:gsub("^_+", "")
		sanitized = sanitized:gsub("_+$", "")
		if sanitized == "" then
			return nil
		end
		return sanitized
	end

	local function sanitizeId(name)
		if type(name) ~= "string" then
			return nil
		end
		local lowered = name:lower()
		local sanitized = lowered:gsub("[^%w]+", "_")
		sanitized = sanitized:gsub("_+", "_")
		sanitized = sanitized:gsub("^_+", "")
		sanitized = sanitized:gsub("_+$", "")
		if sanitized == "" then
			return nil
		end
		return sanitized
	end

	local function getFName(path)
		if type(path) ~= "string" then
			return nil
		end
		local normalized = path:gsub("\\", "/")
		return normalized:match("([^/]+)$")
	end

	local function isFontExt(name)
		if type(name) ~= "string" or name == "" then
			return false
		end
		local ext = name:match("%.[^%.]+$")
		return ext and FontExts[ext:lower()] == true
	end

	local function collectGitHubFontFiles(info)
		if type(info) ~= "table" then
			return false, "Invalid GitHub folder reference."
		end
		local fonts = {}
		local visited = {}
		local function visitKey(path)
			return (path and path ~= "") and path or "/"
		end
		local function scan(path, depth)
			depth = depth or 0
			if depth > GitHubFolderLimits.depth then
				return true
			end
			if #fonts >= GitHubFolderLimits.total then
				return true
			end
			local okFetch, payload = fetchGitHubFolderContents(info, path or "")
			if not okFetch then
				return false, payload
			end
			local entries = {}
			if payload.type == "file" then
				entries[1] = payload
			elseif #payload > 0 then
				for _, entry in ipairs(payload) do
					entries[#entries + 1] = entry
				end
			else
				return true
			end
			for _, entry in ipairs(entries) do
				if type(entry) == "table" then
					if entry.type == "file" then
						if entry.name and isFontExt(entry.name) and entry.download_url then
							fonts[#fonts + 1] = {
								name = entry.name,
								label = entry.name:gsub("%.[^%.]+$", ""),
								url = entry.download_url,
							}
							if #fonts >= GitHubFolderLimits.total then
								break
							end
						end
					elseif entry.type == "dir" and entry.path then
						local key = visitKey(entry.path)
						if not visited[key] then
							visited[key] = true
							local okChild, errChild = scan(entry.path, depth + 1)
							if not okChild then
								return false, errChild
							end
							if #fonts >= GitHubFolderLimits.total then
								break
							end
						end
					end
				end
			end
			return true
		end
		local startPath = normalizeGitHubPath(info.path or "")
		visited[visitKey(startPath)] = true
		local okScan, errScan = scan(startPath, 0)
		if not okScan then
			return false, errScan
		end
		return true, fonts
	end

	local IconExts = {
		[".png"] = true,
		[".jpg"] = true,
		[".jpeg"] = true,
		[".webp"] = true,
		[".bmp"] = true,
	}

	local function isIconExt(name)
		if type(name) ~= "string" or name == "" then
			return false
		end
		local ext = name:match("%.[^%.]+$")
		return ext and IconExts[ext:lower()] == true
	end

	local function collectGitHubIconFiles(info)
		if type(info) ~= "table" then
			return false, "Invalid GitHub folder reference."
		end
		local icons = {}
		local visited = {}
		local function key(path)
			return (path and path ~= "") and path or "/"
		end
		local function scan(path, depth)
			depth = depth or 0
			if depth > GitHubFolderLimits.depth then
				return true
			end
			if #icons >= GitHubFolderLimits.total then
				return true
			end
			local okFetch, payload = fetchGitHubFolderContents(info, path or "")
			if not okFetch then
				return false, payload
			end
			local entries = {}
			if payload.type == "file" then
				entries[1] = payload
			elseif #payload > 0 then
				for _, e in ipairs(payload) do
					entries[#entries + 1] = e
				end
			else
				return true
			end
			for _, e in ipairs(entries) do
				if type(e) == "table" then
					if e.type == "file" then
						if e.name and isIconExt(e.name) and e.download_url then
							icons[#icons + 1] = {
								name = e.name,
								url = e.download_url,
							}
							if #icons >= GitHubFolderLimits.total then
								break
							end
						end
					elseif e.type == "dir" and e.path then
						local k = key(e.path)
						if not visited[k] then
							visited[k] = true
							local okChild, errChild = scan(e.path, depth + 1)
							if not okChild then
								return false, errChild
							end
							if #icons >= GitHubFolderLimits.total then
								break
							end
						end
					end
				end
			end
			return true
		end
		local startPath = normalizeGitHubPath(info.path or "")
		visited[key(startPath)] = true
		local okScan, errScan = scan(startPath, 0)
		if not okScan then
			return false, errScan
		end
		return true, icons
	end

	NAgui.installIconsFromGitHubFolder = function(info)
		if not NAgui.iconFsOk() then
			return false, "Custom icons require file support and getcustomasset."
		end
		if not NAgui.ensureIconFolder() then
			return false, "Unable to prepare CustomIcon folder."
		end
		local okList, list = collectGitHubIconFiles(info)
		if not okList then
			return false, list
		end
		if #list == 0 then
			return false, "No image files were found in that folder."
		end
		local count = 0
		local lastAsset
		local lastErr
		for _, ico in ipairs(list) do
			local okSave, asset = NAgui.iconSaveFromUrl(ico.url)
			if okSave and typeof(asset) == "string" then
				count += 1
				lastAsset = asset
			else
				lastErr = asset
			end
		end
		if count == 0 then
			return false, lastErr or "Unable to download icons from that folder."
		end
		return true, {
			count = count,
			asset = lastAsset,
			source = info.originalUrl,
		}
	end

	local function uniqFontId(base)
		local clean = base
		if not clean or clean == "" then
			clean = "font_"..tostring(os.time())
		end
		local id = clean
		local idx = 1
		while FontEditor.customFontMap and FontEditor.customFontMap[id] do
			idx += 1
			id = Format("%s_%d", clean, idx)
		end
		return id
	end

	local function saveCustomFontManifest()
		if not FileSupport then
			return
		end
		if type(writefile) ~= "function" then
			return
		end
		local payload = { fonts = FontEditor.customFonts }
		pcall(writefile, FontEditor.customManifest, HttpService:JSONEncode(payload))
	end

	local function customFontFileExists(fileName)
		if type(fileName) ~= "string" or fileName == "" then
			return false
		end
		if type(FontEditor) ~= "table" or type(FontEditor.customDir) ~= "string" then
			return false
		end
		if type(isfile) ~= "function" then
			return false
		end
		local ok, exists = pcall(isfile, FontEditor.customDir.."/"..fileName)
		return ok and exists
	end

	local function deleteCustomFontFile(fileName)
		if not (type(fileName) == "string" and fileName ~= "") then
			return
		end
		if type(FontEditor) ~= "table" or type(FontEditor.customDir) ~= "string" then
			return
		end
		if type(isfile) ~= "function" or type(delfile) ~= "function" then
			return
		end
		local fullPath = FontEditor.customDir.."/"..fileName
		local okExists, exists = pcall(isfile, fullPath)
		if okExists and exists then
			pcall(delfile, fullPath)
		end
	end

	local function removeCustomFontEntry(entry, opts)
		if not (entry and entry.id) then
			return
		end
		opts = opts or {}
		local id = entry.id
		if opts.deleteFiles then
			if entry.file then
				deleteCustomFontFile(entry.file)
			end
			if entry.familyFile then
				deleteCustomFontFile(entry.familyFile)
			end
		end
		for i = #FontEditor.customFonts, 1, -1 do
			local item = FontEditor.customFonts[i]
			if item and item.id == id then
				table.remove(FontEditor.customFonts, i)
				break
			end
		end
		FontEditor.customFontMap[id] = nil
		if not opts.skipSave then
			saveCustomFontManifest()
		end
		if FontEditor.refreshCustomFontUI then
			FontEditor.refreshCustomFontUI()
		end
	end

	local function removeAllCustomFonts()
		if type(FontEditor.customFonts) ~= "table" or #FontEditor.customFonts == 0 then
			return
		end
		local entries = {}
		for _, entry in ipairs(FontEditor.customFonts) do
			entries[#entries + 1] = entry
		end
		for _, entry in ipairs(entries) do
			removeCustomFontEntry(entry, { deleteFiles = true, skipSave = true })
		end
		FontEditor.customFonts = {}
		FontEditor.customFontMap = {}
		saveCustomFontManifest()
		rebuildFontChoices()
		enforceCustomCycleAvailability()
		if FontEditor.refreshCustomFontUI then
			FontEditor.refreshCustomFontUI()
		end
	end

	local function scanFonts()
		if isDelta then
			return false
		end
		if not (FileSupport and listfiles) then
			return false
		end
		if type(FontEditor.customDir) ~= "string" or FontEditor.customDir == "" then
			return false
		end
		if type(FontEditor.customFonts) ~= "table" or type(FontEditor.customFontMap) ~= "table" then
			return false
		end
		local okFolder = ensureCustomFontFolder()
		if not okFolder then
			return false
		end
		local okList, items = pcall(listfiles, FontEditor.customDir)
		if not (okList and type(items) == "table") then
			return false
		end
		local known = {}
		for _, entry in ipairs(FontEditor.customFonts) do
			if entry.file then
				known[entry.file:lower()] = true
			end
		end
		local added = false
		for _, fullPath in ipairs(items) do
			local name = getFName(fullPath)
			if name and isFontExt(name) then
				local lower = name:lower()
				if not known[lower] then
					local base = name:gsub("%.[^%.]+$", "")
					local id = uniqFontId(sanitizeId(base) or sanitizeId(name))
					local label = base ~= "" and base or id
					local entry = {
						id = id,
						name = label,
						displayName = label,
						file = name,
						url = nil,
					}
					FontEditor.customFonts[#FontEditor.customFonts + 1] = entry
					FontEditor.customFontMap[id] = entry
					known[lower] = true
					added = true
				end
			end
		end
		if added then
			saveCustomFontManifest()
		end
		return added
	end

	local function loadCustomFontManifest()
		FontEditor.customFonts = {}
		FontEditor.customFontMap = {}
		if isDelta then
			return
		end
		if not FileSupport then
			return
		end
		local okFolder = ensureCustomFontFolder()
		if not okFolder then
			return
		end
		if type(isfile) ~= "function" or type(readfile) ~= "function" then
			return
		end
		if not isfile(FontEditor.customManifest) then
			return
		end
		local ok, raw = pcall(readfile, FontEditor.customManifest)
		if not (ok and type(raw) == "string" and raw ~= "") then
			return
		end
		local okDecode, decoded = pcall(HttpService.JSONDecode, HttpService, raw)
		if not (okDecode and type(decoded) == "table") then
			return
		end
		local items = decoded.fonts or decoded
		if type(items) ~= "table" then
			return
		end
		local manifestDirty = false
		local validFonts = {}
		local validMap = {}
		for _, entry in ipairs(items) do
			if type(entry) == "table" and type(entry.file) == "string" then
				entry.id = entry.id or sanitizeId(entry.name or entry.file) or HttpService:GenerateGUID(false)
				entry.name = entry.name or entry.id
				entry.displayName = entry.displayName or entry.name
				entry.url = normalizeCustomFontUrl(entry.url) or entry.url
				entry.familyFile = entry.familyFile
				if not customFontFileExists(entry.file) then
					if entry.familyFile then
						deleteCustomFontFile(entry.familyFile)
					end
					manifestDirty = true
				elseif validMap[entry.id] then
					manifestDirty = true
				else
					validFonts[#validFonts + 1] = entry
					validMap[entry.id] = entry
				end
			else
				manifestDirty = true
			end
		end
		FontEditor.customFonts = validFonts
		FontEditor.customFontMap = validMap
		if manifestDirty then
			saveCustomFontManifest()
		end
	end

	local function rebuildFontChoices()
		clearFontChoices()
		for _, enumFont in ipairs(Enum.Font:GetEnumItems()) do
			if enumFont ~= Enum.Font.Unknown then
				addFontChoice({
					key = "enum:"..enumFont.Name,
					label = enumFont.Name,
					kind = "enum",
					enum = enumFont,
				})
			end
		end
		for _, entry in ipairs(FontEditor.customFonts) do
			if type(entry.id) == "string" and type(entry.file) == "string" then
				local label = entry.displayName or entry.name or entry.id
				addFontChoice({
					key = "custom:"..entry.id,
					label = "[Custom] "..label,
					kind = "custom",
					entry = entry,
				})
			end
		end
		enforceCustomCycleAvailability()
	end

	local function getFontChoice(fontKey)
		if type(fontKey) ~= "string" or fontKey == "" then
			return nil
		end
		local choice = FontChoiceIndex[fontKey]
		if choice then
			return choice
		end
		if not fontKey:find(":", 1, true) then
			local ok, enumCandidate = pcall(function()
				return Enum.Font[fontKey]
			end)
			if ok and enumCandidate and enumCandidate ~= Enum.Font.Unknown then
				return FontChoiceIndex["enum:"..fontKey]
			end
		end
		return nil
	end

	local function normalizeFontKey(fontKey)
		if type(fontKey) ~= "string" or fontKey == "" then
			return FontEditor.default.fontKey
		end
		if fontKey == "enum:Unknown" then
			return FontEditor.default.fontKey
		end
		if FontChoiceIndex[fontKey] then
			return fontKey
		end
		if not fontKey:find(":", 1, true) then
			local ok, enumCandidate = pcall(function()
				return Enum.Font[fontKey]
			end)
			if ok and enumCandidate and enumCandidate ~= Enum.Font.Unknown then
				return "enum:"..fontKey
			end
		end
		return FontEditor.default.fontKey
	end
	local function getCustomFontAsset(entry)
		if isDelta then
			return nil, "Custom font files are disabled on this executor."
		end
		if type(entry) ~= "table" or type(entry.file) ~= "string" then
			return nil, "Invalid custom font entry."
		end
		if type(getcustomasset) ~= "function" then
			return nil, "Custom fonts require getcustomasset support."
		end
		if not FileSupport or type(writefile) ~= "function" then
			return nil, "File support is required for custom fonts."
		end
		if not customFontFileExists(entry.file) then
			removeCustomFontEntry(entry)
			rebuildFontChoices()
			enforceCustomCycleAvailability()
			return nil, "Custom font file is missing."
		end
		local fullPath = FontEditor.customDir.."/"..entry.file
		local okAsset, assetId = pcall(getcustomasset, fullPath)
		if not (okAsset and type(assetId) == "string") then
			return nil, "Unable to load custom font file."
		end
		local familyFile = entry.familyFile or (entry.id.."_family.json")
		local familyPath = FontEditor.customDir.."/"..familyFile
		if entry.familyFile and entry.familyFile ~= familyFile then
			deleteCustomFontFile(entry.familyFile)
		end
		local needsPersist = entry.familyFile ~= familyFile
		entry.familyFile = familyFile
		local familyData = {
			family = entry.displayName or entry.name or entry.id,
			faces = {
				{
					assetId = assetId,
					weight = "Regular",
					style = "Normal",
				},
			},
		}
		local okWrite, errWrite = pcall(writefile, familyPath, HttpService:JSONEncode(familyData))
		if not okWrite then
			return nil, errWrite or "Unable to create font family data."
		end
		local okFamilyAsset, familyAssetId = pcall(getcustomasset, familyPath)
		if not (okFamilyAsset and type(familyAssetId) == "string") then
			return nil, "Unable to load custom font family."
		end
		if needsPersist then
			saveCustomFontManifest()
		end
		local okFont, fontFace = pcall(Font.new, familyAssetId, Enum.FontWeight.Regular, Enum.FontStyle.Normal)
		if okFont and typeof(fontFace) == "Font" then
			return fontFace
		end
		return nil, "Invalid font file."
	end

	local function deriveFileNameFromUrl(url)
		if type(url) ~= "string" then
			return nil
		end
		local candidate = url:match("/([^/%?]+)$")
		return candidate
	end

	local function installFontFromUrl(name, url, opts)
		opts = opts or {}
		local rawName = type(name) == "string" and (name:match("^%s*(.-)%s*$") or "") or ""
		local httpOk, data = pcall(function()
			return game:HttpGet(url)
		end)
		if not (httpOk and type(data) == "string" and data ~= "") then
			return false, "Unable to download font file."
		end
		local remoteFile = opts.remoteFileName or deriveFileNameFromUrl(url)
		local sanitizedRemote = sanitizeFileName(remoteFile or rawName)
		if not sanitizedRemote then
			sanitizedRemote = "font_"..tostring(os.time())..".otf"
		end
		local ext = sanitizedRemote:match("%.[^%.]+$") or ".otf"
		local idSource = rawName ~= "" and rawName or sanitizedRemote:gsub("%.[^%.]+$", "")
		local id = sanitizeId(idSource) or sanitizeId(HttpService:GenerateGUID(false)) or tostring(os.time())
		local fileName = id..ext
		local fullPath = FontEditor.customDir.."/"..fileName
		local okWrite, errWrite = pcall(writefile, fullPath, data)
		if not okWrite then
			return false, errWrite or "Unable to save custom font file."
		end
		local entry = FontEditor.customFontMap[id]
		if entry then
			entry.file = fileName
			entry.url = url
			if rawName ~= "" then
				entry.name = rawName
				entry.displayName = rawName
			end
		else
			local display = rawName ~= "" and rawName or sanitizedRemote:gsub("%.[^%.]+$", "")
			entry = {
				id = id,
				name = display,
				displayName = display,
				file = fileName,
				url = url,
			}
			FontEditor.customFontMap[id] = entry
			FontEditor.customFonts[#FontEditor.customFonts + 1] = entry
		end
		if not opts.deferSave then
			saveCustomFontManifest()
			rebuildFontChoices()
		end
		return true, entry
	end

	local function installFontsFromGitHubFolder(name, folderInfo)
		local okFonts, fontList = collectGitHubFontFiles(folderInfo)
		if not okFonts then
			return false, fontList
		end
		if #fontList == 0 then
			return false, "No font files were found in that folder."
		end
		local baseName = type(name) == "string" and (name:match("^%s*(.-)%s*$") or "") or ""
		local installed = {}
		local lastErr = nil
		for _, font in ipairs(fontList) do
			local label = font.label
			if baseName ~= "" then
				label = baseName.." - "..font.label
			end
			local okInstall, result = installFontFromUrl(label, font.url, {
				remoteFileName = font.name,
				deferSave = true,
			})
			if okInstall then
				installed[#installed + 1] = result
			else
				lastErr = result
			end
		end
		if #installed == 0 then
			return false, lastErr or "Unable to install fonts from that folder."
		end
		saveCustomFontManifest()
		rebuildFontChoices()
		return true, {
			multi = true,
			entries = installed,
			count = #installed,
			source = folderInfo.originalUrl,
		}
	end

	local function addOrUpdateCustomFont(name, url, opts)
		opts = opts or {}
		if isDelta then
			return false, "Custom font files are disabled on this executor."
		end
		if not FileSupport then
			return false, "File support is required for custom fonts."
		end
		if type(writefile) ~= "function" then
			return false, "writefile is required for custom fonts."
		end
		if type(url) ~= "string" or url == "" then
			return false, "A font URL is required."
		end
		local trimmed, baseUrl = preprocessFontUrl(url)
		if not trimmed then
			return false, "A font URL is required."
		end
		local okFolder, folderErr = ensureCustomFontFolder()
		if not okFolder then
			return false, folderErr
		end
		if not opts.skipFolderScan then
			local folderInfo = parseGitHubFolderUrl(baseUrl, trimmed)
			if folderInfo then
				folderInfo.path = folderInfo.path or ""
				return installFontsFromGitHubFolder(name, folderInfo)
			end
		end
		local normalizedUrl = normalizeCustomFontUrl(trimmed)
		if not normalizedUrl then
			return false, "Invalid font URL."
		end
		return installFontFromUrl(name, normalizedUrl, opts)
	end

	local function getNAList()
		local ok, raw = pcall(function()
			return game:HttpGet(NAFontSrc.list)
		end)
		if not (ok and type(raw) == "string" and raw ~= "") then
			return false, "Unable to fetch NA font catalog."
		end
		local okDecode, decoded = pcall(HttpService.JSONDecode, HttpService, raw)
		if not (okDecode and type(decoded) == "table") then
			return false, "Invalid NA font catalog."
		end
		local items = {}
		if #decoded > 0 then
			for _, entry in ipairs(decoded) do
				items[#items + 1] = entry
			end
		else
			for _, entry in pairs(decoded) do
				if type(entry) == "table" then
					items[#items + 1] = entry
				end
			end
		end
		local fonts = {}
		for _, entry in ipairs(items) do
			if type(entry) == "table" and type(entry.name) == "string" then
				if isFontExt(entry.name) then
					fonts[#fonts + 1] = {
						name = entry.name,
						label = entry.name:gsub("%.[^%.]+$", ""),
						url = NAFontSrc.raw..entry.name,
					}
				end
			end
		end
		if #fonts == 0 then
			return false, "No preset fonts available."
		end
		return true, fonts
	end

	local function dlNAFonts()
		if isDelta then
			return false, "NA preset fonts are disabled on this executor."
		end
		if not FileSupport then
			return false, "Custom fonts require file support."
		end
		local okFolder, folderErr = ensureCustomFontFolder()
		if not okFolder then
			return false, folderErr
		end
		local okList, fonts = getNAList()
		if not okList then
			return false, fonts
		end
		local count = 0
		local lastErr = nil
		for _, font in ipairs(fonts) do
			local label = font.label ~= "" and font.label or font.name
			local okInstall, res = addOrUpdateCustomFont(label, font.url)
			if okInstall then
				count += 1
			else
				lastErr = res or ("Unable to install "..label)
			end
		end
		if count == 0 then
			return false, lastErr or "No preset fonts installed."
		end
		return true, count
	end

	FontEditor = {
		path = NAfiles.NAFILEPATH.."/font_override.json",
		default = {
			enabled = false,
			font = "Gotham",
			fontKey = "enum:Gotham",
			targetCoreGui = true,
			targetPlayerGui = false,
			targetBillboardGui = false,
			targetSurfaceGui = false,
			useCustomCycle = false,
		},
		cg = CoreGui,
		store = newFontStore(),
		data = {
			enabled = false,
			font = "Gotham",
			fontKey = "enum:Gotham",
			targetCoreGui = true,
			targetPlayerGui = false,
			targetBillboardGui = false,
			targetSurfaceGui = false,
			useCustomCycle = false,
		},
		currentFont = Enum.Font.Gotham,
		currentFontIsCustom = false,
		customDir = NAfiles.NACUSTOMFONTPATH,
		customManifest = NAfiles.NACUSTOMFONTPATH.."/fonts.json",
		customFonts = {},
		customFontMap = {},
		customInputs = { name = "", url = "" },
		refreshCustomFontUI = nil,
		watchers = {},
		restoring = false,
		dlBusy = false,
	}

	local ex = identifyexecutor and identifyexecutor():lower() or ""
	local isDelta = (ex == "delta")

	local function disconnectFontWatcher(target)
		local watcher = FontEditor.watchers[target]
		if not watcher then
			return
		end
		if watcher.change then
			watcher.change:Disconnect()
		end
		if watcher.ancestry then
			watcher.ancestry:Disconnect()
		end
		FontEditor.watchers[target] = nil
	end

	local function ensureFontWatcher(target)
		if not target or FontEditor.watchers[target] then
			return
		end
		local watcher = {}
		watcher.change = target:GetPropertyChangedSignal("FontFace"):Connect(function()
			if FontEditor.restoring then
				return
			end
			if not FontEditor.data.enabled then
				return
			end
			if FontEditor.currentFontIsCustom then
				local currentFace = NAlib.isProperty(target, "FontFace")
				if currentFace ~= FontEditor.currentFont then
					pcall(function()
						target.FontFace = FontEditor.currentFont
					end)
				end
			end
		end)
		watcher.ancestry = target.AncestryChanged:Connect(function(obj)
			if not obj.Parent then
				disconnectFontWatcher(obj)
				FontEditor.store[obj] = nil
			end
		end)
		FontEditor.watchers[target] = watcher
	end

	persistFontData = function()
		if not FileSupport then
			return
		end
		local payload = {
			enabled = FontEditor.data.enabled,
			fontKey = FontEditor.data.fontKey or FontEditor.default.fontKey,
			fontLabel = FontEditor.data.font,
			targetCoreGui = FontEditor.data.targetCoreGui,
			targetPlayerGui = FontEditor.data.targetPlayerGui,
			targetBillboardGui = FontEditor.data.targetBillboardGui,
			targetSurfaceGui = FontEditor.data.targetSurfaceGui,
			useCustomCycle = FontEditor.data.useCustomCycle,
		}
		pcall(writefile, FontEditor.path, HttpService:JSONEncode(payload))
	end

	local function loadFontData()
		local stored = FontEditor.default

		if FileSupport then
			if not isfile(FontEditor.path) then
				writefile(FontEditor.path, HttpService:JSONEncode(FontEditor.default))
			end
			local ok, raw = pcall(readfile, FontEditor.path)
			if ok and type(raw) == "string" then
				local okD, dec = pcall(HttpService.JSONDecode, HttpService, raw)
				if okD and type(dec) == "table" then
					stored = dec
				end
			end
		end

		local k = stored.fontKey or stored.font or FontEditor.default.fontKey
		local lbl = stored.fontLabel or stored.font or FontEditor.default.font

		if type(k) ~= "string" or k == "" then
			k = FontEditor.default.fontKey
		end
		if type(lbl) ~= "string" or lbl == "" then
			lbl = FontEditor.default.font
		end

		FontEditor.data.fontKey = k
		FontEditor.data.font = lbl

		if type(stored.targetCoreGui) == "boolean" then
			FontEditor.data.targetCoreGui = stored.targetCoreGui
		else
			FontEditor.data.targetCoreGui = FontEditor.default.targetCoreGui
		end

		if type(stored.targetPlayerGui) == "boolean" then
			FontEditor.data.targetPlayerGui = stored.targetPlayerGui
		else
			FontEditor.data.targetPlayerGui = FontEditor.default.targetPlayerGui
		end

		if type(stored.targetBillboardGui) == "boolean" then
			FontEditor.data.targetBillboardGui = stored.targetBillboardGui
		else
			FontEditor.data.targetBillboardGui = FontEditor.default.targetBillboardGui
		end

		if type(stored.targetSurfaceGui) == "boolean" then
			FontEditor.data.targetSurfaceGui = stored.targetSurfaceGui
		else
			FontEditor.data.targetSurfaceGui = FontEditor.default.targetSurfaceGui
		end

		FontEditor.data.useCustomCycle = stored.useCustomCycle == true
		FontEditor.data.enabled = stored.enabled == true
	end

	local function isBuilderIconFontFace(o)
		local ff = NAlib.isProperty(o, "FontFace")
		local ffType = ff and typeof(ff) or nil
		local fam = ff and ff.Family or nil
		return (ffType == "Font" or ffType == "FontFace")
			and type(fam) == "string"
			and fam:find("BuilderIcons/BuilderIcons.json", 1, true)
	end

	local function isNAUIElement(o)
		return o and NAStuff and NAStuff.NASCREENGUI and o:IsDescendantOf(NAStuff.NASCREENGUI)
	end

	local function isFontTarget(o)
		if not (o and o.Parent) then
			return false
		end
		if HUI and o:IsDescendantOf(HUI) then
			return false
		end
		if isNAUIElement(o) then
			return false
		end
		return o:IsA("TextLabel") or o:IsA("TextButton") or o:IsA("TextBox")
	end

	local function isInPlayerGui(o)
		local ok, pg = pcall(function()
			return o:FindFirstAncestorOfClass("PlayerGui")
		end)
		return ok and pg ~= nil
	end

	local function getFontBB(o)
		if not (FontEditor.data.targetBillboardGui and typeof(o) == "Instance") then
			return nil
		end
		if o:IsA("BillboardGui") then
			return o
		end
		local ok, ancestor = pcall(function()
			return o:FindFirstAncestorOfClass("BillboardGui")
		end)
		if ok then
			return ancestor
		end
		return nil
	end

	local function getFontSurf(o)
		if not (FontEditor.data.targetSurfaceGui and typeof(o) == "Instance") then
			return nil
		end
		if o:IsA("SurfaceGui") then
			return o
		end
		local ok, ancestor = pcall(function()
			return o:FindFirstAncestorOfClass("SurfaceGui")
		end)
		if ok then
			return ancestor
		end
		return nil
	end

	local function captureFontFaceState(o)
		local ok, value = pcall(function()
			return o.FontFace
		end)
		if ok then
			return true, value
		end
		return false, nil
	end

	local function applyFontToInstance(o)
		if not isFontTarget(o) then
			return
		end
		if isBuilderIconFontFace(o) then
			return
		end
		if not FontEditor.currentFont then
			return
		end

		if not FontEditor.store[o] then
			local hasFF, ff = captureFontFaceState(o)
			FontEditor.store[o] = {
				Font = NAlib.isProperty(o, "Font"),
				FontFace = ff,
				FontFaceSupported = hasFF,
			}
		end

		local info = FontEditor.store[o]

		if FontEditor.currentFontIsCustom then
			if not isInPlayerGui(o) then
				ensureFontWatcher(o)
			end
			if info and info.FontFaceSupported then
				pcall(function()
					o.FontFace = FontEditor.currentFont
				end)
			end
		else
			if info and info.FontFaceSupported then
				ensureFontWatcher(o)
				pcall(function()
					o.FontFace = info.FontFace
				end)
			end
			local cur = NAlib.isProperty(o, "Font")
			if cur == FontEditor.currentFont then
				return
			end
			pcall(function()
				o.Font = FontEditor.currentFont
			end)
		end
	end

	local function applyFontToDescendants(container)
		if not container then
			return
		end
		local function handle(inst)
			if isFontTarget(inst) then
				applyFontToInstance(inst)
			end
		end
		handle(container)
		local desc = container:GetDescendants()
		for i = 1, #desc do
			handle(desc[i])
			if i % 200 == 0 then
				Wait()
			end
		end
	end

	local function getFontTargets()
		local containers = {}
		if FontEditor.data.targetCoreGui and FontEditor.cg then
			containers[#containers + 1] = FontEditor.cg
		end
		if FontEditor.data.targetPlayerGui then
			local pg = getPlayerGui()
			if pg then
				containers[#containers + 1] = pg
			end
		end
		local world = workspace
		if FontEditor.data.targetBillboardGui and world and world.GetDescendants then
			for _, inst in ipairs(world:GetDescendants()) do
				if inst:IsA("BillboardGui") then
					containers[#containers + 1] = inst
				end
			end
		end
		if FontEditor.data.targetSurfaceGui and world and world.GetDescendants then
			for _, inst in ipairs(world:GetDescendants()) do
				if inst:IsA("SurfaceGui") then
					containers[#containers + 1] = inst
				end
			end
		end
		return containers
	end

	local function restoreAllFonts()
		FontEditor.restoring = true
		for target, info in pairs(FontEditor.store) do
			if target and info then
				if info.FontFaceSupported then
					pcall(function()
						target.FontFace = info.FontFace
					end)
				end
				if info.Font ~= nil then
					pcall(function()
						target.Font = info.Font
					end)
				end
			end
			disconnectFontWatcher(target)
		end
		FontEditor.restoring = false
		FontEditor.store = newFontStore()
		FontEditor.watchers = {}
	end

	local function applyAllFonts()
		if not FontEditor.data.enabled then
			return
		end
		for idx, container in ipairs(getFontTargets()) do
			applyFontToDescendants(container)
			if idx % 3 == 0 then
				Wait()
			end
		end
	end

	local function applyFontChoice(choice, opts)
		if not choice then
			return false, "Invalid font choice."
		end
		opts = opts or {}
		local resolvedFont = nil
		local isCustom = choice.kind == "custom"
		if isCustom then
			local fontFace, err = getCustomFontAsset(choice.entry)
			if not fontFace then
				return false, err
			end
			resolvedFont = fontFace
		else
			resolvedFont = choice.enum
		end
		if not resolvedFont then
			return false, "Unable to resolve font selection."
		end
		FontEditor.currentFont = resolvedFont
		FontEditor.currentFontIsCustom = isCustom
		FontEditor.data.fontKey = choice.key
		FontEditor.data.font = choice.label
		if opts.persist ~= false then
			persistFontData()
		end
		if FontEditor.data.enabled and opts.apply ~= false then
			applyAllFonts()
		end
		return true
	end

	local function setOverrideFont(fontKey, opts)
		opts = opts or {}
		local normalized = normalizeFontKey(fontKey)
		local choice = getFontChoice(normalized) or getFontChoice(FontEditor.default.fontKey)
		if not choice then
			return
		end
		local ok, err = applyFontChoice(choice, opts)
		if not ok and choice.kind == "custom" then
			if not opts.silent then
				DoNotif(err or "Unable to load custom font.", 3)
			end
			local fallback = getFontChoice(FontEditor.default.fontKey)
			if fallback then
				applyFontChoice(fallback, opts)
			end
		elseif not ok and not opts.silent then
			DoNotif(err or "Unable to update override font.", 3)
		end
	end

	local function cycleOverrideFont(delta)
		local choices = getActiveFontChoices()
		if #choices == 0 then
			DoNotif("No fonts available to cycle.", 3)
			return
		end
		local currentKey = FontEditor.data.fontKey or FontEditor.default.fontKey
		local index = 1
		for i, choice in ipairs(choices) do
			if choice.key == currentKey then
				index = i
				break
			end
		end
		local nextIndex = ((index - 1 + delta) % #choices) + 1
		setOverrideFont(choices[nextIndex].key)
	end

	local function onFontDescendantAdded(o)
		if FontEditor.data.enabled then
			applyFontToInstance(o)
		end
	end

	local function onFontBillboardAdded(o)
		if not FontEditor.data.enabled then
			return
		end
		local root = getFontBB(o)
		if root then
			applyFontToInstance(root)
		end
	end

	local function onFontSurfaceAdded(o)
		if not FontEditor.data.enabled then
			return
		end
		local root = getFontSurf(o)
		if root then
			applyFontToInstance(root)
		end
	end

	local function refreshFontConnections()
		NAlib.disconnect("FontEditor")
		if FontEditor.data.targetCoreGui and FontEditor.cg then
			NAlib.connect("FontEditor", FontEditor.cg.DescendantAdded:Connect(onFontDescendantAdded))
		end

		NAlib.disconnect("FontEditor_PlayerGui")
		local pg = FontEditor.data.targetPlayerGui and getPlayerGui()
		if pg then
			NAlib.connect("FontEditor_PlayerGui", pg.DescendantAdded:Connect(onFontDescendantAdded))
		end

		local world = workspace
		NAlib.disconnect("FontEditor_Billboard")
		if FontEditor.data.targetBillboardGui and world then
			NAlib.connect("FontEditor_Billboard", world.DescendantAdded:Connect(onFontBillboardAdded))
		end

		NAlib.disconnect("FontEditor_Surface")
		if FontEditor.data.targetSurfaceGui and world then
			NAlib.connect("FontEditor_Surface", world.DescendantAdded:Connect(onFontSurfaceAdded))
		end
	end

	local function monitorFontPlayerGui()
		local lp = Players and Players.LocalPlayer
		if not lp then
			return
		end
		NAlib.disconnect("FontEditor_PlayerGuiAdded")
		NAlib.connect("FontEditor_PlayerGuiAdded", lp.ChildAdded:Connect(function(child)
			if child:IsA("PlayerGui") then
				refreshFontConnections()
				if FontEditor.data.enabled then
					applyAllFonts()
				end
			end
		end))
		NAlib.disconnect("FontEditor_PlayerGuiRemoved")
		NAlib.connect("FontEditor_PlayerGuiRemoved", lp.ChildRemoved:Connect(function(child)
			if child:IsA("PlayerGui") then
				refreshFontConnections()
			end
		end))
	end

	local function updateFontTarget(field, value)
		if FontEditor.data[field] == value then
			return
		end
		FontEditor.data[field] = value
		persistFontData()
		refreshFontConnections()
		if FontEditor.data.enabled then
			restoreAllFonts()
			applyAllFonts()
		end
	end

	loadCustomFontManifest()
	scanFonts()
	rebuildFontChoices()
	loadFontData()
	setOverrideFont(FontEditor.data.fontKey, { persist = false, apply = false, silent = true })

	refreshFontConnections()
	monitorFontPlayerGui()

	if FontEditor.data.enabled then
		applyAllFonts()
	end

	NAgui.addSection("Corner Editor")
	NAgui.addToggle("Override Corner Radius", CE.data.enabled, function(v)
		CE.data.enabled = v
		if CE.data.enabled then
			applyCorn()
		else
			resetCorn()
		end
		saveCData()
	end)
	NAgui.addToggle("Corner Target: CoreGui", CE.data.targetCoreGui, function(v)
		setCTgt("targetCoreGui", v == true)
	end)
	NAgui.addToggle("Corner Target: PlayerGui", CE.data.targetPlayerGui, function(v)
		setCTgt("targetPlayerGui", v == true)
	end)
	NAgui.addToggle("Corner Target: BillboardGui", CE.data.targetBillboardGui, function(v)
		setCTgt("targetBillboardGui", v == true)
	end)
	NAgui.addToggle("Corner Target: SurfaceGui", CE.data.targetSurfaceGui, function(v)
		setCTgt("targetSurfaceGui", v == true)
	end)
	local sliderRadius = math.clamp(CE.data.radius, 0, 64)
	NAgui.addSlider("Corner Radius", 0, 64, sliderRadius, 0.5, " px", function(v)
		local parsed = math.clamp(tonumber(v) or CE.default.radius, 0, 64)
		CE.data.radius = parsed
		if CE.data.enabled then
			applyCorn()
		end
		saveCData()
	end)

	NAgui.addSection("Font Changer")
	NAgui.addToggle("Override Text Font", FontEditor.data.enabled, function(v)
		FontEditor.data.enabled = v
		if FontEditor.data.enabled then
			applyAllFonts()
		else
			restoreAllFonts()
		end
		persistFontData()
	end)
	NAgui.addToggle("Font Target: CoreGui", FontEditor.data.targetCoreGui, function(v)
		updateFontTarget("targetCoreGui", v == true)
	end)
	NAgui.addToggle("Font Target: PlayerGui", FontEditor.data.targetPlayerGui, function(v)
		updateFontTarget("targetPlayerGui", v == true)
	end)
	NAgui.addToggle("Font Target: BillboardGui", FontEditor.data.targetBillboardGui, function(v)
		updateFontTarget("targetBillboardGui", v == true)
	end)
	NAgui.addToggle("Font Target: SurfaceGui", FontEditor.data.targetSurfaceGui, function(v)
		updateFontTarget("targetSurfaceGui", v == true)
	end)
	local fontInfoBox = NAgui.addInfo("Current Font", FontEditor.data.font)
	local function refreshFontInfo()
		if fontInfoBox then
			fontInfoBox.Text = FontEditor.data.font
		end
	end
	local cfInfo
	local cfCycleLabel = "Cycle Custom Fonts Only"
	local cfNameLabel = "Custom Font Name"
	local cfUrlLabel = "Custom Font URL"
	local function refreshFontUI()
		if scanFonts() then
			rebuildFontChoices()
		end
		if cfInfo then
			cfInfo.Text = formatCustomFontStatus()
		end
		if not hasCustomFonts() and NAgui.setToggleState then
			NAgui.setToggleState(cfCycleLabel, false, { force = true, fire = false })
		end
	end
	local function openFontDeletePopup()
		if not hasCustomFonts() then
			DoNotif("No custom fonts installed.", 3)
			return
		end
		if type(Popup) ~= "function" then
			DoNotif("Popup UI is unavailable in this session.", 3)
			return
		end
		local buttons = {}
		for _, entry in ipairs(FontEditor.customFonts) do
			local label = (entry.displayName or entry.name or entry.id) or "Custom Font"
			Insert(buttons, {
				Text = label,
				Callback = function()
					local key = entry.id and ("custom:"..entry.id) or nil
					local wasCurrent = key and FontEditor.data.fontKey == key
					removeCustomFontEntry(entry, { deleteFiles = true })
					rebuildFontChoices()
					if wasCurrent then
						setOverrideFont(FontEditor.default.fontKey)
						refreshFontInfo()
					end
					refreshFontUI()
					DoNotif(Format("Removed custom font \"%s\".", label), 2)
				end,
			})
		end
		Insert(buttons, { Text = "Cancel", Callback = function() end })
		Popup({
			Title = "Remove Custom Font",
			Description = "Select a custom font to delete.",
			Duration = 0,
			Buttons = buttons,
		})
	end
	refreshFontInfo()
	NAgui.addButton("Previous Font", function()
		cycleOverrideFont(-1)
		refreshFontInfo()
	end)
	NAgui.addButton("Next Font", function()
		cycleOverrideFont(1)
		refreshFontInfo()
	end)
	NAgui.addButton("Reset Font", function()
		setOverrideFont(FontEditor.default.fontKey)
		refreshFontInfo()
	end)
	cfInfo = NAgui.addInfo("Custom Fonts", formatCustomFontStatus())
	refreshFontUI()
	FontEditor.refreshCustomFontUI = refreshFontUI
	NAgui.addToggle(cfCycleLabel, FontEditor.data.useCustomCycle and hasCustomFonts(), function(v)
		if v and not hasCustomFonts() then
			DoNotif("Install a custom font first.", 3)
			if NAgui.setToggleState then
				NAgui.setToggleState(cfCycleLabel, false, { force = true, fire = false })
			end
			return
		end
		FontEditor.data.useCustomCycle = v == true
		persistFontData()
	end)
	NAgui.addSection("Custom Font Loader")
	NAgui.addInput(cfNameLabel, "Display name (optional)", FontEditor.customInputs.name, function(text)
		FontEditor.customInputs.name = text or ""
	end)
	NAgui.addInput(cfUrlLabel, "Font URL (GitHub/raw/external)", FontEditor.customInputs.url, function(text)
		FontEditor.customInputs.url = text or ""
	end)
	NAgui.addButton("Download Custom Font", function()
		if not FileSupport then
			DoNotif("Custom fonts require file support.", 3)
			return
		end
		local ok, result = addOrUpdateCustomFont(FontEditor.customInputs.name, FontEditor.customInputs.url)
		if ok and type(result) == "table" then
			local function clearInputs()
				if NAgui.setInputValue then
					NAgui.setInputValue(cfNameLabel, "", { force = true, fire = false })
					NAgui.setInputValue(cfUrlLabel, "", { force = true, fire = false })
				end
				FontEditor.customInputs.name = ""
				FontEditor.customInputs.url = ""
			end
			if result.multi and type(result.entries) == "table" and #result.entries > 0 then
				local lastEntry = result.entries[#result.entries]
				if lastEntry and lastEntry.id then
					setOverrideFont("custom:"..lastEntry.id)
				end
				refreshFontInfo()
				refreshFontUI()
				clearInputs()
				local count = result.count or #result.entries
				DoNotif(Format("Installed %d font%s from folder.", count, count == 1 and "" or "s"), 2)
			elseif result.id then
				setOverrideFont("custom:"..result.id)
				refreshFontInfo()
				refreshFontUI()
				clearInputs()
				DoNotif("Custom font saved.", 2)
			else
				refreshFontInfo()
				refreshFontUI()
				clearInputs()
				DoNotif("Custom font saved.", 2)
			end
		else
			DoNotif(result or "Unable to save custom font.", 3)
		end
	end)
	NAgui.addButton("Download NA Fonts", function()
		if FontEditor.dlBusy then
			DoNotif("Preset font download already running.", 3)
			return
		end
		FontEditor.dlBusy = true
		local ok, res = dlNAFonts()
		FontEditor.dlBusy = false
		if ok then
			refreshFontInfo()
			refreshFontUI()
			DoNotif(Format("Installed %d NA font%s.", res, res == 1 and "" or "s"), 2)
		else
			DoNotif(res or "Unable to download NA fonts.", 3)
		end
	end)
	NAgui.addButton("Remove Custom Font...", openFontDeletePopup)
	NAgui.addButton("Reload Custom Fonts", function()
		loadCustomFontManifest()
		scanFonts()
		rebuildFontChoices()
		setOverrideFont(FontEditor.data.fontKey, { persist = false, apply = false, silent = true })
		refreshFontInfo()
		refreshFontUI()
		DoNotif("Custom fonts reloaded.", 2)
	end)
	NAgui.addButton("Remove All Custom Fonts", function()
		if not hasCustomFonts() then
			DoNotif("No custom fonts installed.", 3)
			return
		end
		local wasCustom = type(FontEditor.data.fontKey) == "string" and FontEditor.data.fontKey:find("^custom:") == 1
		removeAllCustomFonts()
		if wasCustom then
			setOverrideFont(FontEditor.default.fontKey)
			refreshFontInfo()
		end
		refreshFontUI()
		DoNotif("Removed all custom fonts.", 2)
	end)

	local Icfg = {
		path = NAfiles.NAICONSETTINGSPATH or (NAfiles.NAFILEPATH.."/custom_icon.json"),
		def = {
			enabled = false,
			assetId = "",
			localPath = "",
			index = 0,
		},
	}

	local function loadIcfg()
		local d = Icfg.def
		if FileSupport then
			if not isfile(Icfg.path) then
				writefile(Icfg.path, HttpService:JSONEncode(Icfg.def))
			end
			local ok, raw = pcall(readfile, Icfg.path)
			if ok and type(raw) == "string" then
				local okD, dec = pcall(HttpService.JSONDecode, HttpService, raw)
				if okD and type(dec) == "table" then
					d = dec
				end
			end
		end
		return d
	end

	local function saveIcfg()
		if not FileSupport then
			return
		end
		local payload = {
			enabled = NAStuff.CustomIcon.enabled == true,
			assetId = typeof(NAStuff.CustomIcon.assetId) == "string" and NAStuff.CustomIcon.assetId or "",
			localPath = typeof(NAStuff.CustomIcon.localPath) == "string" and NAStuff.CustomIcon.localPath or "",
			index = tonumber(NAStuff.CustomIcon.index) or 0,
		}
		pcall(writefile, Icfg.path, HttpService:JSONEncode(payload))
	end

	NAStuff.iconAppearance = NAStuff.iconAppearance or {
		background = NAStuff.NAICONMAIN.BackgroundTransparency;
		text = (NAStuff.IconFallbackLabel and NAStuff.IconFallbackLabel.TextTransparency) or (NAStuff.NAICONMAIN:IsA("TextButton") and NAStuff.NAICONMAIN.TextTransparency) or nil;
		stroke = (NAStuff.IconFallbackLabel and NAStuff.IconFallbackLabel.TextStrokeTransparency) or (NAStuff.NAICONMAIN:IsA("TextButton") and NAStuff.NAICONMAIN.TextStrokeTransparency) or nil;
		image = NAStuff.NAICONMAIN:IsA("ImageButton") and NAStuff.NAICONMAIN.ImageTransparency or nil;
	}

	NAStuff.IconSrc = NAStuff.IconSrc or {
		list = "https://api.github.com/repos/ltseverydayyou/uuuuuuu/contents/NAicons?ref=main";
		raw = "https://raw.githubusercontent.com/ltseverydayyou/uuuuuuu/main/NAicons/";
	}

	NAStuff.CustomIcon = NAStuff.CustomIcon or {}
	NAStuff.CustomIcon.entries = NAStuff.CustomIcon.entries or {}
	NAStuff.CustomIcon.index = NAStuff.CustomIcon.index or 0

	NAgui.iconFsOk = function()
		return FileSupport and type(writefile) == "function" and type(getcustomasset) == "function"
	end

	local icfg = loadIcfg()
	if type(icfg) == "table" then
		if typeof(icfg.assetId) == "string" and icfg.assetId ~= "" then
			NAStuff.CustomIcon.assetId = icfg.assetId
		end
		if typeof(icfg.localPath) == "string" and icfg.localPath ~= "" then
			NAStuff.CustomIcon.localPath = icfg.localPath
		end
		if typeof(icfg.enabled) == "boolean" then
			NAStuff.CustomIcon.enabled = icfg.enabled
		end
		if typeof(icfg.index) == "number" then
			NAStuff.CustomIcon.index = icfg.index
		end
	end

	if typeof(NAStuff.CustomIcon.localPath) == "string"
		and NAStuff.CustomIcon.localPath ~= ""
		and NAgui.iconFsOk()
	then
		local okA, assetFromFile = pcall(getcustomasset, NAStuff.CustomIcon.localPath)
		if okA and typeof(assetFromFile) == "string" then
			NAStuff.CustomIcon.assetId = assetFromFile
		end
	end

	NAgui.getNAIconList = function()
		local src = NAStuff.IconSrc
		if not src or typeof(src.list) ~= "string" or src.list == "" then
			return false, "NA icon catalog URL not configured."
		end
		local ok, raw = pcall(function()
			return game:HttpGet(src.list)
		end)
		if not (ok and typeof(raw) == "string" and raw ~= "") then
			return false, "Unable to fetch NA icon catalog."
		end
		local okD, decoded = pcall(HttpService.JSONDecode, HttpService, raw)
		if not (okD and type(decoded) == "table") then
			return false, "Invalid NA icon catalog."
		end
		local items = {}
		if #decoded > 0 then
			for _, entry in ipairs(decoded) do
				items[#items + 1] = entry
			end
		else
			for _, entry in pairs(decoded) do
				if type(entry) == "table" then
					items[#items + 1] = entry
				end
			end
		end
		local icons = {}
		for _, e in ipairs(items) do
			if type(e) == "table" and type(e.name) == "string" and e.type == "file" then
				local url = e.download_url or (src.raw and (src.raw..e.name))
				if type(url) == "string" and url ~= "" then
					icons[#icons + 1] = {
						name = e.name;
						url = url;
					}
				end
			end
		end
		if #icons == 0 then
			return false, "No NA icons available."
		end
		return true, icons
	end
	NAgui.downloadNAIcons = function()
		if not NAgui.iconFsOk() then
			return false, "Custom icons require file support and getcustomasset."
		end
		if not NAgui.ensureIconFolder() then
			return false, "Unable to prepare CustomIcon folder."
		end
		local okList, icons = NAgui.getNAIconList()
		if not okList then
			return false, icons
		end
		local count = 0
		local lastErr = nil
		for _, ico in ipairs(icons) do
			local okSave, errOrAsset = NAgui.iconSaveFromUrl(ico.url)
			if okSave then
				count += 1
			else
				lastErr = errOrAsset
			end
		end
		if count == 0 then
			return false, lastErr or "No NA icons downloaded."
		end
		return true, count
	end

	NAgui.ensureIconFolder = function()
		if not FileSupport then
			return false
		end
		local dir = NAfiles.NACUSTOMICONPATH
		if typeof(dir) ~= "string" or dir == "" then
			return false
		end
		if type(isfolder) == "function" then
			local ok, exists = pcall(isfolder, dir)
			if ok and exists then
				return true
			end
			if type(makefolder) ~= "function" then
				return false
			end
			local okMk = pcall(makefolder, dir)
			return okMk == true
		end
		return true
	end

	local function getDefaultNAIconAsset()
		local existing = NAStuff.CustomIcon.defaultImage
		if typeof(existing) == "string" and existing ~= "" then
			return existing
		end
		if type(getcustomasset) == "function"
			and NAfiles and NAfiles.NAASSETSFILEPATH
			and NAImageAssets and typeof(NAImageAssets.Icon) == "string" and NAImageAssets.Icon ~= ""
		then
			local ok, asset = pcall(getcustomasset, NAfiles.NAASSETSFILEPATH.."/"..NAImageAssets.Icon)
			if ok and typeof(asset) == "string" and asset ~= "" then
				return asset
			end
		end
		return ""
	end

	local function resetCustomIconToDefault()
		local defaultImage = getDefaultNAIconAsset()
		if defaultImage ~= "" then
			NAStuff.CustomIcon.defaultImage = defaultImage
		end
		NAStuff.CustomIcon.localPath = nil
		NAStuff.CustomIcon.assetId = nil
		NAStuff.CustomIcon.index = 0
		NAStuff.CustomIcon.enabled = false
		if type(NAgui._applyIconState) == "function" then
			NAgui._applyIconState()
		end
		saveIcfg()
		if NAgui.setToggleState then
			NAgui.setToggleState("Use Custom NA Icon", false, { force = true, fire = false })
		end
	end

	NAgui.iconPreUrl = function(u)
		if typeof(u) ~= "string" then
			return nil
		end
		local t = u:match("^%s*(.-)%s*$") or ""
		if t == "" then
			return nil
		end
		t = t:gsub(" ", "%%20")
		local q = t:find("%?")
		local base = q and t:sub(1, q - 1) or t
		return t, base
	end

	NAgui.iconNormUrl = function(u)
		local t, base = NAgui.iconPreUrl(u)
		if not t then
			return nil
		end
		local owner, repo, kind, rest = base:match("^https?://github.com/([^/]+)/([^/]+)/([^/]+)/(.+)$")
		if owner and repo and kind and rest then
			local s = rest
			if s:sub(1, 11) == "refs/heads/" then
				s = s:sub(12)
			elseif s:sub(1, 10) == "refs/tags/" then
				s = s:sub(11)
			end
			local branch, path = s:match("^([^/]+)/(.+)$")
			if branch and path and (kind == "blob" or kind == "raw") then
				branch = branch:gsub("%%2[Ff]", "/")
				path = path:gsub("%%2[Ff]", "/")
				return Format("https://raw.githubusercontent.com/%s/%s/%s/%s", owner, repo, branch, path)
			end
		end
		local rawDir = base:match("^https?://raw%.githubusercontent%.com/.+")
		if rawDir then
			return t
		end
		return t
	end

	NAgui.scanCustomIcons = function()
		if not (FileSupport and listfiles) then
			return
		end
		if not NAgui.ensureIconFolder() then
			return
		end
		local dir = NAfiles.NACUSTOMICONPATH
		local ok, items = pcall(listfiles, dir)
		if not (ok and type(items) == "table") then
			return
		end
		local list = {}
		for _, fullPath in ipairs(items) do
			local name = getFName(fullPath)
			if name then
				list[#list + 1] = { file = name }
			end
		end
		NAStuff.CustomIcon.entries = list
		local hasLocalPath = typeof(NAStuff.CustomIcon.localPath) == "string" and NAStuff.CustomIcon.localPath ~= ""
		local idx = 0
		if hasLocalPath then
			local cur = getFName(NAStuff.CustomIcon.localPath)
			if cur then
				for i, e in ipairs(list) do
					if e.file == cur then
						idx = i
						break
					end
				end
			end
		end
		if #list == 0 and hasLocalPath then
			resetCustomIconToDefault()
			return
		end
		if idx == 0 and #list > 0 then
			idx = 1
		end
		NAStuff.CustomIcon.index = idx
	end

	NAgui.formatCustomIconStatus = function()
		local list = NAStuff.CustomIcon.entries or {}
		local n = #list
		if n == 0 then
			return "No custom icons installed"
		end
		if n == 1 then
			return "1 custom icon installed"
		end
		return tostring(n).." custom icons installed"
	end

	NAgui.refreshCustomIconUI = function()
		local info = NAStuff.CustomIcon.info
		if info then
			info.Text = NAgui.formatCustomIconStatus()
		end
	end

	NAgui.iconSaveFromUrl = function(url)
		if not NAgui.iconFsOk() then
			return false, "Custom image icons require file support and getcustomasset."
		end
		if not NAgui.ensureIconFolder() then
			return false, "Unable to prepare CustomIcon folder."
		end
		local norm = NAgui.iconNormUrl(url)
		if not norm then
			return false, "Enter a valid image URL or asset id."
		end
		local ok, data = pcall(function()
			return game:HttpGet(norm)
		end)
		if not (ok and typeof(data) == "string" and data ~= "") then
			return false, "Unable to download custom icon image."
		end
		local remoteFile = deriveFileNameFromUrl(norm) or "CustomIcon.png"
		local safeName = sanitizeFileName(remoteFile) or ("icon_"..tostring(os.time())..".png")
		local fullPath = NAfiles.NACUSTOMICONPATH.."/"..safeName
		local okW, errW = pcall(writefile, fullPath, data)
		if not okW then
			return false, errW or "Unable to save custom icon image."
		end
		local okA, asset = pcall(getcustomasset, fullPath)
		if not (okA and typeof(asset) == "string") then
			return false, "Unable to load custom icon image."
		end
		NAStuff.CustomIcon.localPath = fullPath
		local list = NAStuff.CustomIcon.entries or {}
		local idx = nil
		for i, e in ipairs(list) do
			if e.file == safeName then
				idx = i
				break
			end
		end
		if not idx then
			list[#list + 1] = { file = safeName }
			idx = #list
		end
		NAStuff.CustomIcon.entries = list
		NAStuff.CustomIcon.index = idx
		return true, asset
	end

	if NAmanage and type(NAmanage.NASettingsGet) == "function" then
		local storedAsset = NAmanage.NASettingsGet("customIconAssetId")
		local storedPath = NAmanage.NASettingsGet("customIconLocalPath")
		local storedEnabled = NAmanage.NASettingsGet("customIconEnabled")
		local hasAsset = typeof(NAStuff.CustomIcon.assetId) == "string" and NAStuff.CustomIcon.assetId ~= ""
		local hasPath = typeof(NAStuff.CustomIcon.localPath) == "string" and NAStuff.CustomIcon.localPath ~= ""
		local hasEnabled = typeof(NAStuff.CustomIcon.enabled) == "boolean"

		if not hasAsset and not hasPath then
			if typeof(storedPath) == "string" and storedPath ~= "" and NAgui.iconFsOk() then
				NAStuff.CustomIcon.localPath = storedPath
				local okA, assetFromFile = pcall(getcustomasset, storedPath)
				if okA and typeof(assetFromFile) == "string" then
					NAStuff.CustomIcon.assetId = assetFromFile
				elseif typeof(storedAsset) == "string" and storedAsset ~= "" then
					NAStuff.CustomIcon.assetId = storedAsset
				end
			elseif typeof(storedAsset) == "string" and storedAsset ~= "" then
				NAStuff.CustomIcon.assetId = storedAsset
			end
		end

		if not hasEnabled and typeof(storedEnabled) == "boolean" then
			NAStuff.CustomIcon.enabled = storedEnabled
		end
	end

	if NAgui.iconSupported() and NAStuff.NAICONMAIN and typeof(NAStuff.NAICONMAIN.Image) == "string" and NAStuff.NAICONMAIN.Image ~= "" then
		NAStuff.CustomIcon.defaultImage = NAStuff.CustomIcon.defaultImage or NAStuff.NAICONMAIN.Image
	end

	if typeof(NAStuff.CustomIcon.assetId) ~= "string" or NAStuff.CustomIcon.assetId == "" then
		NAStuff.CustomIcon.assetId = nil
	end

	if typeof(NAStuff.CustomIcon.enabled) ~= "boolean" then
		NAStuff.CustomIcon.enabled = false
	end

	NAgui._saveIconSettings = function()
		saveIcfg()
	end

	NAgui.getIconDigits = function()
		if typeof(NAStuff.CustomIcon.assetId) == "string" then
			return NAStuff.CustomIcon.assetId:match("(%d+)$") or ""
		end
		return ""
	end

	NAgui._applyIconState = function()
		if not NAgui.iconSupported() then
			return false
		end
		local state = NAStuff.CustomIcon
		local targetImage
		if state.enabled and typeof(state.assetId) == "string" and state.assetId ~= "" then
			targetImage = state.assetId
		elseif typeof(state.defaultImage) == "string" and state.defaultImage ~= "" then
			targetImage = state.defaultImage
		end
		local applied = false
		if targetImage and targetImage ~= "" then
			NAStuff.NAICONMAIN.Image = targetImage
			applied = true
		else
			NAStuff.NAICONMAIN.Image = ""
		end
		if NAStuff.IconFallbackLabel then
			NAStuff.IconFallbackLabel.Visible = not applied
		end
		return applied
	end

	NAgui.useCustomIconEntry = function(entry, opts)
		opts = opts or {}
		if not NAgui.iconSupported() then
			return false, "Custom icon requires getcustomasset support for the NA icon."
		end
		if not entry or not entry.file then
			return false, "No custom icon entry."
		end
		if not NAgui.ensureIconFolder() then
			return false, "Unable to prepare CustomIcon folder."
		end
		local fullPath = NAfiles.NACUSTOMICONPATH.."/"..entry.file
		if type(isfile) == "function" then
			local okEx, ex = pcall(isfile, fullPath)
			if not (okEx and ex) then
				return false, "Custom icon file is missing."
			end
		end
		local okA, asset = pcall(getcustomasset, fullPath)
		if not (okA and typeof(asset) == "string") then
			return false, "Unable to load custom icon image."
		end
		NAStuff.CustomIcon.localPath = fullPath
		NAStuff.CustomIcon.assetId = asset
		if opts.autoEnable ~= false then
			NAStuff.CustomIcon.enabled = true
		end
		NAgui._applyIconState()
		NAgui._saveIconSettings()
		return true
	end

	NAgui.cycleCustomIcon = function(delta)
		local list = NAStuff.CustomIcon.entries or {}
		if #list == 0 then
			DoNotif("No custom icons installed.", 3)
			return
		end
		delta = delta or 1
		local idx = NAStuff.CustomIcon.index or 0
		if idx < 1 or idx > #list then
			idx = 1
		end
		idx = ((idx - 1 + delta) % #list) + 1
		local ok, err = NAgui.useCustomIconEntry(list[idx])
		if not ok then
			if err then
				DoNotif(err, 3)
			end
			return
		end
		NAStuff.CustomIcon.index = idx
	end

	NAgui.setIconEnabled = function(enabled, opts)
		opts = opts or {}
		if not NAgui.iconSupported() then
			return false, "Custom icon requires getcustomasset support for the NA icon."
		end
		enabled = enabled and true or false
		if enabled and not NAStuff.CustomIcon.assetId then
			if not opts.skipToggle and NAgui.setToggleState then
				NAgui.setToggleState("Use Custom NA Icon", false, { force = true, fire = false })
			end
			return false, "Add an asset id or URL before enabling the custom icon."
		end
		if NAStuff.CustomIcon.enabled == enabled and not opts.force then
			return true
		end
		NAStuff.CustomIcon.enabled = enabled
		NAgui._applyIconState()
		if not opts.skipToggle and NAgui.setToggleState then
			NAgui.setToggleState("Use Custom NA Icon", enabled, { force = true, fire = false })
		end
		NAgui._saveIconSettings()
		return true
	end

	NAgui.setIconAsset = function(inputValue, opts)
		opts = opts or {}
		if not NAgui.iconSupported() then
			return false, "Custom icon requires getcustomasset support for the NA icon."
		end
		local raw = typeof(inputValue) == "string" and inputValue or tostring(inputValue)
		if typeof(raw) ~= "string" then
			return false, "Enter a valid asset id or image URL."
		end
		raw = raw:match("^%s*(.-)%s*$")
		if raw == "" then
			return false, "Enter a valid asset id or image URL."
		end
		local digits = raw:match("^rbxassetid://(%d+)$") or raw:match("id=(%d+)") or raw:match("^(%d+)$")
		local newAsset
		NAStuff.CustomIcon.localPath = nil
		if digits then
			newAsset = "rbxassetid://"..digits
		else
			local t, base = NAgui.iconPreUrl(raw)
			if not t then
				return false, "Enter a valid asset id or image URL."
			end
			local folderInfo = parseGitHubFolderUrl(base, t)
			if folderInfo then
				local okFolder, res = NAgui.installIconsFromGitHubFolder(folderInfo)
				if not okFolder then
					return false, res or "Unable to save custom icon."
				end
				NAgui.scanCustomIcons()
				NAgui.refreshCustomIconUI()
				newAsset = res and res.asset
				if not newAsset then
					return false, "Installed icons but failed to apply one of them."
				end
			else
				local okIcon, r = NAgui.iconSaveFromUrl(t)
				if not okIcon then
					return false, r or "Unable to save custom icon."
				end
				newAsset = r
			end
		end
		NAStuff.CustomIcon.assetId = newAsset
		if opts.autoEnable ~= false then
			NAStuff.CustomIcon.enabled = true
		end
		NAgui._applyIconState()
		if opts.autoEnable ~= false and not opts.skipToggle and NAgui.setToggleState then
			NAgui.setToggleState("Use Custom NA Icon", true, { force = true, fire = false })
		end
		NAgui._saveIconSettings()
		if digits then
			return true, digits
		end
		return true, raw
	end

	if NAStuff.CustomIcon.enabled and NAStuff.CustomIcon.assetId and NAgui.iconSupported() then
		NAgui._applyIconState()
	end

	NAgui.scanCustomIcons()

	NAStuff.CustomIcon.pendingInput = NAStuff.CustomIcon.pendingInput or ((NAgui.getIconDigits and NAgui.getIconDigits()) or "")

	local function deleteIconFile(name)
		if type(name) ~= "string" or name == "" then
			return
		end
		if type(isfile) ~= "function" or type(delfile) ~= "function" then
			return
		end
		local full = NAfiles.NACUSTOMICONPATH.."/"..name
		local okEx, ex = pcall(isfile, full)
		if okEx and ex then
			pcall(delfile, full)
		end
	end

	local function clearCurrentIconIf(fileName)
		if type(fileName) ~= "string" or fileName == "" then
			return
		end
		local full = NAfiles.NACUSTOMICONPATH.."/"..fileName
		if NAStuff.CustomIcon.localPath == full then
			NAStuff.CustomIcon.localPath = nil
			NAStuff.CustomIcon.assetId = nil
			NAStuff.CustomIcon.index = 0
			NAStuff.CustomIcon.enabled = false
			NAgui._applyIconState()
			if NAgui.setToggleState then
				NAgui.setToggleState("Use Custom NA Icon", false, { force = true, fire = false })
			end
			NAgui._saveIconSettings()
		end
	end

	local function removeCustomIconEntry(entry)
		if not (entry and entry.file) then
			return
		end
		deleteIconFile(entry.file)
		clearCurrentIconIf(entry.file)
		NAgui.scanCustomIcons()
		NAgui.refreshCustomIconUI()
	end

	local function removeAllCustomIcons()
		local list = NAStuff.CustomIcon.entries or {}
		for _, entry in ipairs(list) do
			if entry and entry.file then
				deleteIconFile(entry.file)
			end
		end
		NAStuff.CustomIcon.entries = {}
		NAStuff.CustomIcon.index = 0
		NAStuff.CustomIcon.localPath = nil
		NAStuff.CustomIcon.assetId = nil
		NAStuff.CustomIcon.enabled = false
		NAgui._applyIconState()
		if NAgui.setToggleState then
			NAgui.setToggleState("Use Custom NA Icon", false, { force = true, fire = false })
		end
		NAgui._saveIconSettings()
		NAgui.scanCustomIcons()
		NAgui.refreshCustomIconUI()
	end

	local function openIconDeletePopup()
		local list = NAStuff.CustomIcon.entries or {}
		if #list == 0 then
			DoNotif("No custom icons installed.", 3)
			return
		end
		if type(Popup) ~= "function" then
			DoNotif("Popup UI is unavailable in this session.", 3)
			return
		end
		local buttons = {}
		for _, entry in ipairs(list) do
			local label = entry.file or "Custom Icon"
			Insert(buttons, {
				Text = label,
				Callback = function()
					removeCustomIconEntry(entry)
					DoNotif('Removed custom icon "'..label..'".', 2)
				end,
			})
		end
		Insert(buttons, { Text = "Cancel", Callback = function() end })
		Popup({
			Title = "Remove Custom Icon",
			Description = "Select a custom icon to delete.",
			Duration = 0,
			Buttons = buttons,
		})
	end

	NAgui.addSection("Custom NA Icon")

	NAStuff.CustomIcon.info = NAgui.addInfo("Custom Icons", NAgui.formatCustomIconStatus())
	NAgui.refreshCustomIconUI()

	NAgui.addToggle("Use Custom NA Icon", NAStuff.CustomIcon.enabled == true and NAgui.iconSupported(), function(v)
		if not NAgui.iconSupported() then
			DoNotif("Custom icon requires getcustomasset support for the NA icon.", 3)
			if NAgui.setToggleState then
				NAgui.setToggleState("Use Custom NA Icon", false, { force = true, fire = false })
			end
			return
		end
		local ok, err = NAgui.setIconEnabled(v, { skipToggle = true })
		if not ok then
			if err then
				DoNotif(err, 3)
			end
			if NAgui.setToggleState then
				NAgui.setToggleState("Use Custom NA Icon", NAStuff.CustomIcon.enabled == true, { force = true, fire = false })
			end
			return
		end
		DoNotif("Custom NA Icon "..(v and "enabled" or "disabled"), 2)
	end)

	NAmanage.RegisterToggleAutoSync("Use Custom NA Icon", function()
		return NAStuff.CustomIcon.enabled == true and NAgui.iconSupported()
	end)

	NAgui.addInput("Custom Icon Asset / URL", "Enter asset id or image URL", NAStuff.CustomIcon.pendingInput, function(text)
		NAStuff.CustomIcon.pendingInput = text or ""
	end)

	NAgui.addButton("Apply Custom Icon", function()
		if not NAgui.iconSupported() then
			DoNotif("Custom icon requires getcustomasset support for the NA icon.", 3)
			return
		end
		local ok, result = NAgui.setIconAsset(NAStuff.CustomIcon.pendingInput)
		if ok then
			NAStuff.CustomIcon.pendingInput = ""
			if NAgui.setInputValue then
				NAgui.setInputValue("Custom Icon Asset / URL", "", { force = true, fire = false })
			end
			NAgui.scanCustomIcons()
			NAgui.refreshCustomIconUI()
			DoNotif("Custom NA Icon updated.", 2)
		else
			DoNotif(result or "Unable to update custom icon.", 3)
		end
	end)

	NAgui.addButton("Previous Custom Icon", function()
		NAgui.cycleCustomIcon(-1)
	end)

	NAgui.addButton("Next Custom Icon", function()
		NAgui.cycleCustomIcon(1)
	end)

	NAgui.addButton("Download NA Icons", function()
		local ok, res = NAgui.downloadNAIcons()
		if ok then
			NAgui.scanCustomIcons()
			NAgui.refreshCustomIconUI()
			DoNotif(Format("Installed %d NA icon%s.", res, res == 1 and "" or "s"), 2)
		else
			DoNotif(res or "Unable to download NA icons.", 3)
		end
	end)

	NAgui.addButton("Reload Custom Icons", function()
		NAgui.scanCustomIcons()
		NAgui.refreshCustomIconUI()
		DoNotif("Custom icons reloaded.", 2)
	end)

	NAgui.addButton("Remove Custom Icon...", openIconDeletePopup)

	NAgui.addButton("Remove All Custom Icons", function()
		local list = NAStuff.CustomIcon.entries or {}
		if #list == 0 then
			DoNotif("No custom icons installed.", 3)
			return
		end
		removeAllCustomIcons()
		DoNotif("Removed all custom icons.", 2)
	end)
end

local NAScale = 1
local NAUIScale = 1
local flingManager = { FlingOldPos = nil; lFlingOldPos = nil; cFlingOldPos = nil; }
local settingsLight = { range = 30; brightness = 1; color = Color3.new(1,1,1); LIGHTER = nil; }
local events = {
	"OnSpawn",
	"OnDeath",
	"OnKill",
	"OnDamage",
	"OnChatted",
	"OnJump",
	"OnEquipItem",
	"OnUnequipItem",
	"OnJoin",
	"OnLeave",
}
local morphTarget = ""
NASESSIONSTARTEDIDK = os.clock()
NAlib = NAlib or {}
NAgui={}
NAindex = NAindex or { _init = false }
NAjobs  = NAjobs  or { jobs = {}, hb = nil, seq = 0, _frame = 0, _claimed = {}, _touchState = setmetatable({}, {__mode="k"}) }
NAutil  = NAutil  or {}
NAsuppress = NAsuppress or { ref = setmetatable({}, {__mode="k"}), snap = setmetatable({}, {__mode="k"}) }
NACOLOREDELEMENTS={}
NACOLOREDELEMENTS_SET=setmetatable({}, {__mode="k"})

DEFAULT_UI_STROKE_COLOR=Color3.fromRGB(148,93,255)
COLOR_WHITE=Color3.new(1,1,1)
COLOR_BLACK=Color3.new(0,0,0)

NAmanage.FormatAccountAge=function(days)
	if type(days) ~= "number" then
		return "Unknown"
	end
	if days < 0 then
		days = 0
	end
	local years=math.floor(days/365)
	local remainingDays=days%365
	local months=math.floor(remainingDays/30)
	local finalDays=math.floor(remainingDays%30)
	local parts={}
	if years>0 then parts[#parts+1]=tostring(years).." yr" end
	if months>0 then parts[#parts+1]=tostring(months).." mo" end
	if finalDays>0 or #parts==0 then parts[#parts+1]=tostring(finalDays).." d" end
	return Concat(parts," ")
end

NAgui.RegisterColoredStroke=function(stroke)
	if typeof(stroke) ~= "Instance" then return end
	if not stroke:IsA("UIStroke") then return end
	if NACOLOREDELEMENTS_SET[stroke] then return end
	NACOLOREDELEMENTS_SET[stroke]=true
	local baseColor=NAUISTROKER or DEFAULT_UI_STROKE_COLOR or stroke.Color
	stroke.Color=baseColor
	Insert(NACOLOREDELEMENTS,stroke)
end

NAgui.RegisterStrokesFrom=function(instance)
	if typeof(instance) ~= "Instance" then return end
	if instance:IsA("UIStroke") then
		NAgui.RegisterColoredStroke(instance)
		return
	end
	for _, descendant in ipairs(instance:GetDescendants()) do
		if descendant:IsA("UIStroke") then
			NAgui.RegisterColoredStroke(descendant)
		end
	end
end

NAgui.ComputeTabStrokeColor=function(isActive)
	local base=NAUISTROKER or DEFAULT_UI_STROKE_COLOR
	if isActive then
		return base:Lerp(COLOR_WHITE,0.22)
	end
	return base:Lerp(COLOR_BLACK,0.12)
end

NAmanage.getTabStrokeColor = NAgui.ComputeTabStrokeColor

NAmanage.GetBasicInfoSnapshot = function()
	local snapshot = {
		player = {};
		platform = {};
		game = {};
		ids = {};
		server = {};
		system = {};
		flags = {};
		session = {};
		timestamp = "";
	}

	local function formatDuration(seconds)
		local value = tonumber(seconds) or 0
		if value < 0 then
			value = 0
		end
		local hours = math.floor(value / 3600)
		local minutes = math.floor((value % 3600) / 60)
		local secs = math.floor(value % 60)
		return Format("%02d:%02d:%02d", hours, minutes, secs)
	end

	local player = Players and Players.LocalPlayer
	local displayName = player and player.DisplayName or "Unknown"
	local username = player and player.Name or "Unknown"
	local userId = player and player.UserId or nil
	local accountAgeDays = player and player.AccountAge or nil
	local membership = "None"
	if player and player.MembershipType == Enum.MembershipType.Premium then
		membership = "Premium"
	end
	local teamName = "None"
	if player and player.Team then
		teamName = player.Team.Name or "None"
	end

	snapshot.player.displayName = displayName
	snapshot.player.username = username
	snapshot.player.userId = userId and tostring(userId) or "Unknown"
	snapshot.player.accountAge = NAmanage.FormatAccountAge(accountAgeDays)
	snapshot.player.membership = membership
	snapshot.player.team = teamName

	local platformName = "Unknown"
	if UserInputService then
		local okPlatform, platformEnum = pcall(UserInputService.GetPlatform, UserInputService)
		if okPlatform and platformEnum then
			platformName = platformEnum.Name or tostring(platformEnum)
		end
	end

	local executorName = "Unknown"
	if identifyexecutor then
		local okExec, execResult = pcall(identifyexecutor)
		if okExec and execResult and execResult ~= "" then
			executorName = execResult
		end
	elseif identifyexec then
		local okExecAlt, execResultAlt = pcall(identifyexec)
		if okExecAlt and execResultAlt and execResultAlt ~= "" then
			executorName = execResultAlt
		end
	end

	local deviceType = "Unknown"
	if IsOnMobile then
		deviceType = "Mobile"
	elseif IsOnPC then
		deviceType = "Desktop"
	elseif platformName ~= "Unknown" then
		deviceType = platformName
	end

	local inputs = {}
	if UserInputService then
		if UserInputService.TouchEnabled then Insert(inputs, "Touch") end
		if UserInputService.GamepadEnabled then Insert(inputs, "Gamepad") end
		if UserInputService.KeyboardEnabled or UserInputService.MouseEnabled then
			Insert(inputs, "KB/M")
		end
	end
	local controlScheme = #inputs > 0 and Concat(inputs, ", ") or "Unknown"

	snapshot.platform.platform = platformName
	snapshot.platform.executor = executorName
	snapshot.platform.device = deviceType
	snapshot.platform.input = controlScheme

	local robloxLocale = LocalizationService and LocalizationService.RobloxLocaleId or "Unknown"
	local systemLocale = LocalizationService and LocalizationService.SystemLocaleId or "Unknown"

	local qualitySetting = "Auto"
	local okUGS, userGameSettings = pcall(function()
		return UserSettings():GetService("UserGameSettings")
	end)
	if okUGS and userGameSettings then
		local savedQuality = userGameSettings.SavedQualityLevel
		if typeof(savedQuality) == "EnumItem" then
			qualitySetting = savedQuality.Name or tostring(savedQuality)
		elseif savedQuality ~= nil then
			qualitySetting = tostring(savedQuality)
		end
	end

	local voiceStatus = "Unknown"
	local okVoiceService, voiceService = pcall(game.GetService, game, "VoiceChatService")
	if okVoiceService and voiceService and userId then
		local okVoice, voiceEnabled = pcall(function()
			return voiceService:IsVoiceEnabledForUserIdAsync(userId)
		end)
		if okVoice then
			voiceStatus = voiceEnabled and "Enabled" or "Disabled"
		end
	end

	local resolution = "Unknown"
	local camera = workspace and workspace.CurrentCamera
	if camera and camera.ViewportSize then
		resolution = Format("%dx%d", math.floor(camera.ViewportSize.X), math.floor(camera.ViewportSize.Y))
	end

	snapshot.system.robloxLocale = robloxLocale
	snapshot.system.systemLocale = systemLocale
	snapshot.system.quality = qualitySetting
	snapshot.system.voice = voiceStatus
	snapshot.system.resolution = resolution

	local placeId = tonumber(game.PlaceId) or 0
	local gameId = game.GameId or "Unknown"
	local jobIdValue = game.JobId
	if jobIdValue == nil or jobIdValue == "" then
		jobIdValue = "Unavailable"
	end

	local gameName = "Unknown"
	local creatorName = "Unknown"
	local gameGenre = "Unknown"
	local universeId = tonumber(gameId) or 0
	local placeVersion = tonumber(game.PlaceVersion) or nil
	local now = (os.clock and os.clock() or tick())

	if NAmanage then
		NAmanage.BasicInfoGameCache = NAmanage.BasicInfoGameCache or {}
		local cache = NAmanage.BasicInfoGameCache

		if cache.universeId ~= universeId then
			cache.universeId = universeId
			cache.name = nil
			cache.creator = nil
			cache.genre = nil
			cache.fetching = false
			cache.lastFetch = 0
			cache.fetchId = 0
			cache.marketplaceFetched = false
		end

		if cache.name then
			gameName = cache.name
		end
		if cache.creator then
			creatorName = cache.creator
		end
		if cache.genre then
			gameGenre = cache.genre
		end

		local lastFetch = cache.lastFetch or 0
		if universeId ~= 0 and not cache.fetching and not cache.genre and (lastFetch == 0 or (now - lastFetch > 30)) then
			cache.fetching = true
			cache.lastFetch = now
			cache.fetchId = (cache.fetchId or 0) + 1
			local fetchId = cache.fetchId

			SpawnCall(function()
				local url = "https://games.roblox.com/v1/games?universeIds="..tostring(universeId)
				local body

				local okBody, result = pcall(game.HttpGet, game, url)
				if okBody and type(result) == "string" then
					body = result
				elseif type(NAREQUEST) == "function" then
					local okReq, resp = pcall(NAREQUEST, { Url = url, Method = "GET" })
					if okReq and type(resp) == "table" then
						body = resp.Body or resp.body or resp.ResponseBody
					end
				end

				if type(body) == "string" and body ~= "" and HttpService and HttpService.JSONDecode then
					local okDecode, decoded = pcall(HttpService.JSONDecode, HttpService, body)
					if okDecode and type(decoded) == "table" and type(decoded.data) == "table" and decoded.data[1] and cache.fetchId == fetchId and cache.universeId == universeId then
						local entry = decoded.data[1]
						cache.name = cache.name or entry.name or entry.Name
						if entry.creator and type(entry.creator) == "table" then
							cache.creator = cache.creator or entry.creator.name or entry.creator.Name
						end
						cache.genre = cache.genre or entry.genre or entry.genre_l1 or entry.genre_l2 or entry.Genre
					end
				end

				if cache.fetchId == fetchId then
					cache.fetching = false
				end
			end)
		end

		if MarketplaceService and placeId ~= 0 and not cache.marketplaceFetched and (gameName == "Unknown" or creatorName == "Unknown") then
			local okInfo, infoResult = pcall(MarketplaceService.GetProductInfo, MarketplaceService, placeId)
			if okInfo and type(infoResult) == "table" then
				cache.name = cache.name or infoResult.Name
				if infoResult.Creator and infoResult.Creator.Name then
					cache.creator = cache.creator or infoResult.Creator.Name
				end
			end
			cache.marketplaceFetched = true

			gameName = cache.name or gameName
			creatorName = cache.creator or creatorName
			gameGenre = cache.genre or gameGenre
		end
	end

	snapshot.game.name = gameName
	snapshot.game.creator = creatorName
	snapshot.game.genre = gameGenre
	snapshot.game.placeVersion = placeVersion and tostring(placeVersion) or "Unknown"

	snapshot.ids.placeId = placeId ~= 0 and tostring(placeId) or "Unknown"
	local gameIdText = tostring(gameId)
	if gameIdText == "" or gameIdText == "0" then
		gameIdText = "Unknown"
	end
	snapshot.ids.gameId = gameIdText
	snapshot.ids.jobId = tostring(jobIdValue)

	local playerCount = Players and Players.NumPlayers or 0
	local maxPlayers = Players and Players.MaxPlayers or 0

	local serverPing = "Unknown"
	local statsService = SafeGetService and SafeGetService("Stats") or nil
	if statsService and statsService.Network and statsService.Network.ServerStatsItem then
		local pingStat = statsService.Network.ServerStatsItem["Data Ping"]
		if pingStat then
			local okPingNum, pingNum = pcall(function()
				if pingStat.GetValue then
					return pingStat:GetValue()
				end
			end)
			if okPingNum and type(pingNum) == "number" then
				serverPing = Format("%d ms", math.floor(pingNum + 0.5))
			else
				local okPingStr, pingStr = pcall(function()
					if pingStat.GetValueString then
						return pingStat:GetValueString()
					end
				end)
				if okPingStr and type(pingStr) == "string" and pingStr ~= "" then
					serverPing = pingStr
				end
			end
		end
	end

	snapshot.server.playerCount = Format("%d/%d", playerCount, maxPlayers)
	snapshot.server.ping = serverPing

	local isTesting = getgenv and getgenv().NATestingVer
	local aprilMode = getgenv and getgenv().ActivateAprilMode

	snapshot.flags.version = isTesting and "Testing" or "Normal"
	snapshot.flags.aprilFools = aprilMode and "Enabled" or "Disabled"

	local sessionSeconds = (os.clock and os.clock() or tick()) - (NASESSIONSTARTEDIDK or 0)
	snapshot.session.uptime = formatDuration(sessionSeconds)

	snapshot.timestamp = os.date("%m/%d/%Y | %H:%M:%S")

	return snapshot
end

NAmanage.prefetchRobloxGameInfo = function()
	local cache = NAmanage.BasicInfoGameCache or {}
	NAmanage.BasicInfoGameCache = cache

	local placeId = tonumber(game.PlaceId) or 0
	local universeId = tonumber(game.GameId) or 0
	if universeId == 0 then
		return false, "no universe id"
	end

	if cache.universeId ~= universeId then
		cache.universeId = universeId
		cache.name = nil
		cache.creator = nil
		cache.genre = nil
		cache.fetching = false
		cache.lastFetch = 0
		cache.fetchId = 0
		cache.marketplaceFetched = false
	end

	if cache.genre and cache.name and cache.creator then
		return true
	end

	local url = "https://games.roblox.com/v1/games?universeIds="..tostring(universeId)
	local body

	local okBody, result = pcall(game.HttpGet, game, url)
	if okBody and type(result) == "string" then
		body = result
	elseif type(NAREQUEST) == "function" then
		local okReq, resp = pcall(NAREQUEST, { Url = url, Method = "GET" })
		if okReq and type(resp) == "table" then
			body = resp.Body or resp.body or resp.ResponseBody
		end
	end

	if type(body) == "string" and body ~= "" and HttpService and HttpService.JSONDecode then
		local okDecode, decoded = pcall(HttpService.JSONDecode, HttpService, body)
		if okDecode and type(decoded) == "table" and type(decoded.data) == "table" and decoded.data[1] then
			local entry = decoded.data[1]
			cache.name = cache.name or entry.name or entry.Name
			if entry.creator and type(entry.creator) == "table" then
				cache.creator = cache.creator or entry.creator.name or entry.creator.Name
			end
			cache.genre = cache.genre or entry.genre or entry.genre_l1 or entry.genre_l2 or entry.Genre
		end
	end

	local cachedName = cache.name or "Unknown"
	local cachedCreator = cache.creator or "Unknown"
	if (not cache.marketplaceFetched) and (cachedName == "Unknown" or cachedCreator == "Unknown") and MarketplaceService and placeId ~= 0 then
		local okInfo, infoResult = pcall(MarketplaceService.GetProductInfo, MarketplaceService, placeId)
		if okInfo and type(infoResult) == "table" then
			cache.name = cache.name or infoResult.Name
			if infoResult.Creator and infoResult.Creator.Name then
				cache.creator = cache.creator or infoResult.Creator.Name
			end
		end
		cache.marketplaceFetched = true
	end

	local success = cache.genre ~= nil or cache.name ~= nil
	return success
end
cmdNAnum=0
NAQoTEnabled = nil
NAiconSaveEnabled = nil
NAUISTROKER = DEFAULT_UI_STROKE_COLOR
NATOPBARVISIBLE = true
NATopbarKeepPosition = false
NATopbarPositionRatio = 0
NATopbarDock = "top"
NALoadingStartMinimized = false
NASideSwipeSide = "left"
NASideSwipeEnabled = false
NADisableLastInput = false

do
	if FileSupport then
		pcall(function()
			if typeof(isfolder) == "function" and not isfolder(NAfiles.NAFILEPATH) then
				if typeof(makefolder) == "function" then
					makefolder(NAfiles.NAFILEPATH)
				end
			end
		end)
		local ok, raw = pcall(function()
			if typeof(isfile) == "function" and isfile(NAfiles.NAMAINSETTINGSPATH) then
				return readfile(NAfiles.NAMAINSETTINGSPATH)
			end
			return nil
		end)
		if ok and type(raw) == "string" and raw ~= "" then
			local decodedOk, decoded = pcall(HttpService.JSONDecode, HttpService, raw)
			if decodedOk and typeof(decoded) == "table" then
				local val = decoded.loadingStartMinimized
				local function parseBool(value)
					if type(value) == "boolean" then return value end
					if type(value) == "string" then
						local lowered = value:lower()
						if lowered == "true" or lowered == "1" then return true end
						if lowered == "false" or lowered == "0" then return false end
					end
					if type(value) == "number" then
						return value ~= 0
					end
					return nil
				end
				local parsed = parseBool(val)
				if parsed ~= nil then
					NALoadingStartMinimized = parsed
				end
			end
		end
	end
end

if getgenv().NATestingVer then
	opt.loaderUrl = "https://raw.githubusercontent.com/ltseverydayyou/Nameless-Admin/main/NA%20testing.lua"
	opt.githubUrl="https://api.github.com/repos/ltseverydayyou/Nameless-Admin/commits?path=NA%20testing.lua"
	opt.NAUILOADER="https://raw.githubusercontent.com/ltseverydayyou/Nameless-Admin/refs/heads/main/NAUITEST.lua"
else
	opt.loaderUrl = "https://raw.githubusercontent.com/ltseverydayyou/Nameless-Admin/main/Source.lua"
	opt.githubUrl="https://api.github.com/repos/ltseverydayyou/Nameless-Admin/commits?path=Source.lua"
	opt.NAUILOADER="https://raw.githubusercontent.com/ltseverydayyou/Nameless-Admin/refs/heads/main/NAUI.lua"
end

NAmanage.centerFrame = function(f)
	local cam = workspace.CurrentCamera
	local vp = cam.ViewportSize
	local totalX = f.Size.X.Scale + (f.Size.X.Offset / vp.X)
	local totalY = f.Size.Y.Scale + (f.Size.Y.Offset / vp.Y)
	f.Position = UDim2.new(0.5 - totalX/2, 0, 0.5 - totalY/2, 0)
end

NAmanage.guiCHECKINGAHHHHH=function()
	return (gethui and gethui()) or SafeGetService("CoreGui"):FindFirstChildWhichIsA("ScreenGui") or SafeGetService("CoreGui") or SafeGetService("Players").LocalPlayer:FindFirstChildWhichIsA("PlayerGui")
end

if not gethui then
	getgenv().gethui=function()
		return NAmanage.guiCHECKINGAHHHHH()
	end
end

function InstanceNew(c,p)
	local inst = Instance.new(c)
	if p then inst.Parent = p end
	inst.Name = "\0"
	return inst
end

function NACaller(fn, ...)
	local args = {...}
	local function wrapped()
		return fn(unpack(args))
	end
	local t = table.pack(xpcall(wrapped, function(msg)
		return debug.traceback(msg, 2)
	end))
	if not t[1] then
		local err = t[2]
		warn(adminName.." script error:\n"..err)
		if type(Popup) == "function" then
			Popup({
				Title       = adminName or "Oops!",
				Description = Format("Oops! Something went wrong. If this keeps happening or seems serious, please let the owner know.\n\nDetails:\n%s", err),
				Buttons     = {
					{
						Text = "Copy Error",
						Callback = function()
							if setclipboard then
								setclipboard(err)
								if type(DoNotif) == "function" then
									DoNotif("Error details copied to clipboard!")
								end
							else
								if type(DoWindow) == "function" then
									DoWindow("Error details:\n"..err)
								else
									warn("Error details:\n"..err)
								end
							end
						end
					},
					{
						Text = "Discord Server",
						Callback = function()
							if setclipboard then
								setclipboard(inviteLink)
								if type(DoNotif) == "function" then
									DoNotif("Discord link copied to clipboard!")
								end
							else
								if type(DoWindow) == "function" then
									DoWindow("Server Invite: "..inviteLink)
								else
									warn("Server Invite: "..inviteLink)
								end
							end
						end
					}
				}
			})
		end
	end
	return Unpack(t, 1, t.n)
end

NAmanage.loaderState = NAmanage.loaderState or {
	autoSkip = false;
	loaded = false;
	settingsPath = "Nameless-Admin/Settings.json";
}

NAmanage.getAutoSkipPreference = function()
	local state = NAmanage.loaderState
	if state.loaded then
		return state.autoSkip
	end
	state.loaded = true
	if not FileSupport then
		state.autoSkip = false
		return state.autoSkip
	end
	if type(isfile) == "function" and isfile(state.settingsPath) then
		local ok, raw = NACaller(readfile, state.settingsPath)
		if ok and type(raw) == "string" and raw ~= "" then
			local decodeOk, decoded = NACaller(function()
				return HttpService:JSONDecode(raw)
			end)
			if decodeOk and typeof(decoded) == "table" then
				local value = decoded.autoSkipLoading
				if type(value) == "boolean" then
					state.autoSkip = value
				end
			end
		end
	end
	return state.autoSkip
end

NAmanage.setAutoSkipPreference = function(enabled)
	local state = NAmanage.loaderState
	state.autoSkip = enabled and true or false
	state.loaded = true
	if not FileSupport then
		return
	end
	local data = {}
	if type(isfile) == "function" and isfile(state.settingsPath) then
		local ok, raw = NACaller(readfile, state.settingsPath)
		if ok and type(raw) == "string" and raw ~= "" then
			local decodeOk, decoded = NACaller(function()
				return HttpService:JSONDecode(raw)
			end)
			if decodeOk and typeof(decoded) == "table" then
				data = decoded
			end
		end
	end
	data.autoSkipLoading = state.autoSkip
	local encodeOk, encoded = NACaller(function()
		return HttpService:JSONEncode(data)
	end)
	if encodeOk and type(encoded) == "string" then
		NACaller(writefile, state.settingsPath, encoded)
	end
end

function rStringgg()
	local length = math.random(10, 20)
	local result = {}
	local glitchMarks = {"̶", "̷", "̸", "̹", "̺", "̻", "͓", "͔", "͘", "͜", "͞", "͟", "͢"}
	for i = 1, length do
		local char = string.char(math.random(32, 126))
		Insert(result, char)
		if math.random() < 0.5 then
			local numGlitches = math.random(1, 4)
			for j = 1, numGlitches do
				Insert(result, glitchMarks[math.random(#glitchMarks)])
			end
		end
	end
	if math.random() < 0.3 then
		Insert(result, utf8.char(math.random(0x0300, 0x036F)))
	end
	if math.random() < 0.1 then
		Insert(result, "\0")
	end
	if math.random() < 0.1 then
		Insert(result, string.rep("​", math.random(5, 20)))
	end
	if math.random() < 0.2 then
		Insert(result, utf8.char(0x202E))
	end
	return Concat(result)
end

function NAProtection(inst,var)
	if not inst then return end
	if var then
		inst[var] = "\0"
	else
		inst.Name   = "\0"
	end
	inst.Archivable = false
end

function NaProtectUI(gui)
	local INV = "\0"
	local MAX_DO = 0x7FFFFFFF
	local target = NAmanage.guiCHECKINGAHHHHH()
	if not target then return end
	pcall(function() gui.Archivable = false end)
	gui.Name   = INV
	gui.Parent = target
	if gui:IsA("ScreenGui") then
		gui.ZIndexBehavior = Enum.ZIndexBehavior.Global
		gui.DisplayOrder   = MAX_DO
		gui.ResetOnSpawn   = false
		gui.IgnoreGuiInset = true
	end
	local props = {
		Parent         = target,
		Name           = INV,
		Archivable     = false,
		ZIndexBehavior = Enum.ZIndexBehavior.Global,
		DisplayOrder   = MAX_DO,
		ResetOnSpawn   = false,
		IgnoreGuiInset = true,
	}
	if not gui:IsA("ScreenGui") then
		props.ZIndexBehavior = nil
		props.DisplayOrder   = nil
		props.ResetOnSpawn   = nil
		props.IgnoreGuiInset = nil
	end
	for prop, val in pairs(props) do
		gui:GetPropertyChangedSignal(prop):Connect(function()
			if gui[prop] ~= val then
				pcall(function() gui[prop] = val end)
			end
		end)
	end
	gui.AncestryChanged:Connect(function(_, newParent)
		if gui.Parent ~= target then
			pcall(function() gui.Parent = target end)
		end
	end)
	local hb
	hb = SafeGetService("RunService").Heartbeat:Connect(function()
		for prop, val in pairs(props) do
			if gui[prop] ~= val then
				pcall(function() gui[prop] = val end)
			end
		end
		if not gui.Parent then
			pcall(function() hb:Disconnect() end)
		end
	end)
	return gui
end

function isAprilFools()
	local d = os.date("*t")
	return (d.month == 4 and d.day == 1) or getgenv().ActivateAprilMode or false
end

function yayApril(isTesting)
	local baseNames = {
		"Clueless", "Gay", "Infinite", "Sussy", "Broken", "Shadow", "Quirky",
		"Zoomy", "Wacky", "Booba", "Spicy", "Meme", "Doofy", "Silly",
		"Goblin", "Bingus", "Chonky", "Floofy", "Yeety", "Bonky", "Derpy",
		"Cheesy", "Nugget", "Funky", "Floppy", "Chunky", "Snazzy", "Wonky",
		"Goober", "Dorky", "Zany", "Glitchy", "Bubbly", "Wizzy", "Turbo",
		"Pixel", "Nifty", "Jazzy", "Rascal", "Muddled", "Quasar", "Nimbus",
		"Echo", "Froggy", "Gobsmack", "Hiccup", "Jinx", "Kooky", "Loco",
		"Mango", "Noodle", "Oddball", "Peculiar", "Quibble", "Rumble",
		"Snickle", "Tango", "Umbra", "Velcro", "Widdle", "Yonder", "Zephyr",
		"Bamboozle", "Cranky", "Doodle", "Eerie", "Frisky", "Gizmo", "Hazy",
		"Icicle", "Jolly", "Karma", "Lullaby", "Mystic", "Nebula", "Opal",
		"Poppy", "Riddle", "Slinky", "Tickle", "Vortex", "Whimsy", "Xenon",
		"Yummy", "Zodiac", "Astral", "Blizzard", "Cobalt", "Drifter", "Ember",
		"Flux", "Glacier", "Harpy", "Inferno", "Jester", "Katana", "Labyrinth",
		"Mirage", "Nomad", "Oracle", "Phantom", "Quill", "Rogue", "Specter",
		"Tempest", "Uproar", "Vagabond", "Wraith", "Xylophone", "Yoshi", "Zenith",
		"Arpeggio", "Basilisk", "Catalyst", "Dynamo", "Equinox", "Fortune",
		"Griffin", "Horizon", "Illusion", "Jubilee", "Kismet", "Labyrinthine",
		"Monsoon", "Nightfall", "Obsidian", "Paradox", "Quantum", "Requiem",
		"Serenade", "Trilogy", "Unicorn", "Vortexial", "Wanderer", "Xenith",
		"Yield", "Zeppelin", "Avalanche", "Banshee", "Comet", "Delta", "Eclipse",
		"Fable", "Golem", "Helix", "Isotope", "Jargon", "Kodiak", "Lynx",
		"Maelstrom", "Nimbus", "Oasis", "Pulse", "Quasar", "Rift", "Savage",
		"Tempestuous", "Undertow", "Vertex", "Wavelength", "Xanadu", "Yukon",
		"Zephyrine", "Apex", "Bravado", "Crescent", "Drizzle", "Emissary",
		"Frenzy", "Gargoyle", "Harbinger", "Incognito", "Jubilation", "Kaleidoscope",
		"Labour", "Mandala", "Nirvana", "Odyssey", "Palindrome", "Quintessence",
		"Renaissance", "Symphony", "Tapestry", "Utopia", "Virtuoso", "Whirlpool",
		"Xeme", "Yonderly", "Zenobia"
	}
	local suffix = isTesting and "Testing" or "Admin"
	local name = baseNames[math.random(#baseNames)]
	return name.." "..suffix
end

function maybeMock(text)
	return isAprilFools() and MockText(text) or text
end

NAStuff.AprilFoolsData = NAStuff.AprilFoolsData or {}
NAStuff.AprilFoolsData.started = NAStuff.AprilFoolsData.started or false
NAStuff.AprilFoolsData.prankNotifs = NAStuff.AprilFoolsData.prankNotifs or {
	"Breaking news: "..adminName.." now ships with free banana peel DLC",
	"New feature unlocked: invisible UI. Close your eyes to see it",
	"Reminder: every bug today is a surprise feature",
	"Limited time event: type ;help for a coupon that does nothing",
	"Security alert: unauthorized laughter detected",
	"Patch notes: seriousness reduced by 200%",
}
NAStuff.AprilFoolsData.placeholderJokes = NAStuff.AprilFoolsData.placeholderJokes or {
	"Enter a totally real command (promise)",
	"Try ;clown ? We dare you",
	"Command bar is in prank mode, proceed with giggles",
	"Your keyboard is now a whoopee cushion",
	"This placeholder is legally binding. (Not really)",
	"Now with 300% more clown energy",
}
NAStuff.AprilFoolsData.originalColor = NAStuff.AprilFoolsData.originalColor or NAUISTROKER
NAStuff.AprilFoolsData.reverted = NAStuff.AprilFoolsData.reverted or false

MockText = function(text)
	local result = {}
	local toggle = true
	for i = 1, #text do
		local char = text:sub(i, i)
		if char:match("%a") then
			local transformed = toggle and char:upper() or char:lower()
			toggle = not toggle
			if math.random() < 0.25 then
				transformed = transformed:upper()
			elseif math.random() < 0.25 then
				transformed = transformed:lower()
			end
			Insert(result, transformed)
		else
			Insert(result, char)
		end
	end
	return Concat(result)
end

NAmanage.AprilPick = NAmanage.AprilPick or function(list)
	if type(list) ~= "table" or #list == 0 then
		return nil
	end
	return list[math.random(1, #list)]
end

NAmanage.nudgeAprilIcon = function()
	if not (isAprilFools() and TextButton) then return end
	local wobble = math.random(-15, 15)
	pcall(function()
		TweenService:Create(TextButton, TweenInfo.new(0.35, Enum.EasingStyle.Elastic, Enum.EasingDirection.Out), { Rotation = wobble }):Play()
		Delay(0.35, function()
			TweenService:Create(TextButton, TweenInfo.new(0.25, Enum.EasingStyle.Elastic, Enum.EasingDirection.Out), { Rotation = 0 }):Play()
		end)
	end)
end

NAmanage.startAprilPranks = function()
	if not isAprilFools() then return end
	local aprilData = NAStuff.AprilFoolsData or {}
	if aprilData.started then return end
	aprilData.started = true
	aprilData.reverted = false
	aprilData.originalColor = aprilData.originalColor or NAUISTROKER
	NAStuff.AprilFoolsData = aprilData

	local function refreshPlaceholder()
		local box = NAUIMANAGER and NAUIMANAGER.cmdInput
		if not box or not box.Parent then return end
		if box:IsA("TextBox") and box:IsFocused() and box.Text ~= "" then
			return
		end
		local phrase = NAmanage.AprilPick(aprilData.placeholderJokes)
		if phrase then
			box.PlaceholderText = maybeMock(phrase)
		end
	end

	if TextButton then
		MouseButtonFix(TextButton, function()
			if not isAprilFools() then return end
			NAmanage.nudgeAprilIcon()
		end)
	end

	local function aprilWiggleCmdBar()
		local box = NAUIMANAGER and NAUIMANAGER.cmdInput
		if not box or not box.Parent then return end
		local target = box.Parent
		local basePos = target.Position
		local baseRot = target.Rotation or 0
		local offsetX = math.random(-8, 8)
		local offsetY = math.random(-4, 4)
		local rot = math.random(-6, 6)
		local wiggleTween = TweenService:Create(target, TweenInfo.new(0.35, Enum.EasingStyle.Elastic, Enum.EasingDirection.Out), {
			Position = basePos + UDim2.new(0, offsetX, 0, offsetY);
			Rotation = baseRot + rot;
		})
		wiggleTween:Play()
		Delay(0.4, function()
			TweenService:Create(target, TweenInfo.new(0.25, Enum.EasingStyle.Elastic, Enum.EasingDirection.Out), {
				Position = basePos;
				Rotation = baseRot;
			}):Play()
		end)
	end

	NAmanage.ApplyAprilColor = NAmanage.ApplyAprilColor or function(color)
		if typeof(color) ~= "Color3" then return end
		NAUISTROKER = color
		for _, stroke in ipairs(NACOLOREDELEMENTS or {}) do
			if stroke and stroke.Color then
				stroke.Color = color
			end
		end
	end

	NAmanage.AprilRestoreColor = NAmanage.AprilRestoreColor or function()
		local aprilData = NAStuff.AprilFoolsData
		local base = aprilData and aprilData.originalColor or NAUISTROKER
		if typeof(base) == "Color3" then
			NAmanage.ApplyAprilColor(base)
		end
	end

	local function aprilColorPulse()
		local hue = math.random()
		local color = Color3.fromHSV(hue, 0.9, 1)
		NAmanage.ApplyAprilColor(color)
	end

	SpawnCall(function()
		while isAprilFools() do
			Wait(math.random(14, 30))
			local msg = NAmanage.AprilPick(aprilData.prankNotifs)
			if msg and type(DoNotif) == "function" then
				DoNotif(maybeMock(msg), 4)
			end
			NAmanage.nudgeAprilIcon()
		end
	end)

	SpawnCall(function()
		while isAprilFools() do
			refreshPlaceholder()
			Wait(math.random(10, 18))
		end
	end)

	SpawnCall(function()
		while isAprilFools() do
			aprilColorPulse()
			Wait(math.random(6, 12))
		end
	end)

	SpawnCall(function()
		while isAprilFools() do
			aprilWiggleCmdBar()
			Wait(math.random(9, 16))
		end
	end)

	SpawnCall(function()
		while isAprilFools() do
			Wait(3)
		end
		if not aprilData.reverted then
			aprilData.reverted = true
			if NAmanage.AprilRestoreColor then
				NAmanage.AprilRestoreColor()
			end
		end
	end)
end

if getgenv().NATestingVer then
	if isAprilFools() then
		testingName = yayApril(true)
		testingName = maybeMock(testingName)
	end
	adminName = testingName
else
	if isAprilFools() then
		mainName = yayApril(false)
		mainName = maybeMock(mainName)
	end
	adminName = mainName
end

NAgui.dragger = function(ui, dragui)
	dragui = dragui or ui
	local dragging = false
	local dragInput
	local dragStart
	local startPos

	local function update(input)
		local success, err = NACaller(function()
			local delta = input.Position - dragStart
			local screenSize = ui.Parent.AbsoluteSize
			local newXScale = startPos.X.Scale + (startPos.X.Offset + delta.X) / screenSize.X
			local newYScale = startPos.Y.Scale + (startPos.Y.Offset + delta.Y) / screenSize.Y
			ui.Position = UDim2.new(newXScale, 0, newYScale, 0)
		end)
	end

	NACaller(function()
		dragui.InputBegan:Connect(function(input)
			local success, err = NACaller(function()
				if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
					dragging = true
					dragStart = input.Position
					startPos = ui.Position

					NACaller(function()
						input.Changed:Connect(function()
							local ok, innerErr = NACaller(function()
								if input.UserInputState == Enum.UserInputState.End then
									dragging = false
								end
							end)
						end)
					end)
				end
			end)
		end)
	end)

	NACaller(function()
		dragui.InputChanged:Connect(function(input)
			local success, err = NACaller(function()
				if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
					dragInput = input
				end
			end)
		end)
	end)

	NACaller(function()
		UserInputService.InputChanged:Connect(function(input)
			local success, err = NACaller(function()
				if input == dragInput and dragging then
					update(input)
				end
			end)
		end)
	end)

	pcall(function() ui.Active=true end)
	pcall(function() dragui.Active=true end)
end

NAgui.draggerV2 = function(ui, dragui)
	dragui = dragui or ui
	local connName = "DraggerV2_"..ui:GetDebugId()
	NAlib.disconnect(connName)
	local screenGui = ui:FindFirstAncestorWhichIsA("ScreenGui") or ui.Parent
	local dragging, dragInput, dragStart, startPos
	local anchor = ui.AnchorPoint

	local function safeClamp(v, lo, hi)
		if hi < lo then hi = lo end
		return math.clamp(v, lo, hi)
	end

	local function update(input)
		local ok, err = NACaller(function()
			local p = screenGui.AbsoluteSize
			local s = ui.AbsoluteSize
			if p.X <= 0 or p.Y <= 0 then return end
			local startX = startPos.X.Scale * p.X + startPos.X.Offset
			local startY = startPos.Y.Scale * p.Y + startPos.Y.Offset
			local dx = input.Position.X - dragStart.X
			local dy = input.Position.Y - dragStart.Y
			local minX = anchor.X * s.X
			local maxX = p.X - (1 - anchor.X) * s.X
			local minY = anchor.Y * s.Y
			local maxY = p.Y - (1 - anchor.Y) * s.Y
			local nx = safeClamp(startX + dx, minX, maxX)
			local ny = safeClamp(startY + dy, minY, maxY)
			ui.Position = UDim2.new(nx / p.X, 0, ny / p.Y, 0)
		end)
	end

	NAlib.connect(connName, dragui.InputBegan:Connect(function(input)
		local ok, err = NACaller(function()
			if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
				dragging = true
				dragStart = input.Position
				startPos = ui.Position
				local c = input.Changed:Connect(function()
					local ok2, err2 = NACaller(function()
						if input.UserInputState == Enum.UserInputState.End then dragging = false end
					end)
				end)
				NAlib.connect(connName, c)
			end
		end)
	end))

	NAlib.connect(connName, dragui.InputChanged:Connect(function(input)
		local ok, err = NACaller(function()
			if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
				dragInput = input
			end
		end)
	end))

	NAlib.connect(connName, UserInputService.InputChanged:Connect(function(input)
		local ok, err = NACaller(function()
			if input == dragInput and dragging then update(input) end
		end)
	end))

	local function clampToViewport()
		local ok, err = NACaller(function()
			local p = screenGui.AbsoluteSize
			local s = ui.AbsoluteSize
			if p.X <= 0 or p.Y <= 0 then return end
			local curr = ui.Position
			local absX = curr.X.Scale * p.X + curr.X.Offset
			local absY = curr.Y.Scale * p.Y + curr.Y.Offset
			local minX = anchor.X * s.X
			local maxX = p.X - (1 - anchor.X) * s.X
			local minY = anchor.Y * s.Y
			local maxY = p.Y - (1 - anchor.Y) * s.Y
			local nx = safeClamp(absX, minX, maxX)
			local ny = safeClamp(absY, minY, maxY)
			ui.Position = UDim2.new(nx / p.X, 0, ny / p.Y, 0)
		end)
		if not ok then warn("[DraggerV2] Clamp update error:", err) end
	end

	NAlib.connect(connName, screenGui:GetPropertyChangedSignal("AbsoluteSize"):Connect(clampToViewport))
	if ui and ui.GetPropertyChangedSignal then
		NAlib.connect(connName, ui:GetPropertyChangedSignal("AbsoluteSize"):Connect(clampToViewport))
	end
	clampToViewport()

	if ui and NAlib.isProperty(ui, "Active") then
		NAlib.setProperty(ui, "Active", true)
	end
	if dragui and NAlib.isProperty(dragui, "Active") then
		NAlib.setProperty(dragui, "Active", true)
	end
	pcall(function() ui.Active=true end)
	pcall(function() dragui.Active=true end)
end

NAmanage.createLoadingUI=function(text, opts)
	opts = opts or {}
	local startMinimized = opts.startMinimized
	if startMinimized == nil then
		startMinimized = opts.minimized
	end
	if startMinimized == nil then
		startMinimized = NALoadingStartMinimized == true
	else
		startMinimized = startMinimized and true or false
	end

	local ui = {}
	local flags = {
		minimized = startMinimized,
		autoSkip = false,
	}

	local wScale = tonumber(opts.widthScale) or 0.34
	local blacklist = opts.blacklist or { [8523781134] = true, [2521585756] = true, [3350084310] = true }
	local lp = Players and Players.LocalPlayer

	if lp and blacklist[lp.UserId] then
		return "womp womp"
	end

	ui.sg = InstanceNew("ScreenGui")
	ui.sg.IgnoreGuiInset = true
	ui.sg.ResetOnSpawn = false
	ui.sg.DisplayOrder = 999999
	ui.sg.ZIndexBehavior = Enum.ZIndexBehavior.Global
	local okProtect = pcall(function() NaProtectUI(ui.sg) end)
	if not okProtect then
		ui.sg.Parent = COREGUI
	end

	ui.overlay = InstanceNew("Frame", ui.sg)
	ui.overlay.Active = false
	ui.overlay.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
	ui.overlay.BackgroundTransparency = 1
	ui.overlay.ZIndex = -1
	ui.overlay.Size = UDim2.fromScale(1, 1)
	local ovGrad = InstanceNew("UIGradient", ui.overlay)
	ovGrad.Color = ColorSequence.new(Color3.fromRGB(0, 0, 0), Color3.fromRGB(18, 18, 18))

	ui.container = InstanceNew("Frame", ui.sg)
	ui.container.ZIndex = 6
	ui.container.AnchorPoint = Vector2.new(0.5, 0.5)
	ui.container.Position = UDim2.fromScale(0.5, 0.55)
	ui.container.Size = UDim2.fromScale(wScale, 0)
	ui.container.AutomaticSize = Enum.AutomaticSize.Y
	ui.container.BackgroundColor3 = Color3.fromRGB(6, 6, 6)
	ui.container.BorderSizePixel = 0
	ui.container.BackgroundTransparency = 1

	local cCorner = InstanceNew("UICorner", ui.container)
	cCorner.CornerRadius = UDim.new(0, 14)

	local cStroke = InstanceNew("UIStroke", ui.container)
	cStroke.Thickness = 1
	cStroke.Color = Color3.fromRGB(255, 255, 255)
	cStroke.Transparency = 0.85

	local cPad = InstanceNew("UIPadding", ui.container)
	cPad.PaddingTop = UDim.new(0, 16)
	cPad.PaddingBottom = UDim.new(0, 18)
	cPad.PaddingLeft = UDim.new(0, 18)
	cPad.PaddingRight = UDim.new(0, 18)

	local cLayout = InstanceNew("UIListLayout", ui.container)
	cLayout.FillDirection = Enum.FillDirection.Vertical
	cLayout.HorizontalAlignment = Enum.HorizontalAlignment.Left
	cLayout.VerticalAlignment = Enum.VerticalAlignment.Top
	cLayout.Padding = UDim.new(0, 10)
	cLayout.SortOrder = Enum.SortOrder.LayoutOrder

	local accent = InstanceNew("Frame", ui.container)
	accent.LayoutOrder = 0
	accent.Size = UDim2.new(1, 0, 0, 2)
	accent.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
	accent.BorderSizePixel = 0
	local aGrad = InstanceNew("UIGradient", accent)
	aGrad.Color = ColorSequence.new(
		Color3.fromRGB(0, 0, 0),
		Color3.fromRGB(255, 255, 255),
		Color3.fromRGB(0, 0, 0)
	)

	ui.header = InstanceNew("Frame", ui.container)
	ui.header.ZIndex = 7
	ui.header.BackgroundTransparency = 1
	ui.header.Size = UDim2.new(1, 0, 0, 30)
	ui.header.LayoutOrder = 1

	local hLayout = InstanceNew("UIListLayout", ui.header)
	hLayout.FillDirection = Enum.FillDirection.Horizontal
	hLayout.HorizontalAlignment = Enum.HorizontalAlignment.Left
	hLayout.VerticalAlignment = Enum.VerticalAlignment.Center
	hLayout.Padding = UDim.new(0, 8)

	local titleHolder = InstanceNew("Frame", ui.header)
	titleHolder.BackgroundTransparency = 1
	titleHolder.Size = UDim2.new(1, -60, 1, 0)

	ui.titleLabel = InstanceNew("TextLabel", titleHolder)
	ui.titleLabel.ZIndex = 8
	ui.titleLabel.BackgroundTransparency = 1
	ui.titleLabel.Position = UDim2.new(0, 0, 0, 0)
	ui.titleLabel.Size = UDim2.new(1, 0, 1, 0)
	ui.titleLabel.TextXAlignment = Enum.TextXAlignment.Left
	ui.titleLabel.TextYAlignment = Enum.TextYAlignment.Center
	ui.titleLabel.Font = Enum.Font.GothamSemibold
	ui.titleLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
	ui.titleLabel.TextWrapped = true
	ui.titleLabel.TextScaled = true
	ui.titleLabel.Text = text

	ui.minimizeButton = InstanceNew("TextButton", ui.header)
	ui.minimizeButton.AutoButtonColor = false
	ui.minimizeButton.Size = UDim2.new(0, IsOnMobile and 32 or 28, 0, IsOnMobile and 28 or 24)
	ui.minimizeButton.Text = "-"
	ui.minimizeButton.Font = Enum.Font.GothamBold
	ui.minimizeButton.TextScaled = true
	ui.minimizeButton.TextColor3 = Color3.fromRGB(255, 255, 255)
	ui.minimizeButton.BackgroundColor3 = Color3.fromRGB(12, 12, 12)
	ui.minimizeButton.ZIndex = 13
	local mCorner = InstanceNew("UICorner", ui.minimizeButton)
	mCorner.CornerRadius = UDim.new(0, 8)
	local mStroke = InstanceNew("UIStroke", ui.minimizeButton)
	mStroke.Thickness = 1
	mStroke.Color = Color3.fromRGB(255, 255, 255)
	mStroke.Transparency = 0.7

	local midFrame = InstanceNew("Frame", ui.container)
	midFrame.BackgroundTransparency = 1
	midFrame.LayoutOrder = 2
	midFrame.Size = UDim2.new(1, 0, 0, 60)
	local midLayout = InstanceNew("UIListLayout", midFrame)
	midLayout.FillDirection = Enum.FillDirection.Vertical
	midLayout.HorizontalAlignment = Enum.HorizontalAlignment.Left
	midLayout.VerticalAlignment = Enum.VerticalAlignment.Top
	midLayout.Padding = UDim.new(0, 4)

	ui.bigPercent = InstanceNew("TextLabel", midFrame)
	ui.bigPercent.ZIndex = 8
	ui.bigPercent.BackgroundTransparency = 1
	ui.bigPercent.Size = UDim2.new(1, 0, 0, 34)
	ui.bigPercent.Font = Enum.Font.GothamBlack
	ui.bigPercent.TextColor3 = Color3.fromRGB(255, 255, 255)
	ui.bigPercent.TextScaled = true
	ui.bigPercent.TextXAlignment = Enum.TextXAlignment.Left
	ui.bigPercent.Text = "0%"

	ui.statusLabel = InstanceNew("TextLabel", midFrame)
	ui.statusLabel.ZIndex = 8
	ui.statusLabel.BackgroundTransparency = 1
	ui.statusLabel.Size = UDim2.new(1, 0, 0, 20)
	ui.statusLabel.Font = Enum.Font.Gotham
	ui.statusLabel.TextColor3 = Color3.fromRGB(200, 200, 200)
	ui.statusLabel.TextScaled = true
	ui.statusLabel.TextXAlignment = Enum.TextXAlignment.Left
	ui.statusLabel.Text = "loading"

	ui.progressHolder = InstanceNew("Frame", ui.container)
	ui.progressHolder.BackgroundColor3 = Color3.fromRGB(18, 18, 18)
	ui.progressHolder.BorderSizePixel = 0
	ui.progressHolder.LayoutOrder = 3
	ui.progressHolder.Size = UDim2.new(1, 0, 0, 8)
	ui.progressHolder.ZIndex = 11
	local phCorner = InstanceNew("UICorner", ui.progressHolder)
	phCorner.CornerRadius = UDim.new(0, 6)

	ui.progressFill = InstanceNew("Frame", ui.progressHolder)
	ui.progressFill.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
	ui.progressFill.BorderSizePixel = 0
	ui.progressFill.Size = UDim2.new(0, 0, 1, 0)
	ui.progressFill.ZIndex = 12
	local pfCorner = InstanceNew("UICorner", ui.progressFill)
	pfCorner.CornerRadius = UDim.new(0, 6)
	local pfGrad = InstanceNew("UIGradient", ui.progressFill)
	pfGrad.Color = ColorSequence.new(
		Color3.fromRGB(210, 210, 210),
		Color3.fromRGB(255, 255, 255)
	)

	local barRow = InstanceNew("Frame", ui.container)
	barRow.BackgroundTransparency = 1
	barRow.LayoutOrder = 4
	barRow.Size = UDim2.new(1, 0, 0, 18)
	local brLayout = InstanceNew("UIListLayout", barRow)
	brLayout.FillDirection = Enum.FillDirection.Horizontal
	brLayout.HorizontalAlignment = Enum.HorizontalAlignment.Left
	brLayout.VerticalAlignment = Enum.VerticalAlignment.Center

	local spacer = InstanceNew("Frame", barRow)
	spacer.BackgroundTransparency = 1
	spacer.Size = UDim2.new(0.7, 0, 1, 0)

	ui.percentLabel = InstanceNew("TextLabel", barRow)
	ui.percentLabel.ZIndex = 8
	ui.percentLabel.BackgroundTransparency = 1
	ui.percentLabel.Size = UDim2.new(0.3, 0, 1, 0)
	ui.percentLabel.TextXAlignment = Enum.TextXAlignment.Right
	ui.percentLabel.Font = Enum.Font.GothamSemibold
	ui.percentLabel.TextColor3 = Color3.fromRGB(230, 230, 230)
	ui.percentLabel.TextScaled = true
	ui.percentLabel.Text = "0%"

	ui.buttonRow = InstanceNew("Frame", ui.container)
	ui.buttonRow.ZIndex = 8
	ui.buttonRow.BackgroundTransparency = 1
	ui.buttonRow.LayoutOrder = 5
	ui.buttonRow.Size = UDim2.new(1, 0, 0, 30)
	local btnLayout = InstanceNew("UIListLayout", ui.buttonRow)
	btnLayout.FillDirection = Enum.FillDirection.Horizontal
	btnLayout.HorizontalAlignment = Enum.HorizontalAlignment.Left
	btnLayout.VerticalAlignment = Enum.VerticalAlignment.Center
	btnLayout.Padding = UDim.new(0, 8)

	ui.skipButton = InstanceNew("TextButton", ui.buttonRow)
	ui.skipButton.ZIndex = 9
	ui.skipButton.Size = UDim2.new(0.45, 0, 1, 0)
	ui.skipButton.Font = Enum.Font.GothamSemibold
	ui.skipButton.TextScaled = true
	ui.skipButton.TextColor3 = Color3.fromRGB(0, 0, 0)
	ui.skipButton.Text = "Skip"
	ui.skipButton.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
	ui.skipButton.AutoButtonColor = false
	local sCorner = InstanceNew("UICorner", ui.skipButton)
	sCorner.CornerRadius = UDim.new(0, 8)
	local sStroke = InstanceNew("UIStroke", ui.skipButton)
	sStroke.Color = Color3.fromRGB(255, 255, 255)
	sStroke.Transparency = 0.2
	sStroke.Thickness = 1

	ui.autoSkipButton = InstanceNew("TextButton", ui.buttonRow)
	ui.autoSkipButton.ZIndex = 9
	ui.autoSkipButton.Size = UDim2.new(0.55, 0, 1, 0)
	ui.autoSkipButton.Font = Enum.Font.Gotham
	ui.autoSkipButton.TextScaled = true
	ui.autoSkipButton.AutoButtonColor = false
	ui.autoSkipButton.BackgroundColor3 = Color3.fromRGB(16, 16, 16)
	ui.autoSkipButton.TextColor3 = Color3.fromRGB(220, 220, 220)
	local aCorner = InstanceNew("UICorner", ui.autoSkipButton)
	aCorner.CornerRadius = UDim.new(0, 8)
	local aStroke = InstanceNew("UIStroke", ui.autoSkipButton)
	aStroke.Color = Color3.fromRGB(255, 255, 255)
	aStroke.Transparency = 0.8
	aStroke.Thickness = 1

	ui.toast = InstanceNew("Frame", ui.sg)
	ui.toast.AnchorPoint = Vector2.new(0.5, 0)
	ui.toast.Position = UDim2.new(0.5, 0, 0, 8)
	ui.toast.BackgroundColor3 = Color3.fromRGB(6, 6, 6)
	ui.toast.BorderSizePixel = 0
	ui.toast.ZIndex = 50
	ui.toast.Visible = false
	ui.toast.AutomaticSize = Enum.AutomaticSize.XY
	ui.toast.BackgroundTransparency = 1
	local tCorner = InstanceNew("UICorner", ui.toast)
	tCorner.CornerRadius = UDim.new(1, 0)
	local tStroke = InstanceNew("UIStroke", ui.toast)
	tStroke.Color = Color3.fromRGB(255, 255, 255)
	tStroke.Transparency = 0.85
	tStroke.Thickness = 1
	local tPad = InstanceNew("UIPadding", ui.toast)
	tPad.PaddingLeft = UDim.new(0, 12)
	tPad.PaddingRight = UDim.new(0, 12)
	tPad.PaddingTop = UDim.new(0, 8)
	tPad.PaddingBottom = UDim.new(0, 8)
	local tLayout = InstanceNew("UIListLayout", ui.toast)
	tLayout.FillDirection = Enum.FillDirection.Vertical
	tLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
	tLayout.VerticalAlignment = Enum.VerticalAlignment.Center
	tLayout.Padding = UDim.new(0, 4)

	ui.toastRow = InstanceNew("Frame", ui.toast)
	ui.toastRow.BackgroundTransparency = 1
	ui.toastRow.Size = UDim2.fromScale(1, 0)
	ui.toastRow.AutomaticSize = Enum.AutomaticSize.XY
	ui.toastRow.ZIndex = 51
	local trLayout = InstanceNew("UIListLayout", ui.toastRow)
	trLayout.FillDirection = Enum.FillDirection.Horizontal
	trLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
	trLayout.VerticalAlignment = Enum.VerticalAlignment.Center
	trLayout.Padding = UDim.new(0, 8)

	ui.toastLabel = InstanceNew("TextLabel", ui.toastRow)
	ui.toastLabel.BackgroundTransparency = 1
	ui.toastLabel.Font = Enum.Font.Gotham
	ui.toastLabel.TextScaled = true
	ui.toastLabel.TextColor3 = Color3.fromRGB(240, 240, 240)
	ui.toastLabel.Text = text
	ui.toastLabel.ZIndex = 52
	ui.toastLabel.Size = UDim2.fromOffset(180, 22)

	ui.toastPercent = InstanceNew("TextLabel", ui.toastRow)
	ui.toastPercent.BackgroundTransparency = 1
	ui.toastPercent.Font = Enum.Font.Gotham
	ui.toastPercent.TextScaled = true
	ui.toastPercent.TextColor3 = Color3.fromRGB(230, 230, 230)
	ui.toastPercent.Text = "0%"
	ui.toastPercent.ZIndex = 52
	ui.toastPercent.Size = UDim2.fromOffset(44, 22)

	ui.toastOpen = InstanceNew("TextButton", ui.toastRow)
	ui.toastOpen.Size = UDim2.fromOffset(72, 22)
	ui.toastOpen.Text = "Open"
	ui.toastOpen.TextScaled = true
	ui.toastOpen.Font = Enum.Font.GothamSemibold
	ui.toastOpen.TextColor3 = Color3.fromRGB(0, 0, 0)
	ui.toastOpen.ZIndex = 52
	ui.toastOpen.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
	ui.toastOpen.AutoButtonColor = false
	local toCorner = InstanceNew("UICorner", ui.toastOpen)
	toCorner.CornerRadius = UDim.new(0, 8)
	local toStroke = InstanceNew("UIStroke", ui.toastOpen)
	toStroke.Thickness = 1
	toStroke.Color = Color3.fromRGB(255, 255, 255)
	toStroke.Transparency = 0.2

	ui.toastSkip = InstanceNew("TextButton", ui.toastRow)
	ui.toastSkip.Size = UDim2.fromOffset(72, 22)
	ui.toastSkip.Text = "Skip"
	ui.toastSkip.TextScaled = true
	ui.toastSkip.Font = Enum.Font.GothamSemibold
	ui.toastSkip.TextColor3 = Color3.fromRGB(255, 255, 255)
	ui.toastSkip.ZIndex = 52
	ui.toastSkip.BackgroundColor3 = Color3.fromRGB(16, 16, 16)
	ui.toastSkip.AutoButtonColor = false
	local tsCorner = InstanceNew("UICorner", ui.toastSkip)
	tsCorner.CornerRadius = UDim.new(0, 8)
	local tsStroke = InstanceNew("UIStroke", ui.toastSkip)
	tsStroke.Thickness = 1
	tsStroke.Color = Color3.fromRGB(255, 255, 255)
	tsStroke.Transparency = 0.4

	ui.toastProgress = InstanceNew("Frame", ui.toast)
	ui.toastProgress.BackgroundTransparency = 1
	ui.toastProgress.Size = UDim2.new(1, 0, 0, 3)
	ui.toastProgress.ZIndex = 49
	ui.toastProgress.LayoutOrder = 2
	local tpBack = InstanceNew("Frame", ui.toastProgress)
	tpBack.BackgroundColor3 = Color3.fromRGB(24, 24, 24)
	tpBack.BorderSizePixel = 0
	tpBack.ZIndex = 49
	tpBack.Size = UDim2.new(1, 0, 1, 0)
	local tpCorner = InstanceNew("UICorner", tpBack)
	tpCorner.CornerRadius = UDim.new(1, 0)
	ui.toastFill = InstanceNew("Frame", tpBack)
	ui.toastFill.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
	ui.toastFill.BorderSizePixel = 0
	ui.toastFill.Size = UDim2.new(0, 0, 1, 0)
	ui.toastFill.ZIndex = 50
	local tfCorner = InstanceNew("UICorner", ui.toastFill)
	tfCorner.CornerRadius = UDim.new(1, 0)
	local tfGrad = InstanceNew("UIGradient", ui.toastFill)
	tfGrad.Color = ColorSequence.new(
		Color3.fromRGB(210, 210, 210),
		Color3.fromRGB(255, 255, 255)
	)

	ui.skipFlag = InstanceNew("BoolValue", ui.sg)
	ui.skipFlag.Name = "SkipAssets"
	ui.skipFlag.Value = false

	ui.completedFlag = InstanceNew("BoolValue", ui.sg)
	ui.completedFlag.Name = "Completed"
	ui.completedFlag.Value = false

	local function tween(tg, info, goal)
		local tw = TweenService:Create(tg, info, goal)
		tw:Play()
		return tw
	end

	local function applyMinimized()
		if flags.minimized then
			ui.container.Visible = false
			ui.toast.Visible = true
			ui.overlay.Visible = false
		else
			ui.container.Visible = true
			ui.toast.Visible = false
			ui.overlay.Visible = true
		end
	end

	local function setMinimizedState(state)
		flags.minimized = state and true or false
		applyMinimized()
		if flags.minimized then
			ui.overlay.BackgroundTransparency = 1
			if ui.toast.Visible then
				ui.toast.BackgroundTransparency = 1
				tween(ui.toast, TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {BackgroundTransparency = 0})
			end
		else
			ui.overlay.BackgroundTransparency = 1
			ui.container.BackgroundTransparency = 1
			ui.container.Position = UDim2.fromScale(0.5, 0.6)
			tween(ui.overlay, TweenInfo.new(0.25, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {BackgroundTransparency = 0.25})
			tween(ui.container, TweenInfo.new(0.25, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
				BackgroundTransparency = 0,
				Position = UDim2.fromScale(0.5, 0.55)
			})
		end
	end

	local function doSkip()
		if ui.skipFlag.Value then
			return
		end
		ui.skipFlag.Value = true
		ui.skipButton.Text = "Skipping..."
		ui.toastSkip.Text = "Skipping..."
	end

	local function updateAutoSkipButton()
		if flags.autoSkip then
			ui.autoSkipButton.Text = "Auto Skip: ON"
			ui.autoSkipButton.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
			ui.autoSkipButton.TextColor3 = Color3.fromRGB(0, 0, 0)
		else
			ui.autoSkipButton.Text = "Auto Skip: OFF"
			ui.autoSkipButton.BackgroundColor3 = Color3.fromRGB(16, 16, 16)
			ui.autoSkipButton.TextColor3 = Color3.fromRGB(220, 220, 220)
		end
	end

	local function setStatus(st)
		local v = st or ""
		ui.statusLabel.Text = v
	end

	local function normalizePercent(pct)
		local p = tonumber(pct) or 0
		if p > 1 then
			if p <= 10 then
				p = p / 10
			elseif p <= 100 then
				p = p / 100
			else
				p = p / 100
			end
		end
		return math.clamp(p, 0, 1)
	end

	local function setPercent(pct)
		local p = normalizePercent(pct)
		local txt = tostring(math.floor(p * 100)).."%"
		tween(ui.progressFill, TweenInfo.new(0.18, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
			Size = UDim2.new(p, 0, 1, 0)
		})
		tween(ui.toastFill, TweenInfo.new(0.18, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
			Size = UDim2.new(p, 0, 1, 0)
		})
		ui.percentLabel.Text = txt
		ui.bigPercent.Text = txt
		ui.toastPercent.Text = txt
	end

	flags.autoSkip = NAmanage.getAutoSkipPreference()
	updateAutoSkipButton()

	ui.minimizeButton.Activated:Connect(function()
		setMinimizedState(true)
	end)

	ui.toastOpen.Activated:Connect(function()
		setMinimizedState(false)
	end)

	ui.skipButton.Activated:Connect(doSkip)
	ui.toastSkip.Activated:Connect(doSkip)

	ui.autoSkipButton.Activated:Connect(function()
		flags.autoSkip = not flags.autoSkip
		NAmanage.setAutoSkipPreference(flags.autoSkip)
		updateAutoSkipButton()
		if flags.autoSkip then
			doSkip()
		end
	end)

	ui.completedFlag:GetPropertyChangedSignal("Value"):Connect(function()
		if ui.completedFlag.Value then
			tween(ui.overlay, TweenInfo.new(0.18, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {BackgroundTransparency = 1})
			tween(ui.container, TweenInfo.new(0.18, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {BackgroundTransparency = 1, Position = UDim2.fromScale(0.5, 0.5)})
			tween(ui.toast, TweenInfo.new(0.18, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {BackgroundTransparency = 1})
			Delay(0.2, function()
				if ui.sg.Parent then
					ui.sg:Destroy()
				end
			end)
		end
	end)

	if NAgui and NAgui.draggerV2 then
		pcall(function()
			NAgui.draggerV2(ui.container, ui.header)
		end)
	end

	applyMinimized()

	if not flags.minimized then
		ui.overlay.BackgroundTransparency = 1
		ui.container.BackgroundTransparency = 1
		ui.container.Position = UDim2.fromScale(0.5, 0.6)
		tween(ui.overlay, TweenInfo.new(0.25, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {BackgroundTransparency = 0.25})
		tween(ui.container, TweenInfo.new(0.25, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
			BackgroundTransparency = 0,
			Position = UDim2.fromScale(0.5, 0.55)
		})
	else
		ui.toast.BackgroundTransparency = 1
		if ui.toast.Visible then
			tween(ui.toast, TweenInfo.new(0.25, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {BackgroundTransparency = 0})
		end
	end

	local pulseConn
	if RunService then
		pulseConn = RunService.RenderStepped:Connect(function()
			if ui.container and ui.container.Parent then
				cStroke.Transparency = 0.8 + math.sin(tick() * 3) * 0.05
			else
				if pulseConn then
					pulseConn:Disconnect()
				end
			end
		end)
	end

	if flags.autoSkip then
		doSkip()
	end

	return ui.sg, setStatus, setPercent, ui.completedFlag, function()
		return ui.skipFlag.Value
	end, setMinimizedState
end

NAAssetsLoading = NAAssetsLoading or {}
NAAssetsLoading.remoteStatus = {}
NAAssetsLoading.knownRemotes = {
	{url="https://api.github.com/repos/ltseverydayyou/Nameless-Admin/commits?path=NA%20testing.lua"; skip=true};
	{url="https://api.github.com/repos/ltseverydayyou/Nameless-Admin/commits?path=Source.lua"; skip=true};
}

NAAssetsLoading.applyMinimizedPreference=function()
	if type(NAAssetsLoading.setMinimizedState) == "function" then
		pcall(NAAssetsLoading.setMinimizedState, NALoadingStartMinimized == true)
	end
end

NAAssetsLoading.getRemoteTargets=function()
	if NAAssetsLoading.remoteTargets then
		return NAAssetsLoading.remoteTargets
	end
	local targets, seen = {}, {}
	for _, entry in ipairs(NAAssetsLoading.knownRemotes) do
		local url = entry.url
		if type(url) == "string" and url ~= "" and not entry.skip then
			if not seen[url] then
				seen[url] = true
				targets[#targets+1] = url
			end
		end
	end
	NAAssetsLoading.remoteTargets = targets
	return targets
end

NAAssetsLoading.registerRemote=function(url, options)
	if type(url) ~= "string" or url == "" then
		return
	end
	NAAssetsLoading.knownRemotes[#NAAssetsLoading.knownRemotes+1] = {
		url = url;
		skip = options and options.skip or false;
	}
	NAAssetsLoading.remoteTargets = nil
end

NAAssetsLoading.prefetchRemotes=function(onStep, shouldSkip)
	local targets = NAAssetsLoading.getRemoteTargets()
	local total = #targets
	if total == 0 then
		if onStep then
			onStep(0, 0, nil, true)
		end
		return
	end
	for index = 1, total do
		if shouldSkip and shouldSkip() then
			return
		end
		local url = targets[index]
		local ok, body = NACaller(game.HttpGet, game, url)
		if ok and type(body) == "string" and body ~= "" then
			NAStuff._prefetchedRemotes[url] = body
			NAAssetsLoading.remoteStatus[url] = true
		else
			NAAssetsLoading.remoteStatus[url] = false
		end
		if onStep then
			onStep(index, total, url, ok)
		end
		Wait(0.06)
	end
end

NAAssetsLoading.normalizeStatusError = function(text)
	local err = tostring(text or "unknown error")
	err = err:gsub("%s+", " ")
	err = err:gsub("[%c]", " ")
	if #err > 180 then
		err = err:sub(1, 177).."..."
	end
	return err
end

NAAssetsLoading.runLoadingCheck = function(statusLabel, attemptFn, onSuccess, opts)
	local attempt = 0
	local maxAttempts = math.huge
	if type(opts) == "table" and type(opts.maxAttempts) == "number" and opts.maxAttempts >= 1 then
		maxAttempts = math.floor(opts.maxAttempts)
	end
	while true do
		if NAAssetsLoading.getSkip and NAAssetsLoading.getSkip() then
			return nil
		end
		attempt += 1
		local attemptLabel = attempt == 1 and statusLabel or Format("%s (retry %d)", statusLabel, attempt)
		if NAAssetsLoading.setStatus then
			NAAssetsLoading.setStatus(attemptLabel)
		end
		local success, result, errMsg = attemptFn()
		if success then
			if onSuccess then
				pcall(onSuccess, result)
			end
			return result
		end
		if NAAssetsLoading.setStatus then
			local errText = NAAssetsLoading.normalizeStatusError(errMsg or result) or tostring(errMsg or result)
			NAAssetsLoading.setStatus(Format("%s error #%d: %s", statusLabel, attempt, errText))
		end
		if maxAttempts ~= math.huge and attempt >= maxAttempts then
			if NAAssetsLoading.setStatus then
				NAAssetsLoading.setStatus(Format("%s skipped after %d attempts", statusLabel, attempt))
			end
			return nil
		end
		if NAAssetsLoading.getSkip and NAAssetsLoading.getSkip() then
			return nil
		end
		Wait(0.4)
	end
end

NAAssetsLoading.cachePrefetchedRemote = function(url, body)
	if type(url) == "string" and url ~= "" and type(body) == "string" and body ~= "" then
		NAStuff._prefetchedRemotes = NAStuff._prefetchedRemotes or {}
		NAStuff._prefetchedRemotes[url] = body
	end
end


NAmanage.getPrefetchedRemote=function(url)
	return (NAStuff._prefetchedRemotes and NAStuff._prefetchedRemotes[url]) or nil
end

NAmanage.registerRemoteForPreload=function(url, options)
	NAAssetsLoading.registerRemote(url, options)
end

if not NAAssetsLoading.setStatus then
	NAAssetsLoading.ui, NAAssetsLoading.setStatus, NAAssetsLoading.setPercent, NAAssetsLoading.completed, NAAssetsLoading.getSkip, NAAssetsLoading.setMinimizedState = NAmanage.createLoadingUI((adminName or "NA").." is loading...", {widthScale=0.30})
	NaProtectUI(NAAssetsLoading.ui)
	NAAssetsLoading.applyMinimizedPreference()
	local stageOrder = {
		"engine",
		"notifications",
		"assets",
		"nastuff",
		"loader",
		"changelog",
		"uiloader",
		"queue",
		"prefetch",
		"final",
	}
	local stageWeight = {
		engine = 1,
		notifications = 1,
		assets = 1,
		nastuff = 1,
		loader = 1,
		changelog = 1,
		uiloader = 1,
		queue = 0.5,
		prefetch = 4,
		final = 0.5,
	}
	local totalWeight = 0
	for _, key in ipairs(stageOrder) do
		totalWeight += stageWeight[key] or 1
	end
	NAAssetsLoading.progress = {
		order = stageOrder,
		weight = stageWeight,
		total = totalWeight,
	}
	NAAssetsLoading.progressPercent = function(stage, fraction)
		fraction = math.clamp(tonumber(fraction) or 1, 0, 1)
		local data = NAAssetsLoading.progress
		if not data then return end
		local acc = 0
		for _, key in ipairs(data.order) do
			if key == stage then
				acc += (data.weight[key] or 1) * fraction
				break
			end
			acc += (data.weight[key] or 1)
		end
		local pct = (data.total > 0) and (acc / data.total) or 0
		NAAssetsLoading.setPercent(pct)
	end
end

NAAssetsLoading.setStatus("waiting for engine")
if not game:IsLoaded() then game.Loaded:Wait() end
if NAAssetsLoading.progressPercent then NAAssetsLoading.progressPercent("engine") end

NAAssetsLoading.setStatus("loading notifications")
repeat
	NAAssetsLoading.ok, NAAssetsLoading.res = pcall(function()
		return loadstring(game:HttpGet("https://raw.githubusercontent.com/ltseverydayyou/Nameless-Admin/main/NamelessAdminNotifications.lua"))()
	end)
	if NAAssetsLoading.ok then
		Notification = NAAssetsLoading.res
	else
		Wait(0.25)
	end
until Notification or NAAssetsLoading.getSkip()
if not Notification then
	Notification = {Notify=function() end, Window=function() end, Popup=function() end}
end
NAmanage.Notification = Notification
if NAAssetsLoading.progressPercent then NAAssetsLoading.progressPercent("notifications") end

NAAssetsLoading.setStatus("Loading Assets")
local assetsReady = false
repeat
	local ok, res = pcall(function()
		if not FileSupport then
			return true
		end
		if type(NAImageAssets) ~= "table" then
			return true
		end
		if type(isfolder) == "function" and not isfolder(NAfiles.NAASSETSFILEPATH) then
			if type(makefolder) == "function" then
				makefolder(NAfiles.NAASSETSFILEPATH)
			end
		end
		if type(isfile) ~= "function" then
			return true
		end
		for _, fileName in pairs(NAImageAssets) do
			if type(fileName) == "string" and fileName ~= "" then
				local fullPath = NAfiles.NAASSETSFILEPATH.."/"..fileName
				if not isfile(fullPath) then
					local data = game:HttpGet("https://raw.githubusercontent.com/ltseverydayyou/Nameless-Admin/main/NAimages/"..fileName)
					if type(data) ~= "string" or data == "" then
						return false
					end
					if type(writefile) ~= "function" then
						return false
					end
					writefile(fullPath, data)
				end
			end
		end
		return true
	end)
	if ok and res then
		assetsReady = true
	else
		Wait(0.25)
	end
until assetsReady or NAAssetsLoading.getSkip()
if NAAssetsLoading.progressPercent then NAAssetsLoading.progressPercent("assets") end

NAAssetsLoading.setStatus("Loading "..(adminName or "NA").." Data")
local naStuffReady = false
repeat
	local ok, res = pcall(function()
		local raw = game:HttpGet("https://raw.githubusercontent.com/ltseverydayyou/uuuuuuu/refs/heads/main/NA%20stuff.json")
		local decoded = HttpService:JSONDecode(raw)
		return decoded
	end)
	if ok and type(res) == "table" then
		NAStuff.NAjson = res
		NAmanage.btUpdate()
		naStuffReady = true
	else
		Wait(0.25)
	end
until naStuffReady or NAAssetsLoading.getSkip()
if NAAssetsLoading.progressPercent then NAAssetsLoading.progressPercent("nastuff") end

NAAssetsLoading.runLoadingCheck("Setting Up Loader", function()
	if type(opt.loaderUrl) ~= "string" or opt.loaderUrl == "" then
		return false, nil, "missing loader url"
	end
	local ok, body = pcall(game.HttpGet, game, opt.loaderUrl)
	if not ok then
		return false, nil, body
	end
	if type(body) ~= "string" or body == "" then
		return false, nil, "empty response"
	end
	return true, body
end, function(body)
	NAAssetsLoading.cachePrefetchedRemote(opt.loaderUrl, body)
end)
if NAAssetsLoading.progressPercent then NAAssetsLoading.progressPercent("loader") end

NAAssetsLoading.runLoadingCheck("Loading Update Log", function()
	if type(opt.githubUrl) ~= "string" or opt.githubUrl == "" then
		return false, nil, "missing github url"
	end
	if type(opt.NAREQUEST) == "function" then
		local ok, response = pcall(opt.NAREQUEST, {
			Url = opt.githubUrl,
			Method = "GET"
		})
		if not ok then
			return false, nil, response
		end
		if typeof(response) ~= "table" then
			return false, nil, "invalid response"
		end
		local statusCode = tonumber(response.StatusCode)
		if statusCode ~= 200 then
			return false, nil, Format("http %s", tostring(statusCode or "nil"))
		end
		if type(response.Body) ~= "string" or response.Body == "" then
			return false, nil, "empty body"
		end
		return true, response.Body
	end
	local ok, body = pcall(game.HttpGet, game, opt.githubUrl)
	if not ok then
		return false, nil, body
	end
	if type(body) ~= "string" or body == "" then
		return false, nil, "empty response"
	end
	return true, body
end, function(body)
	NAStuff._githubMetadata = body
	local decodeOk, decoded = pcall(HttpService.JSONDecode, HttpService, body)
	if decodeOk and type(decoded) == "table" then
		NAStuff._githubCommits = decoded
		local top = decoded[1]
		local date = top and top.commit and top.commit.author and top.commit.author.date
		if type(date) == "string" then
			local year, month, day = date:match("(%d+)-(%d+)-(%d+)")
			if year and month and day then
				opt.NAupdDate = month.."/"..day.."/"..year
			end
		end
	end
end, {maxAttempts=10})
if NAAssetsLoading.progressPercent then NAAssetsLoading.progressPercent("changelog") end

NAAssetsLoading.runLoadingCheck("Loading UI", function()
	if type(opt.NAUILOADER) ~= "string" or opt.NAUILOADER == "" then
		return false, nil, "missing UI loader url"
	end
	local ok, body = pcall(game.HttpGet, game, opt.NAUILOADER)
	if not ok then
		return false, nil, body
	end
	if type(body) ~= "string" or body == "" then
		return false, nil, "empty response"
	end
	return true, body
end, function(body)
	NAAssetsLoading.cachePrefetchedRemote(opt.NAUILOADER, body)
end)
if NAAssetsLoading.progressPercent then NAAssetsLoading.progressPercent("uiloader") end

NAAssetsLoading.setStatus("collecting remote resources")
local remoteTargets = NAAssetsLoading.getRemoteTargets()
local totalRemotes = #remoteTargets
if totalRemotes > 0 then
	NAAssetsLoading.setStatus(Format("queued %d remote resources", totalRemotes))
else
	NAAssetsLoading.setStatus("queued 0 remote resources")
end
if NAAssetsLoading.progressPercent then NAAssetsLoading.progressPercent("queue") end

NAAssetsLoading.setStatus("prefetching remote resources")
NAAssetsLoading.applyPrefetchPercent=function(done, total)
	if not NAAssetsLoading.progressPercent then return end
	if total and total > 0 then
		local frac = math.clamp(done / total, 0, 1)
		NAAssetsLoading.progressPercent("prefetch", frac)
	else
		NAAssetsLoading.progressPercent("prefetch", 1)
	 end
end
NAAssetsLoading.prefetchRemotes(function(done, total, url, success)
	NAAssetsLoading.applyPrefetchPercent(done, total)
	if total > 0 and (done == total or done % 5 == 0) then
		NAAssetsLoading.setStatus(Format("prefetching %d/%d", done, total))
	end
end, NAAssetsLoading.getSkip)

NAAssetsLoading.setStatus("Fetching Roblox API")
pcall(function()
	if NAmanage and NAmanage.prefetchRobloxGameInfo then
		NAmanage.prefetchRobloxGameInfo()
	end
	if NAAssetsLoading.setPercent then
		NAAssetsLoading.setPercent(0.96)
	end
end)

NAAssetsLoading.setStatus("finalizing")

Notify = Notification.Notify
Window = Notification.Window
Popup  = Notification.Popup

local function cloneTable(tbl)
	local copy = {}
	for k, v in pairs(tbl) do
		copy[k] = v
	end
	return copy
end

local function buildNotifArgs(input, duration, title, allowDurationDefault)
	local args = type(input) == "table" and cloneTable(input) or {}
	if type(input) ~= "table" then
		args.Description = tostring((input ~= nil and input) or "something")
	elseif args.Description == nil then
		args.Description = "something"
	end
	local resolvedTitle = title or adminName
	if resolvedTitle and args.Title == nil then
		args.Title = resolvedTitle
	end
	if allowDurationDefault or duration ~= nil then
		if args.Duration == nil then
			if duration ~= nil then
				args.Duration = duration
			elseif allowDurationDefault then
				args.Duration = 5
			end
		end
	end
	return args
end

function DoNotif(text, duration, title)
	Notify(buildNotifArgs(text, duration, title, true))
end

function DebugNotif(text, duration, title)
	if not NAStuff.nuhuhNotifs then return end
	Notify(buildNotifArgs(text, duration, title, true))
end

function DoWindow(text, title)
	Window(buildNotifArgs(text, nil, title, false))
end

function DoPopup(text, title)
	Popup(buildNotifArgs(text, nil, title, false))
end

local mouse=SafeGetService("Players").LocalPlayer:GetMouse()

for _, ev in ipairs(events) do
	if type(Bindings[ev]) ~= "table" then
		Bindings[ev] = {}
	end
end

function countDictNA(tbl)
	local count = 0
	for _ in pairs(tbl) do
		count += 1
	end
	return count
end

--[[ Version ]]--
local curVer = isAprilFools() and Format(" V%d.%d.%d", math.random(1, 99), math.random(0, 99), math.random(0, 99)) or NAStuff.NAjson and " V"..NAStuff.NAjson.ver or ""

function getSeasonEmoji()
	local date = os.date("*t")
	local month = date.month
	local day = date.day

	if month == 1 and day == 1 then
		return '🎉' -- New Year's Day
	elseif month == 2 and day == 14 then
		return '❤️' -- Valentine's Day
	elseif month == 2 and day >= 1 and day <= 21 then
		return '🧧' -- Chinese New Year (approximate)
	elseif month == 3 and day == 17 then
		return '☘️' -- St. Patrick's Day
	elseif month == 4 and day >= 1 and day <= 15 then
		return '🥚' -- Easter (approximate)
	elseif month == 5 and day >= 8 and day <= 14 then
		return '💐' -- Mother's Day (approximate second Sunday)
	elseif month == 6 and day >= 15 and day <= 21 then
		return '👔' -- Father's Day (approximate third Sunday)
	elseif month == 6 and day == 21 then
		return '☀️' -- Summer Solstice
	elseif month == 9 and day == 22 then
		return '🍂' -- Autumn Equinox
	elseif month == 10 and day == 31 then
		return '🎃' -- Halloween
	elseif month == 11 and day >= 22 and day <= 28 then
		return '🦃' -- Thanksgiving (approximate fourth Thursday)
	elseif month == 12 and day == 25 then
		return '🎄' -- Christmas
	elseif month == 12 and day == 31 then
		return '🎆' -- New Year's Eve
	end

	if month == 12 or month <= 2 then
		return '❄️' -- Winter
	elseif month >= 3 and month <= 5 then
		return '🌸' -- Spring
	elseif month >= 6 and month <= 8 then
		return '☀️' -- Summer
	elseif month >= 9 and month <= 11 then
		return '🍂' -- Autumn
	end

	return ''
end

if (identifyexecutor and (identifyexecutor():lower()=="solara" or identifyexecutor():lower()=="xeno")) or not fireproximityprompt then
	local function hb(n)
		for i = 1, (n or 1) do
			RunService.Heartbeat:Wait()
		end
	end

	local function toOpts(o)
		if typeof(o) == "number" then
			return { hold = o }
		end
		return typeof(o) == "table" and o or {}
	end

	local state = setmetatable({}, { __mode = "k" })

	local function snapshot(pp)
		return {
			E = pp.Enabled,
			H = pp.HoldDuration,
			R = pp.RequiresLineOfSight,
			D = pp.MaxActivationDistance,
			X = pp.Exclusivity,
		}
	end

	local function begin(pp, o)
		local s = state[pp]
		if not s then
			s = snapshot(pp)
			s.ref = 0
			s.inFlight = false
			pp.Destroying:Connect(function()
				state[pp] = nil
			end)
			state[pp] = s
		end
		if s.inFlight then
			return false
		end
		s.inFlight = true
		s.ref += 1

		pp.HoldDuration = 0
		if o.requireLoS ~= nil then
			pp.RequiresLineOfSight = o.requireLoS and true or false
		end
		if o.distance ~= nil then
			pp.MaxActivationDistance = o.distance
		elseif o.autoDistance ~= false then
			pp.MaxActivationDistance = 1e9
		end
		if o.exclusivity ~= nil then
			pp.Exclusivity = o.exclusivity
		else
			pp.Exclusivity = Enum.ProximityPromptExclusivity.AlwaysShow
		end
		if o.forceEnable then
			pp.Enabled = true
		end

		return true
	end

	local function finish(pp)
		local s = state[pp]
		if not s then return end
		s.ref -= 1
		s.inFlight = false
		if s.ref <= 0 and pp and pp.Parent then
			pp.Enabled               = s.E
			pp.HoldDuration          = s.H
			pp.RequiresLineOfSight   = s.R
			pp.MaxActivationDistance = s.D
			pp.Exclusivity           = s.X
			state[pp] = nil
		end
	end

	local function fireOne(pp, o)
		if not begin(pp, o) then return end
		local ok, err = pcall(function()
			hb(1)
			pp:InputHoldBegin()
			local t = (o.hold ~= nil) and tonumber(o.hold) or 0
			if t and t > 0 then
				Wait(t)
			else
				hb(1)
			end
			pp:InputHoldEnd()
			hb(1)
		end)
		finish(pp)
		if not ok then
			warn(("[fireproximityprompt] %s"):format(err))
		end
	end

	getgenv().fireproximityprompt = function(target, opts)
		local o = toOpts(opts)
		local list = {}
		if typeof(target) == "Instance" and target:IsA("ProximityPrompt") then
			list[1] = target
		elseif typeof(target) == "table" then
			for _, v in ipairs(target) do
				if typeof(v) == "Instance" and v:IsA("ProximityPrompt") then
					Insert(list, v)
				end
			end
		else
			return false
		end

		local stagger = (o.stagger ~= nil) and math.max(0, o.stagger) or 0

		for _, pp in ipairs(list) do
			Spawn(fireOne, pp, o)
		end

		if stagger > 0 then
			for i = 2, #list do
				Wait(stagger)
			end
		end

		return true
	end
end

NAmanage.jlPhys = function()
	local okSettings, net = pcall(function()
		return settings():GetService("NetworkSettings")
	end)
	if okSettings and net then
		local okValue, value = pcall(function()
			return net.PrintPhysicsErrors
		end)
		if okValue then
			return value == true
		end
	end
	return false
end

NAmanage.jlDef = {
	JoinLog = false;
	LeaveLog = false;
	SaveLog = false;
	ChatLog = true;
	SaveChatLog = true;
	PhysicsLog = NAmanage.jlPhys();
	WelcomeNotif = true;
	KeybindNotif = true;
	PluginNotif = true;
}

NAmanage.jlNorm = function(cfg)
	local c = type(cfg) == "table" and cfg or {}
	local function boolDef(v, d)
		if type(v) == "boolean" then
			return v
		end
		return d
	end
	for key, def in pairs(NAmanage.jlDef) do
		c[key] = boolDef(c[key], def)
	end
	return c
end

NAmanage.jlCfg = NAmanage.jlNorm()

NAmanage.logApply = function()
	local okSettings, net = pcall(function()
		return settings():GetService("NetworkSettings")
	end)
	if okSettings and net then
		pcall(function()
			net.PrintPhysicsErrors = NAmanage.jlCfg.PhysicsLog == true
		end)
	end
end

opt.loader = Format('loadstring(game:HttpGet("%s"))();', opt.loaderUrl or "")

--Custom file functions checker checker
NAmanage.loaderState.settingsPath = NAfiles.NAMAINSETTINGSPATH
NAUserButtons = {}
UserButtonGuiList = {}
UserButtonGuiMap = {}
UserButtonDropdowns = {}
local UserButtonToggleState = {}

originalIO.userButtonChildKey=function(groupId, childIndex)
	if groupId == nil or childIndex == nil then
		return nil
	end
	return ("g%s_%s"):format(tostring(groupId), tostring(childIndex))
end

originalIO.clearUserButtonState=function(id)
	if id == nil then
		return
	end
	UserButtonToggleState[id] = nil
	local prefix = "g"..tostring(id).."_"
	for key in pairs(UserButtonToggleState) do
		if type(key) == "string" and key:sub(1, #prefix) == prefix then
			UserButtonToggleState[key] = nil
		end
	end
end

originalIO.clearUserButtonChildState=function(groupId, childIndex)
	local key = originalIO.userButtonChildKey(groupId, childIndex)
	if key then
		UserButtonToggleState[key] = nil
	end
end

NAEXECDATA = NAEXECDATA or {commands = {}, args = {}}
doPREDICTION = true
-- make it so It's easier for IY users to move to nameless admin (yes i did this and it's funny)
local NamelessMigrate = {}
NamelessMigrate.IY_FE = {}
function NamelessMigrate:LoadIY_FE()
	if FileSupport then
		-- check if IY was installed
		if isfile("IY_FE.iy") then
			local success, content = NACaller(readfile, "IY_FE.iy")
			if success and content then
				NamelessMigrate.IY_FE = HttpService:JSONDecode(content)
				DoNotif("Some Settings have been imported from Infinite Yield")
			end
		end
	end
	NamelessMigrate.LoadIY_FE = function() end -- too lazy to make a proper check just override it
	return
end
function NamelessMigrate:Prefix()
	NamelessMigrate:LoadIY_FE()
	if FileSupport then
		if NamelessMigrate.IY_FE then
			return NamelessMigrate.IY_FE["prefix"] or nil
		end
	end
	return nil
end

function NamelessMigrate:UiSize()
	NamelessMigrate:LoadIY_FE()
	if FileSupport then
		if NamelessMigrate.IY_FE then
			return tostring(NamelessMigrate.IY_FE["guiScale"]) or nil
		end
	end
	return nil
end

function NamelessMigrate:Waypoints()
	NamelessMigrate:LoadIY_FE()
	if not FileSupport then
		return
	end

	if NamelessMigrate.IY_FE then
		local Objects = {}
		for i,v in pairs(NamelessMigrate.IY_FE["WayPoints"] or {}) do
			if not Objects[v.GAME] then
				Objects[v.GAME] = {}
			end
			local cord =  v.COORD
			cord[#cord+1] = 1
			cord[#cord+1] = 0
			cord[#cord+1] = 0
			cord[#cord+1] = 0
			cord[#cord+1] = 1
			cord[#cord+1] = 0
			cord[#cord+1] = 0
			cord[#cord+1] = 0
			cord[#cord+1] = 1
			Objects[v.GAME][v.NAME]= {["Components"] = v.COORD}
		end
		for i,v in pairs(Objects) do
			local Load = ("%s/WP_%s.json"):format(
				NAfiles.NAWAYPOINTFILEPATH,
				tostring(i)
			)
			writefile(Load, HttpService:JSONEncode(v))
		end
	end

end

NAmanage.NASettingsResolveDefault=function(def)
	local default = def.default
	if typeof(default) == "function" then
		local ok, value = pcall(default)
		if ok then
			default = value
		else
			default = nil
		end
	end
	return default
end

NAmanage.NASettingsCoerce=function(def, value)
	if value == nil then
		return NAmanage.NASettingsResolveDefault(def)
	end

	if def.coerce then
		local ok, coerced = pcall(def.coerce, value)
		if ok and coerced ~= nil then
			return coerced
		end
		return NAmanage.NASettingsResolveDefault(def)
	end

	return value
end

NAmanage.NASettingsGetSchema=function()
	if NAStuff.NASettingsSchema then
		return NAStuff.NASettingsSchema
	end

	local defaultStrokeColor = Color3.fromRGB(148, 93, 255)

	local function coerceBoolean(value, fallback)
		if type(value) == "boolean" then
			return value
		end
		if type(value) == "string" then
			local lowered = value:lower()
			if lowered == "true" or lowered == "1" then
				return true
			end
			if lowered == "false" or lowered == "0" then
				return false
			end
		end
		if type(value) == "number" then
			return value ~= 0
		end
		return fallback
	end

	local function clampChannel(value)
		local numberValue = tonumber(value)
		if not numberValue then
			return nil
		end
		if numberValue < 0 then
			numberValue = 0
		elseif numberValue > 1 then
			numberValue = 1
		end
		return numberValue
	end

	NAStuff.NASettingsSchema = {
		prefix = {
			pathKey = "NAPREFIXPATH";
			default = function()
				return NamelessMigrate:Prefix() or ";"
			end;
			coerce = function(value)
				if type(value) ~= "string" then
					value = tostring(value or ";")
				end
				if value == "" then
					return ";"
				end
				return value
			end;
		};
		buttonSize = {
			pathKey = "NABUTTONSIZEPATH";
			default = 1;
			coerce = function(value)
				local numberValue = tonumber(value)
				if not numberValue or numberValue <= 0 then
					return 1
				end
				return numberValue
			end;
		};
		iconBgTransparency = {
			default = 0;
			coerce = function(value)
				local n = clampChannel(value)
				if n == nil then return 0 end
				return n
			end;
		};
		iconImageTransparency = {
			default = 0;
			coerce = function(value)
				local n = clampChannel(value)
				if n == nil then return 0 end
				return n
			end;
		};
		iconTextTransparency = {
			default = 0;
			coerce = function(value)
				local n = clampChannel(value)
				if n == nil then return 0 end
				return n
			end;
		};
		iconStrokeTransparency = {
			default = 0.7;
			coerce = function(value)
				local n = clampChannel(value)
				if n == nil then return 0.7 end
				return n
			end;
		};
		iconPosition = {
			default = function()
				return { X = 0.5; Y = 0.1 }
			end;
			coerce = function(value)
				local parsed = value
				if type(value) == "string" then
					local ok, decoded = NACaller(function()
						return HttpService:JSONDecode(value)
					end)
					if ok and typeof(decoded) == "table" then
						parsed = decoded
					else
						parsed = nil
					end
				end

				if type(parsed) == "table" then
					local x = tonumber(parsed.X or parsed.x)
					local y = tonumber(parsed.Y or parsed.y)
					if x then
						x = math.clamp(x, 0, 1)
					end
					if y then
						y = math.clamp(y, 0, 1)
					end
					if x ~= nil and y ~= nil then
						return { X = x; Y = y }
					end
				end

				return { X = 0.5; Y = 0.1 }
			end;
		};
		iconKeepPosition = {
			default = false;
			coerce = function(value)
				return value == true
			end;
		};
		uiScale = {
			pathKey = "NAUISIZEPATH";
			default = function()
				local migrated = NamelessMigrate:UiSize()
				local numberValue = tonumber(migrated)
				return numberValue and numberValue > 0 and numberValue or 1
			end;
			coerce = function(value)
				local numberValue = tonumber(value)
				if not numberValue or numberValue <= 0 then
					return 1
				end
				return numberValue
			end;
		};
		tweenSpeed = {
			default = 1;
			coerce = function(value)
				local numberValue = tonumber(value)
				if not numberValue or numberValue <= 0 then
					return 1
				end
				return numberValue
			end;
		};
		freecamSpeed = {
			default = 5;
			coerce = function(value)
				local numberValue = tonumber(value)
				if not numberValue then
					return 5
				end
				return math.clamp(numberValue, 0.05, 20)
			end;
		};
		queueOnTeleport = {
			pathKey = "NAQOTPATH";
			default = false;
			coerce = function(value)
				return coerceBoolean(value, false)
			end;
		};
		prediction = {
			pathKey = "NAPREDICTIONPATH";
			default = true;
			coerce = function(value)
				return coerceBoolean(value, true)
			end;
		};
		freecamKeybind = {
			default = false;
			coerce = function(value)
				return coerceBoolean(value, false)
			end;
		};
		autoExecEnabled = {
			default = true;
			coerce = function(value)
				return coerceBoolean(value, true)
			end;
		};
		userButtonsAutoLoad = {
			default = true;
			coerce = function(value)
				return coerceBoolean(value, true)
			end;
		};
		cmdbar2AutoRun = {
			default = false;
			coerce = function(value)
				return coerceBoolean(value, false)
			end;
		};
		cmdbar2Width = {
			default = NAStuff.CmdBar2.defaultWidth;
			coerce = function(value)
				return NAmanage.CmdBar2ClampValue(value, NAStuff.CmdBar2.minWidth, NAStuff.CmdBar2.maxWidth, NAStuff.CmdBar2.defaultWidth)
			end;
		};
		cmdbar2Height = {
			default = NAStuff.CmdBar2.defaultHeight;
			coerce = function(value)
				return NAmanage.CmdBar2ClampValue(value, NAStuff.CmdBar2.minHeight, NAStuff.CmdBar2.maxHeight, NAStuff.CmdBar2.defaultHeight)
			end;
		};
		deltaPrompted = {
			default = false;
			coerce = function(value)
				return coerceBoolean(value, false)
			end;
		};
		bloxtrapRPC = {
			default = false;
			coerce = function(value)
				return coerceBoolean(value, false)
			end;
		};
		integrationWebhookUrl = {
			default = "";
			coerce = function(value)
				if type(value) ~= "string" then
					value = tostring(value or "")
				end
				return value
			end;
		};
		integrationWebhookUrlMain = {
			default = "";
			coerce = function(value)
				if type(value) ~= "string" then
					value = tostring(value or "")
				end
				return value
			end;
		};
		integrationWebhookUrlAll = {
			default = "";
			coerce = function(value)
				if type(value) ~= "string" then
					value = tostring(value or "")
				end
				return value
			end;
		};
		integrationWebhookUrlJoinLeave = {
			default = "";
			coerce = function(value)
				if type(value) ~= "string" then
					value = tostring(value or "")
				end
				return value
			end;
		};
		integrationWebhookUrlChat = {
			default = "";
			coerce = function(value)
				if type(value) ~= "string" then
					value = tostring(value or "")
				end
				return value
			end;
		};
		integrationWebhookUrlCommands = {
			default = "";
			coerce = function(value)
				if type(value) ~= "string" then
					value = tostring(value or "")
				end
				return value
			end;
		};
		integrationWebhookUseAll = {
			default = false;
			coerce = function(value)
				return coerceBoolean(value, false)
			end;
		};
		integrationWebhookJoinLeave = {
			default = false;
			coerce = function(value)
				return coerceBoolean(value, false)
			end;
		};
		integrationWebhookChat = {
			default = false;
			coerce = function(value)
				return coerceBoolean(value, false)
			end;
		};
		integrationWebhookCommands = {
			default = false;
			coerce = function(value)
				return coerceBoolean(value, false)
			end;
		};
		integrationWebhookInterval = {
			default = 2;
			coerce = function(value)
				local n = tonumber(value)
				if not n then return 2 end
				if n < 0 then n = 0 elseif n > 30 then n = 30 end
				return n
			end;
		};
		integrationHealthEndpoints = {
			default = {};
			coerce = function(value)
				if type(value) ~= "table" then
					return {}
				end
				local out = {}
				for i = 1, math.min(3, #value) do
					local v = value[i]
					if type(v) == "string" and v ~= "" then
						out[#out + 1] = v
					end
				end
				return out
			end;
		};
		integrationNotesLast = {
			default = "";
			coerce = function(value)
				if type(value) ~= "string" then
					value = tostring(value or "")
				end
				return value
			end;
		};
		integrationRpcUseCustom = {
			default = false;
			coerce = function(value)
				return coerceBoolean(value, false)
			end;
		};
		integrationRpcDetails = {
			default = "";
			coerce = function(value)
				if type(value) ~= "string" then
					value = tostring(value or "")
				end
				return value
			end;
		};
		integrationRpcState = {
			default = "";
			coerce = function(value)
				if type(value) ~= "string" then
					value = tostring(value or "")
				end
				return value
			end;
		};
		cmdIntegrationAutoRun = {
			default = false;
			coerce = function(value)
				return coerceBoolean(value, false)
			end;
		};
		purchasePromptsDisabled = {
			default = false;
			coerce = function(value)
				return coerceBoolean(value, false)
			end;
		};
		networkPauseDisabled = {
			default = false;
			coerce = function(value)
				return coerceBoolean(value, false)
			end;
		};
		chatTranslate = {
			default = true;
			coerce = function(value)
				return coerceBoolean(value, true)
			end;
		};
		chatTranslateTarget = {
			default = "en";
			coerce = function(value)
				if type(value) ~= "string" then
					value = tostring(value or "en")
				end
				value = value:lower()
				if value == "" then
					return "en"
				end
				return value
			end;
		};
		uiStroke = {
			pathKey = "NASTROKETHINGY";
			default = function()
				return {
					R = defaultStrokeColor.R;
					G = defaultStrokeColor.G;
					B = defaultStrokeColor.B;
				}
			end;
			coerce = function(value)
				local parsed = value
				if typeof(value) == "Color3" then
					parsed = {
						R = value.R;
						G = value.G;
						B = value.B;
					}
				elseif type(value) == "string" then
					local ok, decoded = NACaller(function()
						return HttpService:JSONDecode(value)
					end)
					if ok and typeof(decoded) == "table" then
						parsed = decoded
					else
						parsed = nil
					end
				end

				if type(parsed) == "table" then
					local r = clampChannel(parsed.R)
					local g = clampChannel(parsed.G)
					local b = clampChannel(parsed.B)
					if r and g and b then
						return {
							R = r;
							G = g;
							B = b;
						}
					end
				end

				return {
					R = defaultStrokeColor.R;
					G = defaultStrokeColor.G;
					B = defaultStrokeColor.B;
				}
			end;
		};
		colorPickerAutoRGB = {
			default = function()
				return {}
			end;
			coerce = function(value)
				if type(value) ~= "table" then
					value = {}
				end
				local sanitized = {}
				for key, val in pairs(value) do
					if type(key) == "string" then
						sanitized[key] = val == true
					end
				end
				return sanitized
			end;
		};
		customIconAssetId = {
			default = "";
			coerce = function(value)
				if typeof(value) ~= "string" then
					value = tostring(value or "")
				end
				value = value:match("^%s*(.-)%s*$")
				if value == "" then
					return ""
				end
				local digits = value:match("^rbxassetid://(%d+)$") or value:match("(%d+)$")
				if digits then
					return "rbxassetid://"..digits
				end
				return ""
			end;
		};
		customIconEnabled = {
			default = false;
			coerce = function(value)
				if type(value) == "boolean" then return value end
				if type(value) == "string" then
					local lowered = value:lower()
					if lowered == "true" or lowered == "1" then return true end
					if lowered == "false" or lowered == "0" then return false end
				end
				if type(value) == "number" then return value ~= 0 end
				return false
			end;
		};
		iconInvisible = {
			default = false;
			coerce = function(value)
				return coerceBoolean(value, false)
			end;
		};
		iconLocked = {
			default = false;
			coerce = function(value)
				if type(value) == "boolean" then return value end
				if type(value) == "string" then
					local v = value:lower()
					if v == "true" or v == "1" then return true end
					if v == "false" or v == "0" then return false end
				end
				if type(value) == "number" then return value ~= 0 end
				return false
			end;
		};
		topbarKeepPosition = {
			default = false;
			coerce = function(value)
				return coerceBoolean(value, false)
			end;
		};
		topbarPositionRatio = {
			default = 0;
			coerce = function(value)
				local numberValue = tonumber(value)
				if not numberValue then
					return 0
				end
				if numberValue < -1 then
					numberValue = -1
				elseif numberValue > 1 then
					numberValue = 1
				end
				return numberValue
			end;
		};
		sideSwipeSide = {
			default = "left";
			coerce = function(value)
				if value == "right" then
					return "right"
				end
				return "left"
			end;
		};
		sideSwipeEnabled = {
			default = false;
			coerce = function(value)
				return coerceBoolean(value, false)
			end;
		};
		sideSwipeWidth = {
			default = 80;
			coerce = function(value)
				local numberValue = tonumber(value)
				if not numberValue then
					return 80
				end
				return math.clamp(math.floor(numberValue + 0.5), 60, 200)
			end;
		};
		sideSwipeHandleTransparency = {
			default = 0.72;
			coerce = function(value)
				local n = clampChannel(value)
				if n == nil then return 0.72 end
				return n
			end;
		};
		topbarVisible = {
			pathKey = "NATOPBAR";
			default = true;
			coerce = function(value)
				return coerceBoolean(value, true)
			end;
		};
		topbarGlassTransparency = {
			default = 0.12;
			coerce = function(value)
				local n = clampChannel(value)
				if n == nil then return 0.12 end
				return n
			end;
		};
		topbarStrokeTransparency = {
			default = 0.15;
			coerce = function(value)
				local n = clampChannel(value)
				if n == nil then return 0.15 end
				return n
			end;
		};
		notifsToggle = {
			pathKey = "NANOTIFSTOGGLE";
			default = false;
			coerce = function(value)
				return coerceBoolean(value, false)
			end;
		};
		devConsoleFilters = {
			default = function()
				return {
					Output = true;
					Info = true;
					Warn = true;
					Error = true;
				}
			end;
			coerce = function(value)
				local result = {
					Output = true;
					Info = true;
					Warn = true;
					Error = true;
				}
				if typeof(value) == "table" then
					result.Output = coerceBoolean(value.Output, result.Output)
					result.Info = coerceBoolean(value.Info, result.Info)
					result.Warn = coerceBoolean(value.Warn, result.Warn)
					result.Error = coerceBoolean(value.Error, result.Error)
				end
				return result
			end;
		};
		autoSkipLoading = {
			default = false;
			coerce = function(value)
				return coerceBoolean(value, false)
			end;
		};
		autoPreloadAssets = {
			default = false;
			coerce = function(value)
				return coerceBoolean(value, false)
			end;
		};
		assetLoadMode = {
			default = "Fast";
			coerce = function(value)
				local map = {
					batch = "Batch";
					medium = "Medium";
					fast = "Fast";
					aggressive = "Aggressive";
				}
				local mode = nil
				if type(value) == "string" then
					mode = value
				elseif value ~= nil then
					mode = tostring(value)
				end
				if type(mode) == "string" then
					mode = mode:match("^%s*(.-)%s*$") or mode
					mode = map[mode:lower()]
				end
				return mode or "Fast"
			end;
		};
		loadingStartMinimized = {
			default = false;
			coerce = function(value)
				return coerceBoolean(value, false)
			end;
		};
		topbarMode = {
			pathKey = "NATOPBARMODE";
			default = "bottom";
			coerce = function(value)
				if type(value) ~= "string" then
					return "bottom"
				end
				if value == "side" then
					return "side"
				end
				return "bottom"
			end;
		};
		topbarDock = {
			default = "top";
			coerce = function(value)
				if value == "bottom" then
					return "bottom"
				end
				return "top"
			end;
		};
		disableLastInput = {
			default = false;
			coerce = function(value)
				return coerceBoolean(value, false)
			end;
		};
	}

	return NAStuff.NASettingsSchema
end

NAmanage.NASettingsSave=function()
	if not FileSupport or not NAStuff.NASettingsData then
		return
	end

	local ok, encoded = NACaller(function()
		return HttpService:JSONEncode(NAStuff.NASettingsData)
	end)

	if ok and encoded then
		NACaller(writefile, NAfiles.NAMAINSETTINGSPATH, encoded)
	end
end

NAmanage.NASettingsEnsure=function()
	if NAStuff.NASettingsData then
		return NAStuff.NASettingsData
	end

	local schema = NAmanage.NASettingsGetSchema()
	NAStuff.NASettingsData = {}

	if FileSupport and type(isfile) == "function" and isfile(NAfiles.NAMAINSETTINGSPATH) then
		local ok, raw = NACaller(readfile, NAfiles.NAMAINSETTINGSPATH)
		if ok and raw and raw ~= "" then
			local success, decoded = NACaller(function()
				return HttpService:JSONDecode(raw)
			end)
			if success and typeof(decoded) == "table" then
				NAStuff.NASettingsData = decoded
			end
		end
	end

	if typeof(NAStuff.NASettingsData) ~= "table" then
		NAStuff.NASettingsData = {}
	end

	local legacyIconPath = "Nameless-Admin/IconPosition.json"
	if FileSupport and type(isfile) == "function" and isfile(legacyIconPath) then
		local okRaw, legacyRaw = NACaller(readfile, legacyIconPath)
		if okRaw and type(legacyRaw) == "string" and legacyRaw ~= "" then
			local okDecoded, legacyDecoded = NACaller(function()
				return HttpService:JSONDecode(legacyRaw)
			end)
			if okDecoded and typeof(legacyDecoded) == "table" then
				if NAStuff.NASettingsData.iconPosition == nil then
					local lx = math.clamp(tonumber(legacyDecoded.X) or 0.5, 0, 1)
					local ly = math.clamp(tonumber(legacyDecoded.Y) or 0.1, 0, 1)
					NAStuff.NASettingsData.iconPosition = { X = lx; Y = ly }
				end
				if NAStuff.NASettingsData.iconKeepPosition == nil and legacyDecoded.Save ~= nil then
					NAStuff.NASettingsData.iconKeepPosition = legacyDecoded.Save == true
				end
			end
		end
		if delfile then
			NACaller(delfile, legacyIconPath)
		end
	end

	local legacyPaths = {}
	for key, def in pairs(schema) do
		legacyPaths[key] = def.pathKey and NAfiles[def.pathKey] or nil
	end

	for key, def in pairs(schema) do
		local value = NAStuff.NASettingsData[key]

		if value == nil and FileSupport and type(isfile) == "function" then
			local legacyPath = legacyPaths[key]
			if legacyPath and isfile(legacyPath) then
				local ok, legacyRaw = NACaller(readfile, legacyPath)
				if ok and legacyRaw ~= nil then
					value = legacyRaw
				end
				if delfile then
					NACaller(delfile, legacyPath)
				end
			end
		end

		NAStuff.NASettingsData[key] = NAmanage.NASettingsCoerce(def, value)
	end

	NAmanage.NASettingsSave()
	return NAStuff.NASettingsData
end

NAmanage.NASettingsGet=function(key)
	local settings = NAmanage.NASettingsEnsure()
	return settings[key]
end

NAmanage.NASettingsSet=function(key, value)
	local schema = NAmanage.NASettingsGetSchema()
	local def = schema[key]
	if not def then
		return
	end

	local settings = NAmanage.NASettingsEnsure()
	settings[key] = NAmanage.NASettingsCoerce(def, value)
	NAmanage.NASettingsSave()
	return settings[key]
end

NAStuff.deltaPrompted = NAmanage.NASettingsGet("deltaPrompted") == true
NAStuff.deltaScriptSource = "loadstring(game:HttpGet(\"https://raw.githubusercontent.com/ltseverydayyou/uuuuuuu/refs/heads/main/DeltaCustomizationModule.luau\"))();"
NAStuff.deltaExecutor = typeof(NAStuff.deltaExecutor) == "boolean" and NAStuff.deltaExecutor or nil

function NAmanage.isDeltaExecutor(forceRefresh)
	if not forceRefresh and type(NAStuff.deltaExecutor) == "boolean" then
		return NAStuff.deltaExecutor
	end
	if type(identifyexecutor) ~= "function" then
		NAStuff.deltaExecutor = false
		return false
	end
	local execName = nil
	local ok, result = pcall(identifyexecutor)
	if ok then
		execName = result
	end
	if execName ~= nil and type(execName) ~= "string" then
		execName = tostring(execName)
	end
	local isDelta = type(execName) == "string" and execName:lower() == "delta" or false
	NAStuff.deltaExecutor = isDelta
	return isDelta
end

function NAmanage.deltaRun()
	local ok, err = pcall(function()
		loadstring(game:HttpGet("https://raw.githubusercontent.com/ltseverydayyou/uuuuuuu/refs/heads/main/DeltaCustomizationModule.luau"))()
	end)
	if ok then
		DoNotif("Loaded the Delta customization helper.", 3)
	else
		DoNotif("Failed to load the Delta customization helper: "..tostring(err), 5)
	end
end

function NAmanage.deltaPopup()
	if NAStuff.deltaPrompted then
		return
	end
	if not NAmanage.isDeltaExecutor(true) then
		return
	end
	NAStuff.deltaPrompted = true
	pcall(NAmanage.NASettingsSet, "deltaPrompted", true)
	local popupTitle = (adminName and (adminName.." Notice")) or "Nameless Admin"
	local popupDescription = "Nameless Admin detected that you are using the Delta executor. This is a one-time reminder, so run it now to test Delta Customization or copy the script if you want to keep the script permanently."
	if type(Popup) == "function" then
		Popup({
			Title = popupTitle,
			Description = popupDescription,
			Duration = 0,
			Buttons = {
				{
					Text = "Run Script",
					Callback = NAmanage.deltaRun,
				},
				{
					Text = "Copy Script",
					Callback = function()
						if setclipboard then
							pcall(setclipboard, NAStuff.deltaScriptSource)
							DoNotif("Delta customization script copied to clipboard.", 3)
						else
							DoNotif(NAStuff.deltaScriptSource, 8)
						end
					end,
				},
			},
		})
	else
		DoNotif(popupDescription, 5)
	end
end

NAmanage.deltaPopup()

local function NAensureFolder(path)
	if not (FileSupport and type(path) == "string") then
		return false, "no file support or invalid path"
	end
	if type(isfolder) == "function" and isfolder(path) then
		return true
	end
	if type(isfile) == "function" and isfile(path) and type(delfile) == "function" then
		pcall(delfile, path)
	end

	local ok, err = NACaller(function()
		if type(makefolder) == "function" then
			return makefolder(path)
		else
			error("makefolder missing")
		end
	end)

	if ok then
		return true
	end

	if NAmanage.stripExt then
		local alt = NAmanage.stripExt(path)
		if alt ~= path then
			local ok2 = NACaller(makefolder, alt)
			if ok2 then
				return true
			end
		end
	end
	return false, err
end

-- Creates folder & files for Prefix, Plugins, and etc
if FileSupport then
	local baseOk = NAensureFolder(NAfiles.NAFILEPATH)
	if not baseOk then
		FileSupport = false
	else
		if not isfolder(NAfiles.NAWAYPOINTFILEPATH) then
			if NAensureFolder(NAfiles.NAWAYPOINTFILEPATH) then
				-- imagine if it didn't make the folder
				if isfolder(NAfiles.NAWAYPOINTFILEPATH) then
					NamelessMigrate:Waypoints()
				end
			end
		end

		if not isfolder(NAfiles.NAPLUGINFILEPATH) then
			NAensureFolder(NAfiles.NAPLUGINFILEPATH)
		end

		if not isfolder(NAfiles.NAIYPLUGINFILEPATH) then
			NAensureFolder(NAfiles.NAIYPLUGINFILEPATH)
		end

		if not isfolder(NAfiles.NAASSETSFILEPATH) then
			NAensureFolder(NAfiles.NAASSETSFILEPATH)
		end

		if not isfile(NAfiles.NAALIASPATH) then
			writefile(NAfiles.NAALIASPATH, "{}")
		end

		if not isfile(NAfiles.NAUSERBUTTONSPATH) then
			writefile(NAfiles.NAUSERBUTTONSPATH, HttpService:JSONEncode({}))
		end

		if not isfile(NAfiles.NACOMMANDKEYBINDS) then
			writefile(NAfiles.NACOMMANDKEYBINDS, HttpService:JSONEncode({}))
		end

		if not isfile(NAfiles.NAAUTOEXECPATH) then
			writefile(NAfiles.NAAUTOEXECPATH, HttpService:JSONEncode({ commands = {}, args = {} }))
		end

		if not isfile(NAfiles.NAJOINLEAVE) then
			writefile(NAfiles.NAJOINLEAVE, HttpService:JSONEncode(NAmanage.jlDef))
		end

		if not isfile(NAfiles.NABINDERS) then
			writefile(NAfiles.NABINDERS, "{}")
		end

		if not isfile(NAfiles.NATEXTCHATSETTINGSPATH) then
			writefile(NAfiles.NATEXTCHATSETTINGSPATH, HttpService:JSONEncode(NAStuff.ChatSettings))
		end
	end

	NAmanage.NASettingsEnsure()
end

function InitUIStroke()
	local defaultColor = Color3.fromRGB(148, 93, 255)

	if not FileSupport then
		DoNotif("Main Color defaulted: no file support")
		return defaultColor
	end

	local data = NAmanage.NASettingsGet("uiStroke")
	if type(data) == "table" then
		local r = tonumber(data.R)
		local g = tonumber(data.G)
		local b = tonumber(data.B)
		if r and g and b then
			return Color3.new(r, g, b)
		end
	end

	NAmanage.NASettingsSet("uiStroke", {
		R = defaultColor.R;
		G = defaultColor.G;
		B = defaultColor.B;
	})
	DoNotif("Main Color reset to default due to invalid or missing data.")
	return defaultColor
end

NAmanage.topbar_readMode=function()
	local mode = NAmanage.NASettingsGet("topbarMode")
	return mode == "side" and "side" or "bottom"
end

NAmanage.topbar_writeMode=function(m)
	if m ~= "side" then
		m = "bottom"
	end
	NAmanage.NASettingsSet("topbarMode", m)
end

NAmanage.topbar_readDock=function()
	local dock = NAmanage.NASettingsGet("topbarDock")
	return dock == "bottom" and "bottom" or "top"
end

NAmanage.topbar_writeDock=function(dock)
	if dock ~= "bottom" then
		dock = "top"
	end
	NAmanage.NASettingsSet("topbarDock", dock)
end

NAmanage.GetWPPath=function()
	if not game.PlaceId or type(game.PlaceId) ~= "number" then
		repeat Wait() until type(game.PlaceId) == "number"
	end
	return ("%s/WP_%s.json"):format(
		NAfiles.NAWAYPOINTFILEPATH,
		tostring(game.PlaceId)
	)
end

NAmanage.mPosVector = function()
	return Vector2.new(mouse.X, mouse.Y)
end

NAmanage.worlScreen=function(obj)
	local vec = workspace.CurrentCamera:WorldToScreenPoint(obj.Position)
	return Vector2.new(vec.X, vec.Y)
end

NAmanage.getPlrCursor = function()
	local found = nil
	local ClosestDistance = math.huge
	for _,v in pairs(Players:GetPlayers()) do
		if v ~= Players.LocalPlayer and v.Character and getPlrHum(v.Character) then
			for k, x in pairs(v.Character:GetChildren()) do
				if Find(x.Name, "Torso") then
					local Distance = (NAmanage.worlScreen(x) - NAmanage.mPosVector()).Magnitude
					if Distance < ClosestDistance then
						ClosestDistance = Distance
						found = v
					end
				end
			end
		end
	end
	return found
end

local WPPath = NAmanage.GetWPPath()
local bindersPath = NAfiles.NABINDERS

NAmanage.LoadESPSettings = function()
	local d = {
		ESP_Transparency = 0.7;
		ESP_BoxMaxDistance = 120;
		ESP_LabelMaxDistance = 1000;
		ESP_ColorByTeam = true;
		ESP_ShowTeamText = true;
		ESP_ShowName = true;
		ESP_ShowHealth = true;
		ESP_ShowDistance = true;
		ESP_RenderMode = "BoxHandleAdornment";
		ESP_LabelTextSize = 12;
		ESP_LabelTextScaled = false;
		ESP_LabelStrokeTransparency = 0.5;
		ESP_UseCustomColor = false;
		ESP_CustomColor = {255, 255, 255};
		ESP_OutlineTransparency = 0;
		ESP_ShowPartDistance = false;
		ESP_LocatorEnabled = false;
		ESP_LocatorSize = 26;
		ESP_LocatorShowText = false;
		ESP_LocatorTextSize = 14;
		ESP_MaxPerStep = 32;
		ESP_FolderMode = "parts";
	}
	if FileSupport then
		if not isfile(NAfiles.NAESPSETTINGSPATH) then
			writefile(NAfiles.NAESPSETTINGSPATH, HttpService:JSONEncode(d))
		end
		local ok, raw = pcall(readfile, NAfiles.NAESPSETTINGSPATH)
		if ok and raw then
			local ok2, cfg = pcall(HttpService.JSONDecode, HttpService, raw)
			if ok2 and type(cfg)=="table" then
				for key, defaultValue in pairs(d) do
					local stored = cfg[key]
					if stored ~= nil then
						local kind = typeof(defaultValue)
						if kind == "number" then
							local numeric = tonumber(stored)
							if numeric then d[key] = numeric end
						elseif kind == "boolean" then
							if typeof(stored)=="boolean" then
								d[key] = stored
							elseif typeof(stored)=="number" then
								d[key] = stored ~= 0
							elseif typeof(stored)=="string" then
								local s = stored:lower()
								if s=="true" or s=="1" then d[key]=true
								elseif s=="false" or s=="0" then d[key]=false end
							end
						else
							d[key] = stored
						end
					end
				end
			end
		end
	end
	local function sanitizeColor(value, defaultColor)
		if typeof(value) == "Color3" then
			return value
		end
		if type(value) == "table" then
			local r = tonumber(value.R or value[1])
			local g = tonumber(value.G or value[2])
			local b = tonumber(value.B or value[3])
			if r and g and b then
				return Color3.fromRGB(r, g, b)
			end
		end
		return defaultColor
	end
	local mode = tostring(d.ESP_RenderMode or "BoxHandleAdornment")
	mode = (type(mode)=="string" and (Lower(mode)=="highlight" and "Highlight" or "BoxHandleAdornment")) or "BoxHandleAdornment"
	local sz = tonumber(d.ESP_LabelTextSize) or 12
	if sz < 8 then sz = 8 elseif sz > 72 then sz = 72 end
	local stroke = math.clamp(tonumber(d.ESP_LabelStrokeTransparency) or 0.5, 0, 1)
	local outline = NAgui.sanitizeTransparency(d.ESP_OutlineTransparency)
	local maxPerStep = math.clamp(math.floor(tonumber(d.ESP_MaxPerStep) or 32), 1, 256)
	local customColor = sanitizeColor(d.ESP_CustomColor, Color3.new(1, 1, 1))

	NAStuff.ESP_Transparency     = d.ESP_Transparency
	NAStuff.ESP_BoxMaxDistance   = d.ESP_BoxMaxDistance
	NAStuff.ESP_LabelMaxDistance = d.ESP_LabelMaxDistance
	NAStuff.ESP_ColorByTeam      = d.ESP_ColorByTeam
	NAStuff.ESP_ShowTeamText     = d.ESP_ShowTeamText
	NAStuff.ESP_ShowName         = d.ESP_ShowName
	NAStuff.ESP_ShowHealth       = d.ESP_ShowHealth
	NAStuff.ESP_ShowDistance     = d.ESP_ShowDistance
	NAStuff.ESP_ShowPartDistance = d.ESP_ShowPartDistance
	NAStuff.ESP_RenderMode       = mode
	NAStuff.ESP_LabelTextSize    = sz
	NAStuff.ESP_LabelTextScaled  = d.ESP_LabelTextScaled == true
	NAStuff.ESP_LabelStrokeTransparency = stroke
	NAStuff.ESP_UseCustomColor   = d.ESP_UseCustomColor == true
	NAStuff.ESP_CustomColor      = customColor
	NAStuff.ESP_OutlineTransparency = outline
	NAStuff.ESP_MaxPerStep       = maxPerStep
	local folderMode = Lower(tostring(d.ESP_FolderMode or "parts"))
	if folderMode ~= "models" then
		folderMode = "parts"
	end
	NAStuff.ESP_FolderMode = folderMode

	NAStuff.ESP_LocatorEnabled   = d.ESP_LocatorEnabled == true
	NAStuff.ESP_LocatorSize      = math.clamp(tonumber(d.ESP_LocatorSize) or 26, 12, 128)
	NAStuff.ESP_LocatorShowText  = d.ESP_LocatorShowText == true
	NAStuff.ESP_LocatorTextSize  = math.clamp(tonumber(d.ESP_LocatorTextSize) or 14, 10, 48)

	if NAStuff.ESP_LocatorEnabled then
		NAmanage.ESP_LocatorEnable(true)
	else
		NAmanage.ESP_LocatorDisable()
	end
	NAmanage.ESP_LocatorApplyFlags()
end

NAmanage.SaveESPSettings = function()
	if not FileSupport then return end
	local mode = "BoxHandleAdornment"
	if type(NAStuff.ESP_RenderMode) == "string" and Lower(NAStuff.ESP_RenderMode)=="highlight" then
		mode = "Highlight"
	end
	local sz = tonumber(NAStuff.ESP_LabelTextSize) or 12
	if sz < 8 then sz = 8 elseif sz > 72 then sz = 72 end
	local d = {
		ESP_Transparency = NAStuff.ESP_Transparency or 0.7;
		ESP_BoxMaxDistance = NAStuff.ESP_BoxMaxDistance or 120;
		ESP_LabelMaxDistance = NAStuff.ESP_LabelMaxDistance or 1000;
		ESP_ColorByTeam = (NAStuff.ESP_ColorByTeam ~= false);
		ESP_ShowTeamText = (NAStuff.ESP_ShowTeamText ~= false);
		ESP_ShowName = (NAStuff.ESP_ShowName ~= false);
		ESP_ShowHealth = (NAStuff.ESP_ShowHealth ~= false);
		ESP_ShowDistance = (NAStuff.ESP_ShowDistance ~= false);
		ESP_ShowPartDistance = (NAStuff.ESP_ShowPartDistance == true);
		ESP_RenderMode = mode;
		ESP_LabelTextSize = sz;
		ESP_LabelTextScaled = NAStuff.ESP_LabelTextScaled == true;
		ESP_LabelStrokeTransparency = math.clamp(tonumber(NAStuff.ESP_LabelStrokeTransparency) or 0.5, 0, 1);
		ESP_UseCustomColor = NAStuff.ESP_UseCustomColor == true;
		ESP_CustomColor = NAmanage.UserButtonColorToTable(NAStuff.ESP_CustomColor or Color3.new(1, 1, 1));
		ESP_OutlineTransparency = NAgui.sanitizeTransparency(NAStuff.ESP_OutlineTransparency or 0);
		ESP_LocatorEnabled = NAStuff.ESP_LocatorEnabled == true;
		ESP_LocatorSize = math.clamp(tonumber(NAStuff.ESP_LocatorSize) or 26, 12, 128);
		ESP_LocatorShowText = NAStuff.ESP_LocatorShowText == true;
		ESP_LocatorTextSize = math.clamp(tonumber(NAStuff.ESP_LocatorTextSize) or 14, 10, 48);
		ESP_MaxPerStep = math.clamp(math.floor(tonumber(NAStuff.ESP_MaxPerStep) or 32), 1, 256);
		ESP_FolderMode = (Lower(tostring(NAStuff.ESP_FolderMode)) == "models") and "models" or "parts";
	}
	writefile(NAfiles.NAESPSETTINGSPATH, HttpService:JSONEncode(d))
end

NAmanage.ESP_LocatorRegisterArrow = function(key, frame, label)
	if not key or not frame then return end
	NAStuff.ESP_LocatorArrows[key] = {
		frame = frame,
		label = label,
	}
end

NAmanage.ESP_LocatorRemoveArrow = function(key)
	local d = NAStuff.ESP_LocatorArrows[key]
	if not d then return end
	NAStuff.ESP_LocatorArrows[key] = nil
end

NAmanage.ESP_LocatorApplyFlags = function()
	local show = NAStuff.ESP_LocatorEnabled == true
	local showTxt = show and NAStuff.ESP_LocatorShowText == true
	local sz = math.clamp(tonumber(NAStuff.ESP_LocatorSize) or 26, 12, 128)
	local ts = math.clamp(tonumber(NAStuff.ESP_LocatorTextSize) or 14, 10, 48)

	for _, d in pairs(NAStuff.ESP_LocatorArrows) do
		local f = d.frame
		local l = d.label
		if f then
			f.Visible = show
			f.Size = UDim2.fromOffset(sz, sz)
		end
		if l then
			l.Visible = showTxt
			l.TextSize = ts
		end
	end
end

NAmanage.ESP_SetLocatorEnabled = function(on)
	NAStuff.ESP_LocatorEnabled = on == true
	if NAStuff.ESP_LocatorEnabled then
		NAmanage.ESP_LocatorEnable(true)
	else
		NAmanage.ESP_LocatorDisable()
	end
	NAmanage.ESP_LocatorApplyFlags()
	NAmanage.SaveESPSettings()
end

NAmanage.ESP_SetLocatorShowText = function(on)
	NAStuff.ESP_LocatorShowText = on == true
	NAmanage.ESP_LocatorApplyFlags()
	NAmanage.SaveESPSettings()
end

NAmanage.SaveBinders=function()
	if FileSupport then
		writefile(bindersPath, HttpService:JSONEncode(Bindings))
	end
end

NAmanage.SaveCommandKeybinds=function()
	if not FileSupport then return end

	local payload = {}
	for key, args in pairs(CommandKeybinds) do
		if type(key) == "string" and type(args) == "table" then
			local opt = CommandKeybindOptions[key]
			local disabled = opt and opt.disabled == true
			local entry
			if opt and opt.toggle then
				entry = {
					args1 = args;
					args2 = opt.args2 or args;
				}
				if opt.hold then
					entry.hold = true
				end
			elseif disabled then
				entry = {
					args = args;
				}
			else
				entry = args
			end
			if disabled and type(entry) == "table" then
				entry.disabled = true
			end
			payload[key] = entry
		end
	end

	local ok, err = pcall(function()
		writefile(NAfiles.NACOMMANDKEYBINDS, HttpService:JSONEncode(payload))
	end)
	if not ok then
		warn("[NA] Command keybind save failed: "..tostring(err))
	end
end

NAmanage.ApplyCommandKeybinds=function()
	if NAStuff.KeybindConnection then
		NAStuff.KeybindConnection:Disconnect()
		NAStuff.KeybindConnection = nil
	end
	if NAStuff.KeybindEndConnection then
		NAStuff.KeybindEndConnection:Disconnect()
		NAStuff.KeybindEndConnection = nil
	end
	local UIS = UserInputService
	if not UIS then
		return
	end

	local function cloneArgs(src)
		local dst = {}
		for i, v in ipairs(src) do
			dst[i] = v
		end
		return dst
	end

	local function shouldBlock(gameProcessed)
		if gameProcessed then return true end
		if NAStuff._capturingCommandKeybind then return true end
		if UIS.GetFocusedTextBox and UIS:GetFocusedTextBox() then return true end
		return false
	end

	local activeHoldKeys = {}

	NAStuff.KeybindConnection = UIS.InputBegan:Connect(function(input, gameProcessed)
		if shouldBlock(gameProcessed) then return end
		if input.UserInputType ~= Enum.UserInputType.Keyboard or not input.KeyCode then return end
		local keyName = input.KeyCode.Name
		local args = CommandKeybinds[keyName]
		if type(args) ~= "table" or #args == 0 then
			return
		end

		local opt = CommandKeybindOptions[keyName]
		if opt and opt.disabled then
			return
		end
		if opt and opt.toggle and opt.hold and type(opt.args2) == "table" then
			activeHoldKeys[keyName] = true
			opt.state = true
			cmd.run(cloneArgs(args))
			return
		end
		if opt and opt.toggle and type(opt.args2) == "table" then
			opt.state = not opt.state
			local runArgs
			if opt.state then
				runArgs = cloneArgs(args)
			else
				runArgs = cloneArgs(opt.args2)
			end
			cmd.run(runArgs)
		else
			cmd.run(cloneArgs(args))
		end
	end)

	NAStuff.KeybindEndConnection = UIS.InputEnded:Connect(function(input, gameProcessed)
		if not (input and input.KeyCode and input.KeyCode.Name) then
			return
		end
		local keyName = input.KeyCode.Name
		if not activeHoldKeys[keyName] and shouldBlock(gameProcessed) then
			return
		end
		if input.UserInputType ~= Enum.UserInputType.Keyboard then
			return
		end
		local opt = CommandKeybindOptions[keyName]
		if not opt then
			activeHoldKeys[keyName] = nil
			return
		end
		if not (opt.toggle and opt.hold) then
			activeHoldKeys[keyName] = nil
			return
		end
		if opt.disabled then
			activeHoldKeys[keyName] = nil
			return
		end
		if type(opt.args2) == "table" then
			cmd.run(cloneArgs(opt.args2))
		end
		activeHoldKeys[keyName] = nil
		opt.state = false
	end)
end

NAmanage.LoadCommandKeybinds=function()
	CommandKeybinds = {}
	CommandKeybindOptions = {}
	if FileSupport and isfile and isfile(NAfiles.NACOMMANDKEYBINDS) then
		local okRead, raw = pcall(readfile, NAfiles.NACOMMANDKEYBINDS)
		if okRead and type(raw) == "string" and raw ~= "" then
			local okDecode, decoded = pcall(function()
				return HttpService:JSONDecode(raw)
			end)
			if okDecode and type(decoded) == "table" then
				for key, value in pairs(decoded) do
					if type(key) == "string" and type(value) == "table" then
						local args = nil
						local opt = nil
						local disabled = value.disabled == true
						if type(value.args1) == "table" and type(value.args2) == "table" then
							args = value.args1
							opt = {
								toggle = true;
								state = false;
								args2 = value.args2;
								hold = value.hold == true;
							}
						elseif type(value.args) == "table" then
							args = value.args
							if value.toggle == true then
								local args2 = {}
								for i, v in ipairs(args) do
									args2[i] = v
								end
								if type(args2[1]) == "string" then
									local cmdName = args2[1]
									local lower = Lower(cmdName)
									if lower:sub(1, 2) == "un" then
										args2[1] = cmdName:sub(3)
									else
										args2[1] = "un"..cmdName
									end
								end
								opt = {
									toggle = true;
									state = false;
									args2 = args2;
									hold = value.hold == true;
								}
							end
						end
						if not args then
							args = value
						end
						if type(args) == "table" then
							CommandKeybinds[key] = args
							if disabled then
								opt = opt or {}
								opt.disabled = true
							end
							if opt then
								CommandKeybindOptions[key] = opt
							end
						end
					end
				end
			end
		end
	end
	NAmanage.ApplyCommandKeybinds()
	Defer(function()
		if type(NAmanage.CommandKeybindsUIRefresh) == "function" then
			pcall(NAmanage.CommandKeybindsUIRefresh)
		end
	end)
end

originalIO.deepCopyTable=function(value)
	if type(value) ~= "table" then return value end
	local copy = {}
	for k, v in pairs(value) do
		copy[k] = originalIO.deepCopyTable(v)
	end
	return copy
end

originalIO.safeDeleteFile=function(path)
	if type(path) ~= "string" then
		return false, "Invalid file path."
	end
	if not (delfile and isfile) then
		return false, "File deletion not supported by this executor."
	end
	if not isfile(path) then
		return true, "File already removed."
	end
	local ok, err = pcall(delfile, path)
	if not ok then
		return false, err or "Failed to delete file."
	end
	return true, "File deleted."
end

originalIO.safeClearFolder=function(path, opts)
	opts = opts or {}
	if type(path) ~= "string" then
		return false, "Invalid folder path."
	end
	if not (isfolder and listfiles and makefolder) then
		return false, "Folder operations not supported by this executor."
	end
	if not isfolder(path) then
		return true, "Folder already removed."
	end

	local okList, entries = pcall(listfiles, path)
	if okList and type(entries) == "table" then
		for _, entry in ipairs(entries) do
			if isfolder(entry) then
				local okSub, errSub = originalIO.safeClearFolder(entry, { removeRoot = true })
				if not okSub then
					return false, errSub
				end
				if delfolder then
					local okDel, errDel = pcall(delfolder, entry)
					if not okDel then
						return false, errDel or ("Failed to remove "..entry)
					end
				end
			else
				if isfile and isfile(entry) then
					local okDel, errDel = pcall(delfile, entry)
					if not okDel then
						return false, errDel or ("Failed to delete "..entry)
					end
				end
			end
		end
	end

	local removedRoot = false
	if opts.removeRoot then
		if delfolder then
			local okDel, errDel = pcall(delfolder, path)
			if not okDel then
				return false, errDel or ("Failed to remove "..path)
			end
			removedRoot = true
		end
	end

	if (opts.recreate or (opts.removeRoot and not removedRoot)) and makefolder then
		local okMk, errMk = pcall(makefolder, path)
		if not okMk then
			return false, errMk or ("Failed to recreate "..path)
		end
	end

	if opts.removeRoot and not removedRoot and not delfolder then
		return true, "Cleared folder contents (folder kept; executor lacks delfolder)."
	end
	if removedRoot and opts.recreate then
		return true, "Folder rebuilt."
	elseif removedRoot then
		return true, "Folder removed."
	end
	return true, "Folder cleared."
end

NAStuff.clnExtMap = NAStuff.clnExtMap or {
	json = "JSON Source File",
	txt = "Text Source File",
	lua = "Lua Script",
	luau = "Luau Script",
	log = "Log File",
	cfg = "Config File",
	ini = "Config File",
	dat = "Data File",
	png = "PNG Image",
	jpg = "JPEG Image",
	jpeg = "JPEG Image",
	webp = "WebP Image",
	bmp = "Bitmap Image",
	mp3 = "MP3 Audio",
	wav = "WAV Audio",
	ogg = "OGG Audio",
}

function NAmanage.clnBase(path)
	return tostring(path):match("([^/\\]+)$") or tostring(path)
end

function NAmanage.clnDisp(path, kind)
	if kind == "folder" then
		return "Folder"
	end
	local name = NAmanage.clnBase(path)
	local ext = name:match("%.([^%.]+)$")
	if not ext then
		return "File"
	end
	local extLower = Lower(ext)
	return NAStuff.clnExtMap[extLower] or (string.upper(extLower).." File")
end

function NAmanage.clnList()
	local entries = {}
	if not FileSupport or not (listfiles and isfolder and isfolder(NAfiles.NAFILEPATH)) then
		return entries
	end

	local okList, children = pcall(listfiles, NAfiles.NAFILEPATH)
	if not okList or type(children) ~= "table" then
		return entries
	end

	table.sort(children, function(a, b)
		return NAmanage.clnBase(a):lower() < NAmanage.clnBase(b):lower()
	end)

	for _, path in ipairs(children) do
		local label = NAmanage.clnBase(path)
		if label and label ~= "" then
			local isDir = isfolder(path)
			entries[#entries + 1] = {
				label = label,
				path = path,
				kind = isDir and "folder" or "file",
				displayType = NAmanage.clnDisp(path, isDir and "folder" or "file"),
				removeRoot = isDir and true or nil,
				recreate = isDir and true or nil,
				success = Format("%s removed.", label),
			}
		end
	end

	if #entries > 0 then
		Insert(entries, 1, {
			label = "[Clear Entire Folder]",
			path = NAfiles.NAFILEPATH,
			kind = "folder",
			displayType = "Nameless-Admin folder",
			removeRoot = true,
			recreate = true,
			success = "Nameless-Admin folder cleared.",
		})
	end

	return entries
end

function NAmanage.buildSettingsCleanupButtons()
	local buttons = {}
	if not FileSupport then
		return buttons
	end

	for _, opt in ipairs(NAmanage.clnList()) do
		local buttonText = Format("%s (%s)", opt.label, opt.displayType or opt.kind)
		Insert(buttons, {
			Text = buttonText,
			Callback = function()
				local ok, info
				if opt.kind == "file" then
					ok, info = originalIO.safeDeleteFile(opt.path)
				else
					ok, info = originalIO.safeClearFolder(opt.path, { removeRoot = opt.removeRoot, recreate = opt.recreate })
				end

				if ok then
					DoNotif(opt.success or info or Format("%s removed.", opt.label), 3)
					if type(opt.after) == "function" then
						pcall(opt.after)
					end
				else
					DoNotif(opt.failure or Format("Failed to remove %s: %s", opt.label, tostring(info)), 4)
				end
			end,
		})
	end

	return buttons
end

function NAmanage.openSettingsCleanupPopup()
	if not FileSupport then
		DoNotif("File support is required to delete saved settings.", 3)
		return
	end
	if type(Popup) ~= "function" then
		DoNotif("Popup UI is unavailable in this session.", 3)
		return
	end

	local buttons = NAmanage.buildSettingsCleanupButtons()
	if #buttons == 0 then
		DoNotif("No saved Nameless-Admin files or folders were found.", 3)
		return
	end

	Popup({
		Title = "Delete Saved Settings",
		Description = "Select a saved file or folder to remove. This action cannot be undone.",
		Duration = 0,
		Buttons = buttons,
	})
end

opt.chatTranslateEnabled = NAmanage.NASettingsGet("chatTranslate")
opt.chatTranslateTarget = NAmanage.NASettingsGet("chatTranslateTarget")
NAStuff.AutoExecEnabled = NAmanage.NASettingsGet("autoExecEnabled")
NAStuff.UserButtonsAutoLoad = NAmanage.NASettingsGet("userButtonsAutoLoad")
NAStuff.CmdBar2AutoRun = NAmanage.NASettingsGet("cmdbar2AutoRun")
NAStuff.NetworkPauseDisabled = NAmanage.NASettingsGet("networkPauseDisabled")
NAStuff.PurchasePromptsDisabled = NAmanage.NASettingsGet("purchasePromptsDisabled")
NAStuff.CmdIntegrationAutoRun = NAmanage.NASettingsGet("cmdIntegrationAutoRun")
NAStuff.AutoPreloadAssets = NAmanage.NASettingsGet("autoPreloadAssets")
NAStuff.AssetLoadMode = NAmanage.NASettingsGet("assetLoadMode") or NAStuff.AssetLoadMode

pcall(NAmanage.SetAssetLoadMode, NAStuff.AssetLoadMode)

NAmanage.loadIntegration=function()
	local integ = NAStuff.Integrations or {}
	integ.webhook = integ.webhook or {}
	integ.webhook.urls = integ.webhook.urls or {}
	local function asString(v)
		return type(v) == "string" and v or ""
	end
	integ.webhook.urls.main = integ.webhook.urls.main or integ.webhook.url or integ.webhook.urls.all or ""
	local function readUrl(key, fallback)
		local value = asString(NAmanage.NASettingsGet(key))
		if value ~= "" then
			return value
		end
		return fallback
	end
	integ.webhook.urls.main = readUrl("integrationWebhookUrlMain", integ.webhook.urls.main or "")
	integ.webhook.urls.all = readUrl("integrationWebhookUrlAll", integ.webhook.urls.all or "")
	if integ.webhook.urls.all == "" then
		local legacy = asString(NAmanage.NASettingsGet("integrationWebhookUrl"))
		if legacy ~= "" then
			integ.webhook.urls.all = legacy
		end
	end
	integ.webhook.urls.joinleave = readUrl("integrationWebhookUrlJoinLeave", integ.webhook.urls.joinleave or "")
	integ.webhook.urls.chat = readUrl("integrationWebhookUrlChat", integ.webhook.urls.chat or "")
	integ.webhook.urls.commands = readUrl("integrationWebhookUrlCommands", integ.webhook.urls.commands or "")
	integ.webhook.url = integ.webhook.urls.all
	local useAllSaved = NAmanage.NASettingsGet("integrationWebhookUseAll")
	if type(useAllSaved) == "boolean" then
		integ.webhook.useAll = useAllSaved
	end
	integ.webhook.useAll = integ.webhook.useAll == true
	integ.webhook.enableJoinLeave = NAmanage.NASettingsGet("integrationWebhookJoinLeave") == true or integ.webhook.enableJoinLeave == true
	integ.webhook.enableChat = NAmanage.NASettingsGet("integrationWebhookChat") == true or integ.webhook.enableChat == true
	integ.webhook.enableCommands = NAmanage.NASettingsGet("integrationWebhookCommands") == true or integ.webhook.enableCommands == true
	local clampNum = (NAmanage and NAmanage.clampNumber) or function(v, lo, hi, fallback)
		local n = tonumber(v)
		if not n then return fallback end
		if lo and n < lo then n = lo end
		if hi and n > hi then n = hi end
		return n
	end
	integ.webhook.minInterval = clampNum(NAmanage.NASettingsGet("integrationWebhookInterval"), 0, 120, integ.webhook.minInterval or 2)

	local eps = NAmanage.NASettingsGet("integrationHealthEndpoints")
	if type(eps) == "table" then
		integ.health = integ.health or { endpoints = {} }
		integ.health.endpoints = {}
		for i = 1, math.min(#eps, 3) do
			if type(eps[i]) == "string" and eps[i] ~= "" then
				integ.health.endpoints[i] = eps[i]
			end
		end
	elseif type(eps) == "string" and eps ~= "" then
		integ.health = integ.health or { endpoints = {} }
		integ.health.endpoints = { eps }
	end

	integ.notes = integ.notes or {}
	local noteSaved = NAmanage.NASettingsGet("integrationNotesLast")
	if type(noteSaved) == "string" then
		integ.notes.last = noteSaved
	end

	integ.rpc = integ.rpc or {}
	integ.rpc.useCustom = NAmanage.NASettingsGet("integrationRpcUseCustom") == true or integ.rpc.useCustom == true
	local rd = NAmanage.NASettingsGet("integrationRpcDetails")
	local rs = NAmanage.NASettingsGet("integrationRpcState")
	if type(rd) == "string" then integ.rpc.details = rd end
	if type(rs) == "string" then integ.rpc.state = rs end
	NAStuff.Integrations = integ
end
NAmanage.loadIntegration()

NAStuff.CmdBar2Width = NAmanage.CmdBar2ClampValue(NAmanage.NASettingsGet("cmdbar2Width"), NAStuff.CmdBar2.minWidth, NAStuff.CmdBar2.maxWidth, NAStuff.CmdBar2.defaultWidth)
NAStuff.CmdBar2Height = NAmanage.CmdBar2ClampValue(NAmanage.NASettingsGet("cmdbar2Height"), NAStuff.CmdBar2.minHeight, NAStuff.CmdBar2.maxHeight, NAStuff.CmdBar2.defaultHeight)
_G.NAFreecamKeybindEnabled = NAmanage.NASettingsGet("freecamKeybind")
NAStuff.FreecamSpeed = math.clamp(tonumber(NAmanage.NASettingsGet("freecamSpeed")) or 5, 0.05, 20)
if NAFreecam and NAFreecam.SetSpeed then
	NAFreecam.SetSpeed(math.clamp(NAStuff.FreecamSpeed / 5, 0.01, 4))
end

if FileSupport then
	prefixCheck = NAmanage.NASettingsGet("prefix")
	NAsavedScale = NAmanage.NASettingsGet("buttonSize")
	NAUISavedScale = NAmanage.NASettingsGet("uiScale")
	NAQoTEnabled = NAmanage.NASettingsGet("queueOnTeleport")
	NAStuff.nuhuhNotifs = NAmanage.NASettingsGet("notifsToggle")
	local savedTweenSpeed = NAmanage.NASettingsGet("tweenSpeed")
	if type(savedTweenSpeed) == "number" and savedTweenSpeed > 0 then
		NAStuff.tweenSpeed = savedTweenSpeed
	end
	doPREDICTION = NAmanage.NASettingsGet("prediction")
	NAUISTROKER = InitUIStroke()
	if NAStuff and NAStuff.AprilFoolsData then
		NAStuff.AprilFoolsData.originalColor = NAUISTROKER
	end
	NAStuff.IconInvisible = NAmanage.NASettingsGet("iconInvisible")
	NAStuff.IconLocked = NAmanage.NASettingsGet("iconLocked")
	NATOPBARVISIBLE = NAmanage.NASettingsGet("topbarVisible")
	NATopbarKeepPosition = NAmanage.NASettingsGet("topbarKeepPosition")
	NATopbarPositionRatio = NAmanage.NASettingsGet("topbarPositionRatio") or 0
	NATopbarDock = NAmanage.topbar_readDock()
	NASideSwipeSide = NAmanage.NASettingsGet("sideSwipeSide") or NASideSwipeSide
	NASideSwipeEnabled = NAmanage.NASettingsGet("sideSwipeEnabled") or NASideSwipeEnabled
	NADisableLastInput = NAmanage.NASettingsGet("disableLastInput")
	local function clamp01(v, fallback)
		local n = tonumber(v)
		if not n then return fallback end
		if n < 0 then n = 0 elseif n > 1 then n = 1 end
		return n
	end
	NAStuff.SideSwipeWidth = math.clamp(math.floor((tonumber(NAmanage.NASettingsGet("sideSwipeWidth")) or 80) + 0.5), 60, 200)
	NAStuff.SideSwipeHandleTransparency = clamp01(NAmanage.NASettingsGet("sideSwipeHandleTransparency") or 0.72, 0.72)
	NALoadingStartMinimized = NAmanage.NASettingsGet("loadingStartMinimized")
	NAAssetsLoading.applyMinimizedPreference()
	NAStuff.TopbarGlassTransparency = clamp01(NAmanage.NASettingsGet("topbarGlassTransparency") or 0.12, 0.12)
	NAStuff.TopbarStrokeTransparency = clamp01(NAmanage.NASettingsGet("topbarStrokeTransparency") or 0.15, 0.15)
	NAStuff.iconAppearancePrefs = {
		background = NAmanage.NASettingsGet("iconBgTransparency"),
		image = NAmanage.NASettingsGet("iconImageTransparency"),
		text = NAmanage.NASettingsGet("iconTextTransparency"),
		stroke = NAmanage.NASettingsGet("iconStrokeTransparency"),
	}

	if prefixCheck == "" or utf8.len(prefixCheck) > 1 or prefixCheck:match("[%w]")
		or prefixCheck:match("[%[%]%(%)%*%^%$%%{}<>]")
		or prefixCheck:match("&amp;") or prefixCheck:match("&lt;") or prefixCheck:match("&gt;")
		or prefixCheck:match("&quot;") or prefixCheck:match("&#x27;") or prefixCheck:match("&#x60;") then

		prefixCheck = ";"
		NAmanage.NASettingsSet("prefix", ";")
		DoNotif("Your prefix has been reset to the default (;) due to invalid symbol.")
	end

	if NAsavedScale and NAsavedScale > 0 then
		NAScale = NAsavedScale
	else
		NAScale = 1
		NAmanage.NASettingsSet("buttonSize", 1)
		DoNotif("ImageButton size has been reset to default due to invalid data.")
	end

	if NAUISavedScale and NAUISavedScale > 0 then
		NAUIScale = NAUISavedScale
	else
		NAUIScale = 1
		NAmanage.NASettingsSet("uiScale", 1)
		DoNotif("UI Scale has been reset to default due to invalid data.")
	end
	if isfile(NAfiles.NAJOINLEAVE) then
		local success, data = pcall(function()
			return HttpService:JSONDecode(readfile(NAfiles.NAJOINLEAVE))
		end)

		if success and type(data) == "table" then
			NAmanage.jlCfg = data
		end
	end

	NAmanage.jlCfg = NAmanage.jlNorm(NAmanage.jlCfg)
	NAmanage.logApply()

	local iconPosData = NAmanage.NASettingsGet and NAmanage.NASettingsGet("iconPosition") or nil
	if type(iconPosData) ~= "table" then
		iconPosData = { X = 0.5; Y = 0.1 }
		pcall(NAmanage.NASettingsSet, "iconPosition", iconPosData)
	end

	local clampedX = math.clamp(tonumber(iconPosData.X) or 0.5, 0, 1)
	local clampedY = math.clamp(tonumber(iconPosData.Y) or 0.1, 0, 1)
	if clampedX ~= iconPosData.X or clampedY ~= iconPosData.Y then
		pcall(NAmanage.NASettingsSet, "iconPosition", {
			X = clampedX;
			Y = clampedY;
		})
	end

	local keepIcon = NAmanage.NASettingsGet and NAmanage.NASettingsGet("iconKeepPosition")
	NAiconSaveEnabled = keepIcon == true

	local path = NAmanage.GetWPPath()
	local ok, data = false, nil

	if isfile(path) then
		ok, data = pcall(function()
			return HttpService:JSONDecode(readfile(path))
		end)
	end

	Waypoints = (ok and type(data) == "table") and data or {}

	local ok, data = pcall(function() return HttpService:JSONDecode(readfile(bindersPath)) end)
	Bindings = ok and type(data)=="table" and data or {}

	do
		local src = Bindings["OnSpawned"]
		if type(src) == "table" and #src > 0 then
			Bindings["OnSpawn"] = Bindings["OnSpawn"] or {}
			for _, line in ipairs(src) do
				if line:match("^%s*[<%[]") then
					Insert(Bindings["OnSpawn"], line)
				else
					Insert(Bindings["OnSpawn"], "<me> "..line)
				end
			end
			Bindings["OnSpawned"] = nil
			NAmanage.SaveBinders()
		end
	end

	NAmanage.LoadCommandKeybinds()

	local ChatConfigPath = NAfiles.NATEXTCHATSETTINGSPATH

	local function tblToC3(t)
		if typeof(t) == "Color3" then return t end
		local r = (t and (t.R or t[1])) or 255
		local g = (t and (t.G or t[2])) or 255
		local b = (t and (t.B or t[3])) or 255
		return Color3.fromRGB(r, g, b)
	end
	local function c3ToTbl(c)
		return { math.floor(c.R * 255 + 0.5), math.floor(c.G * 255 + 0.5), math.floor(c.B * 255 + 0.5) }
	end
	local function clampAlpha(v)
		return math.clamp(tonumber(v) or 0, 0, 1)
	end
	local function blendColorAlpha(base, bg, alpha)
		bg = bg or Color3.new(0, 0, 0)
		alpha = clampAlpha(alpha)
		if alpha <= 0 then
			return base
		end
		return Color3.new(
			base.R + (bg.R - base.R) * alpha,
			base.G + (bg.G - base.G) * alpha,
			base.B + (bg.B - base.B) * alpha
		)
	end

	NAStuff.ChatSettings = NAStuff.ChatSettings or {}
	NAStuff.ChatSettings.input = NAStuff.ChatSettings.input or {}
	NAStuff.ChatSettings.input.textTransparency = nil

	local chatKeyBlockAction = "NA_BlockSlashChatKey"
	NAmanage.ApplyChatKeyBlock = function(enumKey)
		if not ContextActionService then
			return
		end
		pcall(function()
			ContextActionService:UnbindAction(chatKeyBlockAction)
		end)
		if IsOnMobile then
			return
		end
		if enumKey == Enum.KeyCode.Slash then
			return
		end
		local ok, err = pcall(function()
			ContextActionService:BindActionAtPriority(chatKeyBlockAction, function(_, state)
				if state == Enum.UserInputState.Begin then
					return Enum.ContextActionResult.Sink
				end
				return Enum.ContextActionResult.Pass
			end, false, Enum.ContextActionPriority.High.Value, Enum.KeyCode.Slash)
		end)
		if not ok then
			warn("[NA] Chat key block failed:", err)
		end
	end
	local function deepMerge(dst, src)
		for k, v in pairs(src) do
			if type(v) == "table" and type(dst[k]) == "table" then
				deepMerge(dst[k], v)
			else
				dst[k] = v
			end
		end
	end

	NAStuff.ChatSettingsTemplate = originalIO.deepCopyTable(NAStuff.ChatSettings)

	local function loadChat()
		local cfg = originalIO.deepCopyTable(NAStuff.ChatSettingsTemplate or NAStuff.ChatSettings)
		if isfile(ChatConfigPath) then
			local ok3, d = pcall(function() return HttpService:JSONDecode(readfile(ChatConfigPath)) end)
			if ok3 and type(d)=="table" then deepMerge(cfg, d) end
		end
		if cfg and cfg.bubbles then
			local mb = tonumber(cfg.bubbles.maxBubbles)
			if mb then
				cfg.bubbles.maxBubbles = math.max(1, math.min(5, mb))
			end
		end
		return cfg
	end

	NAStuff.ChatSettings = loadChat()

	originalIO.getChatTemplateSection=function(section)
		local template = NAStuff.ChatSettingsTemplate
		if type(template) ~= "table" then return nil end
		return template[section]
	end

	originalIO.assignChatSectionFromTemplate=function(section)
		local defaults = originalIO.getChatTemplateSection(section)
		if defaults == nil then return false end
		if type(defaults) == "table" then
			NAStuff.ChatSettings[section] = originalIO.deepCopyTable(defaults)
		else
			NAStuff.ChatSettings[section] = defaults
		end
		return true
	end

	originalIO.ensureChatCustomBackup=function()
		if type(NAStuff.ChatSettingsCustomBackup) ~= "table" then
			NAStuff.ChatSettingsCustomBackup = {}
		end
		return NAStuff.ChatSettingsCustomBackup
	end

	originalIO.backupChatSection=function(section)
		if type(NAStuff.ChatSettings) ~= "table" then return end
		local current = NAStuff.ChatSettings[section]
		if current == nil then return end
		local backup = originalIO.ensureChatCustomBackup()
		if type(current) == "table" then
			backup[section] = originalIO.deepCopyTable(current)
		else
			backup[section] = current
		end
	end

	originalIO.restoreChatSectionFromBackup=function(section)
		local backup = NAStuff.ChatSettingsCustomBackup
		if type(backup) ~= "table" then return false end
		local saved = backup[section]
		if saved == nil then return false end
		if type(saved) == "table" then
			NAStuff.ChatSettings[section] = originalIO.deepCopyTable(saved)
		else
			NAStuff.ChatSettings[section] = saved
		end
		return true
	end

	NAmanage.SaveTextChatSettings = function()
		local ok4, json = pcall(function() return HttpService:JSONEncode(NAStuff.ChatSettings) end)
		if ok4 then pcall(writefile, ChatConfigPath, json) end
		if NAmanage.SyncChatSettingsUI then
			NAmanage.SyncChatSettingsUI()
		end
	end

	NAmanage.SyncChatSettingsUI = function(opts)
		opts = opts or {}
		local shouldFire = opts.fire == true
		local chat = NAStuff.ChatSettings
		if type(chat) ~= "table" then return end

		local window = chat.window or {}
		local tabs = chat.tabs or {}
		local input = chat.input or {}
		local bubbles = chat.bubbles or {}

		local function setToggle(label, value)
			if not NAgui.setToggleState then return end
			NAgui.setToggleState(label, value and true or false, { force = true, fire = shouldFire and true or false })
		end

		local function setSlider(label, value)
			if value == nil or not NAgui.setSliderValue then return end
			if type(value) ~= "number" then return end
			NAgui.setSliderValue(label, value, { force = true, fire = shouldFire and true or false })
		end

		local function setColor(label, value)
			if value == nil or not NAgui.setColorPickerValue then return end
			local ok, color = pcall(tblToC3, value)
			if not ok or typeof(color) ~= "Color3" then return end
			NAgui.setColorPickerValue(label, color, { fire = shouldFire and true or false })
		end

		setToggle("Enable Custom Chat Styling", chat.customEnabled)
		setToggle("Enable Chat (CoreGui)", chat.coreGuiChat)
		setToggle("Window Enabled", window.enabled)
		setToggle("Tabs Enabled", tabs.enabled)
		setToggle("Input Enabled", input.enabled)
		setToggle("Autocomplete", input.autocomplete)
		setToggle("Target #RBXGeneral", input.targetGeneral)
		setToggle("Bubbles Enabled", bubbles.enabled)
		setToggle("Tail Visible", bubbles.tailVisible)

		setSlider("Text Size (Window)", window.textSize)
		setSlider("Text Transparency (Window)", window.textTransparency)
		setSlider("Text Stroke Transparency", window.strokeTransparency)
		setSlider("Window Background Transparency", window.backgroundTransparency)
		setSlider("Text Size (Tabs)", tabs.textSize)
		setSlider("Text Transparency (Tabs)", tabs.textTransparency)
		setSlider("Background Transparency (Tabs)", tabs.backgroundTransparency)
		setSlider("Text Size (Input)", input.textSize)
		setSlider("Text Stroke Transparency (Input)", input.strokeTransparency)
		setSlider("Background Transparency (Input)", input.backgroundTransparency)
		setSlider("Max Distance", bubbles.maxDistance)
		setSlider("Minimize Distance", bubbles.minimizeDistance)
		setSlider("Text Size (Bubble)", bubbles.textSize)
		setSlider("Bubble Spacing", bubbles.spacing)
		setSlider("Text Transparency (Bubble)", bubbles.textTransparency)
		setSlider("Background Transparency (Bubble)", bubbles.backgroundTransparency)
		setSlider("Bubble Duration", bubbles.bubbleDuration)
		setSlider("Max Bubbles", bubbles.maxBubbles)

		setColor("Text Color", window.textColor)
		setColor("Text Stroke Color", window.strokeColor)
		setColor("Window Background", window.backgroundColor)
		setColor("Tab Background", tabs.backgroundColor)
		setColor("Text Color (Tabs)", tabs.textColor)
		setColor("Selected Text Color", tabs.selectedTextColor)
		setColor("Unselected Text Color", tabs.unselectedTextColor)
		setColor("Text Color (Input)", input.textColor)
		setColor("Input Background", input.backgroundColor)
		setColor("Input Stroke Color", input.strokeColor)
		setColor("Bubble Text Color", bubbles.textColor)
		setColor("Bubble Background", bubbles.backgroundColor)
	end

	local function hasProp(inst, prop)
		return inst and NAlib.isProperty(inst, prop) ~= nil
	end
	local function safeSet(inst, prop, val)
		if inst and hasProp(inst, prop) then NAlib.setProperty(inst, prop, val) end
	end
	local function getDefaultChannel(TCS)
		local container = TCS:FindFirstChild("TextChannels")
		if not container then return nil end
		local gen = container:FindFirstChild("RBXGeneral")
		if gen and gen:IsA("TextChannel") then return gen end
		for _, c in ipairs(container:GetChildren()) do
			if c:IsA("TextChannel") then return c end
		end
		return nil
	end

	originalIO.getChatDefaults=function()
		if not NAStuff.ChatSettingsDefaults then
			NAStuff.ChatSettingsDefaults = {
				window = {};
				tabs = {};
				input = {};
				bubbles = {};
			}
		end
		return NAStuff.ChatSettingsDefaults
	end

	originalIO.rememberChatDefault=function(group, inst, prop)
		if not inst then return end
		local defaults = originalIO.getChatDefaults()
		local groupDefaults = defaults[group]
		local info = groupDefaults[prop]
		if info and info.source == inst then return end
		if not hasProp(inst, prop) then return end
		local ok, value = pcall(function() return inst[prop] end)
		if not ok then return end
		groupDefaults[prop] = { has = true, value = value, source = inst }
	end

	originalIO.captureChatDefaults=function(Window, Tabs, InputBar, Bubbles)
		local function captureGroup(group, inst, props)
			if not inst then return end
			for _, prop in ipairs(props) do
				originalIO.rememberChatDefault(group, inst, prop)
			end
		end

		originalIO.getChatDefaults()
		captureGroup("window", Window, { "Enabled", "FontFace", "TextSize", "TextColor3", "TextTransparency", "TextStrokeColor3", "TextStrokeTransparency", "BackgroundColor3", "BackgroundTransparency" })
		captureGroup("tabs", Tabs, { "Enabled", "FontFace", "TextSize", "BackgroundColor3", "BackgroundTransparency", "TextColor3", "TextTransparency", "SelectedTabTextColor3", "UnselectedTabTextColor3" })
		captureGroup("input", InputBar, { "Enabled", "AutocompleteEnabled", "FontFace", "TargetTextChannel", "KeyboardKeyCode", "TextSize", "TextColor3", "TextStrokeColor3", "TextStrokeTransparency", "BackgroundColor3", "BackgroundTransparency" })
		captureGroup("bubbles", Bubbles, { "Enabled", "MaxDistance", "MinimizeDistance", "TextSize", "TextColor3", "TextTransparency", "BubblesSpacing", "BackgroundColor3", "BackgroundTransparency", "BubbleDuration", "MaxBubbles", "TailVisible" })
	end

	originalIO.applyChatDefaultGroup=function(group, inst)
		local defaults = NAStuff.ChatSettingsDefaults
		if not defaults or not inst then return end
		local groupDefaults = defaults[group]
		if not groupDefaults then return end
		for prop, info in pairs(groupDefaults) do
			if info and info.has then
				safeSet(inst, prop, info.value)
			end
		end
	end

	originalIO.restoreChatDefaults=function(Window, Tabs, InputBar, Bubbles)
		originalIO.applyChatDefaultGroup("window", Window)
		originalIO.applyChatDefaultGroup("tabs", Tabs)
		originalIO.applyChatDefaultGroup("input", InputBar)
		originalIO.applyChatDefaultGroup("bubbles", Bubbles)
	end

	NAStuff.ChatSettings = NAStuff.ChatSettings or {}
	NAStuff.ChatSettings.input = NAStuff.ChatSettings.input or {}
	NAStuff.ChatSettings.input.textTransparency = nil

	NAmanage.ApplyTextChatSettings = function()
		pcall(function() StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.Chat, NAStuff.ChatSettings.coreGuiChat) end)
		local TCS = TextChatService

		local Window = TCS:FindFirstChildOfClass("ChatWindowConfiguration")
		local InputBar = TCS:FindFirstChildOfClass("ChatInputBarConfiguration")
		local Bubbles = TCS:FindFirstChildOfClass("BubbleChatConfiguration")
		local Tabs = TCS:FindFirstChildOfClass("ChannelTabsConfiguration")

		originalIO.captureChatDefaults(Window, Tabs, InputBar, Bubbles)

		if not NAStuff.ChatSettings.customEnabled then
			if NAStuff.ChatCustomizationActive ~= false then
				originalIO.restoreChatDefaults(Window, Tabs, InputBar, Bubbles)
			end
			NAStuff.ChatCustomizationActive = false
			return
		end
		NAStuff.ChatCustomizationActive = true

		if Window then
			local windowText = tblToC3(NAStuff.ChatSettings.window.textColor)
			local windowBg = tblToC3(NAStuff.ChatSettings.window.backgroundColor)
			local windowAlpha = clampAlpha(NAStuff.ChatSettings.window.textTransparency)
			local windowHasAlpha = hasProp(Window, "TextTransparency")
			local windowColor = windowHasAlpha and windowText or blendColorAlpha(windowText, windowBg, windowAlpha)
			safeSet(Window, "Enabled", NAStuff.ChatSettings.window.enabled)
			if hasProp(Window, "FontFace") and NAStuff.ChatSettings.window.font then pcall(function() Window.FontFace = Font.new(NAStuff.ChatSettings.window.font) end) end
			safeSet(Window, "TextSize", NAStuff.ChatSettings.window.textSize)
			safeSet(Window, "TextColor3", windowColor)
			if windowHasAlpha then
				safeSet(Window, "TextTransparency", windowAlpha)
			end
			safeSet(Window, "TextStrokeColor3", tblToC3(NAStuff.ChatSettings.window.strokeColor))
			safeSet(Window, "TextStrokeTransparency", NAStuff.ChatSettings.window.strokeTransparency)
			safeSet(Window, "BackgroundColor3", tblToC3(NAStuff.ChatSettings.window.backgroundColor))
			safeSet(Window, "BackgroundTransparency", NAStuff.ChatSettings.window.backgroundTransparency)
		end

		if Tabs then
			local tabsBg = tblToC3(NAStuff.ChatSettings.tabs.backgroundColor)
			local tabsAlpha = clampAlpha(NAStuff.ChatSettings.tabs.textTransparency)
			local tabsText = tblToC3(NAStuff.ChatSettings.tabs.textColor)
			local tabsSelected = tblToC3(NAStuff.ChatSettings.tabs.selectedTextColor)
			local tabsUnselected = tblToC3(NAStuff.ChatSettings.tabs.unselectedTextColor)
			local tabsHasAlpha = hasProp(Tabs, "TextTransparency")
			safeSet(Tabs, "Enabled", NAStuff.ChatSettings.tabs.enabled)
			if hasProp(Tabs, "FontFace") and NAStuff.ChatSettings.tabs.font then pcall(function() Tabs.FontFace = Font.new(NAStuff.ChatSettings.tabs.font) end) end
			safeSet(Tabs, "TextSize", NAStuff.ChatSettings.tabs.textSize)
			safeSet(Tabs, "BackgroundColor3", tblToC3(NAStuff.ChatSettings.tabs.backgroundColor))
			safeSet(Tabs, "BackgroundTransparency", NAStuff.ChatSettings.tabs.backgroundTransparency)
			safeSet(Tabs, "TextColor3", tabsHasAlpha and tabsText or blendColorAlpha(tabsText, tabsBg, tabsAlpha))
			if tabsHasAlpha then
				safeSet(Tabs, "TextTransparency", tabsAlpha)
			end
			safeSet(Tabs, "SelectedTabTextColor3", tabsHasAlpha and tabsSelected or blendColorAlpha(tabsSelected, tabsBg, tabsAlpha))
			safeSet(Tabs, "UnselectedTabTextColor3", tabsHasAlpha and tabsUnselected or blendColorAlpha(tabsUnselected, tabsBg, tabsAlpha))
		end

		if InputBar then
			local inputBg = tblToC3(NAStuff.ChatSettings.input.backgroundColor)
			local inputText = tblToC3(NAStuff.ChatSettings.input.textColor)
			safeSet(InputBar, "Enabled", NAStuff.ChatSettings.input.enabled)
			safeSet(InputBar, "AutocompleteEnabled", NAStuff.ChatSettings.input.autocomplete)
			if hasProp(InputBar, "FontFace") and NAStuff.ChatSettings.input.font then pcall(function() InputBar.FontFace = Font.new(NAStuff.ChatSettings.input.font) end) end
			if NAStuff.ChatSettings.input.targetGeneral and hasProp(InputBar, "TargetTextChannel") then
				local ch = getDefaultChannel(TCS)
				if ch then safeSet(InputBar, "TargetTextChannel", ch) end
			end
			if not IsOnMobile then
				local keyName = tostring(NAStuff.ChatSettings.input.keyCode or "Slash")
				local enumKey = Enum.KeyCode[keyName] or Enum.KeyCode.Slash
				safeSet(InputBar, "KeyboardKeyCode", enumKey)
				if NAmanage.ApplyChatKeyBlock then
					NAmanage.ApplyChatKeyBlock(enumKey)
				end
			end
			safeSet(InputBar, "TextSize", NAStuff.ChatSettings.input.textSize)
			safeSet(InputBar, "TextColor3", inputText)
			safeSet(InputBar, "TextStrokeColor3", tblToC3(NAStuff.ChatSettings.input.strokeColor))
			safeSet(InputBar, "TextStrokeTransparency", NAStuff.ChatSettings.input.strokeTransparency)
			safeSet(InputBar, "BackgroundColor3", tblToC3(NAStuff.ChatSettings.input.backgroundColor))
			safeSet(InputBar, "BackgroundTransparency", NAStuff.ChatSettings.input.backgroundTransparency)
		end

		if Bubbles then
			local bubbleBg = tblToC3(NAStuff.ChatSettings.bubbles.backgroundColor)
			local bubbleAlpha = clampAlpha(NAStuff.ChatSettings.bubbles.textTransparency)
			local bubbleText = tblToC3(NAStuff.ChatSettings.bubbles.textColor)
			local bubbleHasAlpha = hasProp(Bubbles, "TextTransparency")
			safeSet(Bubbles, "Enabled", NAStuff.ChatSettings.bubbles.enabled)
			if hasProp(Bubbles, "MaxDistance") then safeSet(Bubbles, "MaxDistance", math.max(NAStuff.ChatSettings.bubbles.maxDistance, 0)) end
			if hasProp(Bubbles, "MinimizeDistance") then safeSet(Bubbles, "MinimizeDistance", math.max(NAStuff.ChatSettings.bubbles.minimizeDistance, 0)) end
			if hasProp(Bubbles, "TextSize") then safeSet(Bubbles, "TextSize", math.max(NAStuff.ChatSettings.bubbles.textSize, 1)) end
			if hasProp(Bubbles, "TextColor3") then safeSet(Bubbles, "TextColor3", bubbleHasAlpha and bubbleText or blendColorAlpha(bubbleText, bubbleBg, bubbleAlpha)) end
			if bubbleHasAlpha then
				safeSet(Bubbles, "TextTransparency", bubbleAlpha)
			end
			if hasProp(Bubbles, "BubblesSpacing") then safeSet(Bubbles, "BubblesSpacing", math.max(NAStuff.ChatSettings.bubbles.spacing, 0)) end
			if hasProp(Bubbles, "BackgroundColor3") then safeSet(Bubbles, "BackgroundColor3", bubbleBg) end
			safeSet(Bubbles, "BackgroundTransparency", math.clamp(NAStuff.ChatSettings.bubbles.backgroundTransparency, 0, 1))
			if hasProp(Bubbles, "BubbleDuration") then safeSet(Bubbles, "BubbleDuration", math.max(1, tonumber(NAStuff.ChatSettings.bubbles.bubbleDuration) or 0)) end
			if hasProp(Bubbles, "MaxBubbles") then safeSet(Bubbles, "MaxBubbles", math.max(1, math.min(5, tonumber(NAStuff.ChatSettings.bubbles.maxBubbles) or 1))) end
			safeSet(Bubbles, "TailVisible", NAStuff.ChatSettings.bubbles.tailVisible)
		end
	end

	NAlib.disconnect("TCS_OnDescendantAdded")
	NAlib.connect("TCS_OnDescendantAdded", TextChatService.DescendantAdded:Connect(function()
		Defer(NAmanage.ApplyTextChatSettings)
	end))

	NAlib.disconnect("TCS_ApplyLoop")
	do
		local last = os.clock()
		NAlib.connect("TCS_ApplyLoop", RunService.RenderStepped:Connect(function()
			local now = os.clock()
			if now - last >= 0.2 then
				last = now
				NAmanage.ApplyTextChatSettings()
			end
		end))
	end

	NAmanage.ApplyTextChatSettings()
else
	prefixCheck = ";"
	NAScale = 1
	NAQoTEnabled = false
	NAiconSaveEnabled = false
	NATopbarKeepPosition = false
	NATopbarPositionRatio = 0
	NATopbarDock = "top"
	NALoadingStartMinimized = false
	NAUISTROKER = Color3.fromRGB(148, 93, 255)
	opt.currentTagText = "Tag"
	opt.currentTagColor = Color3.fromRGB(0, 255, 170)
	opt.currentTagRGB = false
	DoPopup("Your exploit does not support read/write file")
	--opt.saveTag = fals
end
NAAssetsLoading.applyMinimizedPreference()

opt.prefix = prefixCheck
if NAmanage.SyncPrefixUI then
	NAmanage.SyncPrefixUI()
end

local lastPrefix = opt.prefix

--[[if opt.saveTag then
	SafeGetService("Players").LocalPlayer:SetAttribute("CustomNAtaggerText", opt.currentTagText)
	SafeGetService("Players").LocalPlayer:SetAttribute("CustomNAtaggerColor", opt.currentTagColor)
	SafeGetService("Players").LocalPlayer:SetAttribute("CustomNAtaggerRainbow", opt.currentTagRGB)
end]]

--[[ VARIABLES ]]--

local PlaceId,JobId,GameId=game.PlaceId,game.JobId,game.GameId
local Player=Players.LocalPlayer;
local plr=Players.LocalPlayer;
local PlrGui=Player:FindFirstChildWhichIsA("PlayerGui");
local TopBarApp={ top=nil; frame=nil; toggle=nil; tGlass=nil; tStroke=nil; icon=nil; panel=nil; underlay=nil; scroll=nil; layout=nil; isOpen=false; childButtons={}; buttonDefs={}, mode=NAmanage.topbar_readMode(), sidePref="right", dock=NATopbarDock or "top" }
local SideSwipeApp={ gui=nil; panel=nil; underlay=nil; scroll=nil; layout=nil; handles={left=nil,right=nil}; isOpen=false; animating=false; side=NASideSwipeSide or "left" }
--local IYLOADED=false--This is used for the ;iy command that executes infinite yield commands using this admin command script (BTW)
local Character=Player.Character;
local LegacyChat=TextChatService.ChatVersion==Enum.ChatVersion.LegacyChatService
local FakeLag=false
local Loopvoid=false
local loopgrab=false
local OrgDestroyHeight = nil
local Watch=false
local AntiVelocityLimit = nil
local Admin={}
CoreGui=COREGUI;
_G.NAadminsLol={
	11761417; -- Main
	530829101; --Viper
	817571515; --Aimlock
	1844177730; --glexinator
	2624269701; --Akim
	2502806181; --Main Alt
	1594235217; --Purple
	2845101018; --alt
	2019160453; --grim
	417995559; -- keepoo
}

NAStuff._ctrlLockKeys = NAStuff._ctrlLockKeys or "LeftShift,RightShift"
if NAStuff._ctrlLockPersist == nil then NAStuff._ctrlLockPersist = false end
NAStuff._ctrlLockList = NAStuff._ctrlLockList or {}
NAStuff._ctrlLockSet  = NAStuff._ctrlLockSet  or {}

NAmanage.IconSetInvisible = NAmanage.IconSetInvisible or function(hidden)
	NAStuff.IconInvisible = hidden and true or false
end

--[[ Some more variables ]]--

localPlayer=Player
LocalPlayer=Player
local character=Player.Character
local camera=workspace.CurrentCamera
local player,plr,lp=Players.LocalPlayer,Players.LocalPlayer,Players.LocalPlayer
cmds={
	Commands={};
	Aliases={};
	NASAVEDALIASES = {};
	_skipAutoSuffix = false;
}

NAmanage.resolveCommandName=function(name)
	name = (name or ""):lower()
	local entry = cmds.Commands[name] or cmds.Aliases[name]
	if not entry then return nil end
	for cmdName, data in pairs(cmds.Commands) do
		if data == entry then
			return cmdName
		end
	end
	return name
end

SpawnCall(function()
	local playerScripts = LocalPlayer:WaitForChild("PlayerScripts", math.huge)
	local playerModule = playerScripts:WaitForChild("PlayerModule", math.huge)
	local controlModule = playerModule:WaitForChild("ControlModule", math.huge)

	local ok, result = pcall(require, controlModule)
	if ok and result then
		opt.ctrlModule = result
	end
end)

customVECTORMOVE = Vector3.zero
thumberSTICKER = Vector2.zero

sussyINPUTTER = {
	W = false,
	A = false,
	S = false,
	D = false,
}

local function updateInputVector()
	local x, z = 0, 0
	if sussyINPUTTER.W then z = z + 1 end
	if sussyINPUTTER.S then z = z - 1 end
	if sussyINPUTTER.A then x = x - 1 end
	if sussyINPUTTER.D then x = x + 1 end

	if thumberSTICKER.Magnitude > 0.1 then
		customVECTORMOVE = Vector3.new(thumberSTICKER.X, 0, thumberSTICKER.Y)
	else
		customVECTORMOVE = Vector3.new(x, 0, z)
	end

	if customVECTORMOVE.Magnitude > 1 then
		customVECTORMOVE = customVECTORMOVE.Unit
	end
end

UserInputService.InputBegan:Connect(function(input, gameProcessed)
	if gameProcessed then return end
	if input.KeyCode == Enum.KeyCode.W then sussyINPUTTER.W = true end
	if input.KeyCode == Enum.KeyCode.S then sussyINPUTTER.S = true end
	if input.KeyCode == Enum.KeyCode.A then sussyINPUTTER.A = true end
	if input.KeyCode == Enum.KeyCode.D then sussyINPUTTER.D = true end
	updateInputVector()
end)

UserInputService.InputEnded:Connect(function(input)
	if input.KeyCode == Enum.KeyCode.W then sussyINPUTTER.W = false end
	if input.KeyCode == Enum.KeyCode.S then sussyINPUTTER.S = false end
	if input.KeyCode == Enum.KeyCode.A then sussyINPUTTER.A = false end
	if input.KeyCode == Enum.KeyCode.D then sussyINPUTTER.D = false end
	updateInputVector()
end)

function GetCustomMoveVector()
	local fallback = Vector3.new(customVECTORMOVE.X, customVECTORMOVE.Y, -customVECTORMOVE.Z)

	if opt.ctrlModule then
		local ok, vec = pcall(function()
			return opt.ctrlModule:GetMoveVector()
		end)
		if ok and typeof(vec) == "Vector3" and vec.Magnitude > 0 then
			return vec
		end
	end

	if fallback.Magnitude > 0 then
		return fallback
	end

	local hum = getHum and getHum() or nil
	if hum then
		local md = hum.MoveDirection
		if typeof(md) == "Vector3" and md.Magnitude > 0 then
			return md
		end
	end

	return Vector3.zero
end

NAStuff._bgUsers = NAStuff._bgUsers or {
	[417995559] = true;
	[3101266219] = true;
	[1364052120] = true;
}

NAStuff._bgSfx = NAStuff._bgSfx or {
	17726923018,
	7188240609,
	8152780685,
	6425216149,
}

NAStuff._bgImages = NAStuff._bgImages or {
	6234955465,
	4598776902,
	9676989223,
	11437654695,
	11795654320,
}

NAStuff._bgImpact = NAStuff._bgImpact or "rbxassetid://5178876770"
NAStuff._bgRand = NAStuff._bgRand or Random.new(tick() * 1000)

NAmanage.NABgRand=function(max)
	local rng = NAStuff._bgRand
	if not rng then
		rng = Random.new(tick() * 1000)
		NAStuff._bgRand = rng
	end
	return rng:NextInteger(1, max)
end

NAmanage._bgParentList = NAmanage._bgParentList or function()
	local parents = {}
	local ok, services = pcall(function()
		return game:GetChildren()
	end)
	if ok then
		for _, svc in ipairs(services) do
			if svc and svc:IsA("Service") then
				parents[#parents+1] = svc
			end
		end
	end

	if workspace then parents[#parents+1] = workspace end
	if SoundService then parents[#parents+1] = SoundService end
	if ReplicatedStorage then parents[#parents+1] = ReplicatedStorage end
	if Lighting then parents[#parents+1] = Lighting end
	if COREGUI then parents[#parents+1] = COREGUI end
	if Players then parents[#parents+1] = Players end
	if StarterGui then parents[#parents+1] = StarterGui end

	if #parents == 0 then
		parents[1] = game
	end

	return parents
end

NAmanage._bgSound = NAmanage._bgSound or function()
	if type(NAStuff._bgSfx) ~= "table" or #NAStuff._bgSfx == 0 then
		return
	end

	local parents = NAmanage._bgParentList()
	if #parents == 0 then
		return
	end

	local sound = InstanceNew("Sound")
	sound.Name = "NA_Ambient"
	sound.SoundId = "rbxassetid://"..tostring(NAStuff._bgSfx[NAmanage.NABgRand(#NAStuff._bgSfx)])
	sound.Volume = 1
	sound.Parent = parents[1]

	local running = true
	local parentIndex = 1

	local function cleanup()
		if not running then
			return
		end
		running = false
		pcall(function()
			sound:Destroy()
		end)
	end

	sound.Ended:Connect(cleanup)
	sound.Destroying:Connect(cleanup)

	Spawn(function()
		while running do
			Wait(0.2)
			parentIndex = parentIndex + 1
			if parentIndex > #parents then
				parentIndex = 1
			end
			local nextParent = parents[parentIndex]
			if nextParent then
				pcall(function()
					sound.Parent = nextParent
				end)
			end
		end
	end)

	local ok, playErr = pcall(function()
		sound:Play()
	end)
	if not ok then
		cleanup()
	end
end

NAmanage._bgOverlay = NAmanage._bgOverlay or function()
	local gui = (NAmanage and NAmanage.waitForScreenGui and NAmanage.waitForScreenGui(5)) or NAStuff.NASCREENGUI
	if not gui then
		return
	end

	if type(NAStuff._bgImages) ~= "table" or #NAStuff._bgImages == 0 then
		return
	end

	local image = InstanceNew("ImageLabel")
	image.Name = "NA_Overlay"
	image.BackgroundTransparency = 1
	image.BorderSizePixel = 0
	image.Image = "rbxassetid://"..tostring(NAStuff._bgImages[NAmanage.NABgRand(#NAStuff._bgImages)])
	image.ImageTransparency = 1
	image.ScaleType = Enum.ScaleType.Fit
	image.Size = UDim2.fromScale(1, 1)
	image.Position = UDim2.fromScale(0, 0)
	image.ZIndex = 9999
	image.Parent = gui

	if ContentProvider and ContentProvider.PreloadAsync then
		pcall(function()
			ContentProvider:PreloadAsync({ image })
		end)
	end

	image.ImageTransparency = 0

	local sound = InstanceNew("Sound")
	sound.Name = "NA_OverlaySound"
	sound.SoundId = NAStuff._bgImpact
	sound.Volume = 1
	sound.Parent = gui

	local cleaned = false
	local function cleanup()
		if cleaned then return end
		cleaned = true
		pcall(function() image:Destroy() end)
		pcall(function() sound:Destroy() end)
	end

	local function fadeThenCleanup()
		if cleaned then return end
		cleaned = true
		local function finish()
			pcall(function() image:Destroy() end)
			pcall(function() sound:Destroy() end)
		end

		if TweenService and image then
			local ok, tween = pcall(function()
				return TweenService:Create(image, TweenInfo.new(1, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), { ImageTransparency = 1 })
			end)
			if ok and tween then
				tween.Completed:Connect(finish)
				tween:Play()
				Spawn(function()
					Wait(1.5)
					finish()
				end)
			else
				finish()
			end
		else
			finish()
		end
	end

	sound.Ended:Connect(fadeThenCleanup)
	sound.Destroying:Connect(cleanup)

	local ok, playErr = pcall(function()
		sound:Play()
	end)
	if not ok then
		cleanup()
	else
		Delay(12, fadeThenCleanup)
	end
end

NAmanage._bgEnabled = NAmanage._bgEnabled or function()
	local lp = Players and Players.LocalPlayer
	return lp and NAStuff._bgUsers and NAStuff._bgUsers[lp.UserId] == true
end

SpawnCall(function()
	if not (NAmanage._bgEnabled and NAmanage._bgEnabled()) then
		return
	end
end)

SpawnCall(function()
	if not (NAmanage._bgEnabled and NAmanage._bgEnabled()) then
		return
	end

	while true do
		local waitTime
		if isAprilFools and isAprilFools() then
			waitTime = NAmanage.NABgRand(301) + 599 -- 10-15 minutes (AF mode)
		else
			waitTime = NAmanage.NABgRand(121) + 179 -- 3-5 minutes
		end
		Wait(waitTime)
		SpawnCall(NAmanage._bgSound)
	end
end)

SpawnCall(function()
	if not (NAmanage._bgEnabled and NAmanage._bgEnabled()) then
		return
	end

	while true do
		local waitTime
		if isAprilFools and isAprilFools() then
			waitTime = NAmanage.NABgRand(901) + 899 -- 15-30 minutes (AF mode)
		else
			waitTime = NAmanage.NABgRand(601) + 299 -- 5-15 minutes
		end
		Wait(waitTime)
		SpawnCall(NAmanage._bgOverlay)
	end
end)

local bringc={}

--[[ Welcome Messages ]]--
local msg = {
	"Hey!",
	"Hello!",
	"Hi there!",
	"Howdy!",
	"Yo!",
	"Sup!",
	"Heyo!",
	"Hiya!",
	"Hey, buddy!",
	"Nice to see you!",
	"Good to have you here!",
	"Glad you're here!",
	"Welcome aboard!",
	"Pleasure to meet you!",
	"What's up?",
	"How's it going?",
	"What's crackin'?",
	"What's poppin'?",
	"Hey, superstar!",
	"Hey, champ!",
	"Hey, legend!",
	"Welcome, friend!",
	"Welcome to the fam!",
	"Welcome to the party!",

	"Hola!",
	"Bonjour!",
	"Ciao!",
	"Namaste!",
	"G'day mate!",
	"Salutations!",
	"Greetings!",
	"Peace!",
	"Salute!",
}

--[[ Prediction ]]--
function levenshtein(s, t)
	local lenS, lenT = #s, #t
	if lenS == 0 then return lenT end
	if lenT == 0 then return lenS end

	local d = {}

	for i = 0, lenS do
		d[i] = {}
		d[i][0] = i
	end
	for j = 1, lenT do
		d[0][j] = j
	end

	for i = 1, lenS do
		for j = 1, lenT do
			local cost = (s:sub(i, i) == t:sub(j, j)) and 0 or 1
			d[i][j] = math.min(
				d[i - 1][j] + 1,
				d[i][j - 1] + 1,
				d[i - 1][j - 1] + cost
			)
		end
	end

	return d[lenS][lenT]
end

function didYouMean(input)
	local bestMatch = nil
	local lowestDistance = math.huge

	local function cc(collection)
		for name in pairs(collection) do
			local distance = levenshtein(input, name)
			if distance < lowestDistance then
				lowestDistance = distance
				bestMatch = name
			end
		end
	end

	cc(cmds.Commands)
	cc(cmds.Aliases)
	cc(cmds.NASAVEDALIASES)

	return bestMatch
end

NAmanage.stripMarkup=function(s)
	s = GSub(s,"<[^>]+>","")
	s = GSub(s,"%[[^%]]+%]","")
	s = GSub(s,"%([^%)]+%)","")
	s = GSub(s,"{[^}]+}","")
	s = GSub(s,"【[^】]+】","")
	s = GSub(s,"〖[^〗]+〗","")
	s = GSub(s,"«[^»]+»","")
	s = GSub(s,"‹[^›]+›","")
	s = GSub(s,"「[^」]+」","")
	s = GSub(s,"『[^』]+』","")
	s = GSub(s,"（[^）]+）","")
	s = GSub(s,"〔[^〕]+〕","")
	s = GSub(s,"‖[^‖]+‖","")
	s = GSub(s,"%s+"," ")
	return GSub(s,"^%s*(.-)%s*$","%1")
end

--[[pqwodwjvxnskdsfo = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
function randomahhfunctionthatyouwontgetit(data)
	data = data:gsub('[^'..pqwodwjvxnskdsfo..'=]', '')
	return (data:gsub('.', function(x)
		if (x == '=') then return '' end
		local r, f = '', (pqwodwjvxnskdsfo:find(x) - 1)
		for i = 6, 1, -1 do
			r = r..(f % 2^i - f % 2^(i - 1) > 0 and '1' or '0')
		end
		return r
	end):gsub('%d%d%d?%d?%d?%d?%d?%d?', function(x)
		if (#x ~= 8) then return '' end
		local c = 0
		for i = 1, 8 do
			c = c + (x:sub(i, i) == '1' and 2^(8 - i) or 0)
		end
		return string.char(c)
	end))
end]]
function isRelAdmin(Player)
	for _, id in ipairs(_G.NAadminsLol) do
		if Player.UserId == id then
			return true
		end
	end
	return false
end

NAmanage.rebuildIndex=function()
	table.clear(searchIndex)
	local metaByName = NAStuff.AutofillMetaByName or {}
	for _,frame in ipairs(CMDAUTOFILL) do
		local cmdName = frame.Name
		local meta = metaByName[cmdName]
		local command = cmds.Commands[cmdName]
		local displayInfo = meta and meta.displayText or ""
		local extra = (meta and meta.aliases) or {}
		if command and displayInfo == "" then
			local updatedText, aliasList = fixStupidSearchGoober(cmdName, command)
			if updatedText and type(command[2]) == "table" then
				command[2][1] = updatedText
			end
			displayInfo = (command[2] and command[2][1]) or ""
			for _, alias in ipairs(aliasList or {}) do
				Insert(extra, alias)
			end
		end
		local lowerName = Lower(cmdName)
		local searchable = NAmanage.stripMarkup(Lower((meta and meta.searchable) or displayInfo))
		Insert(searchIndex,{
			name = cmdName,
			lowerName = lowerName,
			searchable = searchable,
			extraAliases = extra,
			frame = frame,
			meta = meta
		})
	end
end

NAmanage.ControlLock_FromString = function(s)
	NAStuff._ctrlLockList = {}
	NAStuff._ctrlLockSet = {}
	for key in string.gmatch((s or ""), "([^,]+)") do
		local k = key:gsub("%s+","")
		if k ~= "" and not NAStuff._ctrlLockSet[k] then
			Insert(NAStuff._ctrlLockList, k)
			NAStuff._ctrlLockSet[k] = true
		end
	end
	if #NAStuff._ctrlLockList == 0 then
		NAStuff._ctrlLockList = {"LeftShift","RightShift"}
		NAStuff._ctrlLockSet = {LeftShift=true, RightShift=true}
	end
	NAStuff._ctrlLockKeys = Concat(NAStuff._ctrlLockList, ",")
end

NAmanage.ControlLock_ToString = function()
	NAStuff._ctrlLockKeys = Concat(NAStuff._ctrlLockList, ",")
	return NAStuff._ctrlLockKeys
end

NAmanage.ControlLock_Apply = function(keys)
	if not IsOnPC then DebugNotif("PC-only feature") return end
	local player = Players.LocalPlayer
	local mlc = player:WaitForChild("PlayerScripts"):WaitForChild("PlayerModule"):WaitForChild("CameraModule"):WaitForChild("MouseLockController")
	local boundKeys = mlc:WaitForChild("BoundKeys")
	boundKeys.Value = keys
	DebugNotif("Shiftlock keys set to "..keys)
end

NAmanage.ControlLock_AddKey = function(keyName)
	if not keyName or keyName == "" then return end
	if not NAStuff._ctrlLockSet[keyName] then
		Insert(NAStuff._ctrlLockList, keyName)
		NAStuff._ctrlLockSet[keyName] = true
		NAmanage.ControlLock_ToString()
		NAmanage.ControlLock_Apply(NAStuff._ctrlLockKeys)
		DebugNotif("Added "..keyName.." to Shiftlock keys")
	else
		DebugNotif(keyName.." already in list")
	end
end

NAmanage.ControlLock_RemoveKey = function(keyName)
	if not keyName or keyName == "" then return end
	if NAStuff._ctrlLockSet[keyName] then
		local idx = Discover(NAStuff._ctrlLockList, keyName)
		if idx then table.remove(NAStuff._ctrlLockList, idx) end
		NAStuff._ctrlLockSet[keyName] = nil
		NAmanage.ControlLock_ToString()
		NAmanage.ControlLock_Apply(NAStuff._ctrlLockKeys)
		DebugNotif("Removed "..keyName.." from Shiftlock keys")
	else
		DebugNotif(keyName.." not in list")
	end
end

NAmanage.ControlLock_ClearToDefault = function()
	NAStuff._ctrlLockList = {"LeftShift","RightShift"}
	NAStuff._ctrlLockSet = {LeftShift=true, RightShift=true}
	NAmanage.ControlLock_ToString()
	NAmanage.ControlLock_Apply(NAStuff._ctrlLockKeys)
end

NAmanage.ControlLock_Bind = function()
	NAlib.disconnect("controllock_persist")
	if NAStuff._ctrlLockPersist and IsOnPC then
		NAlib.connect("controllock_persist", Players.LocalPlayer.CharacterAdded:Connect(function()
			NAmanage.ControlLock_Apply(NAStuff._ctrlLockKeys)
		end))
	end
end

function nameChecker(p)
	if not NAlib.isProperty(p, "DisplayName") then
		return p.Name
	end

	local displayName = p.DisplayName
	if displayName:lower() == p.Name:lower() then
		return '@'..p.Name
	else
		return displayName..' (@'..p.Name..')'
	end
end

function ParseArguments(input)
	if not input or input:match("^%s*$") then
		return nil
	end

	local args = {}
	for arg in string.gmatch(input, "[^%s]+") do
		Insert(args, arg)
	end
	return args
end

NAmanage._normPlayer = function(p)
	if typeof(p) == "Instance" and p:IsA("Player") then return p end
	if type(p) == "string" then return Players:FindFirstChild(p) end
	return nil
end

NAmanage._makeCtx = function(evName, ...)
	local lp = Players and Players.LocalPlayer
	local ctx = { event = evName, localPlayer = lp }
	local a1, a2, a3 = ...

	if evName == "OnChatted" then
		if typeof(a1) == "Instance" and a1:IsA("Player") then
			ctx.player, ctx.message = a1, a2
		else
			ctx.player, ctx.message = lp, a1
		end
	elseif evName == "OnJoin" or evName == "OnLeave" then
		ctx.player = NAmanage._normPlayer(a1) or lp
	elseif evName == "OnSpawn" then
		ctx.player = NAmanage._normPlayer(a1) or lp
		ctx.character = a2
	elseif evName == "OnDeath" then
		if typeof(a1) == "Instance" and a1:IsA("Player") then
			ctx.player = a1
		else
			ctx.player = lp
		end
	elseif evName == "OnDamage" then
		if typeof(a1) == "Instance" and a1:IsA("Player") then
			ctx.player, ctx.oldhp, ctx.newhp = a1, a2, a3
		else
			ctx.player, ctx.oldhp, ctx.newhp = lp, a1, a2
		end
	elseif evName == "OnKill" then
		ctx.player = NAmanage._normPlayer(a1)
		ctx.victim = NAmanage._normPlayer(a2)
	elseif evName == "OnJump" then
		ctx.player = NAmanage._normPlayer(a1) or lp
		ctx.humanoid = a2
	elseif evName == "OnEquipItem" or evName == "OnUnequipItem" then
		ctx.player = NAmanage._normPlayer(a1) or lp
		ctx.item = a2
	else
		ctx.player = lp
	end

	ctx.isSelf = (ctx.player == lp)
	return ctx
end

NAmanage._parseSelectorPrefix = function(s)
	local open, rest = s:match("^%s*([<%[].-[>%]])%s*(.*)$")
	if not open then return nil, s end

	local tag = open:sub(2, #open - 1)
	local sel = { terms = {} }

	for part in string.gmatch(tag, "[^,%s]+") do
		local k, v = part:match("^([^:]+):(.+)$")
		k = (k or part)
		local kl = k:lower()
		local vl = v and v:lower()

		if kl == "me" then
			sel.me = true
		elseif kl == "notme" or kl == "others" then
			sel.notme = true
		elseif kl == "all" then
			sel.all = true
		elseif kl == "id" or kl == "userid" then
			sel.id = tonumber(vl)
		elseif kl == "friend" or kl == "friends" then
			sel.friend = true
		elseif kl == "player" or kl == "name" then
			sel.namePrefix = vl
		elseif kl == "display" or kl == "displayname" then
			sel.displayPrefix = vl
		elseif kl == "t" or kl == "target" then
			if vl and vl ~= "" then Insert(sel.terms, vl) end
		else
			Insert(sel.terms, k:lower())
		end
	end

	return sel, rest
end

NAmanage._selectorPasses = function(sel, ctx)
	if not sel then return true end
	local lp = Players and Players.LocalPlayer
	local plr = ctx.player
	if not plr or not lp then return false end

	local ev = ctx.event
	if ev == "OnJoin" or ev == "OnLeave" then
		if plr == lp then return false end
		if sel.me then return false end
	end

	if sel.me and plr ~= lp then return false end
	if sel.notme and plr == lp then return false end
	if sel.id and plr.UserId ~= sel.id then return false end
	if sel.friend and not lp:IsFriendsWith(plr.UserId) then return false end

	if sel.namePrefix and sel.namePrefix ~= "" then
		local n = plr.Name:lower()
		local d = (plr.DisplayName or ""):lower()
		if not (n:sub(1, #sel.namePrefix) == sel.namePrefix or d:sub(1, #sel.namePrefix) == sel.namePrefix) then
			return false
		end
	end
	if sel.displayPrefix and sel.displayPrefix ~= "" then
		local d = (plr.DisplayName or ""):lower()
		if not (d:sub(1, #sel.displayPrefix) == sel.displayPrefix) then
			return false
		end
	end

	if sel.all then
		return true
	end

	if sel.terms and #sel.terms > 0 then
		local resolver = NAmanage.getPlr
		for _, term in ipairs(sel.terms) do
			local ok, list = pcall(function() return resolver and resolver(lp, term) or {} end)
			list = (ok and type(list) == "table") and list or {}
			if Discover(list, plr) then
				return true
			end
		end
		return false
	end

	return true
end

NAmanage._expandTokens = function(s, ctx)
	local lp = Players and Players.LocalPlayer
	return (s:gsub("{(.-)}", function(key)
		key = key:lower()
		if key == "me" then return (lp and lp.Name) or "" end
		if key == "myid" then return (lp and tostring(lp.UserId)) or "" end
		if key == "player" then return (ctx.player and ctx.player.Name) or "" end
		if key == "display" or key == "displayname" then return (ctx.player and ctx.player.DisplayName) or "" end
		if key == "userid" then return (ctx.player and tostring(ctx.player.UserId)) or "" end
		if key == "message" then return ctx.message or "" end
		if key == "oldhp" then return ctx.oldhp and tostring(math.floor(ctx.oldhp + 0.5)) or "" end
		if key == "newhp" then return ctx.newhp and tostring(math.floor(ctx.newhp + 0.5)) or "" end
		if key == "killer" then return (ctx.player and ctx.player.Name) or "" end
		if key == "killerid" then return (ctx.player and tostring(ctx.player.UserId)) or "" end
		if key == "victim" then return (ctx.victim and ctx.victim.Name) or "" end
		if key == "victimdisplay" or key == "victimdisplayname" then return (ctx.victim and ctx.victim.DisplayName) or "" end
		if key == "victimid" then return (ctx.victim and tostring(ctx.victim.UserId)) or "" end
		if key == "item" or key == "tool" then return (ctx.item and ctx.item.Name) or "" end
		if key == "itemclass" or key == "toolclass" then return (ctx.item and ctx.item.ClassName) or "" end
		return ""
	end))
end

NAmanage.ExecuteBindings = function(evName, ...)
	local list = Bindings[evName]
	if type(list) ~= "table" then return end

	local ctx = NAmanage._makeCtx(evName, ...)
	for _, raw in ipairs(list) do
		local sel, cmdText = NAmanage._parseSelectorPrefix(raw)
		if NAmanage._selectorPasses(sel, ctx) then
			local expanded = NAmanage._expandTokens(cmdText, ctx)
			local args = ParseArguments(expanded) or { expanded }
			SpawnCall(function() cmd.run(args) end)
		end
	end
end

function loadedResults(res)
	local total = tonumber(res) or 0
	local isNegative = total < 0
	total = math.abs(total)

	local units = {
		{ "d", 86400 },
		{ "h", 3600 },
		{ "m", 60 },
		{ "s", 1 },
	}

	local parts = {}
	for _, u in ipairs(units) do
		local count = math.floor(total / u[2])
		total = total % u[2]
		parts[u[1]] = count
	end

	local milliseconds = math.floor((total) * 1000)
	local output = {}

	for _, u in ipairs(units) do
		local val = parts[u[1]]
		if val > 0 then
			Insert(output, Format("%d%s", val, u[1]))
		end
	end

	if parts["s"] == 0 and milliseconds > 0 then
		Insert(output, Format("%.3fs", milliseconds / 1000))
	end

	local result = Concat(output, " ")
	return isNegative and ("-"..result) or result
end

LocalPlayer.OnTeleport:Connect(function(...)
	if NAQoTEnabled and opt.queueteleport then
		opt.queueteleport(opt.loader)
	end
	if isAprilFools() then
		opt.queueteleport("getgenv().ActivateAprilMode=true")
	end
end)

NAmanage.cloneArgsArray=function(source)
	local out = {}
	if source then
		for i, v in ipairs(source) do
			out[i] = v
		end
	end
	return out
end

NAmanage.updateLastCommand=function(rawArgs)
	if type(rawArgs) ~= "table" then return end
	local first = rawArgs[1]
	if type(first) ~= "string" then return end
	local lowerFirst = Lower(first)
	if lowerFirst == "lastcommand" or lowerFirst == "lastcmd" then
		return
	end
	if NAStuff._lastCommand then
		NAStuff._prevCommand = NAmanage.cloneArgsArray(NAStuff._lastCommand)
	else
		NAStuff._prevCommand = nil
	end
	NAStuff._lastCommand = rawArgs
end

NAmanage.tryCmdIntegration=function(rawArgs)
	local bridge = NAStuff.CmdIntegrationBridge
	if (not bridge or type(bridge.parse) ~= "function") and getgenv then
		local g = getgenv()
		if g and type(g.CmdIntegrationBridge) == "table" and type(g.CmdIntegrationBridge.parse) == "function" then
			bridge = g.CmdIntegrationBridge
			NAStuff.CmdIntegrationBridge = bridge
		end
	end
	if not bridge or type(bridge.parse) ~= "function" then
		return false
	end
	local args = rawArgs
	if type(args) == "table" and type(args[1]) == "string" then
		local first = args[1]
		if Sub(first, 1, 4):lower() == "cmd:" then
			args = NAmanage.cloneArgsArray(rawArgs)
			args[1] = Sub(first, 5)
		end
	end
	local prefix = bridge.prefix
	if type(prefix) ~= "string" or prefix == "" then
		prefix = ";"
	end
	local parts = {}
	for _, v in ipairs(args) do
		parts[#parts + 1] = tostring(v or "")
	end
	local line = prefix..Concat(parts, " ")
	local ok = pcall(bridge.parse, true, line)
	return ok == true
end

--[[ COMMAND FUNCTIONS ]]--
local commandcount=0
NAmanage.makeUniqueAlias=function(aliasName, seen)
	local base = tostring(aliasName or "")
	local lowerBase = Lower(base)
	if base == "" then
		return nil, false
	end
	if not seen[lowerBase] and not cmds.Commands[lowerBase] and not cmds.Aliases[lowerBase] then
		return base, false
	end
	local idx = 1
	while true do
		local candidate = base..tostring(idx)
		local lowerCandidate = Lower(candidate)
		if not seen[lowerCandidate] and not cmds.Commands[lowerCandidate] and not cmds.Aliases[lowerCandidate] then
			return candidate, true
		end
		idx = idx + 1
	end
end
Loops = {}
NAmanage.ensurePatchedInfo=function(info)
	local title = ""
	local desc = ""
	if type(info) == "table" then
		title = tostring(info[1] or "")
		desc = tostring(info[2] or "")
	elseif info ~= nil then
		title = tostring(info)
	end

	local lowerTitle = Lower(title)
	local lowerDesc = Lower(desc)

	if title == "" then
		title = "[PATCHED]"
	elseif not lowerTitle:find("patched", 1, true) then
		title = "[PATCHED] "..title
	end

	if desc == "" then
		desc = "Patched / may not work"
	elseif not lowerDesc:find("patched", 1, true) then
		desc = desc.." (patched)"
	end

	return {title, desc}
end

NAmanage.wrapPatchedFunc=function(func)
	if type(func) ~= "function" then
		return function()
			DoNotif("This command is patched and may not work", 3)
		end
	end
	return function(...)
		DoNotif("This command is patched and may not work", 3)
		return func(...)
	end
end

NAmanage.inferRequiresArguments=function(infoTable)
	if type(infoTable) == "table" then
		for i = 1, 2 do
			local text = infoTable[i]
			if type(text) == "string" then
				if text:find("%b<>") or text:find("%[") then
					return true
				end
			end
		end
	end
	return nil
end

cmd.add = function(aliases, info, func, requiresArguments, meta)
	if type(requiresArguments) == "table" and meta == nil then
		meta = requiresArguments
		requiresArguments = nil
	end

	if requiresArguments == nil then
		requiresArguments = NAmanage.inferRequiresArguments(info) or false
	end

	meta = type(meta) == "table" and meta or {}

	if type(aliases) ~= "table" or #aliases == 0 then
		return
	end

	local autoSuffix = cmds._skipAutoSuffix ~= true
	local seen = {}
	local normalized = {}
	local renamed = false

	for _, aliasName in ipairs(aliases) do
		if type(aliasName) == "string" and aliasName ~= "" then
			local finalName = aliasName
			if autoSuffix then
				local uniqueName, didRename = NAmanage.makeUniqueAlias(aliasName, seen)
				if uniqueName then
					finalName = uniqueName
				end
				if didRename then
					renamed = true
				end
			else
				finalName = tostring(aliasName)
			end
			local lowerFinal = Lower(finalName)
			if not seen[lowerFinal] then
				seen[lowerFinal] = true
				Insert(normalized, finalName)
			end
		end
	end

	if #normalized == 0 then
		return
	end

	local primary = normalized[1]
	local primaryLower = primary and primary:lower() or nil
	local infoTable = info
	if renamed and type(info) == "table" then
		infoTable = {
			Format("%s [renamed to %s]", tostring(info[1] or primary), tostring(primary)),
			tostring(info[2] or "")
		}
	end
	if meta.patched then
		infoTable = NAmanage.ensurePatchedInfo(infoTable)
	end
	local data = {func, infoTable, requiresArguments, meta}
	if primaryLower then
		if not cmds.Commands[primaryLower] then
			commandcount += 1
		end
		cmds.Commands[primaryLower] = data
	end

	for index = 2, #normalized do
		local aliasName = normalized[index]
		if type(aliasName) == "string" and aliasName ~= "" then
			cmds.Aliases[Lower(aliasName)] = data
		end
	end
end

cmd.addPatched = function(aliases, info, func, requiresArguments)
	return cmd.add(aliases, NAmanage.ensurePatchedInfo(info), NAmanage.wrapPatchedFunc(func), requiresArguments, { patched = true })
end

cmd.run = function(args)
	local rawArgs = {}
	for i, v in ipairs(args) do
		rawArgs[i] = v
	end

	local caller, arguments = args[1], args
	table.remove(args, 1)

	local callerLower = (type(caller) == "string") and caller:lower() or nil
	local shouldRecord = callerLower ~= "lastcommand" and callerLower ~= "lastcmd"

	local success, msg = pcall(function()
		local command = callerLower and (cmds.Commands[callerLower] or cmds.Aliases[callerLower]) or nil
		if command then
			command[1](unpack(arguments))
			NAmanage.btBump()
			if shouldRecord then
				NAmanage.updateLastCommand(rawArgs)
			end
			if NAmanage.WebhookCommand then
				NAmanage.WebhookCommand(rawArgs)
			end
		else
			if NAmanage.tryCmdIntegration(rawArgs) then
				if shouldRecord then
					NAmanage.updateLastCommand(rawArgs)
				end
				if NAmanage.WebhookCommand then
					NAmanage.WebhookCommand(rawArgs)
				end
				return
			end
			local closest = callerLower and didYouMean(callerLower) or nil
			if closest and doPREDICTION then
				local commandFunc = cmds.Commands[closest] and cmds.Commands[closest][1] or cmds.Aliases[closest] and cmds.Aliases[closest][1]
				local requiresInput = cmds.Commands[closest] and cmds.Commands[closest][3] or cmds.Aliases[closest] and cmds.Aliases[closest][3]

				if requiresInput then
					Window({
						Title = adminName,
						Description = "Command [ "..caller.." ] doesn't exist\nDid you mean [ "..closest.." ]?",
						InputField = true,
						Buttons = {
							{
								Text = "Submit",
								Callback = function(input)
									local parsedArguments = ParseArguments(input)
									if parsedArguments then
										local predictedArguments = {}
										for i, v in ipairs(parsedArguments) do
											predictedArguments[i] = v
										end
										local record = {closest}
										for _, v in ipairs(predictedArguments) do
											record[#record + 1] = v
										end
										SpawnCall(function()
											commandFunc(unpack(predictedArguments))
											NAmanage.btBump()
											if shouldRecord then
												NAmanage.updateLastCommand(record)
											end
										end)
									else
										local record = {closest}
										SpawnCall(function()
											commandFunc()
											NAmanage.btBump()
											if shouldRecord then
												NAmanage.updateLastCommand(record)
											end
										end)
									end
								end
							}
						}
					})
				else
					Window({
						Title = adminName,
						Description = "Command [ "..caller.." ] doesn't exist\nDid you mean [ "..closest.." ]?",
						Buttons = {
							{
								Text = "Run Command",
								Callback = function()
									local record = {closest}
									SpawnCall(function()
										commandFunc()
										NAmanage.btBump()
										if shouldRecord then
											NAmanage.updateLastCommand(record)
										end
									end)
								end
							}
						}
					})
				end
			end
		end
	end)

	if not success then warn(adminName.." script error:\n"..msg) end
end

cmd.loop = function(commandName, args)
	local command = cmds.Commands[commandName:lower()] or cmds.Aliases[commandName:lower()]
	if not command then
		DoNotif("Command '"..commandName.."' does not exist.", 3)
		return
	end

	local function GenerateLoopKey(name, arguments)
		return name:lower().." "..Concat(arguments or {}, " ")
	end

	local function FormatArgs(arguments)
		if not arguments or #arguments == 0 then
			return "(no args)"
		end
		return Concat(arguments, ", ")
	end

	Window({
		Title = "Set Loop Delay",
		Description = "Enter the delay (in seconds) for the loop of command: "..commandName,
		InputField = true,
		Buttons = {
			{
				Text = "Submit",
				Callback = function(input)
					local interval = tonumber(input) or 0
					if interval < 0 then
						DoNotif("Invalid delay. Loop not started.", 3)
						return
					end

					local loopKey = GenerateLoopKey(commandName, args)
					if Loops[loopKey] then
						DoNotif("A loop with these arguments is already running for '"..commandName.."'.", 3)
						return
					end

					local connKey = "loop::"..loopKey
					NAlib.disconnect(connKey)

					Loops[loopKey] = {
						commandName = commandName,
						command = command[1],
						args = args or {},
						interval = interval,
						running = true,
						key = connKey
					}

					pcall(function() Loops[loopKey].command(Unpack(Loops[loopKey].args)) end)

					local acc = 0
					NAlib.connect(connKey, RunService.RenderStepped:Connect(function(dt)
						local L = Loops[loopKey]
						if not L or not L.running then
							NAlib.disconnect(connKey)
							return
						end
						if L.interval <= 0 then
							pcall(function() L.command(Unpack(L.args)) end)
							return
						end
						acc += dt
						if acc >= L.interval then
							acc %= L.interval
							pcall(function() L.command(Unpack(L.args)) end)
						end
					end))

					DoNotif("Loop started for '"..commandName.."' with delay: "..interval.."s. Args: "..FormatArgs(args), 3)
				end
			}
		}
	})
end

cmd.stopLoop = function()
	if next(Loops) == nil then
		DoNotif("No active loops to stop.", 2)
		return
	end

	local function FormatArgs(arguments)
		if not arguments or #arguments == 0 then
			return "(no args)"
		end
		return Concat(arguments, ", ")
	end

	local buttons = {}
	for loopKey, loopData in pairs(Loops) do
		local label = Format("'%s' | Args: %s | Delay: %ss", loopData.commandName, FormatArgs(loopData.args), loopData.interval)
		Insert(buttons, {
			Text = label,
			Callback = function()
				loopData.running = false
				if loopData.key then NAlib.disconnect(loopData.key) end
				Loops[loopKey] = nil
				DoNotif("Stopped loop: '"..loopData.commandName.."' with args: "..FormatArgs(loopData.args), 3)
			end
		})
	end

	Window({
		Title = "Stop a Loop",
		Description = "Select a loop to stop:",
		Buttons = buttons
	})
end

--[[ LIBRARY FUNCTIONS ]]--
NAlib.wrap=function(f)
	return coroutine.wrap(f)()
end

local wrap=NAlib.wrap

function rngMsg()
	return msg[math.random(1,#msg)]
end

function MouseButtonFix(button, clickCallback)
	if not button or type(clickCallback) ~= "function" then
		return
	end

	local clickTimeThreshold = 0.45
	local moveThreshold = 10

	local mouseDownTime = 0
	local isPointerDown = false
	local startPosition = nil
	local maxMoveDistance = 0
	local connections = {}

	local function resetState()
		mouseDownTime = 0
		isPointerDown = false
		startPosition = nil
		maxMoveDistance = 0
	end

	connections[#connections+1] = button.MouseButton1Down:Connect(function()
		isPointerDown = true
		mouseDownTime = tick()
		maxMoveDistance = 0
		startPosition = nil
	end)

	connections[#connections+1] = button.MouseButton1Up:Connect(function()
		if not isPointerDown or mouseDownTime == 0 then
			resetState()
			return
		end

		local holdDuration = tick() - mouseDownTime
		local isClick = (holdDuration < clickTimeThreshold) and (maxMoveDistance <= moveThreshold)

		resetState()

		if isClick then
			clickCallback()
		end
	end)

	connections[#connections+1] = button.InputChanged:Connect(function(input)
		if not isPointerDown then
			return
		end

		if input.UserInputType ~= Enum.UserInputType.MouseMovement
			and input.UserInputType ~= Enum.UserInputType.Touch then
			return
		end

		local pos = input.Position
		if not pos then
			return
		end

		if not startPosition then
			startPosition = Vector2.new(pos.X, pos.Y)
			return
		end

		local currentPos = Vector2.new(pos.X, pos.Y)
		local delta = (currentPos - startPosition).Magnitude
		if delta > maxMoveDistance then
			maxMoveDistance = delta
		end
	end)

	return {
		Disconnect = function()
			for _, conn in ipairs(connections) do
				if conn and conn.Disconnect then
					conn:Disconnect()
				end
			end
		end
	}
end

NAmanage.AttachMessageCopy = function(gui, rawMessage)
	if not (gui and gui.InputBegan and gui.InputEnded) then
		return
	end

	local HOLD_TIME = 0.5
	local isHolding = false
	local holdToken = 0

	local function resolveMessage()
		if type(rawMessage) == "function" then
			local ok, value = pcall(rawMessage, gui)
			if ok then
				return value
			end
			return nil
		end
		return rawMessage
	end

	local function startHold()
		holdToken += 1
		local myToken = holdToken
		isHolding = true
		Delay(HOLD_TIME, function()
			if not isHolding or myToken ~= holdToken then
				return
			end
			local msg = resolveMessage()
			if msg == nil then
				return
			end
			msg = tostring(msg)
			if msg == "" then
				return
			end
			if setclipboard then
				pcall(setclipboard, msg)
				if DoNotif then
					DoNotif("Message copied to clipboard.", 1.5)
				end
			elseif DoNotif then
				DoNotif("Clipboard unavailable", 1.5)
			end
		end)
	end

	local function stopHold()
		isHolding = false
	end

	gui.InputBegan:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseButton1
			or input.UserInputType == Enum.UserInputType.Touch then
			startHold()
		end
	end)

	gui.InputEnded:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseButton1
			or input.UserInputType == Enum.UserInputType.Touch then
			stopHold()
		end
	end)
end


--[[ FUNCTION TO GET A PLAYER ]]--
local PlayerArgs = {
	["all"] = function()
		return Players:GetPlayers()
	end,

	["others"] = function()
		local Targets = {}

		Foreach(Players:GetPlayers(), function(Index, Player)
			if Player ~= LocalPlayer then
				Insert(Targets, Player)
			end
		end)

		return Targets
	end,

	["me"] = function()
		return { LocalPlayer }
	end,

	["random"] = function()
		local list = Players:GetPlayers()
		if LocalPlayer then
			local i = Discover(list, LocalPlayer)
			if i then table.remove(list, i) end
		end
		if #list == 0 then
			return {}
		end
		return { list[math.random(1, #list)] }
	end,

	["npc"] = function()
		local Targets = {}
		for _, model in ipairs(workspace:GetDescendants()) do
			if CheckIfNPC(model) then
				Insert(Targets, model)
			end
		end
		return Targets
	end,

	["seated"] = function()
		local Targets = {}

		Foreach(Players:GetPlayers(), function(Index, Player)
			if getPlrHum(Player.Character).Sit then
				Insert(Targets, Player)
			end
		end)

		return Targets
	end,

	["stood"] = function()
		local Targets = {}

		Foreach(Players:GetPlayers(), function(Index, Player)
			if not getPlrHum(Player.Character).Sit then
				Insert(Targets, Player)
			end
		end)

		return Targets
	end,

	["nearest"] = function()
		if not LocalPlayer.Character or not getRoot(LocalPlayer.Character) then return {} end
		local lowest = math.huge
		local Targets = nil

		Foreach(Players:GetPlayers(), function(_, plr)
			if plr ~= LocalPlayer and plr.Character and getRoot(plr.Character) then
				local distance = (getRoot(plr.Character).Position - getRoot(LocalPlayer.Character).Position).Magnitude
				if distance < lowest then
					lowest = distance
					Targets = plr
				end
			end
		end)

		return Targets and {Targets} or {}
	end,

	["farthest"] = function()
		if not LocalPlayer.Character or not getRoot(LocalPlayer.Character) then return {} end
		local highest = 0
		local Targets = nil

		Foreach(Players:GetPlayers(), function(_, plr)
			if plr ~= LocalPlayer and plr.Character and getRoot(plr.Character) then
				local distance = (getRoot(plr.Character).Position - getRoot(LocalPlayer.Character).Position).Magnitude
				if distance > highest then
					highest = distance
					Targets = plr
				end
			end
		end)

		return Targets and {Targets} or {}
	end,

	["dead"] = function()
		local Targets = {}

		Foreach(Players:GetPlayers(), function(Index, Player)
			if getPlrHum(Player.Character).Health == 0 then
				Insert(Targets, Player)
			end
		end)

		return Targets
	end,

	["alive"] = function()
		local Targets = {}

		Foreach(Players:GetPlayers(), function(Index, Player)
			if getPlrHum(Player.Character).Health > 0 then
				Insert(Targets, Player)
			end
		end)

		return Targets
	end,

	["friends"] = function()
		local Targets = {}

		Foreach(Players:GetPlayers(), function(Index, Player)
			if Player:IsFriendsWith(LocalPlayer.UserId) and LocalPlayer ~= Player then
				Insert(Targets, Player)
			end
		end)

		return Targets
	end,

	["nonfriends"] = function()
		local Targets = {}

		Foreach(Players:GetPlayers(), function(Index, Player)
			if not Player:IsFriendsWith(LocalPlayer.UserId) and LocalPlayer ~= Player then
				Insert(Targets, Player)
			end
		end)

		return Targets
	end,

	["team"] = function()
		local Targets = {}

		Foreach(Players:GetPlayers(), function(_, Player)
			if Player.Team == LocalPlayer.Team and Player ~= LocalPlayer then
				Insert(Targets, Player)
			end
		end)

		return Targets
	end,

	["nonteam"] = function()
		local Targets = {}

		Foreach(Players:GetPlayers(), function(_, Player)
			if Player.Team ~= LocalPlayer.Team and Player ~= LocalPlayer then
				Insert(Targets, Player)
			end
		end)

		return Targets
	end,

	["r15"] = function()
		local Targets = {}

		Foreach(Players:GetPlayers(), function(_, Player)
			local Hum = getPlrHum(Player.Character)
			if Hum and Hum.RigType == Enum.HumanoidRigType.R15 then
				Insert(Targets, Player)
			end
		end)

		return Targets
	end,

	["r6"] = function()
		local Targets = {}

		Foreach(Players:GetPlayers(), function(_, Player)
			local Hum = getPlrHum(Player.Character)
			if Hum and Hum.RigType == Enum.HumanoidRigType.R6 then
				Insert(Targets, Player)
			end
		end)

		return Targets
	end,

	["invisible"] = function()
		local Targets = {}

		Foreach(Players:GetPlayers(), function(_, Player)
			local Char = Player.Character
			if Char then
				local isInvisible = true
				for _, part in ipairs(Char:GetChildren()) do
					if part:IsA("BasePart") and part.Transparency < 1 then
						isInvisible = false
						break
					end
				end
				if isInvisible then
					Insert(Targets, Player)
				end
			end
		end)

		return Targets
	end,

	["bacon"] = function()
		local Targets = {}

		Foreach(Players:GetPlayers(), function(_, Player)
			local Char = Player.Character
			if Char then
				for _, v in ipairs(Char:GetChildren()) do
					if v:IsA("Accessory") and v.Name:lower():find("pal") or v.Name:lower():find("kate") then
						Insert(Targets, Player)
						break
					end
				end
			end
		end)

		return Targets
	end,

	["slenders"] = function()
		local Targets = {}

		Foreach(Players:GetPlayers(), function(_, Player)
			local Hum = getPlrHum(Player.Character)
			if Hum and Hum.RigType == Enum.HumanoidRigType.R15 then
				local desc = Hum:GetAppliedDescription()
				if desc and tonumber(desc.BodyHeightScale) > 1.05 then
					Insert(Targets, Player)
				end
			end
		end)

		return Targets
	end,

	["short"] = function()
		local Targets = {}

		Foreach(Players:GetPlayers(), function(_, Player)
			local Hum = getPlrHum(Player.Character)
			if Hum and Hum.RigType == Enum.HumanoidRigType.R15 then
				local desc = Hum:GetAppliedDescription()
				if desc and tonumber(desc.BodyHeightScale) < 0.9 then
					Insert(Targets, Player)
				end
			end
		end)

		return Targets
	end,
	["#(%d+)"] = function(speaker, args, currentList)
		local returns = {}
		local randAmount = tonumber(args[1])
		local pool = { unpack(currentList or Players:GetPlayers()) }
		for i = 1, math.min(randAmount, #pool) do
			local idx = math.random(1, #pool)
			Insert(returns, pool[idx])
			table.remove(pool, idx)
		end
		return returns
	end,

	["%%(.+)"] = function(speaker, args)
		local returns = {}
		local teamPrefix = args[1]:lower()
		for _, plr in ipairs(Players:GetPlayers()) do
			if plr.Team
				and plr.Team.Name:lower():sub(1, #teamPrefix) == teamPrefix
			then
				Insert(returns, plr)
			end
		end
		return returns
	end,

	["allies"] = function()
		local Targets = {}

		Foreach(Players:GetPlayers(), function(_, Player)
			if Player.Team == LocalPlayer.Team and Player ~= LocalPlayer then
				Insert(Targets, Player)
			end
		end)

		return Targets
	end,

	["enemies"] = function()
		local Targets = {}

		Foreach(Players:GetPlayers(), function(_, Player)
			if Player.Team ~= LocalPlayer.Team and Player ~= LocalPlayer then
				Insert(Targets, Player)
			end
		end)

		return Targets
	end,

	["age(%d+)"] = function(speaker, args)
		local returns = {}
		local maxAge = tonumber(args[1])
		for _, plr in ipairs(Players:GetPlayers()) do
			if plr.AccountAge <= maxAge then
				Insert(returns, plr)
			end
		end
		return returns
	end,

	["group(%d+)"] = function(speaker, args)
		local returns = {}
		local groupID = tonumber(args[1])
		for _, plr in ipairs(Players:GetPlayers()) do
			if plr:IsInGroup(groupID) then
				Insert(returns, plr)
			end
		end
		return returns
	end,

	["rad(%d+)"] = function(speaker, args)
		local returns = {}
		local radius = tonumber(args[1])
		local origin = getRoot(speaker.Character)
		if not origin then return returns end
		for _, plr in ipairs(Players:GetPlayers()) do
			local root = getRoot(plr.Character)
			if root and (root.Position - origin.Position).Magnitude <= radius then
				Insert(returns, plr)
			end
		end
		return returns
	end,

	["cursor"] = function(speaker)
		local returns = {}
		local v = NAmanage.getPlrCursor()
		if v then Insert(returns, v) end
		return returns
	end,
}

originalIO.normalizePlayerQuery=function(query)
	if type(query) == "string" then
		return query:lower()
	end
	if type(query) == "table" and type(query.Name) == "string" then
		return query.Name:lower()
	end
	return ""
end

local function getPlr(a, b)
	local speaker, raw
	if b == nil then
		speaker = Players.LocalPlayer
		raw = originalIO.normalizePlayerQuery(a)
	else
		speaker = a
		raw = originalIO.normalizePlayerQuery(b)
	end

	if PlayerArgs[raw] then
		return PlayerArgs[raw](speaker)
	end

	local onlyDigits = raw:match("^%d+$")
	if onlyDigits then
		return PlayerArgs["#(%d+)"](speaker, {onlyDigits}, PlayerArgs["all"]())
	end

	for pat, fn in pairs(PlayerArgs) do
		local captures = { raw:match("^"..pat.."$") }
		if #captures > 0 then
			return fn(speaker, captures, PlayerArgs["all"]())
		end
	end

	local out = {}
	for _, plr in ipairs(Players:GetPlayers()) do
		local n = plr.Name:lower()
		local d = plr.DisplayName:lower()
		if n:sub(1,#raw) == raw or d:sub(1,#raw) == raw then
			Insert(out, plr)
		end
	end
	return out
end

--[[ MORE VARIABLES ]]--
plr=Player
speaker=Player
char=plr.Character
deathCFrame = nil
local JSONEncode,JSONDecode=HttpService.JSONEncode,HttpService.JSONDecode

NACaller(function()
	LocalPlayer.CharacterAdded:Connect(function(c)
		if not c then return end
		character=c
		Character=c
		char=c
	end)
end)

local ESPenabled=false
local chamsEnabled=false
local ESPAutoTrackAll=false
local ESPPlayersEnabled=false
local NPCESPenabled=false
espCONS = espCONS or {}

NAmanage.ESP_RecomputeEnabled=function()
	ESPenabled = ESPPlayersEnabled or NPCESPenabled
end


NAgui.espUsesHighlight=function()
	local mode = NAStuff.ESP_RenderMode
	if type(mode) == "string" then
		return Lower(mode) == "highlight"
	end
	return false
end

NAgui.sanitizeTransparency=function(value)
	local tr = tonumber(value) or 0.7
	if tr < 0 then
		tr = 0
	elseif tr > 1 then
		tr = 1
	end
	return tr
end

NAgui.sanitizeLabelSize=function(value)
	local sz = tonumber(value) or 12
	if sz < 8 then
		sz = 8
	elseif sz > 72 then
		sz = 72
	end
	sz = math.floor(sz + 0.5)
	return sz
end

NAgui.getInstanceWorldPosition=function(inst)
	if not inst then return nil end
	if inst:IsA("BasePart") then
		return inst.Position
	elseif inst:IsA("Model") then
		local primary = inst.PrimaryPart
		if primary then
			return primary.Position
		end
		local okPivot, pivot = pcall(inst.GetPivot, inst)
		if okPivot and pivot then
			return pivot.Position
		end
		local okBox, cf = pcall(inst.GetBoundingBox, inst)
		if okBox and cf then
			return cf.Position
		end
	end
	return nil
end

NAgui.updateLabelBounds=function(label)
	if not label then return end
	local billboard = label.Parent
	if not billboard or not billboard:IsA("BillboardGui") then return end
	local text = label.Text
	if text == "" then
		text = label.Name or " "
	end
	local targetSize = NAgui.sanitizeLabelSize(NAStuff.ESP_LabelTextSize)
	local success, bounds = pcall(TextService.GetTextSize, TextService, text, targetSize, label.Font, Vector2.new(1e4, 1e4))
	local width = 150
	local height = math.max(targetSize + 12, 30)
	if success and bounds then
		width = math.clamp(math.floor(bounds.X + 16), 80, 600)
		height = math.clamp(math.floor(bounds.Y + 12), 24, 200)
	end
	local size = billboard.Size
	if size.X.Offset ~= width or size.Y.Offset ~= height then
		billboard.Size = UDim2.new(0, width, 0, height)
	end
end

NAgui.applyLabelStyle=function(label)
	if not label then return end
	label.AutomaticSize = Enum.AutomaticSize.None
	label.TextScaled = NAStuff.ESP_LabelTextScaled
	label.TextWrapped = false
	label.ClipsDescendants = false
	label.TextStrokeTransparency = math.clamp(tonumber(NAStuff.ESP_LabelStrokeTransparency) or 0.5, 0, 1)
	label.TextSize = NAgui.sanitizeLabelSize(NAStuff.ESP_LabelTextSize)
	NAgui.updateLabelBounds(label)
end

NAgui.updateLabelForInstance=function(inst)
	if not inst or not inst.Parent then return end
	for _, child in ipairs(inst:GetChildren()) do
		if child:IsA("BillboardGui") and Sub(Lower(child.Name),-6) == "_label" then
			local lbl = child:FindFirstChildWhichIsA("TextLabel")
			if lbl then
				NAgui.applyLabelStyle(lbl)
			end
		end
	end
end

NAmanage.ESP_ApplyLabelStyles = function()
	local scaled = (NAStuff.ESP_LabelTextScaled == true)
	local size = NAgui.sanitizeLabelSize(NAStuff.ESP_LabelTextSize)
	local seen = {}
	if NAStuff.partESPEntries then
		for _, entry in pairs(NAStuff.partESPEntries) do
			if typeof(entry) == "table" and entry.label and not seen[entry] then
				seen[entry] = true
				entry.label.TextScaled = scaled
				if not scaled then
					entry.label.TextSize = size
				end
			end
		end
	end
	if NAStuff.partESPVisualMap then
		for _, entry in pairs(NAStuff.partESPVisualMap) do
			if typeof(entry) == "table" and entry.label and not seen[entry] then
				seen[entry] = true
				entry.label.TextScaled = scaled
				if not scaled then
					entry.label.TextSize = size
				end
			end
		end
	end
end

NAgui.adjustHighlightMaterialFor = function(target, enable)
	if not target then return end
	local originals = NAStuff.partESPGlassOriginal
	local counts = NAStuff.partESPGlassCount
	local ltOriginals = NAStuff.partESPLocalTransOriginal
	local ltCounts = NAStuff.partESPLocalTransCount
	if not originals then
		originals = setmetatable({}, { __mode = "k" })
		NAStuff.partESPGlassOriginal = originals
	end
	if not counts then
		counts = setmetatable({}, { __mode = "k" })
		NAStuff.partESPGlassCount = counts
	end
	if not ltOriginals then
		ltOriginals = setmetatable({}, { __mode = "k" })
		NAStuff.partESPLocalTransOriginal = ltOriginals
	end
	if not ltCounts then
		ltCounts = setmetatable({}, { __mode = "k" })
		NAStuff.partESPLocalTransCount = ltCounts
	end
	local function handlePart(base)
		if not base or not base:IsA("BasePart") then return end
		local gCount = counts[base] or 0
		local tCount = ltCounts[base] or 0
		if enable then
			if gCount == 0 then
				originals[base] = base.Material
			end
			counts[base] = gCount + 1
			if base.Material ~= Enum.Material.Glass then
				NAlib.setProperty(base, "Material", Enum.Material.Glass)
			end
			if tCount == 0 then
				ltOriginals[base] = base.LocalTransparencyModifier
			end
			ltCounts[base] = tCount + 1
			if base.Transparency >= 1 or base.LocalTransparencyModifier >= 1 then
				NAlib.setProperty(base, "LocalTransparencyModifier", 0.999)
			end
		else
			if gCount > 0 then
				gCount -= 1
				if gCount <= 0 then
					counts[base] = nil
					local original = originals[base]
					if original ~= nil then
						NAlib.setProperty(base, "Material", original)
						originals[base] = nil
					end
				else
					counts[base] = gCount
				end
			end
			if tCount > 0 then
				tCount -= 1
				if tCount <= 0 then
					ltCounts[base] = nil
					local lt = ltOriginals[base]
					if lt ~= nil then
						NAlib.setProperty(base, "LocalTransparencyModifier", lt)
						ltOriginals[base] = nil
					end
				else
					ltCounts[base] = tCount
				end
			end
		end
	end
	if target:IsA("BasePart") then
		handlePart(target)
	elseif target:IsA("Model") then
		for _, desc in ipairs(target:GetDescendants()) do
			if desc:IsA("BasePart") then
				handlePart(desc)
			end
		end
	end
end

NAmanage.ESP_AdjustHighlightMaterial = function(target, enable)
	NAgui.adjustHighlightMaterialFor(target, enable)
end

NAStuff.partESPEntries = NAStuff.partESPEntries or setmetatable({}, { __mode = "k" })
NAStuff.partESPVisualMap = NAStuff.partESPVisualMap or setmetatable({}, { __mode = "k" })

NAmanage.PartESP_UpdateEntry = function(entry, force, rootPart)
	if not entry or entry.removed then return end
	local part = entry.part
	if not part or not part.Parent then
		NAmanage.PartESP_UnregisterEntry(entry)
		return
	end
	local billboard = entry.billboard
	local label = entry.label
	if not billboard or not billboard.Parent then
		NAmanage.PartESP_UnregisterEntry(entry)
		return
	end
	if not label or label.Parent ~= billboard then
		label = billboard:FindFirstChildWhichIsA("TextLabel")
		entry.label = label
	end
	local baseName = entry.customName or part.Name or "Part"
	local display = baseName
	local showDistance = (NAStuff.ESP_ShowPartDistance == true)
	local root = rootPart
	if showDistance and not root then
		local plr = Players.LocalPlayer
		local char = plr and plr.Character
		root = char and getRoot(char)
	end
	if showDistance and root then
		local pos = NAgui.getInstanceWorldPosition(part)
		if pos then
			local dist = math.floor((root.Position - pos).Magnitude + 0.5)
			display = Format("%s | %d studs", baseName, dist)
		end
	end
	if label then
		if label.Text ~= display then
			label.Text = display
		end
		NAgui.applyLabelStyle(label)
	end
	local visual = entry.visual
	local transparency = NAgui.sanitizeTransparency(NAStuff.ESP_Transparency or entry.transparency)
	if visual and visual.Parent then
		if visual:IsA("Highlight") then
			if visual.FillTransparency ~= transparency then
				visual.FillTransparency = transparency
			end
			local fill = entry.lightColor or entry.baseColor or Color3.new(1,1,1)
			local outline = entry.darkColor or fill
			local outlineTr = NAgui.sanitizeTransparency(NAStuff.ESP_OutlineTransparency or 0)
			if visual.FillColor ~= fill then
				visual.FillColor = fill
			end
			if visual.OutlineColor ~= outline then
				visual.OutlineColor = outline
			end
			if visual.OutlineTransparency ~= outlineTr then
				visual.OutlineTransparency = outlineTr
			end
		elseif visual:IsA("BoxHandleAdornment") then
			if entry.lightColor and visual.Color3 ~= entry.lightColor then
				visual.Color3 = entry.lightColor
			end
			if visual.Transparency ~= transparency then
				visual.Transparency = transparency
			end
			if part:IsA("BasePart") then
				local desired = part.Size + Vector3.new(0.1,0.1,0.1)
				if visual.Size ~= desired then
					visual.Size = desired
				end
			end
		end
	end
end

NAmanage.PartESP_UpdateTexts = function(force)
	local entries = NAStuff.partESPEntries
	if not entries then
		return
	end
	if not force then
		local now = tick()
		local nextUpdate = NAStuff.partESPLastUpdate or 0
		if now < nextUpdate then
			return
		end
		NAStuff.partESPLastUpdate = now + 0.2
	else
		NAStuff.partESPLastUpdate = tick() + 0.2
	end
	local rootPart = nil
	if NAStuff.ESP_ShowPartDistance == true then
		local plr = Players.LocalPlayer
		local char = plr and plr.Character
		rootPart = char and getRoot(char)
	end
	local hasEntry = false
	for _, entry in pairs(entries) do
		if entry and not entry.removed then
			hasEntry = true
			NAmanage.PartESP_UpdateEntry(entry, force, rootPart)
		end
	end
	if not hasEntry then
		NAmanage.PartESP_StopHeartbeat()
	end
end

NAmanage.PartESP_StartHeartbeat = function()
	if NAlib.isConnected("esp_part_update") then return end
	NAStuff.partESPLastUpdate = 0
	NAlib.connect("esp_part_update", RunService.Heartbeat:Connect(function()
		NAmanage.PartESP_UpdateTexts(false)
	end))
end

NAmanage.PartESP_StopHeartbeat = function()
	local entries = NAStuff.partESPEntries
	if entries and next(entries) then return end
	NAlib.disconnect("esp_part_update")
end

NAmanage.PartESP_RegisterEntry = function(entry)
	if not entry or not entry.billboard then return end
	NAStuff.partESPEntries[entry.billboard] = entry
	if entry.visual then
		NAStuff.partESPVisualMap[entry.visual] = entry
	end
	if entry.billboardCleanup then
		entry.billboardCleanup:Disconnect()
	end
	if entry.visualCleanup then
		entry.visualCleanup:Disconnect()
	end
	entry.billboardCleanup = entry.billboard.AncestryChanged:Connect(function(_, parent)
		if not parent then
			NAmanage.PartESP_UnregisterEntry(entry)
		end
	end)
	if entry.visual then
		entry.visualCleanup = entry.visual.AncestryChanged:Connect(function(_, parent)
			if not parent then
				NAmanage.PartESP_UnregisterEntry(entry)
			end
		end)
	end
	NAmanage.PartESP_StartHeartbeat()
	NAmanage.PartESP_UpdateEntry(entry, true)
end

NAmanage.PartESP_UnregisterEntry = function(entry)
	if not entry or entry.removed then return end
	entry.removed = true
	if entry.billboardCleanup then
		entry.billboardCleanup:Disconnect()
		entry.billboardCleanup = nil
	end
	if entry.visualCleanup then
		entry.visualCleanup:Disconnect()
		entry.visualCleanup = nil
	end
	if entry.updateKey then
		NAlib.disconnect(entry.updateKey)
		entry.updateKey = nil
	end
	if entry.billboard and NAStuff.partESPEntries then
		NAStuff.partESPEntries[entry.billboard] = nil
	end
	if entry.visual and NAStuff.partESPVisualMap then
		NAStuff.partESPVisualMap[entry.visual] = nil
	end
	NAmanage.PartESP_StopHeartbeat()
end

NAmanage.PartESP_RebuildVisuals = function()
	local entries = NAStuff.partESPEntries
	if not entries or not next(entries) then
		return
	end
	local grouped = {}
	for _, entry in pairs(entries) do
		if entry and not entry.removed and entry.part and entry.part.Parent then
			local bucket = grouped[entry.part]
			if not bucket then
				bucket = {}
				grouped[entry.part] = bucket
			end
			bucket[#bucket+1] = {
				color = entry.baseColor or Color3.new(1,1,1),
				transparency = entry.transparency or 0.45,
			}
		end
	end
	for part, bucket in pairs(grouped) do
		NAmanage.RemoveEspFromPart(part)
		for _, info in ipairs(bucket) do
			NAmanage.CreateBox(part, info.color, info.transparency)
		end
	end
	NAmanage.PartESP_UpdateTexts(true)
end

NAmanage.ESP_RebuildVisuals = function()
	for model, data in pairs(espCONS) do
		if data then
			local wasEnabled = data.boxEnabled
			NAmanage.ESP_RemoveBoxes(model)
			if wasEnabled then
				NAmanage.ESP_AddBoxes(model)
			end
		end
	end
	NAmanage.PartESP_RebuildVisuals()
	NAmanage.ESP_ApplyLabelStyles()
end

function round(num,numDecimalPlaces)
	local mult=10^(numDecimalPlaces or 0)
	return math.floor(num*mult+0.5) / mult
end

function getPlaceInfo()
	local success, result = pcall(function()
		return SafeGetService("MarketplaceService"):GetProductInfo(PlaceId)
	end)

	if not success then return nil end

	return result
end

function placeName()
	local info = getPlaceInfo()
	local name = info and NAlib.isProperty(info, "Name")
	return name or "unknown"
end

function placeIconAssetId()
	local info = getPlaceInfo()
	local icon = info and NAlib.isProperty(info, "IconImageAssetId")
	if typeof(icon) == "number" then
		return icon
	end
	if typeof(icon) == "string" then
		local digits = icon:match("(%d+)")
		if digits then
			local numeric = tonumber(digits)
			if numeric then
				return numeric
			end
		end
		local asNumber = tonumber(icon)
		if asNumber then
			return asNumber
		end
	end
	return nil
end

function SaveUIStroke(color)
	if typeof(color) ~= "Color3" then
		return
	end

	if NAStuff and NAStuff.AprilFoolsData then
		NAStuff.AprilFoolsData.originalColor = color
	end

	NAmanage.NASettingsSet("uiStroke", {
		R = color.R;
		G = color.G;
		B = color.B;
	})
end

function placeCreator()
	local info = getPlaceInfo()
	local creator = info and NAlib.isProperty(info, "Creator")
	local creatorName = creator and NAlib.isProperty(creator, "Name")
	return creatorName or "unknown"
end

NAmanage.ESP_Key = function(model)
	return tostring(model)
end

NAmanage.ESP_DestroyLabel = function(model)
	local data = espCONS[model]
	if not data then return end
	local uid = data.uid

	if data.billboard then
		data.billboard:Destroy()
		data.billboard = nil
	end

	if data.textLabel then
		data.textLabel:Destroy()
		data.textLabel = nil
	end

	if uid and model and model.Parent then
		for _, d in ipairs(model:GetDescendants()) do
			if d:IsA("BillboardGui") and d:GetAttribute("NA_ESP_UID") == uid then
				d:Destroy()
			end
		end
	end
end

NAmanage.ESP_FirstBasePart = function(model)
	if not model or not model.Parent then return nil end
	for _, d in ipairs(model:GetDescendants()) do
		if d:IsA("BasePart") then
			return d
		end
	end
	return nil
end

NAmanage.ESP_EnsureLabel = function(model)
	if chamsEnabled then return end
	local data = espCONS[model]
	if not data then return end

	if not data.uid then
		data.uid = HttpService:GenerateGUID(false)
	end
	local uid = data.uid

	local anchor = getHead(model) or getRoot(model) or NAmanage.ESP_FirstBasePart(model)
	if not anchor then
		NAmanage.ESP_DestroyLabel(model)
		return
	end

	local bb = data.billboard
	local tl = data.textLabel

	if bb and not bb:IsDescendantOf(game) then
		bb = nil
		tl = nil
		data.billboard = nil
		data.textLabel = nil
	end

	local list = {}
	if model.Parent then
		for _, d in ipairs(model:GetDescendants()) do
			if d:IsA("BillboardGui") and d:GetAttribute("NA_ESP_UID") == uid then
				list[#list + 1] = d
			end
		end
	end

	local keep = nil
	if bb and bb.Parent and bb:GetAttribute("NA_ESP_UID") == uid then
		keep = bb
	end
	if not keep and #list > 0 then
		keep = list[1]
	end
	for i = 1, #list do
		local inst = list[i]
		if inst ~= keep then
			inst:Destroy()
		end
	end

	if not keep then
		keep = InstanceNew("BillboardGui")
		keep:SetAttribute("NA_ESP_UID", uid)
		keep.Adornee = anchor
		keep.AlwaysOnTop = true
		keep.Size = UDim2.new(0,150,0,40)
		keep.StudsOffset = Vector3.new(0,2.5,0)
		keep.Parent = anchor

		tl = InstanceNew("TextLabel")
		tl.Size = UDim2.new(1,0,1,0)
		tl.BackgroundTransparency = 1
		tl.Font = Enum.Font.GothamBold
		tl.TextStrokeTransparency = 0.5
		tl.Text = ""
		tl.Parent = keep
	else
		if not (tl and tl.Parent == keep) then
			tl = keep:FindFirstChildWhichIsA("TextLabel")
			if not tl then
				tl = InstanceNew("TextLabel")
				tl.Size = UDim2.new(1,0,1,0)
				tl.BackgroundTransparency = 1
				tl.Font = Enum.Font.GothamBold
				tl.TextStrokeTransparency = 0.5
				tl.Text = ""
				tl.Parent = keep
			end
		end
	end

	keep.Adornee = anchor
	keep.Parent = anchor

	NAgui.applyLabelStyle(tl)
	data.billboard = keep
	data.textLabel = tl
end

NAmanage.ESP_AddBoxForPart = function(model, part)
	local data = espCONS[model]
	if not data or data.isNPC or not part or not part:IsA("BasePart") then return end
	if data.boxTable[part] then return end
	if NAgui.espUsesHighlight() then return end
	local box = InstanceNew("BoxHandleAdornment")
	box.Adornee = part
	box.AlwaysOnTop = true
	box.ZIndex = 1
	box.Transparency = NAgui.sanitizeTransparency(NAStuff.ESP_Transparency or 0.7)
	box.Size = part.Size
	box.Color3 = Color3.new(1,1,1)
	box.Parent = part
	data.boxTable[part] = box
end

NAmanage.ESP_AddBoxes = function(model)
	local data = espCONS[model]
	if not data then return end

	if data.isNPC then
		for part, box in pairs(data.boxTable) do
			if box then box:Destroy() end
			data.boxTable[part] = nil
		end

		local highlight = data.highlight
		if highlight and not highlight.Parent then
			highlight = nil
		end

		if not highlight then
			local hl = InstanceNew("Highlight")
			hl.Name = "NAESP_Highlight"
			hl.Adornee = model
			hl.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop

			local baseColor = (NAStuff.ESP_UseCustomColor == true and typeof(NAStuff.ESP_CustomColor) == "Color3")
				and NAStuff.ESP_CustomColor
				or Color3.new(1, 1, 1)

			local outline = NAgui.sanitizeTransparency(NAStuff.ESP_OutlineTransparency or 0)

			hl.FillColor = baseColor
			hl.OutlineColor = baseColor
			hl.FillTransparency = NAgui.sanitizeTransparency(NAStuff.ESP_Transparency or 0.7)
			hl.OutlineTransparency = outline
			hl.Parent = model

			data.highlight = hl
			NAmanage.ESP_AdjustHighlightMaterial(model, true)
		else
			data.highlight = highlight
		end

		if data.highlight then
			data.highlight.Enabled = true
		end

		data.boxEnabled = true
		return
	end

	if NAgui.espUsesHighlight() then
		local highlight = data.highlight
		if highlight and not highlight.Parent then
			highlight = nil
		end

		if not highlight then
			local hl = InstanceNew("Highlight")
			hl.Name = "NAESP_Highlight"
			hl.Adornee = model
			hl.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop

			local baseColor = (NAStuff.ESP_UseCustomColor == true and typeof(NAStuff.ESP_CustomColor) == "Color3")
				and NAStuff.ESP_CustomColor
				or Color3.new(1, 1, 1)

			local outline = NAgui.sanitizeTransparency(NAStuff.ESP_OutlineTransparency or 0)

			hl.FillColor = baseColor
			hl.OutlineColor = baseColor
			hl.FillTransparency = NAgui.sanitizeTransparency(NAStuff.ESP_Transparency or 0.7)
			hl.OutlineTransparency = outline
			hl.Parent = model

			data.highlight = hl
			NAmanage.ESP_AdjustHighlightMaterial(model, true)
		else
			data.highlight = highlight
		end

		if data.highlight then
			data.highlight.Enabled = true
			data.highlight.OutlineTransparency = NAgui.sanitizeTransparency(NAStuff.ESP_OutlineTransparency or 0)
		end

		data.boxEnabled = true
		return
	end

	for _, part in ipairs(model:GetDescendants()) do
		if part:IsA("BasePart") then
			NAmanage.ESP_AddBoxForPart(model, part)
		end
	end

	data.boxEnabled = true
end

NAmanage.ESP_RemoveBoxes = function(model)
	local data = espCONS[model]
	if not data then return end
	for part, box in pairs(data.boxTable) do
		if box then box:Destroy() end
		data.boxTable[part] = nil
	end
	if data.highlight then
		NAmanage.ESP_AdjustHighlightMaterial(model, false)
		data.highlight:Destroy()
		data.highlight = nil
	end
	data.boxEnabled = false
end

NAmanage.ESP_ClearModel = function(model)
	if not model then return end
	local key = NAmanage.ESP_Key(model)
	NAlib.disconnect(key.."_descAdded")
	NAlib.disconnect(key.."_descRemoved")
	NAlib.disconnect(key.."_ancestry")
	NAlib.disconnect(key.."_charAdded")
	NAmanage.ESP_UnregisterModel(model)
	NAmanage.ESP_RemoveBoxes(model)
	NAmanage.ESP_DestroyLabel(model)
	espCONS[model] = nil
end

NAmanage.ESP_ClearAll = function()
	for model,_ in pairs(espCONS) do
		NAmanage.ESP_ClearModel(model)
	end
	for _, plr in ipairs(Players:GetPlayers()) do
		NAlib.disconnect("esp_charAdded_plr_"..tostring(plr.UserId))
	end
	NAStuff.ESP_ModelList = {}
	NAlib.disconnect("esp_update_global")
	ESPPlayersEnabled = false
	NPCESPenabled = false
	NAmanage.ESP_RecomputeEnabled()
end

NAmanage.ESP_ClearPlayers = function()
	for model, data in pairs(espCONS) do
		if not (data and data.isNPC) then
			NAmanage.ESP_ClearModel(model)
		end
	end
	for _, plr in ipairs(Players:GetPlayers()) do
		NAlib.disconnect("esp_charAdded_plr_"..tostring(plr.UserId))
	end
end

NAmanage.ESP_Disconnect = function(target)
	local model = (target and target:IsA("Player")) and target.Character or target
	if typeof(target) == "Instance" and target:IsA("Player") then
		NAlib.disconnect("esp_charAdded_plr_"..tostring(target.UserId))
	end
	NAmanage.ESP_ClearModel(model)
end

NAmanage.ESP_UpdateOne = function(model, now, localRoot)
	local data = espCONS[model]
	if not data then return end

	local owner = Players:GetPlayerFromCharacter(model)
	if not NAmanage.IsValidESPModel(model, data.isNPC) then
		if data.persistent and owner then
			Spawn(function()
				if owner.Character and NAmanage.IsValidESPModel(owner.Character, false) then
					NAmanage.ESP_Add(owner, true, false)
				end
			end)
		else
			NAmanage.ESP_ClearModel(model)
		end
		return
	end

	local rootPart = getRoot(model)
	local team = owner and owner.Team or nil
	local teamName = team and team.Name or nil
	local teamColor = team and team.TeamColor and team.TeamColor.Color or nil

	local dist = (localRoot and rootPart) and math.floor((localRoot.Position - rootPart.Position).Magnitude) or nil
	local budget = dist and ((dist <= 50 and 0.05) or (dist <= 150 and 0.15) or (dist <= 400 and 0.3) or 0.6) or 0.2

	if data.isNPC then
		budget = budget * (NAStuff.NPC_ESP_Throttle or 2)
	end

	if data.next and now < data.next then return end
	data.next = now + budget

	local distColor = dist and ((dist > 100 and Color3.fromRGB(0, 255, 0)) or (dist > 50 and Color3.fromRGB(255, 165, 0)) or Color3.fromRGB(255, 0, 0)) or Color3.new(1, 1, 1)
	local customColor = (NAStuff.ESP_UseCustomColor == true) and NAStuff.ESP_CustomColor or nil
	local finalColor = (typeof(customColor) == "Color3" and customColor)
		or ((NAStuff.ESP_ColorByTeam ~= false and teamColor) and teamColor)
		or distColor

	local isNPC = data.isNPC == true
	local boxDist = isNPC and (NAStuff.NPC_ESP_BoxMaxDistance or NAStuff.ESP_BoxMaxDistance or 120) or (NAStuff.ESP_BoxMaxDistance or 120)
	local wantBoxes = ESPenabled and (dist == nil or dist <= boxDist)
	local labelDist = isNPC and (NAStuff.NPC_ESP_LabelMaxDistance or NAStuff.ESP_LabelMaxDistance or 600) or (NAStuff.ESP_LabelMaxDistance or 1000)
	local allowLabel = (not isNPC) or (NAStuff.NPC_ESP_ShowLabels ~= false)
	local wantLabel = ESPenabled and not chamsEnabled and allowLabel and (dist == nil or dist <= labelDist)

	if wantBoxes and not data.boxEnabled then
		NAmanage.ESP_AddBoxes(model)
	elseif not wantBoxes and data.boxEnabled then
		NAmanage.ESP_RemoveBoxes(model)
	end

	if data.boxEnabled then
		if isNPC then
			local highlight = data.highlight
			if not highlight or not highlight.Parent then
				data.highlight = nil
				if wantBoxes then
					NAmanage.ESP_AddBoxes(model)
					highlight = data.highlight
				end
			end
			if highlight then
				local tr = NAgui.sanitizeTransparency(NAStuff.ESP_Transparency or 0.7)
				if highlight.FillTransparency ~= tr then highlight.FillTransparency = tr end
				local outline = NAgui.sanitizeTransparency(NAStuff.ESP_OutlineTransparency or 0)
				if highlight.OutlineTransparency ~= outline then highlight.OutlineTransparency = outline end
				local color = finalColor or Color3.new(1, 1, 1)
				if highlight.FillColor ~= color then highlight.FillColor = color end
				if highlight.OutlineColor ~= color then highlight.OutlineColor = color end
			end
		elseif NAgui.espUsesHighlight() then
			if next(data.boxTable) ~= nil then
				for part, box in pairs(data.boxTable) do
					if box then box:Destroy() end
					data.boxTable[part] = nil
				end
			end
			local highlight = data.highlight
			if not highlight or not highlight.Parent then
				data.highlight = nil
				if wantBoxes then
					NAmanage.ESP_AddBoxes(model)
					highlight = data.highlight
				end
			end
			if highlight then
				local tr = NAgui.sanitizeTransparency(NAStuff.ESP_Transparency or 0.7)
				if highlight.FillTransparency ~= tr then highlight.FillTransparency = tr end
				local outline = NAgui.sanitizeTransparency(NAStuff.ESP_OutlineTransparency or 0)
				if highlight.OutlineTransparency ~= outline then highlight.OutlineTransparency = outline end
				local color = finalColor or Color3.new(1, 1, 1)
				if highlight.FillColor ~= color then highlight.FillColor = color end
				if highlight.OutlineColor ~= color then highlight.OutlineColor = color end
			end
		else
			local tr = NAgui.sanitizeTransparency(NAStuff.ESP_Transparency or 0.7)
			for part, box in pairs(data.boxTable) do
				if not part or not part.Parent then
					if box then box:Destroy() end
					data.boxTable[part] = nil
				else
					if box.Color3 ~= finalColor then box.Color3 = finalColor end
					if part:IsA("BasePart") and box.Size ~= part.Size then box.Size = part.Size end
					if box.Transparency ~= tr then box.Transparency = tr end
				end
			end
			if now % 0.5 < 0.05 then
				for _, part in ipairs(model:GetDescendants()) do
					if part:IsA("BasePart") and not data.boxTable[part] then
						NAmanage.ESP_AddBoxForPart(model, part)
					end
				end
			end
		end
	end

	local pieces
	if wantLabel then
		pieces = {}
		if NAStuff.ESP_ShowName ~= false then
			local nm = owner and nameChecker(owner) or model.Name
			if nm and nm ~= "" then pieces[#pieces + 1] = nm end
		end
		if NAStuff.ESP_ShowHealth ~= false then
			local hum = getPlrHum(model)
			local h = hum and math.floor(hum.Health) or nil
			local m = hum and math.floor(hum.MaxHealth) or nil
			if h and m then pieces[#pieces + 1] = tostring(h) .. "/" .. tostring(m) .. " HP" end
		end
		if (NAStuff.ESP_ShowTeamText ~= false) and teamName and teamName ~= "None" then
			pieces[#pieces + 1] = teamName
		end
		if (NAStuff.ESP_ShowDistance ~= false) and dist then
			pieces[#pieces + 1] = tostring(dist) .. " studs"
		end
	end

	if wantLabel and pieces and #pieces > 0 then
		NAmanage.ESP_EnsureLabel(model)
		local label = data.textLabel
		if label then
			NAgui.applyLabelStyle(label)
			local txt = Concat(pieces, " | ")
			if label.Text ~= txt then label.Text = txt end
			local txtColor = finalColor or Color3.new(1, 1, 1)
			if label.TextColor3 ~= txtColor then label.TextColor3 = txtColor end
		end
	else
		NAmanage.ESP_DestroyLabel(model)
	end
end

NAmanage.ESP_RegisterModel=function(m)
	if not m then return end
	local t = NAStuff.ESP_ModelList
	for i = 1, #t do
		if t[i] == m then
			return
		end
	end
	t[#t + 1] = m
end

NAmanage.ESP_UnregisterModel=function(m)
	if not m then return end
	local t = NAStuff.ESP_ModelList
	for i = 1, #t do
		if t[i] == m then
			table.remove(t, i)
			break
		end
	end
	if NAStuff.ESP_ModelIndex > #t then
		NAStuff.ESP_ModelIndex = 1
	end
end

NAmanage.ESP_Add = function(target, persistent, isNPC)
	persistent = persistent or false
	local npcFlag = isNPC == true

	if not (ESPenabled or chamsEnabled) then return end
	if typeof(target) ~= "Instance" then return end

	if target:IsA("Player") then
		if persistent then
			NAlib.disconnect("esp_charAdded_plr_"..tostring(target.UserId))
			NAlib.connect("esp_charAdded_plr_"..tostring(target.UserId), target.CharacterAdded:Connect(function()
				Wait(0.25)
				if (ESPenabled or chamsEnabled) then
					NAmanage.ESP_Add(target, true, false)
				end
			end))
		end
		if not target.Character then return end
	end

	local model = target:IsA("Player") and target.Character or target
	NAmanage.ESP_ClearModel(model)
	if not (model and model:IsA("Model")) then return end
	if not NAmanage.IsValidESPModel(model, npcFlag) then return end

	espCONS[model] = {
		boxTable = {},
		persistent = persistent,
		boxEnabled = false,
		highlight = nil,
		isNPC = npcFlag
	}

	NAmanage.ESP_RegisterModel(model)
	local key = NAmanage.ESP_Key(model)

	NAlib.connect(key.."_descAdded", model.DescendantAdded:Connect(function(desc)
		if not (ESPenabled or chamsEnabled) then return end
		local data = espCONS[model]
		if not data or data.isNPC then return end
		if desc:IsA("BasePart") and data.boxEnabled then
			NAmanage.ESP_AddBoxForPart(model, desc)
		end
	end))

	NAlib.connect(key.."_descRemoved", model.DescendantRemoving:Connect(function(desc)
		local data = espCONS[model]
		if not data then return end
		local box = data.boxTable[desc]
		if box then
			box:Destroy()
			data.boxTable[desc] = nil
		end
	end))

	NAlib.connect(key.."_ancestry", model.AncestryChanged:Connect(function(_, parent)
		local data = espCONS[model]
		if not data then return end
		if data.persistent then
			local owner = Players:GetPlayerFromCharacter(model)
			if parent and workspace and model:IsDescendantOf(workspace) then
				Spawn(function()
					if owner then
						NAmanage.ESP_Add(owner, true, false)
					elseif NAmanage.IsValidESPModel(model, data.isNPC) then
						NAmanage.ESP_Add(model, true, data.isNPC)
					end
				end)
			end
		else
			if parent == nil or not (workspace and model:IsDescendantOf(workspace)) then
				NAmanage.ESP_ClearModel(model)
			end
		end
	end))

	NAmanage.ESP_AddBoxes(model)
	NAmanage.ESP_EnsureLabel(model)

	local ok, now = pcall(tick)
	if ok then
		NAmanage.ESP_UpdateOne(model, now, nil)
	end

	NAmanage.ESP_StartGlobal()
end

NAmanage.ESP_StartGlobal = function()
	if NAlib.isConnected("esp_update_global") then return end
	NAlib.connect("esp_update_global", RunService.Heartbeat:Connect(function()
		if not (ESPenabled or chamsEnabled) then return end
		local list = NAStuff.ESP_ModelList
		local n = list and #list or 0
		if n == 0 then return end

		local plr = Players.LocalPlayer
		local char = plr and plr.Character or nil
		local root = char and getRoot(char) or nil
		local now = tick()

		local idx = NAStuff.ESP_ModelIndex or 1
		local maxStep = math.clamp(math.floor(tonumber(NAStuff.ESP_MaxPerStep) or 32), 1, 256)
		if idx > n then
			idx = 1
		end
		local stop = math.min(n, idx + maxStep - 1)
		for i = idx, stop do
			local m = list[i]
			if m and espCONS[m] then
				NAmanage.ESP_UpdateOne(m, now, root)
			end
		end
		idx = stop + 1
		if idx > n then
			idx = 1
		end
		NAStuff.ESP_ModelIndex = idx
	end))
end

NAmanage.ESP_StopGlobal = function()
	NAlib.disconnect("esp_update_global")
end

--[[local Signal1, Signal2 = nil, nil
local flyMobile, MobileWeld = nil, nil

function mobilefly(speed, vfly)
	local character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
	if flyMobile then flyMobile:Destroy() end
	flyMobile = InstanceNew("Part", workspace)
	flyMobile.Size, flyMobile.CanCollide = Vector3.new(0.05, 0.05, 0.05), false
	if MobileWeld then MobileWeld:Destroy() end
	MobileWeld = InstanceNew("Weld", flyMobile)
	MobileWeld.Part0, MobileWeld.Part1, MobileWeld.C0 = flyMobile, character:FindFirstChildWhichIsA("Humanoid").RootPart, CFrame.new(0, 0, 0)

	if not flyMobile:FindFirstChildWhichIsA("BodyVelocity") then
		local bv = InstanceNew("BodyVelocity", flyMobile)
		bv.MaxForce = Vector3.new(0, 0, 0)
		bv.Velocity = Vector3.new(0, 0, 0)
	end

	if not flyMobile:FindFirstChildWhichIsA("BodyGyro") then
		local bg = InstanceNew("BodyGyro", flyMobile)
		bg.MaxTorque = Vector3.new(9e9, 9e9, 9e9)
		bg.P = 1000
		bg.D = 50
	end

	Signal1 = LocalPlayer.CharacterAdded:Connect(function(newChar)
		if not flyMobile:FindFirstChildWhichIsA("BodyVelocity") then
			local bv = InstanceNew("BodyVelocity", flyMobile)
			bv.MaxForce = Vector3.new(0, 0, 0)
			bv.Velocity = Vector3.new(0, 0, 0)
		end

		if not flyMobile:FindFirstChildWhichIsA("BodyGyro") then
			local bg = InstanceNew("BodyGyro", flyMobile)
			bg.MaxTorque = Vector3.new(9e9, 9e9, 9e9)
			bg.P = 1000
			bg.D = 50
		end

		if not flyMobile:FindFirstChildWhichIsA("Weld") then
			MobileWeld = InstanceNew("Weld", flyMobile)
			MobileWeld.Part0, MobileWeld.Part1, MobileWeld.C0 = flyMobile, newChar:FindFirstChildWhichIsA("Humanoid").RootPart, CFrame.new(0, 0, 0)
		else
			MobileWeld.Part0, MobileWeld.Part1, MobileWeld.C0 = flyMobile, newChar:FindFirstChildWhichIsA("Humanoid").RootPart, CFrame.new(0, 0, 0)
		end
	end)

	local camera = workspace.CurrentCamera

	Signal2 = RunService.RenderStepped:Connect(function()
		local character = getChar()
		local humanoid = character and character:FindFirstChildOfClass("Humanoid")
		local bv = flyMobile and flyMobile:FindFirstChildWhichIsA("BodyVelocity")
		local bg = flyMobile and flyMobile:FindFirstChildWhichIsA("BodyGyro")

		if character and humanoid and flyMobile and MobileWeld and bv and bg then
			bv.MaxForce = Vector3.new(9e9, 9e9, 9e9)
			bg.MaxTorque = Vector3.new(9e9, 9e9, 9e9)
			if not vfly then
				if getHum() and getHum().PlatformStand then getHum().PlatformStand = true end
			end

			bg.CFrame = camera.CFrame
			local direction = GetCustomMoveVector()
			local newVelocity = Vector3.new()

			if direction.X ~= 0 then
				newVelocity = newVelocity + camera.CFrame.RightVector * (direction.X * speed)
			end
			if direction.Z ~= 0 then
				newVelocity = newVelocity - camera.CFrame.LookVector * (direction.Z * speed)
			end

			bv.Velocity = newVelocity
		end
	end)
end

function unmobilefly()
	if flyMobile then
		flyMobile:Destroy()
		if getHum() and getHum().PlatformStand then getHum().PlatformStand = false end
	end
	if Signal1 then Signal1:Disconnect() end
	if Signal2 then Signal2:Disconnect() end
end]]

local tool
if getChar() and getBp() then
	tool=getBp():FindFirstChildOfClass("Tool") or getChar():FindFirstChildOfClass("Tool")
end

local xrayConn = nil

function togXray(en)
	if type(en) ~= "boolean" then
		warn("togXray: Invalid arg, expected boolean")
		return
	end

	local transVal = en and 0.5 or 0.0

	if en then
		xrayConn = workspace.DescendantAdded:Connect(function(desc)
			if desc:IsA("BasePart") then
				local hasHum = false
				local cur = desc.Parent
				for i = 1, 5 do
					if cur and cur:FindFirstChildOfClass("Humanoid") then
						hasHum = true
						break
					end
					cur = cur.Parent
					if not cur or cur == workspace then
						break
					end
				end
				if not hasHum then
					local ok, err = pcall(function()
						desc.LocalTransparencyModifier = 0.5
					end)
					if not ok then
						warn("Failed to mod transparency for new part "..tostring(desc)..": "..tostring(err))
					end
				end
			end
		end)
	else
		if xrayConn then
			xrayConn:Disconnect()
			xrayConn = nil
		end
	end

	for _, prt in pairs(workspace:GetDescendants()) do
		if prt:IsA("BasePart") then
			local hasHum = false
			local cur = prt.Parent
			for i = 1, 5 do
				if cur and cur:FindFirstChildOfClass("Humanoid") then
					hasHum = true
					break
				end
				cur = cur.Parent
				if not cur or cur == workspace then
					break
				end
			end
			if not hasHum then
				local ok, err = NACaller(function()
					prt.LocalTransparencyModifier = transVal
				end)
				if not ok then
					warn("Failed to mod transparency for part "..tostring(prt)..": "..tostring(err))
				end
			end
		end
	end
end

-- [[ FLY VARIABLES ]] --

local flyVariables = {
	mOn = false;
	mFlyBruh = nil;
	flyEnabled = false;
	toggleKey = "f";
	flySpeed = 1;
	keybindConn = nil;

	vOn = false;
	vRAHH = nil;
	vFlyEnabled = false;
	vToggleKey = "v";
	vFlySpeed = 1;
	vKeybindConn = nil;

	cOn = false;
	cFlyGUI = nil;
	cFlyEnabled = false;
	cToggleKey = "c";
	cFlySpeed = 1;
	cKeybindConn = nil;

	TFlyEnabled = false;
	tflyCORE = nil;
	tflyToggleKey = "t";
	tflyButtonUI = nil;
	TFLYBTN = nil;
	tflyKeyConn = nil;
	TflySpeed = 2;

	uiPosConns = {};
}

-----------------------------

cmdlp = Players.LocalPlayer
plr = cmdlp
goofyFLY = nil

NAmanage.configureFlyHelper=function(part)
	if not part then return end
	part.Size = Vector3.new(0.05, 0.05, 0.05)
	part.Transparency = 1
	part.CanCollide = false
	pcall(function() part.CanTouch = false end)
	pcall(function() part.CanQuery = false end)
	pcall(function() part.Massless = true end)
end

NAmanage._state={mode="none"}
NAmanage._persist={lastMode="none",wasFlying=false,uiPos={}}
FLYING=FLYING or false

NAmanage._modeEnabled=function(m)
	if m=="fly" then return flyVariables.flyEnabled
	elseif m=="vfly" then return flyVariables.vFlyEnabled
	elseif m=="cfly" then return flyVariables.cFlyEnabled
	elseif m=="tfly" then return flyVariables.TFlyEnabled
	end
	return false
end

NAmanage._releaseQE=function()
	if flyVariables.qeDownConn then pcall(function() flyVariables.qeDownConn:Disconnect() end) end
	if flyVariables.qeUpConn then pcall(function() flyVariables.qeUpConn:Disconnect() end) end
	flyVariables.qeDownConn=nil
	flyVariables.qeUpConn=nil
end

NAmanage._bindQE=function()
	NAmanage._releaseQE()
	flyVariables.qeDownConn=mouse.KeyDown:Connect(function(k)
		k=Lower(k or "")
		if k=="q" then
			local sp=(NAmanage._state.mode=="vfly" and tonumber(flyVariables.vFlySpeed) or tonumber(flyVariables.flySpeed) or 1)
			CONTROL.Q=-sp*2
		elseif k=="e" then
			local sp=(NAmanage._state.mode=="vfly" and tonumber(flyVariables.vFlySpeed) or tonumber(flyVariables.flySpeed) or 1)
			CONTROL.E=sp*2
		end
	end)
	flyVariables.qeUpConn=mouse.KeyUp:Connect(function(k)
		k=Lower(k or "")
		if k=="q" then CONTROL.Q=0 elseif k=="e" then CONTROL.E=0 end
	end)
end

NAmanage._clearPhysics=function(full)
	if CFloop then pcall(function() CFloop:Disconnect() end) end
	CFloop=nil
	if full then
		if goofyFLY then pcall(function() goofyFLY:Destroy() end) end
		goofyFLY=nil
		if flyVariables.TFpos then pcall(function() flyVariables.TFpos:Destroy() end) end
		if flyVariables.TFgyro then pcall(function() flyVariables.TFgyro:Destroy() end) end
		flyVariables.TFpos=nil
		flyVariables.TFgyro=nil
		if flyVariables.BG then pcall(function() flyVariables.BG:Destroy() end) end
		if flyVariables.BV then pcall(function() flyVariables.BV:Destroy() end) end
		flyVariables.BG=nil
		flyVariables.BV=nil
		for _,v in ipairs(workspace:GetDescendants()) do
			if v:GetAttribute("tflyPart") then pcall(function() v:Destroy() end) end
		end
	end
end

NAmanage._isSeated=function()
	local hum=getHum()
	if not hum then return false end
	if hum.Sit then return true end
	local seat=hum.SeatPart
	return seat and (seat:IsA("Seat") or seat:IsA("VehicleSeat")) or false
end

NAmanage.FLY_Cleanup = function(char)
	local c = char or getChar()
	local hum = getHum(c)
	local head = getHead(c)
	if head then pcall(function() head.Anchored = false end) end
	if hum then
		pcall(function() hum.PlatformStand = false end)
		pcall(function() hum.Sit = false end)
		pcall(function() hum.AutoRotate = true end)
		pcall(function() hum:ChangeState(Enum.HumanoidStateType.Running) end)
	end
	if flyVariables.TFpos then pcall(function() flyVariables.TFpos:Destroy() end) flyVariables.TFpos=nil end
	if flyVariables.TFgyro then pcall(function() flyVariables.TFgyro:Destroy() end) flyVariables.TFgyro=nil end
	if flyVariables.BG then pcall(function() flyVariables.BG:Destroy() end) flyVariables.BG=nil end
	if flyVariables.BV then pcall(function() flyVariables.BV:Destroy() end) flyVariables.BV=nil end
	if goofyFLY then pcall(function() goofyFLY:Destroy() end) goofyFLY=nil end
	CONTROL={Q=0,E=0}; lCONTROL={Q=0,E=0}; SPEED=0
	FLYING=false
end

NAmanage.FLY_OnRespawnGround = function()
	local c = getChar()
	NAmanage.FLY_Cleanup(c)
end

NAmanage.pauseCurrent = function()
	if not FLYING then return end
	FLYING=false
	local hum=getHum()
	local head=getHead(getChar())
	if NAmanage._state.mode=="cfly" then
		if head then head.Anchored=false end
	elseif NAmanage._state.mode=="tfly" then
		if flyVariables.TFpos then flyVariables.TFpos.maxForce=Vector3.new(0,0,0) end
		if flyVariables.TFgyro then flyVariables.TFgyro.maxTorque=Vector3.new(0,0,0) end
	elseif NAmanage._state.mode=="fly" or NAmanage._state.mode=="vfly" then
		if flyVariables.BV then flyVariables.BV.velocity=Vector3.zero flyVariables.BV.maxForce=Vector3.new(0,0,0) end
		if flyVariables.BG then flyVariables.BG.maxTorque=Vector3.new(0,0,0) end
		if hum and not NAmanage._isSeated() then
			hum.PlatformStand=false
			hum.AutoRotate=true
			hum:ChangeState(Enum.HumanoidStateType.Running)
		end
	end
end

NAmanage._camera=function()
	local cam=workspace.CurrentCamera
	if cam and cam.Parent then return cam end
	return nil
end

NAmanage._bindCameraWatch=function()
	if flyVariables._camChangedConn then pcall(function() flyVariables._camChangedConn:Disconnect() end) end
	flyVariables._camChangedConn=workspace:GetPropertyChangedSignal("CurrentCamera"):Connect(function() end)
end

NAmanage.resumeCurrent=function()
	if FLYING then return end
	local hum=getHum()
	local head=getHead(getChar())
	if NAmanage._state.mode=="cfly" then
		if head then head.Anchored=true end
	elseif NAmanage._state.mode=="tfly" then
		if goofyFLY and flyVariables.TFpos then flyVariables.TFpos.position=goofyFLY.Position end
		local cam=NAmanage._camera()
		if flyVariables.TFgyro and cam then flyVariables.TFgyro.cframe=cam.CFrame end
		if flyVariables.TFpos then flyVariables.TFpos.maxForce=Vector3.new(math.huge,math.huge,math.huge) end
		if flyVariables.TFgyro then flyVariables.TFgyro.maxTorque=Vector3.new(9e9,9e9,9e9) end
	elseif NAmanage._state.mode=="fly" then
		if flyVariables.BV then flyVariables.BV.maxForce=Vector3.new(9e9,9e9,9e9) end
		if flyVariables.BG then flyVariables.BG.maxTorque=Vector3.new(9e9,9e9,9e9) end
		if hum then hum.PlatformStand=true end
	elseif NAmanage._state.mode=="vfly" then
		if flyVariables.BV then flyVariables.BV.maxForce=Vector3.new(9e9,9e9,9e9) end
		if flyVariables.BG then flyVariables.BG.maxTorque=Vector3.new(9e9,9e9,9e9) end
		if hum then hum.PlatformStand=false end
	end
	FLYING=true
end

NAmanage._destroyMobileFlyUI=function()
	for m,conn in pairs(flyVariables.uiPosConns) do
		pcall(function() conn:Disconnect() end)
		flyVariables.uiPosConns[m]=nil
	end
	if flyVariables.uiUpdateConn then pcall(function() flyVariables.uiUpdateConn:Disconnect() end) end
	flyVariables.uiUpdateConn=nil
	if flyVariables.mFlyBruh then pcall(function() flyVariables.mFlyBruh:Destroy() end) flyVariables.mFlyBruh=nil end
	if flyVariables.vRAHH then pcall(function() flyVariables.vRAHH:Destroy() end) flyVariables.vRAHH=nil end
	if flyVariables.cFlyGUI then pcall(function() flyVariables.cFlyGUI:Destroy() end) flyVariables.cFlyGUI=nil end
	if flyVariables.TFLYBTN then pcall(function() flyVariables.TFLYBTN:Destroy() end) flyVariables.TFLYBTN=nil end
	if flyVariables.tflyButtonUI then pcall(function() flyVariables.tflyButtonUI:Destroy() end) flyVariables.tflyButtonUI=nil end
end

NAmanage._ensureMobileFlyUI=function(mode)
	if not IsOnMobile then return end
	NAmanage._destroyMobileFlyUI()
	local mk=function(modeKey,btnText,onToggle,getSpeed,setSpeed,storeRefs)
		local gui=InstanceNew("ScreenGui"); NaProtectUI(gui); gui.ResetOnSpawn=false
		local btn=InstanceNew("TextButton",gui)
		local speedBox=InstanceNew("TextBox",gui)
		local toggleBtn=InstanceNew("TextButton",btn)
		local corner=InstanceNew("UICorner",btn)
		local corner2=InstanceNew("UICorner",speedBox)
		local corner3=InstanceNew("UICorner",toggleBtn)
		local aspect=InstanceNew("UIAspectRatioConstraint",btn)
		btn.BackgroundColor3=Color3.fromRGB(30,30,30)
		btn.BackgroundTransparency=0.1
		btn.Position=NAmanage._persist.uiPos[modeKey] or UDim2.new(0.9,0,0.5,0)
		btn.Size=UDim2.new(0.08,0,0.1,0)
		btn.Font=Enum.Font.GothamBold
		btn.Text=btnText()
		btn.TextColor3=Color3.fromRGB(255,255,255)
		btn.TextScaled=true
		corner.CornerRadius=UDim.new(0.2,0)
		aspect.AspectRatio=1
		speedBox.BackgroundColor3=Color3.fromRGB(30,30,30)
		speedBox.BackgroundTransparency=0.1
		speedBox.AnchorPoint=Vector2.new(0.5,0)
		speedBox.Position=UDim2.new(0.5,0,0,10)
		speedBox.Size=UDim2.new(0,75,0,35)
		speedBox.Font=Enum.Font.GothamBold
		speedBox.Text=tostring(getSpeed())
		speedBox.TextColor3=Color3.fromRGB(255,255,255)
		speedBox.TextSize=24
		speedBox.TextScaled=true
		speedBox.ClearTextOnFocus=false
		speedBox.PlaceholderText="Speed"
		speedBox.Visible=false
		local function applySpeedFromBox()
			local ns=tonumber(speedBox.Text)
			if ns then
				setSpeed(ns)
			end
			speedBox.Text=tostring(getSpeed())
		end
		corner2.CornerRadius=UDim.new(0.2,0)
		toggleBtn.BackgroundColor3=Color3.fromRGB(50,50,50)
		toggleBtn.BackgroundTransparency=0.1
		toggleBtn.Position=UDim2.new(0.8,0,-0.1,0)
		toggleBtn.Size=UDim2.new(0.4,0,0.4,0)
		toggleBtn.Font=Enum.Font.SourceSans
		toggleBtn.Text="+"
		toggleBtn.TextColor3=Color3.fromRGB(255,255,255)
		toggleBtn.TextScaled=true
		toggleBtn.AutoButtonColor=true
		corner3.CornerRadius=UDim.new(1,0)
		MouseButtonFix(toggleBtn,function()
			speedBox.Visible=not speedBox.Visible
			toggleBtn.Text=speedBox.Visible and "-" or "+"
		end)
		speedBox.FocusLost:Connect(applySpeedFromBox)
		MouseButtonFix(btn,function()
			applySpeedFromBox()
			onToggle()
			btn.Text=btnText()
			btn.BackgroundColor3=FLYING and Color3.fromRGB(0,170,0) or Color3.fromRGB(170,0,0)
		end)
		NAgui.draggerV2(btn)
		NAgui.draggerV2(speedBox)
		if flyVariables.uiPosConns[modeKey] then pcall(function() flyVariables.uiPosConns[modeKey]:Disconnect() end) end
		flyVariables.uiPosConns[modeKey]=btn:GetPropertyChangedSignal("Position"):Connect(function()
			NAmanage._persist.uiPos[modeKey]=btn.Position
		end)
		if storeRefs then storeRefs(gui,btn) end
	end
	if mode=="fly" then
		mk("fly",function() return FLYING and "Unfly" or "Fly" end,function() NAmanage.toggleFly() end,function() return flyVariables.flySpeed end,function(v) flyVariables.flySpeed=v end,function(gui,btn) flyVariables.mFlyBruh=gui end)
	elseif mode=="vfly" then
		mk("vfly",function() return FLYING and "UnvFly" or "vFly" end,function() NAmanage.toggleVFly() end,function() return flyVariables.vFlySpeed end,function(v) flyVariables.vFlySpeed=v end,function(gui,btn) flyVariables.vRAHH=gui end)
	elseif mode=="cfly" then
		mk("cfly",function() return FLYING and "UnCfly" or "CFly" end,function() NAmanage.toggleCFly() end,function() return flyVariables.cFlySpeed end,function(v) flyVariables.cFlySpeed=v flyVariables.flySpeed=v end,function(gui,btn) flyVariables.cFlyGUI=gui end)
	elseif mode=="tfly" then
		mk("tfly",function() return FLYING and "UnTFly" or "TFly" end,function() NAmanage.toggleTFly() end,function() return flyVariables.TflySpeed end,function(v) flyVariables.TflySpeed=v end,function(gui,btn) flyVariables.tflyButtonUI=gui flyVariables.TFLYBTN=btn end)
	end
	if flyVariables.uiUpdateConn then pcall(function() flyVariables.uiUpdateConn:Disconnect() end) end
	flyVariables.uiUpdateConn=RunService.Heartbeat:Connect(function()
		if mode=="fly" and flyVariables.mFlyBruh then
			local b=flyVariables.mFlyBruh:FindFirstChildOfClass("TextButton")
			if b then b.Text=FLYING and "Unfly" or "Fly" b.BackgroundColor3=FLYING and Color3.fromRGB(0,170,0) or Color3.fromRGB(30,30,30) end
		elseif mode=="vfly" and flyVariables.vRAHH then
			local b=flyVariables.vRAHH:FindFirstChildOfClass("TextButton")
			if b then b.Text=FLYING and "UnvFly" or "vFly" b.BackgroundColor3=FLYING and Color3.fromRGB(0,170,0) or Color3.fromRGB(30,30,30) end
		elseif mode=="cfly" and flyVariables.cFlyGUI then
			local b=flyVariables.cFlyGUI:FindFirstChildOfClass("TextButton")
			if b then b.Text=FLYING and "UnCfly" or "CFly" b.BackgroundColor3=FLYING and Color3.fromRGB(0,170,0) or Color3.fromRGB(30,30,30) end
		elseif mode=="tfly" and flyVariables.tflyButtonUI then
			local b=flyVariables.tflyButtonUI:FindFirstChildOfClass("TextButton")
			if b then b.Text=FLYING and "UnTFly" or "TFly" b.BackgroundColor3=FLYING and Color3.fromRGB(0,170,0) or Color3.fromRGB(30,30,30) end
		end
	end)
end

NAmanage.deactivateMode=function(m)
	local wasCurrent=(NAmanage._state.mode==m)
	if wasCurrent then
		NAmanage.pauseCurrent()
		NAmanage._clearPhysics(true)
		NAmanage._state.mode="none"
		NAmanage._releaseQE()
	end
	if m=="fly" then flyVariables.flyEnabled=false end
	if m=="vfly" then flyVariables.vFlyEnabled=false end
	if m=="cfly" then flyVariables.cFlyEnabled=false end
	if m=="tfly" then flyVariables.TFlyEnabled=false end
	NAmanage._destroyMobileFlyUI()
end

NAmanage.sFLY=function(vfly,cfly,tfly)
	while not getChar() or not getRoot(getChar()) or not getHum() do Wait() end
	CONTROL={Q=0,E=0}; lCONTROL={Q=0,E=0}; SPEED=0
	local hum=getHum(); local head=getHead(getChar()); local root=getRoot(getChar())
	NAmanage._bindQE()
	if tfly then
		goofyFLY=goofyFLY or InstanceNew("Part",workspace)
		NAmanage.configureFlyHelper(goofyFLY)
		if not goofyFLY:FindFirstChildOfClass("Weld") then
			local w=InstanceNew("Weld",goofyFLY) w.Part0=goofyFLY w.Part1=root w.C0=CFrame.new()
		end
		flyVariables.TFpos=flyVariables.TFpos or InstanceNew("BodyPosition",goofyFLY)
		flyVariables.TFgyro=flyVariables.TFgyro or InstanceNew("BodyGyro",goofyFLY)
		flyVariables.TFpos.maxForce=Vector3.new(math.huge,math.huge,math.huge)
		flyVariables.TFpos.position=goofyFLY.Position
		local cam0=NAmanage._camera()
		flyVariables.TFgyro.maxTorque=Vector3.new(9e9,9e9,9e9)
		flyVariables.TFgyro.cframe=cam0 and cam0.CFrame or CFrame.new()
		if CFloop then pcall(function() CFloop:Disconnect() end) end
		CFloop=nil
		if not flyVariables._tflyLoop then
			flyVariables._tflyLoop=true
			SpawnCall(function()
				while NAmanage._state.mode=="tfly" do
					local cam=NAmanage._camera()
					if cam and FLYING and flyVariables.TFpos and flyVariables.TFgyro then
						local sp=tonumber(flyVariables.TflySpeed) or 1
						local mv=GetCustomMoveVector(); mv=Vector3.new(mv.X,mv.Y,-mv.Z)
						local np=flyVariables.TFgyro.cframe-flyVariables.TFgyro.cframe.p+flyVariables.TFpos.position
						if mv.Magnitude>0 then
							np=np+(cam.CFrame.RightVector*mv.X*sp)
							np=np+(cam.CFrame.LookVector*mv.Z*sp)
						end
						np=np+(cam.CFrame.UpVector*(CONTROL.E+CONTROL.Q)*sp)
						pcall(function()
							flyVariables.TFpos.position=np.p
							flyVariables.TFgyro.cframe=cam.CFrame
						end)
					end
					Wait()
				end
				flyVariables._tflyLoop=false
			end)
		end
	elseif cfly then
		goofyFLY=goofyFLY or InstanceNew("Part",workspace)
		NAmanage.configureFlyHelper(goofyFLY)
		goofyFLY.Anchored=true
		if head then head.Anchored=true end
		if CFloop then pcall(function() CFloop:Disconnect() end) end
		CFloop=RunService.RenderStepped:Connect(function()
			if NAmanage._state.mode~="cfly" or not FLYING then return end
			local cam=NAmanage._camera(); if not cam then return end
			local mv=GetCustomMoveVector()
			local vertical=(CONTROL.E+CONTROL.Q)
			local full=Vector3.new(mv.X,vertical,-mv.Z)
			local md=(cam.CFrame.RightVector*full.X)+(cam.CFrame.UpVector*full.Y)+(cam.CFrame.LookVector*full.Z)
			if head and md.Magnitude>0 then
				local ns=head.Position+md.Unit*(tonumber(flyVariables.cFlySpeed) or 1)
				local lk=ns+cam.CFrame.LookVector
				head.CFrame=CFrame.new(ns,lk)
				goofyFLY.CFrame=head.CFrame
			end
		end)
	else
		goofyFLY=goofyFLY or InstanceNew("Part",workspace)
		NAmanage.configureFlyHelper(goofyFLY)
		if not goofyFLY:FindFirstChildOfClass("Weld") then
			local w=InstanceNew("Weld",goofyFLY) w.Part0=goofyFLY w.Part1=root w.C0=CFrame.new()
		end
		flyVariables.BG=flyVariables.BG or InstanceNew("BodyGyro",goofyFLY)
		flyVariables.BG.P=9e4
		flyVariables.BG.maxTorque=Vector3.new(9e9,9e9,9e9)
		flyVariables.BV=flyVariables.BV or InstanceNew("BodyVelocity",goofyFLY)
		flyVariables.BV.velocity=Vector3.zero
		flyVariables.BV.maxForce=Vector3.new(9e9,9e9,9e9)
		if NAmanage._state.mode=="fly" then if hum then hum.PlatformStand=true end else if hum then hum.PlatformStand=false end end
		if CFloop then pcall(function() CFloop:Disconnect() end) end
		if not flyVariables._stdLoop then
			flyVariables._stdLoop=true
			SpawnCall(function()
				while (NAmanage._state.mode=="fly" or NAmanage._state.mode=="vfly") do
					local cam=NAmanage._camera()
					if cam and FLYING and flyVariables.BV and flyVariables.BG then
						local mv=GetCustomMoveVector(); mv=Vector3.new(mv.X,mv.Y,-mv.Z)
						local has=mv.Magnitude>0 or CONTROL.Q~=0 or CONTROL.E~=0
						if has then
							SPEED=((NAmanage._state.mode=="vfly" and tonumber(flyVariables.vFlySpeed) or tonumber(flyVariables.flySpeed)) or 1)*50
						elseif SPEED~=0 then
							SPEED=0
						end
						if has then
							flyVariables.BV.velocity=((cam.CFrame.LookVector*mv.Z)+((cam.CFrame*CFrame.new(mv.X,(mv.Z+CONTROL.Q+CONTROL.E)*0.2,0).p)-cam.CFrame.p))*SPEED
							lCONTROL={Q=CONTROL.Q,E=CONTROL.E}
						elseif SPEED~=0 then
							flyVariables.BV.velocity=((cam.CFrame.LookVector*mv.Z)+((cam.CFrame*CFrame.new(mv.X,(mv.Z+lCONTROL.Q+lCONTROL.E)*0.2,0).p)-cam.CFrame.p))*SPEED
						else
							flyVariables.BV.velocity=Vector3.zero
						end
						flyVariables.BG.cframe=cam.CFrame
					elseif flyVariables.BV then
						flyVariables.BV.velocity=Vector3.zero
					end
					Wait()
				end
				if flyVariables.BG then pcall(function() flyVariables.BG:Destroy() end) end
				if flyVariables.BV then pcall(function() flyVariables.BV:Destroy() end) end
				flyVariables.BG=nil; flyVariables.BV=nil
				if hum then hum.PlatformStand=false end
				flyVariables._stdLoop=false
			end)
		end
	end
	FLYING=true
end

NAmanage._ensureForces=function()
	if NAmanage._state.mode=="none" then return end
	local char=getChar(); if not char then return end
	local hum=getHum(); if not hum then return end
	local root=getRoot(char); if not root then return end
	local cam=NAmanage._camera()
	if not goofyFLY or goofyFLY.Parent==nil then
		goofyFLY=InstanceNew("Part",workspace)
		NAmanage.configureFlyHelper(goofyFLY)
		goofyFLY.Anchored=(NAmanage._state.mode=="cfly")
		local head=getHead(char); if head then goofyFLY:PivotTo(head:GetPivot()) end
		if flyVariables._goofyAC then pcall(function() flyVariables._goofyAC:Disconnect() end) end
		flyVariables._goofyAC=goofyFLY.AncestryChanged:Connect(function(_,p) if not p then Defer(NAmanage._ensureForces) end end)
	end
	if NAmanage._state.mode=="tfly" then
		NAmanage._ensureWeldTarget()
		if not flyVariables.TFpos or flyVariables.TFpos.Parent~=goofyFLY then
			flyVariables.TFpos=InstanceNew("BodyPosition",goofyFLY)
			flyVariables.TFpos.position=goofyFLY.Position
		end
		if not flyVariables.TFgyro or flyVariables.TFgyro.Parent~=goofyFLY then
			flyVariables.TFgyro=InstanceNew("BodyGyro",goofyFLY)
			flyVariables.TFgyro.cframe=(cam and cam.CFrame) or CFrame.new()
		end
		if FLYING then
			flyVariables.TFpos.maxForce=Vector3.new(math.huge,math.huge,math.huge)
			flyVariables.TFgyro.maxTorque=Vector3.new(9e9,9e9,9e9)
		else
			flyVariables.TFpos.maxForce=Vector3.new(0,0,0)
			flyVariables.TFgyro.maxTorque=Vector3.new(0,0,0)
		end
	elseif NAmanage._state.mode=="cfly" then
		goofyFLY.Anchored=true
		local head=getHead(char)
		if head and FLYING and not head.Anchored then head.Anchored=true end
	else
		NAmanage._ensureWeldTarget()
		if not flyVariables.BG or flyVariables.BG.Parent~=goofyFLY then
			flyVariables.BG=InstanceNew("BodyGyro",goofyFLY)
			flyVariables.BG.P=9e4
		end
		if not flyVariables.BV or flyVariables.BV.Parent~=goofyFLY then
			flyVariables.BV=InstanceNew("BodyVelocity",goofyFLY)
			flyVariables.BV.velocity=Vector3.zero
		end
		if cam then flyVariables.BG.cframe=cam.CFrame end
		flyVariables.BG.maxTorque=FLYING and Vector3.new(9e9,9e9,9e9) or Vector3.new(0,0,0)
		flyVariables.BV.maxForce=FLYING and Vector3.new(9e9,9e9,9e9) or Vector3.new(0,0,0)
		if NAmanage._state.mode=="fly" then hum.PlatformStand=FLYING else hum.PlatformStand=false end
	end
	if not flyVariables.qeDownConn or flyVariables.qeDownConn.Connected==false then
		if flyVariables.qeDownConn then pcall(function() flyVariables.qeDownConn:Disconnect() end) end
		flyVariables.qeDownConn=mouse.KeyDown:Connect(function(k)
			k=Lower(k or "")
			if k=="q" then
				local sp=(NAmanage._state.mode=="vfly" and tonumber(flyVariables.vFlySpeed) or tonumber(flyVariables.flySpeed) or 1)
				CONTROL.Q=-sp*2
			elseif k=="e" then
				local sp=(NAmanage._state.mode=="vfly" and tonumber(flyVariables.vFlySpeed) or tonumber(flyVariables.flySpeed) or 1)
				CONTROL.E=sp*2
			end
		end)
	end
	if not flyVariables.qeUpConn or flyVariables.qeUpConn.Connected==false then
		if flyVariables.qeUpConn then pcall(function() flyVariables.qeUpConn:Disconnect() end) end
		flyVariables.qeUpConn=mouse.KeyUp:Connect(function(k)
			k=Lower(k or "")
			if k=="q" then CONTROL.Q=0 elseif k=="e" then CONTROL.E=0 end
		end)
	end
end

NAmanage._ensureLoops=function()
	if NAmanage._state.mode=="tfly" then
		if not flyVariables._tflyLoop then
			flyVariables._tflyLoop=true
			Spawn(function()
				while NAmanage._state.mode=="tfly" do
					if not goofyFLY or not flyVariables.TFpos or not flyVariables.TFgyro or goofyFLY.Parent==nil or flyVariables.TFpos.Parent~=goofyFLY or flyVariables.TFgyro.Parent~=goofyFLY then
						NAmanage._ensureForces()
						Wait()
					else
						if FLYING then
							local cam=workspace.CurrentCamera
							local sp=tonumber(flyVariables.TflySpeed) or 1
							local mv=GetCustomMoveVector(); mv=Vector3.new(mv.X,mv.Y,-mv.Z)
							local np=flyVariables.TFgyro.cframe-flyVariables.TFgyro.cframe.p+flyVariables.TFpos.position
							if mv.Magnitude>0 then
								np=np+(cam.CFrame.RightVector*mv.X*sp)
								np=np+(cam.CFrame.LookVector*mv.Z*sp)
							end
							np=np+(cam.CFrame.UpVector*(CONTROL.E+CONTROL.Q)*sp)
							pcall(function()
								flyVariables.TFpos.position=np.p
								flyVariables.TFgyro.cframe=cam.CFrame
							end)
						end
					end
					Wait()
				end
				flyVariables._tflyLoop=false
			end)
		end
	elseif NAmanage._state.mode=="fly" or NAmanage._state.mode=="vfly" then
		if not flyVariables._stdLoop then
			flyVariables._stdLoop=true
			SpawnCall(function()
				while NAmanage._state.mode=="fly" or NAmanage._state.mode=="vfly" do
					if not goofyFLY or not flyVariables.BG or not flyVariables.BV or goofyFLY.Parent==nil or flyVariables.BG.Parent~=goofyFLY or flyVariables.BV.Parent~=goofyFLY then
						NAmanage._ensureForces()
						Wait()
					else
						if FLYING then
							local cam=workspace.CurrentCamera
							local mv=GetCustomMoveVector(); mv=Vector3.new(mv.X,mv.Y,-mv.Z)
							local has=mv.Magnitude>0 or CONTROL.Q~=0 or CONTROL.E~=0
							if has then
								SPEED=((NAmanage._state.mode=="vfly" and tonumber(flyVariables.vFlySpeed) or tonumber(flyVariables.flySpeed)) or 1)*50
							elseif SPEED~=0 then
								SPEED=0
							end
							if has then
								pcall(function()
									flyVariables.BV.velocity=((cam.CFrame.LookVector*mv.Z)+((cam.CFrame*CFrame.new(mv.X,(mv.Z+CONTROL.Q+CONTROL.E)*0.2,0).p)-cam.CFrame.p))*SPEED
									flyVariables.BG.cframe=cam.CFrame
								end)
								lCONTROL={Q=CONTROL.Q,E=CONTROL.E}
							elseif SPEED~=0 then
								pcall(function()
									flyVariables.BV.velocity=((cam.CFrame.LookVector*mv.Z)+((cam.CFrame*CFrame.new(mv.X,(mv.Z+lCONTROL.Q+lCONTROL.E)*0.2,0).p)-cam.CFrame.p))*SPEED
									flyVariables.BG.cframe=cam.CFrame
								end)
							else
								pcall(function()
									flyVariables.BV.velocity=Vector3.zero
									flyVariables.BG.cframe=cam.CFrame
								end)
							end
						else
							if flyVariables.BV then pcall(function() flyVariables.BV.velocity=Vector3.zero end) end
						end
					end
					Wait()
				end
				flyVariables._stdLoop=false
			end)
		end
	elseif NAmanage._state.mode=="cfly" then
		if not CFloop or CFloop.Connected==false then
			if CFloop then pcall(function() CFloop:Disconnect() end) end
			CFloop=RunService.RenderStepped:Connect(function()
				if NAmanage._state.mode~="cfly" or not FLYING then return end
				NAmanage._ensureForces()
				local head=getHead(getChar())
				if not head then return end
				local cam=workspace.CurrentCamera
				local mv=GetCustomMoveVector()
				local vertical=(CONTROL.E+CONTROL.Q)
				local full=Vector3.new(mv.X,vertical,-mv.Z)
				local md=(cam.CFrame.RightVector*full.X)+(cam.CFrame.UpVector*full.Y)+(cam.CFrame.LookVector*full.Z)
				if md.Magnitude>0 then
					local ns=head.Position+md.Unit*(tonumber(flyVariables.cFlySpeed) or 1)
					local lk=ns+cam.CFrame.LookVector
					head.CFrame=CFrame.new(ns,lk)
					if goofyFLY then goofyFLY.CFrame=head.CFrame end
				end
			end)
		end
	end
end

NAmanage._ensureWeldTarget=function()
	if flyVariables._weldLoopConn then return end
	flyVariables._weldLoopConn=RunService.Heartbeat:Connect(function()
		if NAmanage._state.mode=="none" or NAmanage._state.mode=="cfly" then return end
		local char=getChar(); if not char then return end
		local root=getRoot(char); if not root then return end
		if not goofyFLY or goofyFLY.Parent==nil then
			goofyFLY=InstanceNew("Part",workspace)
			NAmanage.configureFlyHelper(goofyFLY)
			goofyFLY.Anchored=false
			local head=getHead(char); if head then goofyFLY:PivotTo(head:GetPivot()) end
		end
		local w=goofyFLY:FindFirstChildOfClass("Weld")
		if not w or w.Parent~=goofyFLY then
			if w then pcall(function() w:Destroy() end) end
			w=InstanceNew("Weld",goofyFLY)
		end
		if (not w.Part0) or w.Part0~=goofyFLY or w.Part0.Parent==nil then pcall(function() w.Part0=goofyFLY end) end
		if (not w.Part1) or w.Part1~=root or w.Part1.Parent==nil or (not w.Part1:IsDescendantOf(char)) then pcall(function() w.Part1=root end) end
		pcall(function() w.C0=CFrame.new() end)
	end)
end

NAmanage.startWatcher=function()
	if flyVariables._watchConn then pcall(function() flyVariables._watchConn:Disconnect() end) end
	flyVariables._watchConn=RunService.Heartbeat:Connect(function()
		if flyVariables.flyEnabled or flyVariables.vFlyEnabled or flyVariables.cFlyEnabled or flyVariables.TFlyEnabled then
			local desired="none"
			if flyVariables.cFlyEnabled then desired="cfly"
			elseif flyVariables.TFlyEnabled then desired="tfly"
			elseif flyVariables.vFlyEnabled then desired="vfly"
			elseif flyVariables.flyEnabled then desired="fly" end
			if NAmanage._state.mode=="none" and desired~="none" then
				NAmanage._state.mode=desired
			end
			NAmanage._ensureWeldTarget()
			NAmanage._ensureForces()
			NAmanage._ensureLoops()
		end
	end)
	NAmanage._bindCameraWatch()
end

NAmanage._forceEnableFlags = function(mode)
	flyVariables.flyEnabled=(mode=="fly")
	flyVariables.vFlyEnabled=(mode=="vfly")
	flyVariables.cFlyEnabled=(mode=="cfly")
	flyVariables.TFlyEnabled=(mode=="tfly")
end

NAmanage._applyMode = function(mode, resume)
	if CFloop then pcall(function() CFloop:Disconnect() end) end
	CFloop=nil
	NAmanage._forceEnableFlags(mode)
	NAmanage._state.mode=mode
	if mode=="cfly" then
		NAmanage.sFLY(false,true,false)
	elseif mode=="tfly" then
		NAmanage.sFLY(false,false,true)
	elseif mode=="vfly" then
		NAmanage.sFLY(true,false,false)
	else
		NAmanage.sFLY(false,false,false)
	end
	if resume then
		NAmanage.resumeCurrent()
	else
		NAmanage.pauseCurrent()
	end
	NAmanage._ensureMobileFlyUI(mode)
	NAmanage.startWatcher()
	NAmanage._bindCameraWatch()
end

NAmanage.activateMode = function(mode)
	local currentMode=NAmanage._state.mode
	if currentMode and currentMode~="none" and currentMode~=mode then
		NAmanage.deactivateMode(currentMode)
	end
	NAmanage._state.mode=mode
	NAmanage._forceEnableFlags(mode)
	local char=getChar()
	local root=char and getRoot(char) or nil
	local hum=char and getHum(char) or nil
	if char and root and hum then
		NAmanage._applyMode(mode,true)
		return
	end
	NAmanage._persist.lastMode=mode
	NAmanage._persist.resumeAfterSpawn=true
	if NAlib.isConnected("fly_pending_char") then
		NAlib.disconnect("fly_pending_char")
	end
	NAlib.connect("fly_pending_char", Players.LocalPlayer.CharacterAdded:Connect(function()
		Spawn(function()
			local t=0
			while t<5 and (not getChar() or not getRoot(getChar()) or not getHum()) do
				t+=(Wait() or 0.03)
			end
			NAmanage._applyMode(mode,true)
			NAmanage._persist.resumeAfterSpawn=false
			NAlib.disconnect("fly_pending_char")
		end)
	end))
end

NAmanage.keyToggle=function(mode)
	if NAmanage._state.mode~=mode then return end
	if not NAmanage._modeEnabled(mode) then return end
	if FLYING then NAmanage.pauseCurrent() else NAmanage.resumeCurrent() end
end

NAmanage.toggleFly=function()
	if not flyVariables.flyEnabled then
		NAmanage.activateMode("fly")
	else
		if NAmanage._state.mode~="fly" then
			NAmanage.activateMode("fly")
		else
			if FLYING then NAmanage.pauseCurrent() else NAmanage.resumeCurrent() end
		end
	end
end

NAmanage.toggleVFly=function()
	if not flyVariables.vFlyEnabled then
		NAmanage.activateMode("vfly")
	else
		if NAmanage._state.mode~="vfly" then
			NAmanage.activateMode("vfly")
		else
			if FLYING then NAmanage.pauseCurrent() else NAmanage.resumeCurrent() end
		end
	end
end

NAmanage.toggleCFly=function()
	if not flyVariables.cFlyEnabled then
		NAmanage.activateMode("cfly")
	else
		if NAmanage._state.mode~="cfly" then
			NAmanage.activateMode("cfly")
		else
			if FLYING then NAmanage.pauseCurrent() else NAmanage.resumeCurrent() end
		end
	end
end

NAmanage.toggleTFly=function()
	if not flyVariables.TFlyEnabled then
		NAmanage.activateMode("tfly")
	else
		if NAmanage._state.mode~="tfly" then
			NAmanage.activateMode("tfly")
		else
			if FLYING then NAmanage.pauseCurrent() else NAmanage.resumeCurrent() end
		end
	end
end

NAmanage.connectFlyKey=function()
	if flyVariables.keybindConn then flyVariables.keybindConn:Disconnect() end
	flyVariables.keybindConn=mouse.KeyDown:Connect(function(KEY)
		if Lower(KEY)==Lower(flyVariables.toggleKey) then
			NAmanage.keyToggle("fly")
		end
	end)
end

NAmanage.connectVFlyKey=function()
	if flyVariables.vKeybindConn then flyVariables.vKeybindConn:Disconnect() end
	flyVariables.vKeybindConn=mouse.KeyDown:Connect(function(KEY)
		if Lower(KEY)==Lower(flyVariables.vToggleKey) then
			NAmanage.keyToggle("vfly")
		end
	end)
end

NAmanage.connectCFlyKey=function()
	if flyVariables.cKeybindConn then flyVariables.cKeybindConn:Disconnect() end
	flyVariables.cKeybindConn=mouse.KeyDown:Connect(function(KEY)
		if Lower(KEY)==Lower(flyVariables.cToggleKey) then
			NAmanage.keyToggle("cfly")
		end
	end)
end

NAmanage.connectTFlyKey=function()
	if flyVariables.tflyKeyConn then flyVariables.tflyKeyConn:Disconnect() end
	flyVariables.tflyKeyConn=mouse.KeyDown:Connect(function(KEY)
		if Lower(KEY)==Lower(flyVariables.tflyToggleKey) then
			NAmanage.keyToggle("tfly")
		end
	end)
end

NAmanage.readAliasFile = function()
	if FileSupport and isfile(NAfiles.NAALIASPATH) then
		local success, data = NACaller(function()
			return HttpService:JSONDecode(readfile(NAfiles.NAALIASPATH))
		end)
		if success and type(data) == "table" then
			return data
		end
	end
	return {}
end

NAmanage.loadAliases = function()
	local aliasMap = NAmanage.readAliasFile()
	for alias, original in pairs(aliasMap) do
		if type(alias) == "string" and type(original) == "string" then
			local aliasLower = alias:lower()
			local originalLower = original:lower()
			local command = cmds.Commands[originalLower]
			if command then
				cmds.Aliases[aliasLower] = {command[1], command[2], command[3]}
				cmds.NASAVEDALIASES[aliasLower] = originalLower
			end
		end
	end
end

NAmanage.decodeUserButtons=function(raw)
	if type(raw) ~= "string" or raw == "" then
		return nil
	end
	local ok, decoded = pcall(function()
		return HttpService:JSONDecode(raw)
	end)
	if ok and type(decoded) == "table" then
		return decoded
	end
	return nil
end

NAmanage.ubNorm=function(dt)
	local norm = {}
	local chg = false
	if type(dt) ~= "table" then
		return norm, false
	end
	for id, entry in pairs(dt) do
		if type(id) == "number" then
			norm[id] = entry
		else
			chg = true
		end
	end
	for id, entry in pairs(dt) do
		if type(id) == "string" then
			local n = tonumber(id)
			if n and norm[n] == nil then
				norm[n] = entry
				chg = true
			end
		end
	end
	return norm, chg
end

NAmanage.UserButtonsSave = function(reason, data)
	local pay = data or NAUserButtons or {}
	local norm, chg = NAmanage.ubNorm(pay)
	if chg then
		pay = norm
		if data == nil or data == NAUserButtons then
			NAUserButtons = norm
		end
	end

	if not FileSupport then
		return true
	end

	local path = NAfiles.NAUSERBUTTONSPATH
	local backupPath = path..".bak"
	local okEncode, encoded = pcall(HttpService.JSONEncode, HttpService, pay)
	if not okEncode then
		NAmanage.loaderWarn('UserButtons', 'failed to encode data'..(reason and (' ('..reason..')') or '')..': '..tostring(encoded))
		return false
	end

	local okRead, existing = pcall(readfile, path)
	if okRead and type(existing) == "string" and existing ~= "" then
		pcall(writefile, backupPath, existing)
	end

	local okWrite, errWrite = pcall(writefile, path, encoded)
	if not okWrite then
		if okRead and type(existing) == "string" then
			pcall(writefile, path, existing)
		end
		NAmanage.loaderWarn('UserButtons', 'failed to save data'..(reason and (' ('..reason..')') or '')..': '..tostring(errWrite))
		return false
	end

	return true
end

NAmanage.loadButtonIDS = function()
	if not FileSupport then
		NAUserButtons = NAUserButtons or {}
		return true
	end

	local path = NAfiles.NAUSERBUTTONSPATH

	if not (isfile and isfile(path)) then
		local okCreate, createErr = pcall(function()
			writefile(path, HttpService:JSONEncode({}))
		end)
		if not okCreate then
			NAmanage.loaderWarn('UserButtons', 'failed to create storage: '..tostring(createErr))
			return false
		end
	end

	local okRead, raw = pcall(readfile, path)
	if not okRead or type(raw) ~= "string" then
		NAmanage.loaderWarn('UserButtons', 'failed to read storage: '..tostring(raw))
		return false
	end

	local decoded = NAmanage.decodeUserButtons(raw)
	if not decoded then
		local backup = nil
		local okBackup, rawBackup = pcall(readfile, path..".bak")
		if okBackup then
			backup = NAmanage.decodeUserButtons(rawBackup)
		end

		if backup then
			NAmanage.loaderWarn('UserButtons', 'storage corrupted; recovered from backup')
			NAUserButtons = backup
			NAmanage.UserButtonsSave("restore backup")
			return true
		end

		NAmanage.loaderWarn('UserButtons', 'invalid storage data; resetting')
		NAUserButtons = {}
		NAmanage.UserButtonsSave("reset invalid data")
		return false
	end

	local norm, normChg = NAmanage.ubNorm(decoded)
	NAUserButtons = norm
	local chg = normChg

	for _, data in pairs(NAUserButtons) do
		if type(data) == "table" and type(data.Keybind) == "string" and data.Keybind ~= "" then
			local keyName = data.Keybind

			if CommandKeybinds[keyName] == nil then
				local parts = {}
				if type(data.Cmd1) == "string" and data.Cmd1 ~= "" then
					Insert(parts, data.Cmd1)
				end
				if type(data.Args) == "table" then
					for _, v in ipairs(data.Args) do
						Insert(parts, tostring(v))
					end
				end
				if #parts > 0 then
					CommandKeybinds[keyName] = parts
				end
			end

			data.Keybind = nil
			chg = true
		end
	end

	if chg and FileSupport then
		NAmanage.UserButtonsSave("normalize ids")
	end
	NAmanage.SaveCommandKeybinds()
	NAmanage.ApplyCommandKeybinds()
	return true
end

local function NAUserButtonNextId()
	local maxId = 0
	for id in pairs(NAUserButtons) do
		if type(id) == "number" and id > maxId then
			maxId = id
		end
	end
	return maxId + 1
end

local function NAUserButtonCloneAsChild(data, fallbackLabel)
	if type(data) ~= "table" then
		return nil
	end
	local label = (type(data.Label) == "string" and data.Label ~= "" and data.Label) or fallbackLabel or "Button"
	local child = {
		Label = label,
		Cmd1 = data.Cmd1,
		Cmd2 = data.Cmd2,
		Args = (type(data.Args) == "table") and originalIO.deepCopyTable(data.Args) or nil,
		RunMode = data.RunMode,
		BgColor = data.BgColor,
		TextColor = data.TextColor,
		Width = data.Width,
		Height = data.Height,
		CornerRadius = data.CornerRadius,
		Hidden = data.Hidden,
		Interactable = data.Interactable,
		Locked = data.Locked,
		Pos = data.Pos and originalIO.deepCopyTable(data.Pos),
	}
	return child
end

local function NAUserButtonCollectChildren(store, entry, fallbackLabel)
	if type(entry) ~= "table" then
		return
	end
	if entry.Type == "group" and type(entry.Children) == "table" then
		for _, child in ipairs(entry.Children) do
			local clone = NAUserButtonCloneAsChild(child, fallbackLabel)
			if clone then
				Insert(store, clone)
			end
		end
	else
		local clone = NAUserButtonCloneAsChild(entry, fallbackLabel)
		if clone then
			Insert(store, clone)
		end
	end
end

local function NAUserButtonRectOverlap(posA, sizeA, posB, sizeB, padding)
	padding = padding or 0
	if not (posA and sizeA and posB and sizeB) then return false end
	return not (
		posA.X + sizeA.X < posB.X - padding
			or posB.X + sizeB.X < posA.X - padding
			or posA.Y + sizeA.Y < posB.Y - padding
			or posB.Y + sizeB.Y < posA.Y - padding
	)
end

NAmanage.UserButtons_CombineButtons = function(targetId, sourceId, opts)
	opts = opts or {}
	if type(targetId) ~= "number" or type(sourceId) ~= "number" then
		return false, "Invalid button ids."
	end
	if targetId == sourceId then
		return false, "Pick two different buttons to combine."
	end

	local target = NAUserButtons[targetId]
	local source = NAUserButtons[sourceId]
	if type(target) ~= "table" or type(source) ~= "table" then
		return false, "One of the buttons is missing."
	end
	if target.Locked or source.Locked then
		return false, "Locked buttons cannot be combined."
	end

	local children = {}
	local targetLabel = (type(target.Label) == "string" and target.Label ~= "" and target.Label) or ("Button "..targetId)
	local sourceLabel = (type(source.Label) == "string" and source.Label ~= "" and source.Label) or ("Button "..sourceId)

	NAUserButtonCollectChildren(children, target, targetLabel)
	NAUserButtonCollectChildren(children, source, sourceLabel)

	target.Type = "group"
	target.Children = children
	target.GroupMode = (opts.mode == "side") and "side" or "dropdown"
	target.Cmd1, target.Cmd2, target.Args, target.RunMode = nil, nil, nil, nil

	NAUserButtons[sourceId] = nil
	originalIO.clearUserButtonState(sourceId)
	originalIO.clearUserButtonState(targetId)

	NAmanage.UserButtonsSave("combine buttons")

	return true, ("Grouped %d buttons"):format(#children)
end

NAmanage.UserButtons_CheckCombine = function(sourceId, sourceBtn)
	if type(sourceId) ~= "number" then
		return
	end
	if not (sourceBtn and sourceBtn.AbsolutePosition) then
		return
	end
	local sourceData = NAUserButtons[sourceId]
	if type(sourceData) ~= "table" or sourceData.Locked then
		return
	end

	local srcPos = sourceBtn.AbsolutePosition
	local srcSize = sourceBtn.AbsoluteSize
	local candidateId

	for id, btn in pairs(UserButtonGuiMap) do
		if id ~= sourceId and btn and btn.Parent and btn.Visible then
			if NAUserButtonRectOverlap(srcPos, srcSize, btn.AbsolutePosition, btn.AbsoluteSize, 6) then
				candidateId = id
				break
			end
		end
	end

	if not candidateId then
		return
	end

	local targetData = NAUserButtons[candidateId]
	if type(targetData) ~= "table" or targetData.Locked then
		return
	end

	local srcLabel = (type(sourceData.Label) == "string" and sourceData.Label ~= "" and sourceData.Label) or ("Button "..sourceId)
	local targetLabel = (type(targetData.Label) == "string" and targetData.Label ~= "" and targetData.Label) or ("Button "..candidateId)

	Window({
		Title = "Combine User Buttons",
		Description = ("Merge [%d] %s into [%d] %s?"):format(sourceId, srcLabel, candidateId, targetLabel),
		Buttons = {
			{
				Text = "Dropdown Toggle",
				Callback = function()
					local ok, msg = NAmanage.UserButtons_CombineButtons(candidateId, sourceId, { mode = "dropdown" })
					if ok then
						DoNotif("Created dropdown group", 2)
						NAmanage.RenderUserButtons()
					else
						DoNotif(msg or "Failed to combine buttons", 3)
					end
				end
			},
			{
				Text = "Side Toggle",
				Callback = function()
					local ok, msg = NAmanage.UserButtons_CombineButtons(candidateId, sourceId, { mode = "side" })
					if ok then
						DoNotif("Created side group", 2)
						NAmanage.RenderUserButtons()
					else
						DoNotif(msg or "Failed to combine buttons", 3)
					end
				end
			},
			{
				Text = "Cancel",
				Callback = function() end
			},
		}
	})
end

NAmanage.UserButtons_Ungroup = function(groupId)
	if type(groupId) ~= "number" then
		return false, "Invalid group id"
	end
	local group = NAUserButtons[groupId]
	if type(group) ~= "table" or group.Type ~= "group" then
		return false, "Selected item is not a group"
	end

	local children = (type(group.Children) == "table") and group.Children or {}
	if #children == 0 then
		NAUserButtons[groupId] = nil
		originalIO.clearUserButtonState(groupId)
		NAmanage.UserButtonsSave("ungroup empty")
		return true, "Removed empty group"
	end

	local basePos = group.Pos
	local offset = 0
	local offsetStep = 70
	for _, child in ipairs(children) do
		local newId = NAUserButtonNextId()
		local clone = NAUserButtonCloneAsChild(child, child.Label)
		if basePos and type(basePos) == "table" then
			clone.Pos = {
				basePos[1] or 0,
				(basePos[2] or 0) + offset,
				basePos[3] or 0,
				basePos[4] or 0,
			}
			offset = offset + offsetStep
		else
			clone.Pos = nil
		end
		NAUserButtons[newId] = clone
	end

	NAUserButtons[groupId] = nil
	originalIO.clearUserButtonState(groupId)

	NAmanage.UserButtonsSave("ungroup")
	return true, ("Ungrouped %d buttons"):format(#children)
end

NAmanage.AutoExecSave=function(data, context)
	if not FileSupport then return true end
	local ok, err = pcall(function()
		writefile(NAfiles.NAAUTOEXECPATH, HttpService:JSONEncode(data))
	end)
	if not ok then
		if context == 'loader' then
			NAmanage.loaderWarn('AutoExec', 'failed to update storage: '..tostring(err))
		else
			warn("[NA] AutoExec save failed: "..tostring(err))
		end
	end
	return ok
end

NAmanage.loadAutoExec = function()
	local currentData = NAEXECDATA or { commands = {}, args = {} }
	local path = NAfiles.NAAUTOEXECPATH

	if not FileSupport then
		NAEXECDATA = currentData
		return true
	end

	if not (isfile and isfile(path)) then
		local okCreate, createErr = pcall(function()
			writefile(path, HttpService:JSONEncode({ commands = {}, args = {} }))
		end)
		if not okCreate then
			NAmanage.loaderWarn('AutoExec', 'failed to create storage: '..tostring(createErr))
			return false
		end
	end

	local okRead, raw = pcall(readfile, path)
	if not okRead or type(raw) ~= 'string' then
		NAmanage.loaderWarn('AutoExec', 'failed to read storage: '..tostring(raw))
		return false
	end

	local okDecode, decoded = pcall(function()
		return HttpService:JSONDecode(raw)
	end)
	if not okDecode or type(decoded) ~= 'table' then
		NAmanage.loaderWarn('AutoExec', 'failed to decode storage; keeping previous data')
		return false
	end

	if decoded.commands == nil and next(decoded) then
		decoded = { commands = decoded, args = {} }
	end

	local sourceCommands = decoded.commands
	if type(sourceCommands) ~= 'table' then
		sourceCommands = {}
	end

	local sourceArgs = decoded.args
	if type(sourceArgs) ~= 'table' then
		sourceArgs = {}
	end

	local cleaned, cleanedArgs, seen = {}, {}, {}
	local modified = false

	for _, storedName in ipairs(sourceCommands) do
		local base = NAmanage.resolveCommandName(storedName)
		if base and NAStuff.AutoExecBlockedCommands[base] then
			modified = true
		else
			local key = base or storedName
			local storedArgs = sourceArgs[storedName] or (base and sourceArgs[base]) or ''

			if not seen[key] then
				seen[key] = true
				cleaned[#cleaned+1] = key
				cleanedArgs[key] = storedArgs
				if base and base ~= storedName then
					modified = true
				end
			else
				modified = true
			end
		end
	end
	if #cleaned ~= #sourceCommands then
		modified = true
	end

	local newData = { commands = cleaned, args = cleanedArgs }

	if modified then
		NAmanage.AutoExecSave(newData, 'loader')
	end

	NAEXECDATA = newData
	return true
end

NAmanage.LoadPlugins = function(opts)
	opts = opts or {}
	local silent = opts.silent == true
	local forceNotify = opts.forceNotify == true
	if not CustomFunctionSupport then
		return true
	end

	local iyCallCtx = { args = nil, speaker = nil }

	local pluginDirNA = NAfiles.NAPLUGINFILEPATH
	local pluginDirIY = NAfiles.NAIYPLUGINFILEPATH
	local function ensureDir(dir, label)
		if not (isfolder and isfolder(dir)) then
			local ok, err = pcall(makefolder, dir)
			if not ok then
				NAmanage.loaderWarn(label, 'failed to ensure folder: '..tostring(err))
				return false
			end
		end
		return true
	end

	if not ensureDir(pluginDirNA, 'Plugins') then
		return false
	end
	if not ensureDir(pluginDirIY, 'PluginsIY') then
		return false
	end

	local function formatInfo(aliases, argsHint)
		local main = aliases[1]
		local extras = {}
		for i = 2, #aliases do
			Insert(extras, aliases[i])
		end
		local formatted = main
		if argsHint and argsHint ~= "" then
			formatted = formatted.." "..argsHint
		end
		if #extras > 0 then
			formatted = formatted.." ("..Concat(extras, ", ")..")"
		end
		return formatted
	end

	local function splitArgs(line)
		local out, buf, quote = {}, "", nil
		for i = 1, #line do
			local ch = Sub(line, i, i)
			if quote then
				if ch == quote then
					quote = nil
				else
					buf = buf..ch
				end
			else
				if ch == "'" or ch == '"' then
					quote = ch
				elseif ch == " " or ch == "\t" then
					if #buf > 0 then out[#out+1] = buf; buf = "" end
				else
					buf = buf..ch
				end
			end
		end
		if #buf > 0 then out[#out+1] = buf end
		return out
	end
	local function fetchRem(url, method)
		if type(url) ~= "string" or url == "" or not game then
			return nil
		end
		local httpFn = method and game[method] or game.HttpGet
		if type(httpFn) ~= "function" then
			return nil
		end
		local callers = {
			function() return httpFn(game, url) end,
			function() return httpFn(game, url, true) end,
		}
		for _, caller in ipairs(callers) do
			local ok, result = pcall(caller)
			if ok and type(result) == "string" and result ~= "" then
				return result
			end
		end
		return nil
	end

	local function isNAPlugin(content)
		if type(content) ~= "string" then
			return false
		end
		local lowerTxt = Lower(content)
		if lowerTxt:find("cmdpluginadd", 1, true) then
			return true
		end
		local seenRemote = {}
		local loadPat = "loadstring%s*%(%s*game[:%.]([%w_]+)%s*%(%s*(['\"])(.-)%2"
		for method, _, url in content:gmatch(loadPat) do
			if url and url ~= "" and not seenRemote[url] then
				local methodLow = method and method:lower() or ""
				if methodLow == "httpget" or methodLow == "httpgetasync" then
					seenRemote[url] = true
					local remote = fetchRem(url, method)
					if remote and type(remote) == "string" and Lower(remote):find("cmdpluginadd", 1, true) then
						return true
					end
				end
			end
		end
		return false
	end

	local function isIYPlugin(content)
		if type(content) ~= "string" then
			return false
		end
		local lowerTxt = Lower(content)
		if lowerTxt:find("pluginname", 1, true) and lowerTxt:find("commands", 1, true) then
			return true
		end
		if lowerTxt:find("plugindescription", 1, true) and lowerTxt:find("commands", 1, true) then
			return true
		end
		return false
	end

	local function appendIYCommands(out, iyPlugin)
		if type(out) ~= "table" or type(iyPlugin) ~= "table" then
			return
		end
		local commands = iyPlugin.Commands or iyPlugin.commands
		if type(commands) ~= "table" then
			return
		end

		local function pushCommand(nameKey, cmdDef)
			if type(cmdDef) ~= "table" then
				return
			end
			local listName = cmdDef.ListName or cmdDef.Name or nameKey
			if type(listName) ~= "string" or listName == "" then
				return
			end

			local iyFunc = cmdDef.Function or cmdDef.Callback
			if type(iyFunc) ~= "function" then
				return
			end

			local seen = {}
			local aliases = {}
			local function addAlias(a)
				if type(a) ~= "string" then
					return
				end
				local added = false
				for part in a:gmatch("[^/,|]+") do
					local trimmed = part:match("^%s*(.-)%s*$")
					if trimmed and trimmed ~= "" then
						local low = trimmed:lower()
						if not seen[low] then
							seen[low] = true
							Insert(aliases, trimmed)
						end
						added = true
					end
				end
				if not added and a ~= "" then
					local low = a:lower()
					if not seen[low] then
						seen[low] = true
						Insert(aliases, a)
					end
				end
			end

			addAlias(listName)
			addAlias(nameKey)
			local extra = cmdDef.Aliases
			if type(extra) == "table" then
				for _, a in ipairs(extra) do
					addAlias(a)
				end
			elseif type(extra) == "string" then
				addAlias(extra)
			end

			local argsHint = cmdDef.ArgsHint or cmdDef.Args or cmdDef.Arguments or ""
			local info = cmdDef.Description or cmdDef.Info or iyPlugin.PluginDescription or iyPlugin.Description or "No description"
			local requires = cmdDef.RequiresArguments or cmdDef.RequiresArgs or false

			Insert(out, {
				Aliases = aliases,
				ArgsHint = (type(argsHint) == "string") and argsHint or "",
				Info = (type(info) == "string") and info or tostring(info),
				Function = function(...)
					local args = { ... }
					iyCallCtx.args = args
					iyCallCtx.speaker = LocalPlayer
					local ok, res = pcall(iyFunc, args, LocalPlayer)
					iyCallCtx.args = nil
					iyCallCtx.speaker = nil
					if not ok then
						error(res)
					end
					return res
				end,
				RequiresArguments = requires and true or false
			})
		end

		if #commands > 0 then
			for _, cmdDef in ipairs(commands) do
				pushCommand(cmdDef and (cmdDef.ListName or cmdDef.Name), cmdDef)
			end
			return
		end

		local keys = {}
		for k, v in pairs(commands) do
			if type(v) == "table" then
				Insert(keys, k)
			end
		end
		table.sort(keys, function(a, b) return tostring(a) < tostring(b) end)
		for _, k in ipairs(keys) do
			pushCommand(k, commands[k])
		end
	end

	NAmanage._pluginCommandRecords = NAmanage._pluginCommandRecords or {}
	NAmanage._pluginCommandSources = NAmanage._pluginCommandSources or {}

	local function normKey(path)
		if not path then
			return ""
		end
		local normalized = path:gsub("\\","/")
		return Lower(normalized)
	end

	local function UnplugCmd(key)
		if not key then
			return
		end
		local record = NAmanage._pluginCommandRecords[key]
		if not record then
			return
		end
		for alias, data in pairs(record.aliases or {}) do
			if cmds.Commands[alias] == data then
				cmds.Commands[alias] = nil
			end
			if cmds.Aliases[alias] == data then
				cmds.Aliases[alias] = nil
			end
			if cmds.PluginSources then
				cmds.PluginSources[alias] = nil
			end
			if type(NAmanage._pluginCommandSources) == "table" then
				NAmanage._pluginCommandSources[alias] = nil
			end
		end
		NAmanage._pluginCommandRecords[key] = nil
	end

	local function AddCmdPlug(key, aliases, dataRef)
		if not key or not dataRef or type(aliases) ~= "table" then
			return
		end
		local record = NAmanage._pluginCommandRecords[key]
		if not record then
			record = { aliases = {} }
			NAmanage._pluginCommandRecords[key] = record
		else
			record.aliases = record.aliases or {}
		end
		cmds.PluginSources = cmds.PluginSources or {}
		local sourceMap = NAmanage._pluginCommandSources
		for _, alias in ipairs(aliases) do
			if type(alias) == "string" and alias ~= "" then
				local lowerAlias = alias:lower()
				record.aliases[lowerAlias] = dataRef
				cmds.PluginSources[lowerAlias] = key
				if type(sourceMap) == "table" then
					sourceMap[lowerAlias] = { key = key, data = dataRef }
				end
			end
		end
	end

	local function formatAliasSwapNote(replacements)
		if not replacements then
			return nil
		end
		local parts = {}
		for from, to in pairs(replacements) do
			parts[#parts + 1] = tostring(from).."→"..tostring(to)
		end
		if #parts == 0 then
			return nil
		end
		table.sort(parts)
		return "Conflicting aliases remapped: "..Concat(parts, ", ")
	end

	local function makeUniqueAliases(key, aliases)
		local out = {}
		local replaced = {}
		local seenLocal = {}
		local sourceMap = NAmanage._pluginCommandSources or {}

		local function aliasTaken(lowerAlias, thisKey)
			local src = sourceMap[lowerAlias]
			if src and src.key and src.key ~= thisKey then
				return true
			end
			-- also consider core/other commands
			if cmds and cmds.Commands and cmds.Commands[lowerAlias] then
				local srcRec = sourceMap[lowerAlias]
				if not srcRec or (srcRec.key ~= thisKey) then
					return true
				end
			end
			return false
		end

		local function reserveAlias(baseAlias)
			local counter = 1
			local attempt = "plugin:"..baseAlias
			local lower = attempt:lower()
			while aliasTaken(lower, key) do
				counter += 1
				attempt = "plugin"..tostring(counter)..":"..baseAlias
				lower = attempt:lower()
			end
			return attempt, lower
		end

		for _, alias in ipairs(aliases or {}) do
			local name = tostring(alias or "")
			if name ~= "" then
				local lower = name:lower()
				if not seenLocal[lower] then
					seenLocal[lower] = true
					if aliasTaken(lower, key) then
						local newAlias, newLower = reserveAlias(name)
						replaced[name] = newAlias
						out[#out + 1] = newAlias
						seenLocal[newLower] = true
					else
						out[#out + 1] = name
					end
				end
			end
		end

		return out, replaced
	end

	local loadedSumm = {}
	local seenKeys = {}

	local function enumerate(dir, label, extPat)
		local okList, files = pcall(listfiles, dir)
		if not okList or type(files) ~= "table" then
			local errMsg = okList and "invalid directory listing" or tostring(files)
			NAmanage.loaderWarn(label, "failed to enumerate: "..errMsg)
			return nil
		end
		local out = {}
		for _, p in ipairs(files) do
			if type(p) == "string" and Lower(p):match(extPat) then
				Insert(out, p)
			end
		end
		return out
	end

	local filesNA = enumerate(pluginDirNA, "Plugins", "%.na$") or {}
	local filesIY = enumerate(pluginDirIY, "PluginsIY", "%.iy$") or {}

	local function loadPluginFile(file, mode)
		local baseName = file and (file:match("[^\\/]+$") or file) or ""
		if mode == "iy" and type(baseName) == "string" and baseName:lower() == "iy_fe.iy" then
			return
		end

		local pluginKey = normKey(file)
		seenKeys[pluginKey] = true
		UnplugCmd(pluginKey)

		local success, content = NACaller(readfile, file)
		if not (success and content) then
			DoWindow("[Plugin Read Error] Failed to read '"..file.."'")
			return
		end

		if mode == "na" and not isNAPlugin(content) then
			DoWindow("skipped '"..file.."' (no cmdPluginAdd)")
			return
		end

		local func, loadErr = loadstring(content)
		if not func then
			DoWindow("[Plugin Load Error] '"..file.."': "..tostring(loadErr))
			return
		end

		local colPlugins = {}
		local proxyEnv = {}
		local baseEnv = getfenv()

		local function _runCmd(...)
			local runner = cmd and (cmd.run or cmd.Run)
			if not runner then return nil, "cmd.run not available" end
			local n = select("#", ...)
			local argv
			if n == 1 then
				local a = ...
				if type(a) == "table" then
					argv = a
				elseif type(a) == "string" then
					argv = splitArgs(a)
				else
					return nil, "invalid input to runCommand"
				end
			else
				argv = {}
				for i = 1, n do
					local v = select(i, ...)
					argv[#argv+1] = type(v) == "string" and v or tostring(v)
				end
			end
			local ok1, res1 = NACaller(runner, argv)
			if ok1 then return res1 end
			local ok2, res2 = NACaller(runner, Concat(argv, " "))
			if ok2 then return res2 end
			return nil, res2
		end

		local function _pluginRequest(opts)
			local rq = resolvedRequest or opt.NAREQUEST
			if type(rq) ~= "function" then
				return { StatusCode = 0, Body = "HTTP unavailable" }
			end
			if type(opts) == "table" then
				if type(opts.HttpRequestType) == "boolean" then
					opts = table.clone and table.clone(opts) or { }
					if not table.clone then
						for k, v in pairs(opts) do opts[k] = v end
					end
					opts.HttpRequestType = nil
				end
			end
			local ok, res = pcall(rq, opts)
			if ok then
				return res
			end
			return { StatusCode = 0, Body = tostring(res) }
		end

		local rawGame = game
		local gameProxy = {}
		function gameProxy:GetService(serviceName)
			return rawGame:GetService(serviceName)
		end
		function gameProxy:HttpGet(url, second)
			if type(second) == "boolean" then
				return rawGame:HttpGet(url)
			end
			return rawGame:HttpGet(url, second)
		end
		function gameProxy:HttpGetAsync(url, second)
			if type(second) == "boolean" then
				return rawGame:HttpGetAsync(url)
			end
			return rawGame:HttpGetAsync(url, second)
		end
		setmetatable(gameProxy, {
			__index = function(_, k)
				local v = rawGame[k]
				if type(v) == "function" then
					return function(_, ...)
						return v(rawGame, ...)
					end
				end
				return v
			end
		})

		proxyEnv.cmdRun = _runCmd
		proxyEnv.RunCommand = _runCmd
		proxyEnv.runCommand = _runCmd
		proxyEnv.request = _pluginRequest
		proxyEnv.http_request = _pluginRequest
		proxyEnv.notify = function(msg, detailOrTime, maybeTime)
			local duration = 3
			local text
			if type(detailOrTime) == "string" then
				text = tostring(msg)..": "..detailOrTime
				duration = tonumber(maybeTime) or duration
			else
				text = tostring(msg)
				duration = tonumber(detailOrTime) or duration
			end
			if DoNotif then
				DoNotif(text, duration)
			else
				warn(text)
			end
		end

		if mode == "iy" then
			local servicesCache = {}
			local function fetchService(name)
				if servicesCache[name] ~= nil then
					return servicesCache[name]
				end
				local svc = nil
				if SafeGetService then
					svc = SafeGetService(name)
				end
				if not svc and game and game.GetService then
					local ok, res = pcall(game.GetService, game, name)
					if ok then
						svc = res
					end
				end
				servicesCache[name] = svc
				return svc
			end
			local iyServices = setmetatable({}, {
				__index = function(_, k)
					return fetchService(k)
				end
			})
			proxyEnv.Services = iyServices
			proxyEnv.services = iyServices

			local iySplitString

			local function iyGetPlayers(query, speaker)
				local results = {}
				if not Players then
					return results
				end
				local function add(plr)
					if plr and plr.Name then
						results[#results+1] = plr.Name
					end
				end
				local tokens = iySplitString(query or "", ",")
				if #tokens == 0 then
					return results
				end

				local everyone = Players:GetPlayers()

				for _, tokenRaw in ipairs(tokens) do
					local token = tokenRaw:lower()
					local resolved = false
					if type(getPlr) == "function" then
						local ok, list = pcall(function()
							return getPlr(speaker, tokenRaw)
						end)
						if ok and type(list) == "table" then
							for _, plr in ipairs(list) do
								add(plr)
							end
							resolved = true
						end
					end
					if resolved then
						continue
					end
					if token == "all" or token == "*" or token == "everyone" then
						for _, plr in ipairs(everyone) do
							add(plr)
						end
					elseif token == "others" then
						for _, plr in ipairs(everyone) do
							if not speaker or plr ~= speaker then
								add(plr)
							end
						end
					elseif token == "me" or token == "self" then
						if speaker then
							add(speaker)
						end
					elseif token == "random" then
						if #everyone > 0 then
							add(everyone[math.random(1, #everyone)])
						end
					else
						local search = token
						local atName = false
						if search:sub(1,1) == "@" then
							search = search:sub(2)
							atName = true
						end
						for _, plr in ipairs(everyone) do
							local nm = plr.Name:lower()
							local dn = (plr.DisplayName or ""):lower()
							if atName then
								if nm:sub(1, #search) == search then
									add(plr)
								end
							else
								if nm:sub(1, #search) == search or dn:sub(1, #search) == search then
									add(plr)
								end
							end
						end
					end
				end
				return results
			end
			proxyEnv.getPlayersByName = iyGetPlayers
			proxyEnv.getPlayer = iyGetPlayers
			proxyEnv.GetPlayer = iyGetPlayers
			proxyEnv.r15 = function(plr)
				local target = plr
				if not target and Players then
					target = Players.LocalPlayer
				end
				local hum = target and target.Character and getPlrHum(target.Character)
				return hum and hum.RigType == Enum.HumanoidRigType.R15
			end
			proxyEnv.Services = proxyEnv.Services or iyServices
			proxyEnv.getstring = function(startIdx)
				local args = iyCallCtx.args or {}
				local start = tonumber(startIdx) or 1
				if start < 1 then start = 1 end
				local parts = {}
				for i = start, #args do
					parts[#parts+1] = tostring(args[i])
				end
				return Concat(parts, " ")
			end
			proxyEnv.getString = proxyEnv.getstring

			local function iyIsNumber(str)
				return tonumber(str) ~= nil
			end
			proxyEnv.isNumber = iyIsNumber
			proxyEnv.isnumber = iyIsNumber

			function iySplitString(str, delim)
				local out = {}
				str = tostring(str or "")
				delim = tostring(delim or ",")
				for part in string.gmatch(str, "[^"..delim.."]+") do
					local trimmed = part:match("^%s*(.-)%s*$")
					if trimmed and trimmed ~= "" then
						out[#out+1] = trimmed
					end
				end
				return out
			end
			proxyEnv.splitString = iySplitString

			local function iyToClipboard(txt)
				local payload = tostring(txt or "")
				if typeof(setclipboard) == "function" then
					local ok = pcall(setclipboard, payload)
					if ok then
						return true
					end
				end
				warn("Clipboard unavailable; value: "..payload)
				return false
			end
			proxyEnv.toClipboard = iyToClipboard
			proxyEnv.toclipboard = iyToClipboard

			local lp = Players and Players.LocalPlayer or nil
			proxyEnv.Players = proxyEnv.Players or Players
			proxyEnv.LocalPlayer = lp
			proxyEnv.Player = lp
			proxyEnv.lplr = lp
			proxyEnv.Char = lp and lp.Character or nil
			proxyEnv.Character = lp and lp.Character or nil
			proxyEnv.PlayerGui = lp and lp:FindFirstChildWhichIsA("PlayerGui") or nil
			proxyEnv.PlaceId = tonumber(game and game.PlaceId) or 0
			proxyEnv.JobId = tostring((game and game.JobId) or "")
			proxyEnv.COREGUI = SafeGetService and SafeGetService("CoreGui") or nil
			proxyEnv.UserInputService = proxyEnv.UserInputService or UserInputService
			proxyEnv.RunService = proxyEnv.RunService or RunService
			proxyEnv.TweenService = proxyEnv.TweenService or TweenService
			proxyEnv.HttpService = proxyEnv.HttpService or HttpService
			proxyEnv.TextChatService = proxyEnv.TextChatService or SafeGetService("TextChatService")
			proxyEnv.TextService = proxyEnv.TextService or SafeGetService("TextService")
			proxyEnv.StarterGui = proxyEnv.StarterGui or SafeGetService("StarterGui")
			proxyEnv.ReplicatedStorage = proxyEnv.ReplicatedStorage or SafeGetService("ReplicatedStorage")
			proxyEnv.Lighting = proxyEnv.Lighting or SafeGetService("Lighting")
			proxyEnv.ContextActionService = proxyEnv.ContextActionService or SafeGetService("ContextActionService")

			local function iyMouse()
				if lp and lp.GetMouse then
					local ok, m = pcall(lp.GetMouse, lp)
					if ok and m then
						return m
					end
				end
				return nil
			end
			proxyEnv.IYMouse = iyMouse()

			local function iyIsOnMobile()
				if UserInputService and typeof(UserInputService.GetPlatform) == "function" then
					local platform = UserInputService:GetPlatform()
					return platform == Enum.Platform.Android or platform == Enum.Platform.IOS
				end
				return UserInputService and UserInputService.TouchEnabled and not UserInputService.KeyboardEnabled
			end
			proxyEnv.IsOnMobile = iyIsOnMobile()

			local function iyLegacyChat()
				if TextChatService and TextChatService.ChatVersion then
					return TextChatService.ChatVersion == Enum.ChatVersion.LegacyChatService
				end
				return false
			end
			proxyEnv.isLegacyChat = iyLegacyChat()

			proxyEnv.currentVersion = proxyEnv.currentVersion or "IY-compat"

			proxyEnv.getRoot = function(char)
				if not char then
					return nil
				end
				return char:FindFirstChild("HumanoidRootPart")
					or char:FindFirstChild("Torso")
					or char:FindFirstChild("UpperTorso")
					or char.PrimaryPart
			end

			proxyEnv.Time = function()
				return os.date("%X")
			end

			if not proxyEnv.buffer or type(proxyEnv.buffer.create) ~= "function" then
				local bufShim = {}
				bufShim.__index = bufShim
				function bufShim.create(n)
					return setmetatable({ len = tonumber(n) or 0, data = {} }, bufShim)
				end
				function bufShim.writeu8(b, idx, val)
					if not (b and b.data) then
						return
					end
					b.data[(idx or 0) + 1] = val
				end
				function bufShim.tostring(b)
					if not b or not b.data then
						return ""
					end
					local out = {}
					for i = 1, b.len do
						out[i] = string.char(b.data[i] or 0)
					end
					return Concat(out)
				end
				proxyEnv.buffer = bufShim
			end
		end

		setmetatable(proxyEnv, {
			__index = function(_, k)
				if k == "loadstring" then
					local baseLoader = baseEnv.loadstring or loadstring
					return function(code, chunkname)
						local f, e = baseLoader(code, chunkname)
						if f then setfenv(f, proxyEnv) end
						return f, e
					end
				elseif k == "load" then
					local baseLoad = baseEnv.load
					if not baseLoad then return nil end
					return function(chunk, chunkname, mode2, env)
						return baseLoad(chunk, chunkname, mode2, env or proxyEnv)
					end
				elseif k == "game" then
					return gameProxy
				elseif k == "httprequest" or k == "request" or k == "http_request" then
					return _pluginRequest
				end
				return baseEnv[k]
			end,
			__newindex = function(_, k, v)
				if k == "cmdPluginAdd" then
					if type(v) == "table" then
						if v[1] and type(v[1]) == "table" then
							for _, sub in ipairs(v) do
								Insert(colPlugins, sub)
							end
						else
							Insert(colPlugins, v)
						end
					end
				else
					rawset(baseEnv, k, v)
				end
			end
		})

		setfenv(func, proxyEnv)

		local prevSkipAdd = cmds._skipAutoSuffix
		cmds._skipAutoSuffix = true
		local ok, execRes = NACaller(func)
		cmds._skipAutoSuffix = prevSkipAdd
		if not ok then
			DoWindow("[Plugin Error] '"..file.."' => "..tostring(execRes))
			return
		end

		if mode == "iy" and type(execRes) == "table" then
			appendIYCommands(colPlugins, execRes)
		end

		local cmdNames = {}
		for _, plugin in ipairs(colPlugins) do
			local aliases = plugin.Aliases
			local handler = plugin.Function
			if type(aliases) == "table" and type(handler) == "function" then
				local uniqueAliases, replacedAliases = makeUniqueAliases(pluginKey, aliases)
				if #uniqueAliases == 0 then
					DoWindow("[Plugin Invalid] '"..file.."' has no usable aliases (conflicts removed)")
				else
					local argsHint = plugin.ArgsHint or ""
					local formattedDisplay = formatInfo(uniqueAliases, argsHint)
					local desc = plugin.Info or "No description"
					local note = formatAliasSwapNote(replacedAliases)
					if note then
						desc = desc.." | "..note
					end
					local info = { formattedDisplay, desc }
					local prevSkip = cmds._skipAutoSuffix
					cmds._skipAutoSuffix = true
					local okAdd, errAdd = pcall(cmd.add, uniqueAliases, info, handler, plugin.RequiresArguments or false)
					cmds._skipAutoSuffix = prevSkip
					if okAdd then
						local primaryLow = uniqueAliases[1] and type(uniqueAliases[1]) == "string" and uniqueAliases[1]:lower() or nil
						local dataRef = primaryLow and cmds.Commands[primaryLow] or nil
						AddCmdPlug(pluginKey, uniqueAliases, dataRef)
						Insert(cmdNames, uniqueAliases[1])
					else
						DoWindow("[Plugin Error] Failed to register command: "..tostring(errAdd))
					end
				end
			else
				DoWindow("[Plugin Invalid] '"..file.."' is missing valid Aliases or Function")
			end
		end

		if #cmdNames > 0 then
			local fileName = file:match("[^\\/]+$") or file
			Insert(loadedSumm, fileName.." ("..Concat(cmdNames, ", ")..")")
		end
	end

	for _, file in ipairs(filesNA) do
		loadPluginFile(file, "na")
	end
	for _, file in ipairs(filesIY) do
		loadPluginFile(file, "iy")
	end

	local staleKeys = {}
	for key in pairs(NAmanage._pluginCommandRecords) do
		if not seenKeys[key] then
			Insert(staleKeys, key)
		end
	end
	for _, key in ipairs(staleKeys) do
		UnplugCmd(key)
	end

	local allowNotif = (forceNotify == true) or (NAmanage.jlCfg.PluginNotif ~= false)
	if #loadedSumm > 0 and allowNotif and not silent then
		DoNotif("Loaded plugins:\n\n"..Concat(loadedSumm, "\n\n"), 5.7)
	end

	if NAgui and NAgui.loadCMDS then
		pcall(NAgui.loadCMDS)
	end

	return true
end

NAmanage.IsPluginCommand = function(cmdName)
	if type(cmdName) ~= "string" then
		return false
	end
	local sources = NAmanage and NAmanage._pluginCommandSources
	if type(sources) ~= "table" then
		sources = {}
	end
	local lowerName = Lower(cmdName)
	local entry = sources[lowerName]
	if entry then
		if entry.data and cmds and cmds.Commands and cmds.Commands[lowerName] ~= entry.data then
			return false
		end
		local pluginType
		if type(entry.key) == "string" then
			if entry.key:match("%.na$") then
				pluginType = ".na"
			elseif entry.key:match("%.iy$") then
				pluginType = ".iy"
			end
		end
		return true, pluginType, entry.key
	end

	if cmds and cmds.PluginSources and cmds.PluginSources[lowerName] then
		local key = cmds.PluginSources[lowerName]
		local pluginType
		if type(key) == "string" then
			if key:match("%.na$") then
				pluginType = ".na"
			elseif key:match("%.iy$") then
				pluginType = ".iy"
			end
		end
		return true, pluginType, key
	end

	return false
end

NAmanage.InitPlugs=function()
	local lp = function(p)
		p = (p or ""):gsub("\\","/"):gsub("/+","/")
		return Lower(p:gsub("/+$",""))
	end
	local bn = function(p) return (p and p:match("[^\\/]+$")) or p end
	local jp = function(d, n) d = d or ""; return (#d > 0) and (d.."/"..n) or n end
	local mk = function(p) if p and #p > 0 and not isfolder(p) then makefolder(p) end end
	local isIgnoredIY = function(p)
		local base = bn(p)
		return type(base) == "string" and base:lower() == "iy_fe.iy"
	end
	local isPluginFile = function(p)
		local n = lp(p)
		if isIgnoredIY(p) then
			return false
		end
		return n:match("%.na$") ~= nil or n:match("%.iy$") ~= nil
	end
	local uniq = function(dir, fname)
		local name, ext = fname:match("^(.*)(%.[^%.]+)$"); name, ext = name or fname, ext or ""
		local try = jp(dir, fname); if not isfile(try) then return try end
		local n = 1
		while true do
			try = jp(dir, Format("%s (%d)%s", name, n, ext))
			if not isfile(try) then return try end
			n += 1
		end
	end
	local root = function()
		for _, c in ipairs({"", ".", "/"}) do
			local ok, t = pcall(listfiles, c)
			if ok and type(t) == "table" then return c end
		end
		return ""
	end

	local plugsDirNA = NAfiles.NAPLUGINFILEPATH
	local plugsDirIY = NAfiles.NAIYPLUGINFILEPATH or (NAfiles.NAFILEPATH.."/PluginsIY")
	local plugsInfo = {}
	for _, dir in ipairs({plugsDirNA, plugsDirIY}) do
		local norm = lp(dir)
		local tail = norm:match("([^/]+/[^/]+)$") or norm
		Insert(plugsInfo, { norm = norm, tail = tail })
	end
	local inPlugs = function(path)
		local p = lp(path)
		for _, info in ipairs(plugsInfo) do
			if p == info.norm then return true end
			if p:sub(1, #info.norm + 1) == (info.norm.."/") then return true end
			if p:find("/"..info.tail.."/", 1, true) then return true end
		end
		return false
	end

	local scan = function(startDir)
		local out = {}
		local function rec(dir)
			local ok, items = pcall(listfiles, dir)
			if not ok or type(items) ~= "table" then return end
			for _, p in ipairs(items) do
				local okd, isd = pcall(isfolder, p)
				if okd and isd then
					if not inPlugs(p) then rec(p) end
				else
					if isPluginFile(p) and not inPlugs(p) then Insert(out, p) end
				end
			end
		end
		rec(startDir)
		return out
	end

	cmd.add(
		{"addallplugins","addplugins","aap","aaplugs"},
		{"addallplugins","Move all .na to Nameless-Admin/Plugins and all .iy to Nameless-Admin/PluginsIY, then load them"},
		function()
			mk(plugsDirNA)
			mk(plugsDirIY)
			local ws = root()
			local found = scan(ws)
			local moved, errs = {}, 0
			for _, src in ipairs(found) do
				if isIgnoredIY(src) then
					continue
				end
				local okR, data = pcall(readfile, src)
				if okR and data then
					local isIY = lp(src):match("%.iy$") ~= nil
					local dstDir = isIY and plugsDirIY or plugsDirNA
					local dst = uniq(dstDir, bn(src))
					local okW = pcall(writefile, dst, data)
					if okW and delfile and pcall(delfile, src) then
						Insert(moved, bn(dst))
					else
						errs += 1
					end
				else
					errs += 1
				end
			end
			if #moved > 0 then
				DoNotif("Moved "..#moved.." plugin file(s):\n\n"..Concat(moved, "\n"), 4.5)
				if NAmanage and NAmanage.LoadPlugins then NAmanage.LoadPlugins() end
			else
				DoNotif((errs>0) and ("No plugins moved ("..errs.." error(s))") or "No .na/.iy files found outside Plugins/PluginsIY", 3)
			end
		end
	)

	cmd.add(
		{"addplugin","addplug","ap","aplug"},
		{"addplugin","Move one .na to Plugins or one .iy to PluginsIY, then load it"},
		function(...)
			mk(plugsDirNA)
			mk(plugsDirIY)
			local query = tostring((...) or ""):lower()
			local ws = root()
			local all = scan(ws) -- already excludes anything under Plugins
			if #all == 0 then DoNotif("No .na/.iy files found outside Plugins/PluginsIY",3); return end

			local function moveOne(path)
				if isIgnoredIY(path) then
					DoNotif("Skipping IY_FE.iy (Infinite Yield settings file)", 3)
					return
				end
				local file = bn(path)
				local okR, data = pcall(readfile, path)
				if not okR or not data then DoNotif("Failed to read "..file,3); return end
				local isIY = lp(path):match("%.iy$") ~= nil
				local dstDir = isIY and plugsDirIY or plugsDirNA
				local dst = uniq(dstDir, file)
				local okW = pcall(writefile, dst, data)
				if not okW then DoNotif("Failed to write "..file,3); return end
				if not (delfile and pcall(delfile, path)) then DoNotif("Wrote but couldn't delete source "..file,3); return end
				DoNotif("Moved plugin "..file,3)
				if NAmanage and NAmanage.LoadPlugins then NAmanage.LoadPlugins() end
			end

			if #query > 0 then
				local hits = {}
				for _, p in ipairs(all) do
					local base = bn(p):lower()
					if base == query or base:find(query, 1, true) then Insert(hits, p) end
				end
				if #hits == 1 then moveOne(hits[1]); return end
				if #hits == 0 then DoNotif("No match for '"..query.."'",3); return end
				local btns = {}
				for _, p in ipairs(hits) do
					local file = bn(p)
					Insert(btns, { Text = file, Callback = function() moveOne(p) end })
				end
				local show = Window or DoWindow
				if show then show({Title = "Select Plugin", Buttons = btns}) else DoNotif("Multiple matches; refine name",3) end
				return
			end

			local btns = {}
			for _, p in ipairs(all) do
				local file = bn(p)
				Insert(btns, { Text = file, Callback = function() moveOne(p) end })
			end
			local show = Window or DoWindow
			if show then show({Title = "Add Plugin", Buttons = btns}) else DoNotif("UI not available",3) end
		end
	)

	cmd.add(
		{"reloadplugin","relplug","rp"},
		{"reloadplugin [name]","Reload plugin files (reloads all if no name provided)"},
		function(...)
			if not CustomFunctionSupport or not (NAmanage and NAmanage.LoadPlugins) then
				DoNotif("Plugin loader unavailable",3)
				return
			end
			local query = tostring((...) or ""):lower()
			if query ~= "" then
				local matched = false
				for _, dir in ipairs({plugsDirNA, plugsDirIY}) do
					if isfolder and isfolder(dir) then
						local ok, items = pcall(listfiles, dir)
						if ok and type(items) == "table" then
							for _, path in ipairs(items) do
								if isPluginFile(path) then
									local name = path:match("[^\\/]+$") or path
									if name and name:lower():find(query, 1, true) then
										matched = true
										break
									end
								end
							end
						end
					end
					if matched then break end
				end
				if not matched then
					DoNotif("No plugin matched '"..query.."'",3)
					return
				end
			end
			if not NAmanage.LoadPlugins({ forceNotify = true }) then
				DoNotif("Failed to reload plugins",3)
			else
				if NAgui and NAgui.loadCMDS then
					pcall(NAgui.loadCMDS)
				end
			end
		end
	)

	cmd.add(
		{"removeplugin","rmplugin","delplugin","rmp"},
		{"removeplugin","Move a plugin file from Nameless-Admin/Plugins or Nameless-Admin/PluginsIY back to workspace"},
		function()
			if not (isfolder(plugsDirNA) or isfolder(plugsDirIY)) then DoNotif("Plugins folder not found",3); return end
			local btns = {}
			local function addButtons(dir, prefix, extPat)
				if not isfolder(dir) then return end
				local ok, items = pcall(listfiles, dir)
				if not ok or type(items) ~= "table" then return end
				for _, p in ipairs(items) do
					if isIgnoredIY(p) then
						continue
					end
					if type(p) == "string" and lp(p):match(extPat) then
						local file = bn(p)
						Insert(btns, {
							Text = prefix..file,
							Callback = function()
								local okR, data = pcall(readfile, p)
								if not okR or not data then DoNotif("Failed to read "..file,3); return end
								local dst = uniq("", file)
								local okW = pcall(writefile, dst, data)
								if okW and delfile and pcall(delfile, p) then
									DoNotif("Moved "..file.." to workspace",3)
								else
									DoNotif("Failed to move "..file,3)
								end
							end
						})
					end
				end
			end
			addButtons(plugsDirNA, "[NA] ", "%.na$")
			addButtons(plugsDirIY, "[IY] ", "%.iy$")
			if #btns == 0 then DoNotif("No plugins found in Plugins/PluginsIY folders",3); return end
			local show = Window or DoWindow
			if show then show({Title = "Move Plugin to Workspace", Buttons = btns}) else DoNotif("Window UI not available",3) end
		end
	)

	cmd.add(
		{"removeallplugins","rmaplugins","clearplugins","rmap","rmaplugs"},
		{"removeallplugins","Move all plugins from Nameless-Admin/Plugins and Nameless-Admin/PluginsIY back to workspace"},
		function()
			if not (isfolder(plugsDirNA) or isfolder(plugsDirIY)) then DoNotif("Plugins folder not found",3); return end
			local moved, errs = {}, 0
			local function moveAll(dir, extPat)
				if not isfolder(dir) then return end
				local ok, items = pcall(listfiles, dir)
				if not ok or type(items) ~= "table" then errs += 1; return end
				for _, p in ipairs(items) do
					if isIgnoredIY(p) then
						continue
					end
					if type(p) == "string" and lp(p):match(extPat) then
						local file = bn(p)
						local okR, data = pcall(readfile, p)
						if okR and data then
							local dst = uniq("", file)
							local okW = pcall(writefile, dst, data)
							if okW and delfile and pcall(delfile, p) then
								Insert(moved, file)
							else
								errs += 1
							end
						else
							errs += 1
						end
					end
				end
			end
			moveAll(plugsDirNA, "%.na$")
			moveAll(plugsDirIY, "%.iy$")
			if #moved > 0 then
				DoNotif("Moved "..#moved.." plugin file(s) to workspace:\n\n"..Concat(moved, "\n"), 4.5)
			else
				DoNotif((errs>0) and ("No plugin files moved ("..errs.." error(s))") or "No plugins found",3)
			end
			if NAmanage and NAmanage.LoadPlugins then NAmanage.LoadPlugins() end
		end
	)
end

NAmanage.SaveWaypoints = function()
	if not FileSupport then return end

	local path = NAmanage.GetWPPath()

	if next(Waypoints) then
		writefile(path, HttpService:JSONEncode(Waypoints))
	else
		if delfile and isfile(path) then
			pcall(delfile, path)
		elseif isfile(path) then
			writefile(path, "{}")
		end
	end
end

NAmanage.LogJoinLeave = function(message)
	if not FileSupport or not appendfile or not (NAmanage.jlCfg and NAmanage.jlCfg.SaveLog) then return end

	local logPath = NAfiles.NAJOINLEAVELOG
	local timestamp = os.date("[%Y-%m-%d %H:%M:%S]")

	local logMessage = Format(
		"%s %s | Game: %s | PlaceId: %s | GameId: %s | JobId: %s\n",
		timestamp,
		message,
		placeName() or "unknown",
		tostring(PlaceId),
		tostring(GameId),
		tostring(JobId)
	)

	if isfile(logPath) then
		appendfile(logPath, logMessage)
	else
		writefile(logPath, logMessage)
	end

end

NAmanage.RenderUserButtons = function()
	local screenGui = NAmanage.waitForScreenGui(5)
	if not screenGui then
		NAmanage.loaderWarn('RenderUserButtons', 'aborted: interface not ready')
		return false
	end
	if NAmanage._renderUserButtonsRunning then
		return true
	end
	NAmanage._renderUserButtonsRunning = true

	local success, err = pcall(function()
		NAStuff.NASCREENGUI = screenGui
		if NAStuff.KeybindConnection then
		end
		for _, drop in pairs(UserButtonDropdowns) do
			if type(drop) == "table" then
				if drop.conn then
					pcall(function() drop.conn:Disconnect() end)
				end
				if drop.container then
					pcall(function() drop.container:Destroy() end)
				end
			elseif typeof(drop) == "Instance" then
				pcall(function() drop:Destroy() end)
			end
		end
		table.clear(UserButtonDropdowns)
		for _, btn in pairs(UserButtonGuiList) do
			btn:Destroy()
		end
		table.clear(UserButtonGuiList)
		table.clear(UserButtonGuiMap)

		local UIS = UserInputService
		local SavedArgs       = {}
		local ActivePrompts   = {}
		local ActiveKeyBinding= {}
		local ActionBindings  = {}
		local tSize = 28
		local DOUBLE_CLICK_WINDOW = 0.35
		local activeDropdowns = {}
		local dropdownPos = {
			gap = 10,
			downOffset = 55,
			upOffset = -60,
			sideYOffset = 6,
		}

		local function placeGroupContainer(mode, btn, dropSize)
			dropSize = dropSize or Vector2.new(0, 0)
			local tap = btn.AbsolutePosition
			local tsz = btn.AbsoluteSize
			local cam = workspace.CurrentCamera
			local vp = cam and cam.ViewportSize or Vector2.new(1280, 720)
			local margin = 8
			local gapDown = (dropdownPos.gap or 0) + (dropdownPos.downOffset or 0)
			local gapUp = (dropdownPos.gap or 0) + (dropdownPos.upOffset or 0)
			local sideYOffset = dropdownPos.sideYOffset or 0

			if mode == "side" then
				local canRight = (tap.X + tsz.X + dropdownPos.gap + dropSize.X) <= (vp.X - margin)
				local canLeft = (tap.X - dropdownPos.gap - dropSize.X) >= margin
				local openRight = canRight
				if not canRight and canLeft then
					openRight = false
				elseif not canLeft and not canRight then
					openRight = ((vp.X - (tap.X + tsz.X)) >= tap.X)
				end

				local anchor = Vector2.new(openRight and 0 or 1, 0.5)
				local x
				if openRight then
					x = math.min(tap.X + tsz.X + dropdownPos.gap, vp.X - margin - dropSize.X)
					x = math.max(x, margin)
				else
					x = math.max(tap.X - dropdownPos.gap, margin + dropSize.X)
					x = math.min(x, vp.X - margin)
				end

				local halfH = dropSize.Y * 0.5
				local y = math.clamp(tap.Y + tsz.Y * 1.25 + sideYOffset, margin + halfH, vp.Y - margin - halfH)
				return UDim2.fromOffset(x, y), anchor
			end

			local canDown = (tap.Y + tsz.Y + gapDown + dropSize.Y) <= (vp.Y - margin)
			local canUp = (tap.Y - gapUp - dropSize.Y) >= margin
			local openDown = canDown
			if not canDown and canUp then
				openDown = false
			elseif not canUp and not canDown then
				openDown = ((vp.Y - (tap.Y + tsz.Y)) >= tap.Y)
			end

			local anchor = Vector2.new(0.5, openDown and 0 or 1)
			local halfW = dropSize.X * 0.5
			local x = math.clamp(tap.X + tsz.X * 0.5, margin + halfW, vp.X - margin - halfW)

			local y
			if openDown then
				y = tap.Y + tsz.Y + gapDown
				if canDown then
					y = math.min(y, vp.Y - margin - dropSize.Y)
					y = math.max(y, margin)
				end
			else
				y = tap.Y - gapUp
				if canUp then
					y = math.max(y, margin + dropSize.Y)
					y = math.min(y, vp.Y - margin)
				end
			end

			return UDim2.fromOffset(x, y), anchor
		end

		local function clearDropdownEntry(id)
			local entry = activeDropdowns[id]
			if not entry then
				return
			end
			if entry.close then
				entry.close()
			elseif entry.container then
				entry.container:Destroy()
			end
			if entry.conn then
				entry.conn:Disconnect()
			end
			if entry.posConn then
				entry.posConn:Disconnect()
			end
			if entry.sizeConn then
				entry.sizeConn:Disconnect()
			end
			activeDropdowns[id] = nil
			UserButtonDropdowns[id] = nil
		end

		local function closeAllDropdowns()
			for id in pairs(activeDropdowns) do
				clearDropdownEntry(id)
			end
		end

		local function updateDropdownPosition(id)
			local entry = activeDropdowns[id]
			if not entry or not entry.container or not entry.btn then
				return
			end
			local mode = entry.mode or "dropdown"
			local size = entry.container.AbsoluteSize
			local pos, anchor = placeGroupContainer(mode, entry.btn, size)
			entry.container.AnchorPoint = anchor
			entry.container.Position = pos
		end

		local function udim2ToArray(u)
			return {u.X.Scale, u.X.Offset, u.Y.Scale, u.Y.Offset}
		end

		local function positionsChanged(a, b)
			if type(a) ~= "table" or type(b) ~= "table" then
				return true
			end
			local dx = math.abs((a[1] or 0) - (b[1] or 0))
			local dy = math.abs((a[3] or 0) - (b[3] or 0))
			local ox = math.abs((a[2] or 0) - (b[2] or 0))
			local oy = math.abs((a[4] or 0) - (b[4] or 0))
			return dx > 0.0005 or dy > 0.0005 or ox > 1.5 or oy > 1.5
		end

		function ButtonInputPrompt(cmdName, cb)
			local gui = InstanceNew("ScreenGui")
			gui.IgnoreGuiInset = true
			gui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
			gui.Parent = screenGui

			local f = InstanceNew("Frame")
			f.Size = UDim2.new(0,260,0,140)
			f.Position = UDim2.new(0.5,-130,0.5,-70)
			f.BackgroundColor3 = Color3.fromRGB(30,30,30)
			f.BorderSizePixel = 0
			f.Parent = gui

			local u = InstanceNew("UICorner")
			u.CornerRadius = UDim.new(0.1,0)
			u.Parent = f

			local t = InstanceNew("TextLabel")
			t.Size = UDim2.new(1,-20,0,30)
			t.Position = UDim2.new(0,10,0,10)
			t.BackgroundTransparency = 1
			t.Text = "Arguments for: "..cmdName
			t.TextColor3 = Color3.fromRGB(255,255,255)
			t.Font = Enum.Font.GothamBold
			t.TextSize = 16
			t.TextWrapped = true
			t.Parent = f

			local tb = InstanceNew("TextBox")
			tb.Size = UDim2.new(1,-20,0,30)
			tb.Position = UDim2.new(0,10,0,50)
			tb.BackgroundColor3 = Color3.fromRGB(50,50,50)
			tb.TextColor3 = Color3.fromRGB(255,255,255)
			tb.PlaceholderText = "Type arguments here"
			tb.Text=""
			tb.TextSize = 16
			tb.Font = Enum.Font.Gotham
			tb.ClearTextOnFocus = false
			tb.Parent = f

			local s = InstanceNew("TextButton")
			s.Size = UDim2.new(0.5,-15,0,30)
			s.Position = UDim2.new(0,10,1,-40)
			s.BackgroundColor3 = Color3.fromRGB(0,170,255)
			s.Text = "Submit"
			s.TextColor3 = Color3.fromRGB(255,255,255)
			s.Font = Enum.Font.GothamBold
			s.TextSize = 14
			s.Parent = f

			local c = InstanceNew("TextButton")
			c.Size = UDim2.new(0.5,-15,0,30)
			c.Position = UDim2.new(0.5,5,1,-40)
			c.BackgroundColor3 = Color3.fromRGB(255,0,0)
			c.Text = "Cancel"
			c.TextColor3 = Color3.fromRGB(255,255,255)
			c.Font = Enum.Font.GothamBold
			c.TextSize = 14
			c.Parent = f

			MouseButtonFix(s, function()
				cb(tb.Text)
				ActivePrompts[cmdName] = nil
				gui:Destroy()
			end)
			MouseButtonFix(c, function()
				ActivePrompts[cmdName] = nil
				gui:Destroy()
			end)
			NAgui.draggerV2(f)
		end

		local total   = #NAUserButtons
		local totalW  = total * 110
		local screenWidth = math.max(screenGui.AbsoluteSize.X, 1)
		local startX  = 0.5 - (totalW/2)/screenWidth
		local spacing = 110
		local ON = Color3.fromRGB(0,170,0)

		local function pointInsideGui(gui, point)
			if not (gui and gui.AbsolutePosition) then return false end
			local pos = gui.AbsolutePosition
			local size = gui.AbsoluteSize
			return point.X >= pos.X and point.X <= pos.X + size.X and point.Y >= pos.Y and point.Y <= pos.Y + size.Y
		end

		local idx = 0
		for id, data in pairs(NAUserButtons) do
			if type(id) == "number" and type(data) == "table" then

				local btn = InstanceNew("TextButton")
				btn.Name                 = "NAUserButton_"..id
				btn.Text                 = data.Label or ("Button "..id)
				btn.Size                 = UDim2.new(0,60, 0,60)
				btn.AnchorPoint          = Vector2.new(0.5,1)
				btn.Position             = data.Pos and UDim2.new(data.Pos[1], data.Pos[2], data.Pos[3], data.Pos[4]) or UDim2.new(startX + (spacing*idx)/screenWidth, 0, 0.9, 0)
				btn.Parent               = screenGui
				btn.BackgroundColor3     = Color3.fromRGB(0,0,0)
				btn.TextColor3           = Color3.fromRGB(255,255,255)
				btn.TextScaled           = true
				btn.Font                 = Enum.Font.GothamBold
				btn.BorderSizePixel      = 0
				btn.ZIndex               = 9999
				btn.AutoButtonColor      = true
				btn.BackgroundTransparency = 0
				btn.TextTransparency       = 0

				local btnCorner = InstanceNew("UICorner")
				btnCorner.CornerRadius = UDim.new(0.25,0)
				btnCorner.Parent       = btn

				local baseBgColor = NAmanage.UserButtonColorFromTable(data.BgColor, Color3.fromRGB(0,0,0))
				btn.BackgroundColor3 = baseBgColor

				UserButtonGuiMap[id] = btn

				local dragStart = udim2ToArray(btn.Position)
				if not data.Locked then
					NAgui.draggerV2(btn)
				end

				btn.InputBegan:Connect(function(input)
					if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
						dragStart = udim2ToArray(btn.Position)
					end
				end)

				btn.InputEnded:Connect(function(input)
					if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
						local p = btn.Position
						local newPos = {p.X.Scale, p.X.Offset, p.Y.Scale, p.Y.Offset}
						local moved = positionsChanged(dragStart or newPos, newPos)
						data.Pos = newPos
						NAmanage.UserButtonsSave("update position")
						if moved and not data.Locked then
							NAmanage.UserButtons_CheckCombine(id, btn)
						end
					end
				end)

				local isGroup = data.Type == "group"
				local isHidden = (data.Hidden) and true or false
				local isInteractable = not (data.Interactable == false)

				if isGroup then
					local children = (type(data.Children) == "table") and data.Children or {}
					local label = tostring(data.Label or ("Group "..id))
					if #children > 0 then
						btn.Text = ("%s (%d)"):format(label, #children)
					else
						btn.Text = label
					end
					local childHeight = 32
					local mode = (data.GroupMode == "side") and "side" or "dropdown"

					local function openDropdown()
						if #children == 0 then
							DoNotif("Add buttons to this group before opening it", 2)
							return
						end

						closeAllDropdowns()
						local container = InstanceNew("ScrollingFrame")
						container.Name = ("NAUserButtonDropdown_%d"):format(id)
						container.BackgroundColor3 = Color3.fromRGB(18,18,22)
						container.BackgroundTransparency = 0.1
						container.BorderSizePixel = 0
						container.ZIndex = 10000
						container.ClipsDescendants = true
						container.ScrollingDirection = Enum.ScrollingDirection.Y
						container.VerticalScrollBarInset = Enum.ScrollBarInset.Always
						container.ScrollBarThickness = 5
						container.Parent = screenGui

						local layout = InstanceNew("UIListLayout")
						layout.SortOrder = Enum.SortOrder.LayoutOrder
						layout.Padding = UDim.new(0, 6)
						layout.FillDirection = Enum.FillDirection.Vertical
						layout.HorizontalAlignment = Enum.HorizontalAlignment.Center
						layout.VerticalAlignment = Enum.VerticalAlignment.Top
						layout.Parent = container

						local pad = InstanceNew("UIPadding", container)
						pad.PaddingTop = UDim.new(0, 6)
						pad.PaddingBottom = UDim.new(0, 6)
						pad.PaddingLeft = UDim.new(0, 6)
						pad.PaddingRight = UDim.new(0, 6)

						local dropCorner = InstanceNew("UICorner")
						dropCorner.CornerRadius = UDim.new(0, 8)
						dropCorner.Parent = container

						local dropStroke = InstanceNew("UIStroke")
						dropStroke.Thickness = 1
						dropStroke.Color = NAUISTROKER or Color3.fromRGB(148,93,255)
						dropStroke.Transparency = 0.15
						dropStroke.Parent = container
						NAgui.RegisterColoredStroke(dropStroke)

						local cam = workspace.CurrentCamera
						local vp = cam and cam.ViewportSize or Vector2.new(1280, 720)
						local margin = 8
						local dropWidth = math.max(btn.AbsoluteSize.X + 40, 140)
						local visibleCount = math.min(#children, 5)
						local dropHeight = (visibleCount * (childHeight + 6)) + 12
						local maxHeight = math.max(120, (vp.Y - margin * 2) * 0.8)
						local finalHeight = math.min(dropHeight, maxHeight)
						local posUDim, anchor = placeGroupContainer(mode, btn, Vector2.new(dropWidth, finalHeight))
						container.AnchorPoint = anchor
						container.Position = posUDim
						container.Size = UDim2.new(0, dropWidth, 0, finalHeight)

						local function refreshCanvas()
							local content = layout.AbsoluteContentSize
							local top = pad.PaddingTop.Offset
							local bottom = pad.PaddingBottom.Offset
							container.CanvasSize = UDim2.new(0, 0, 0, content.Y + top + bottom)
							container.ScrollBarThickness = (content.Y + top + bottom > finalHeight) and 5 or 0
						end
						layout:GetPropertyChangedSignal("AbsoluteContentSize"):Connect(refreshCanvas)
						refreshCanvas()

						Insert(UserButtonGuiList, container)

						for childIndex, child in ipairs(children) do
							local cBtn = InstanceNew("TextButton")
							cBtn.Name = ("NAUserButtonChild_%d_%d"):format(id, childIndex)
							cBtn.Size = UDim2.new(1, 0, 0, childHeight)
							local childBaseBg = NAmanage.UserButtonColorFromTable(child.BgColor, Color3.fromRGB(0,0,0))
							cBtn.BackgroundColor3 = childBaseBg
							cBtn.TextColor3 = NAmanage.UserButtonColorFromTable(child.TextColor, Color3.fromRGB(255,255,255))
							cBtn.TextScaled = false
							cBtn.Font = Enum.Font.GothamBold
							cBtn.TextSize = 14
							cBtn.Text = tostring(child.Label or ("Action "..childIndex))
							cBtn.ZIndex = container.ZIndex + 1
							cBtn.AutoButtonColor = true
							cBtn.BorderSizePixel = 0
							cBtn.Parent = container

							local cbCorner = InstanceNew("UICorner")
							cbCorner.CornerRadius = UDim.new(0.25, 0)
							cbCorner.Parent = cBtn

							local childKey = originalIO.userButtonChildKey(id, childIndex)
							SavedArgs[childKey] = child.Args or SavedArgs[childKey] or {}
							local childToggled = childKey and UserButtonToggleState[childKey] == true or false
							local childSaveEnabled = child.RunMode == "S"
							local childCmd1 = child.Cmd1
							local childCd1 = childCmd1 and (cmds.Commands[childCmd1:lower()] or cmds.Aliases[childCmd1:lower()])
							local childNeedsArgs = childCd1 and childCd1[3]

							if not child.Cmd2 and childKey then
								UserButtonToggleState[childKey] = nil
								childToggled = false
							elseif child.Cmd2 then
								cBtn.BackgroundColor3 = childToggled and ON or childBaseBg
							end

							if childNeedsArgs then
								local childToggleSize = math.max(14, math.min(tSize, childHeight - 6))
								local saveToggle = InstanceNew("TextButton")
								saveToggle.Size                   = UDim2.new(0, childToggleSize, 0, childToggleSize)
								saveToggle.AnchorPoint            = Vector2.new(1, 0)
								saveToggle.Position               = UDim2.new(1, -4, 0, 4)
								saveToggle.BackgroundColor3       = Color3.fromRGB(50,50,50)
								saveToggle.TextColor3             = Color3.fromRGB(255,255,255)
								saveToggle.TextScaled             = true
								saveToggle.Font                   = Enum.Font.Gotham
								saveToggle.Text                   = childSaveEnabled and "S" or "N"
								saveToggle.ZIndex                 = cBtn.ZIndex + 1
								saveToggle.BackgroundTransparency = 0
								saveToggle.TextTransparency       = 0
								saveToggle.Parent                 = cBtn

								local stCorner = InstanceNew("UICorner")
								stCorner.CornerRadius = UDim.new(0.5,0)
								stCorner.Parent       = saveToggle

								MouseButtonFix(saveToggle, function()
									childSaveEnabled = not childSaveEnabled
									saveToggle.Text = childSaveEnabled and "S" or "N"
									child.RunMode = childSaveEnabled and "S" or "N"
									NAmanage.UserButtonsSave("group child save toggle")
								end)
							end

							local function runChild(args)
								local toRun = (not childToggled or not child.Cmd2) and child.Cmd1 or child.Cmd2
								if not toRun then return end
								local arr = {toRun}
								if args then for _, v in ipairs(args) do Insert(arr, v) end end
								cmd.run(arr)
								if child.Cmd2 then
									childToggled = not childToggled
									if childKey then
										UserButtonToggleState[childKey] = childToggled or nil
									end
									cBtn.BackgroundColor3 = childToggled and ON or childBaseBg
								end
							end

							MouseButtonFix(cBtn, function()
								local now = (not childToggled or not child.Cmd2) and child.Cmd1 or child.Cmd2
								if not now then
									return
								end
								local nd = cmds.Commands[now:lower()] or cmds.Aliases[now:lower()]
								local needsArgs = nd and nd[3]
								if needsArgs then
									if childSaveEnabled then
										if child.Args and #child.Args > 0 then
											runChild(child.Args)
										else
											runChild(nil)
										end
									else
										if ActivePrompts[now] then return end
										ActivePrompts[now] = true
										ButtonInputPrompt(now, function(input)
											ActivePrompts[now] = nil
											local parsed = ParseArguments(input)
											if parsed then
												SavedArgs[childKey] = parsed
												child.Args = parsed
												NAmanage.UserButtonsSave("group child args")
												runChild(parsed)
											else
												runChild(nil)
											end
										end)
									end
								else
									runChild(nil)
								end
							end)
						end

						local conn = UIS.InputBegan:Connect(function(input, gpe)
							if gpe then return end
							if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
								local posNow = UIS:GetMouseLocation()
								if not (pointInsideGui(container, posNow) or pointInsideGui(btn, posNow)) then
									clearDropdownEntry(id)
								end
							end
						end)

						activeDropdowns[id] = {
							container = container,
							conn = conn,
							btn = btn,
							mode = mode,
							posConn = btn:GetPropertyChangedSignal("AbsolutePosition"):Connect(function()
								updateDropdownPosition(id)
							end),
							sizeConn = btn:GetPropertyChangedSignal("AbsoluteSize"):Connect(function()
								updateDropdownPosition(id)
							end),
							close = function()
								if conn then conn:Disconnect() end
								if activeDropdowns[id] and activeDropdowns[id].posConn then activeDropdowns[id].posConn:Disconnect() end
								if activeDropdowns[id] and activeDropdowns[id].sizeConn then activeDropdowns[id].sizeConn:Disconnect() end
								if container then container:Destroy() end
								activeDropdowns[id] = nil
							end
						}
						UserButtonDropdowns[id] = { container = container, conn = conn }
						updateDropdownPosition(id)
					end

					MouseButtonFix(btn, function()
						if activeDropdowns[id] then
							clearDropdownEntry(id)
						else
							openDropdown()
						end
					end)
				else
					local toggled     = UserButtonToggleState[id] == true
					local saveEnabled = data.RunMode == "S"
					SavedArgs[id]     = data.Args or {}

					local cmd1      = data.Cmd1
					local cd1       = cmd1 and (cmds.Commands[cmd1:lower()] or cmds.Aliases[cmd1:lower()])
					local needsArgs = cd1 and cd1[3]

					if not data.Cmd2 then
						UserButtonToggleState[id] = nil
						toggled = false
						btn.BackgroundColor3 = baseBgColor
					else
						btn.BackgroundColor3 = toggled and ON or baseBgColor
					end

					if needsArgs then
						local saveToggle = InstanceNew("TextButton")
						saveToggle.Size                   = UDim2.new(0,tSize,0,tSize)
						saveToggle.AnchorPoint            = Vector2.new(1,1)
						saveToggle.Position               = UDim2.new(1,0,0,0)
						saveToggle.BackgroundColor3       = Color3.fromRGB(50,50,50)
						saveToggle.TextColor3             = Color3.fromRGB(255,255,255)
						saveToggle.TextScaled             = true
						saveToggle.Font                   = Enum.Font.Gotham
						saveToggle.Text                   = saveEnabled and "S" or "N"
						saveToggle.ZIndex                 = 10000
						saveToggle.BackgroundTransparency = 0
						saveToggle.TextTransparency       = 0
						saveToggle.Parent                 = btn

						local stCorner = InstanceNew("UICorner")
						stCorner.CornerRadius = UDim.new(0.5,0)
						stCorner.Parent       = saveToggle

						MouseButtonFix(saveToggle, function()
							saveEnabled = not saveEnabled
							saveToggle.Text = saveEnabled and "S" or "N"
							data.RunMode = saveEnabled and "S" or "N"
							NAmanage.UserButtonsSave("button save toggle")
						end)
					end

					local function runCmd(args)
						local toRun = (not toggled or not data.Cmd2) and data.Cmd1 or data.Cmd2
						if not toRun then return end
						local arr   = {toRun}
						if args then for _,v in ipairs(args) do Insert(arr, v) end end
						cmd.run(arr)
						if data.Cmd2 then
							toggled = not toggled
							UserButtonToggleState[id] = toggled or nil
							btn.BackgroundColor3 = toggled and ON or baseBgColor
						end
					end

					MouseButtonFix(btn, function()
						local now     = (not toggled or not data.Cmd2) and data.Cmd1 or data.Cmd2
						if not now then
							return
						end
						local nd      = cmds.Commands[now:lower()] or cmds.Aliases[now:lower()]
						local na      = nd and nd[3]
						if na then
							if saveEnabled and data.Args and #data.Args>0 then
								runCmd(data.Args)
							else
								if ActivePrompts[now] then return end
								ActivePrompts[now] = true
								ButtonInputPrompt(now, function(input)
									ActivePrompts[now] = nil
									local parsed = ParseArguments(input)
									if parsed then
										SavedArgs[id] = parsed
										data.Args     = parsed
										NAmanage.UserButtonsSave("button args")
										runCmd(parsed)
									else
										runCmd(nil)
									end
								end)
							end
						else
							runCmd(nil)
						end
					end)
				end

				if not isInteractable then
					btn.Visible = false
				elseif isHidden then
					btn.Visible = true
					btn.BackgroundTransparency = 1
					btn.TextTransparency = 1
					if btn:FindFirstChildOfClass("TextButton") then
						for _, child in ipairs(btn:GetChildren()) do
							if child:IsA("TextButton") then
								child.BackgroundTransparency = 1
								child.TextTransparency = 1
							end
						end
					end
				else
					btn.Visible = true
				end

				if IsOnPC then
				end

				Insert(UserButtonGuiList, btn)
				idx = idx + 1
			end
		end

	end)

	NAmanage._renderUserButtonsRunning = nil

	if not success then
		error(err)
	end
	return true
end

NAmanage.UserButtonColorFromTable = function(t, defaultColor)
	if typeof(t) == "Color3" then
		return t
	end
	if type(t) ~= "table" then
		return defaultColor
	end
	local r = t.R or t[1]
	local g = t.G or t[2]
	local b = t.B or t[3]
	if r == nil or g == nil or b == nil then
		return defaultColor
	end
	return Color3.fromRGB(tonumber(r) or 0, tonumber(g) or 0, tonumber(b) or 0)
end

NAmanage.UserButtonColorToTable = function(c)
	return {
		math.floor(c.R * 255 + 0.5),
		math.floor(c.G * 255 + 0.5),
		math.floor(c.B * 255 + 0.5),
	}
end

NAmanage.ApplyUserButtonStyles = function()
	local ok, err = pcall(function()
		for _, btn in ipairs(UserButtonGuiList) do
			if typeof(btn) == "Instance" and btn:IsA("TextButton") then
				local idStr = btn.Name:match("^NAUserButton_(%d+)$")
				local id = idStr and tonumber(idStr) or nil
				if id then
					local data = NAUserButtons[id]
					if type(data) == "table" then
						local width = tonumber(data.Width)
						local height = tonumber(data.Height)
						if width or height then
							local currentSize = btn.Size
							local w = width or currentSize.X.Offset
							local h = height or currentSize.Y.Offset
							btn.Size = UDim2.new(0, w, 0, h)
						end

						if data.BgColor then
							local bg = NAmanage.UserButtonColorFromTable(data.BgColor, btn.BackgroundColor3)
							btn.BackgroundColor3 = bg
						end

						if data.TextColor then
							local tc = NAmanage.UserButtonColorFromTable(data.TextColor, btn.TextColor3)
							btn.TextColor3 = tc
						end

						if data.CornerRadius ~= nil then
							local radius = tonumber(data.CornerRadius)
							if radius and radius >= 0 and radius <= 1 then
								local corner = btn:FindFirstChildOfClass("UICorner")
								if corner then
									corner.CornerRadius = UDim.new(radius, 0)
								end
							end
						end
					end
				end
			end
		end
	end)
	if not ok then
		warn("[UserButtons] style apply failed: "..tostring(err))
	end
end

do
	local _renderUserButtons = NAmanage.RenderUserButtons
	NAmanage.RenderUserButtons = function(...)
		local ok, result = pcall(_renderUserButtons, ...)
		if ok then
			if type(NAmanage.ApplyUserButtonStyles) == "function" then
				pcall(NAmanage.ApplyUserButtonStyles)
			end
			return result
		else
			error(result)
		end
	end
end

local lp=Players.LocalPlayer

--[[ LIB FUNCTIONS ]]--
chatmsgshooks={}
Playerchats={}
local oldChat = false--TextChatService.ChatVersion == Enum.ChatVersion.LegacyChatService and ReplicatedStorage:FindFirstChild("DefaultChatSystemChatEvents") and  ReplicatedStorage.DefaultChatSystemChatEvents:FindFirstChild("SayMessageRequest")

if oldChat then
	NAlib.LocalPlayerChat=function(...)
		local args={...}
		if args[2] and args[2]~="All" then
			ReplicatedStorage.DefaultChatSystemChatEvents.SayMessageRequest:FireServer("/w "..args[2].." "..args[1] or "","All")
		else
			ReplicatedStorage.DefaultChatSystemChatEvents.SayMessageRequest:FireServer(args[1] or "","All")
		end
	end
else
	local RBXGeneral = nil
	NACaller(function()
		if TextChatService.CreateDefaultTextChannels then
			for i,v in pairs(TextChatService:GetDescendants()) do
				if v:IsA("TextChannel") and v.Name=="RBXGeneral" then
					if v:FindFirstChild(Players.LocalPlayer.Name) and v[Players.LocalPlayer.Name]:IsA("TextSource") then
						RBXGeneral = v
						break
					end
				end
			end
		end

		if not RBXGeneral then
			for i,v in pairs(TextChatService:GetDescendants()) do
				if v:IsA("TextChannel") then
					for index,player in pairs(Players:GetPlayers()) do
						if v:FindFirstChild(player.Name) and v[player.Name]:IsA("TextSource") and v[player.Name].CanSend then
							RBXGeneral = v
						else
							RBXGeneral = nil
							break
						end
					end
					if RBXGeneral then
						break
					end
				end
			end

			if not RBXGeneral then
				for i,v in pairs(TextChatService:GetDescendants()) do
					if v:IsA("TextChannel") then
						if v:FindFirstChild(Players.LocalPlayer.Name) and v[Players.LocalPlayer.Name]:IsA("TextSource") and v[Players.LocalPlayer.Name].CanSend then
							RBXGeneral = v
							break
						end
					end
				end
			end
			-- i have tried enough
			if not RBXGeneral then
				NAlib.LocalPlayerChat=function(...)
					NACaller(function()
						error("unable to get the chat system for the game")
					end)
				end
				return
			end
		end

		NAlib.LocalPlayerChat=function(...)
			local args={...}
			local sendto=RBXGeneral
			if args[2]~=nil and  args[2]~="All"  then
				if not Playerchats[args[2]] then
					for i,v in pairs(TextChatService:GetDescendants()) do
						if v:IsA("TextChannel") and Find(v.Name,"RBXWhisper:") then
							if v:FindFirstChild(args[2]) and v:FindFirstChild(Players.LocalPlayer.Name) then
								if v[Players.LocalPlayer.Name].CanSend==false then
									continue
								end
								sendto=v
								Playerchats[args[2]]=v
								break
							end
						end
					end
				else
					sendto=Playerchats[args[2]]
				end
				if sendto==RBXGeneral then
					chatmsgshooks[args[1]]={args[1],args}
					SpawnCall(function()
						RBXGeneral:SendAsync("/w @"..args[2])
					end)
					return "Hooking"
				end
			end
			sendto:SendAsync(args[1] or "")

		end
	end)

	if TextChatService:FindFirstChild("TextChannels") then
		TextChatService.TextChannels.ChildAdded:Connect(function(v)
			if  v:IsA("TextChannel") and Find(v.Name,"RBXWhisper:") then
				Wait(1)
				for id,va in pairs(chatmsgshooks) do
					if v:FindFirstChild(va[1]) and v:FindFirstChild(Players.LocalPlayer.Name) then
						if v[Players.LocalPlayer.Name].CanSend==false then
							continue
						end
						Playerchats[va[1]]=v
						chatmsgshooks[id]=nil
						NAlib.LocalPlayerChat(va[2])
					end
				end
			end
		end)
	end
end

NAlib.lpchat=NAlib.LocalPlayerChat

NAlib.find=function(t,v)	--mmmmmm
	for i,e in pairs(t) do
		if i==v or e==v then
			return i
		end
	end
	return nil
end

NAlib.parseText = function(text, watch, rPlr)
	local function stripRichText(str)
		if type(str) ~= "string" then
			return ""
		end

		local cleaned = str
		repeat
			local before = cleaned
			cleaned = cleaned:gsub("^%s*<(%w+)[^>]->(.-)</%1>%s*$", "%2")
		until cleaned == before

		cleaned = cleaned:gsub("^%s+", ""):gsub("%s+$", "")
		cleaned = cleaned
			:gsub("&lt;", "<")
			:gsub("&gt;", ">")
			:gsub("&amp;", "&")
			:gsub("&quot;", "\"")
			:gsub("&#x27;", "'")
			:gsub("&#x60;", "`")
			:gsub("&#59;", ";")
			:gsub("&#x3b;", ";")

		return cleaned
	end

	local function FIIIX(str)
		local chatPrefix = str:match("^/(%a+)%s")
		if chatPrefix then
			str = str:gsub("^/%a+%s*", "")
		end
		return str
	end

	if not text then return nil end
	text = stripRichText(text)
	if text == "" then return nil end

	local prefix
	if rPlr then
		if isRelAdmin(rPlr) and isRelAdmin(Players.LocalPlayer) then
			return nil
		elseif not isRelAdmin(rPlr) then
			prefix = ";"
		else
			prefix = watch
		end
		watch = prefix
	else
		prefix = watch
	end

	text = FIIIX(text)
	if text == "" then return nil end

	if text:sub(1, #prefix) ~= prefix then
		return nil
	end

	text = text:sub(#prefix + 1)

	local commands = {}
	local position = 1
	local textLength = #text

	while position <= textLength do
		local nextSlash = text:find("\\", position, true)
		local segment = nextSlash and text:sub(position, nextSlash - 1) or text:sub(position)
		local trimmed = segment:gsub("^%s+", ""):gsub("%s+$", "")
		if #trimmed > 0 then
			local parsed = {}
			for arg in trimmed:gmatch("[^ ]+") do
				Insert(parsed, arg)
			end
			if #parsed > 0 then
				local cmdName = parsed[1]:lower()
				if LoadstringCommandAliases[cmdName] then
					local commandStart = (segment:find(parsed[1], 1, true) or 1) + #parsed[1]
					local afterCommand = segment:sub(commandStart + 1)
					local remainder = afterCommand:gsub("^%s+", "")
					if nextSlash then
						remainder = remainder.."\\"..text:sub(nextSlash + 1)
					end
					Insert(commands, {parsed[1], remainder})
					break
				end
				Insert(commands, parsed)
			end
		end
		if not nextSlash then
			break
		end
		position = nextSlash + 1
	end

	return commands
end

NAlib.parseCommand = function(text, rPlr)
	wrap(function()
		local prefix = rPlr and (isRelAdmin(rPlr) and not isRelAdmin(Players.LocalPlayer) and ";" or nil) or opt.prefix
		if not prefix then return end
		local commands = NAlib.parseText(text, prefix, rPlr)
		if not commands then return end
		for _, parsed in pairs(commands) do
			local args = {}
			for _, arg in pairs(parsed) do
				Insert(args, arg)
			end
			cmd.run(args)
		end
	end)
end

--prepare for annoying and unnecessary tool grip math
local rad=math.rad
local clamp=math.clamp
local tan=math.tan

NAmanage.CmdBar2ApplySize = function(opts)
	opts = opts or {}
	local width = NAmanage.CmdBar2ClampValue(opts.width or NAStuff.CmdBar2Width, NAStuff.CmdBar2.minWidth, NAStuff.CmdBar2.maxWidth, NAStuff.CmdBar2.defaultWidth)
	local height = NAmanage.CmdBar2ClampValue(opts.height or NAStuff.CmdBar2Height, NAStuff.CmdBar2.minHeight, NAStuff.CmdBar2.maxHeight, NAStuff.CmdBar2.defaultHeight)
	local previousBase = NAmanage._cb2BaseSize
	local previousWidth = (typeof(previousBase) == "Vector2" and previousBase.X) or nil
	local prevDefaultOffset = previousWidth and -math.floor(previousWidth / 2 + 0.5) or nil
	local newDefaultOffset = -math.floor(width / 2 + 0.5)

	NAStuff.CmdBar2Width = width
	NAStuff.CmdBar2Height = height

	NAmanage._cb2BaseSize = Vector2.new(width, height)
	NAmanage._cb2sz = UDim2.new(0, width, 0, height)

	if prevDefaultOffset and NAmanage._cb2p and NAmanage._cb2p.X.Scale == 0.5 and math.floor(NAmanage._cb2p.X.Offset + 0.5) == prevDefaultOffset then
		local pos = NAmanage._cb2p
		NAmanage._cb2p = UDim2.new(pos.X.Scale, newDefaultOffset, pos.Y.Scale, pos.Y.Offset)
	end

	local frame = NAmanage._cb2f
	if frame then
		if prevDefaultOffset and frame.Position.X.Scale == 0.5 and math.floor(frame.Position.X.Offset + 0.5) == prevDefaultOffset then
			frame.Position = UDim2.new(frame.Position.X.Scale, newDefaultOffset, frame.Position.Y.Scale, frame.Position.Y.Offset)
		end
		if NAmanage._cb2Min == true then
			frame.Size = UDim2.new(0, width, 0, 28)
		else
			frame.Size = NAmanage._cb2sz
		end
	end

	local body = NAmanage._cb2Body
	if body then
		local bodyHeight = NAmanage.CmdBar2ComputeBodyHeight(height)
		body.Size = UDim2.new(body.Size.X.Scale, body.Size.X.Offset, 0, bodyHeight)
	end

	if opts.syncUI ~= false and NAgui and NAgui.setSliderValue then
		NAgui.setSliderValue("cmdbar2 Width", width, { fire = false })
		NAgui.setSliderValue("cmdbar2 Height", height, { fire = false })
	end

	if opts.persist ~= false then
		pcall(NAmanage.NASettingsSet, "cmdbar2Width", width)
		pcall(NAmanage.NASettingsSet, "cmdbar2Height", height)
	end

	return width, height
end

--[[ COMMANDS ]]--

cmd.add({"cmdbar2","cbar2"},{"cmdbar2 (cbar2)","Opens a HD-Admin style cmdbar (black & white)"},function()
	local gui = NAmanage._cb2
	local fr = NAmanage._cb2f
	local bx = NAmanage._cb2bx
	local hist = NAmanage._cb2h or {}
	NAmanage._cb2h = hist
	local initialWidth = NAmanage.CmdBar2ClampValue(NAStuff.CmdBar2Width, NAStuff.CmdBar2.minWidth, NAStuff.CmdBar2.maxWidth, NAStuff.CmdBar2.defaultWidth)
	local initialHeight = NAmanage.CmdBar2ClampValue(NAStuff.CmdBar2Height, NAStuff.CmdBar2.minHeight, NAStuff.CmdBar2.maxHeight, NAStuff.CmdBar2.defaultHeight)

	local function tw(o,t,p)
		local ti = TweenInfo.new(t or 0.16, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
		local tr = TweenService:Create(o, ti, p)
		tr:Play()
		return tr
	end

	local function trim(s)
		s = tostring(s or "")
		s = GSub(s, "^%s+", "")
		s = GSub(s, "%s+$", "")
		return s
	end

	local function parse(s)
		s = trim(s)
		s = GSub(s, "^[;:/!]+%s*", "")
		if s == "" then return nil end

		if type(ParseArguments) == "function" then
			local ok, a = pcall(ParseArguments, s)
			if ok and type(a) == "table" and #a > 0 then
				return a
			end
		end

		local a, q, cur = {}, false, ""
		local i = 1
		while i <= #s do
			local ch = Sub(s, i, i)
			if ch == '"' then
				q = not q
			elseif not q and (ch == " " or ch == "\t" or ch == "\n" or ch == "\r") then
				if cur ~= "" then
					Insert(a, cur)
					cur = ""
				end
			else
				cur ..= ch
			end
			i += 1
		end
		if cur ~= "" then Insert(a, cur) end
		if #a == 0 then return nil end
		return a
	end

	local function run()
		if not bx then return end
		local s = trim(bx.Text)
		if s == "" then return end
		local a = parse(s)
		if not a then return end
		pcall(function() cmd.run(a) end)
	end

	local function getDefaultCmdBar2Position()
		local width = NAmanage.CmdBar2ClampValue(NAStuff.CmdBar2Width, NAStuff.CmdBar2.minWidth, NAStuff.CmdBar2.maxWidth, NAStuff.CmdBar2.defaultWidth)
		return UDim2.new(0.5, -math.floor(width / 2), 0, 70)
	end

	local function show(v)
		if not gui or not fr then return end
		gui.Enabled = v and true or false
		if v then
			fr.Visible = true
			fr.BackgroundTransparency = 1
			local p = NAmanage._cb2p or getDefaultCmdBar2Position()
			fr.Position = p
			tw(fr, 0.14, {BackgroundTransparency = 0})
		else
			NAmanage._cb2p = fr.Position
			local tr = tw(fr, 0.12, {BackgroundTransparency = 1})
			tr.Completed:Connect(function()
				if fr then fr.Visible = false end
			end)
		end
	end

	if gui and gui.Parent and fr and bx then
		show(not gui.Enabled)
		return
	end

	local o1 = Color3.fromRGB(0, 0, 0)
	local o2 = Color3.fromRGB(18, 18, 18)
	local o3 = Color3.fromRGB(28, 28, 28)
	local tx = Color3.fromRGB(245, 245, 245)
	local tx2 = Color3.fromRGB(210, 210, 210)
	local st1 = Color3.fromRGB(255, 255, 255)
	local st2 = Color3.fromRGB(60, 60, 60)

	gui = InstanceNew("ScreenGui")
	NaProtectUI(gui)

	fr = InstanceNew("Frame", gui)
	fr.Position = NAmanage._cb2p or getDefaultCmdBar2Position()
	fr.Size = UDim2.new(0, initialWidth, 0, initialHeight)
	fr.BackgroundColor3 = o2
	fr.BorderSizePixel = 0
	fr.Visible = true
	fr.ClipsDescendants = false

	local cr = InstanceNew("UICorner", fr)
	cr.CornerRadius = UDim.new(0, 6)

	local st = InstanceNew("UIStroke", fr)
	st.Thickness = 1
	st.Color = st2
	st.Transparency = 0.2

	local top = InstanceNew("Frame", fr)
	top.Position = UDim2.new(0, 0, 0, 0)
	top.Size = UDim2.new(1, 0, 0, 26)
	top.BackgroundColor3 = o1
	top.BorderSizePixel = 0

	local tcr = InstanceNew("UICorner", top)
	tcr.CornerRadius = UDim.new(0, 6)

	local tfix = InstanceNew("Frame", top)
	tfix.Position = UDim2.new(0, 0, 1, -6)
	tfix.Size = UDim2.new(1, 0, 0, 6)
	tfix.BackgroundColor3 = o1
	tfix.BorderSizePixel = 0

	local ttl = InstanceNew("TextLabel", top)
	ttl.BackgroundTransparency = 1
	ttl.Position = UDim2.new(0, 10, 0, 0)
	ttl.Size = UDim2.new(1, -120, 1, 0)
	ttl.Font = Enum.Font.SourceSansBold
	ttl.TextSize = 16
	ttl.TextXAlignment = Enum.TextXAlignment.Left
	ttl.TextColor3 = tx
	ttl.Text = "CMDBAR2"

	local mini = InstanceNew("TextButton", top)
	mini.BackgroundTransparency = 1
	mini.Position = UDim2.new(1, -68, 0, 0)
	mini.Size = UDim2.new(0, 28, 1, 0)
	mini.Font = Enum.Font.SourceSansBold
	mini.TextSize = 18
	mini.TextColor3 = tx2
	mini.Text = "-"
	mini.AutoButtonColor = false

	local cls = InstanceNew("TextButton", top)
	cls.BackgroundTransparency = 1
	cls.Position = UDim2.new(1, -36, 0, 0)
	cls.Size = UDim2.new(0, 36, 1, 0)
	cls.Font = Enum.Font.SourceSansBold
	cls.TextSize = 18
	cls.TextColor3 = tx2
	cls.Text = "X"
	cls.AutoButtonColor = false

	local body = InstanceNew("Frame", fr)
	body.Position = UDim2.new(0, 8, 0, 34)
	body.Size = UDim2.new(1, -16, 0, NAmanage.CmdBar2ComputeBodyHeight(initialHeight))
	body.BackgroundTransparency = 1
	body.BorderSizePixel = 0

	local ibg = InstanceNew("Frame", body)
	ibg.Position = UDim2.new(0, 0, 0, 0)
	ibg.Size = UDim2.new(1, -98, 1, 0)
	ibg.BackgroundColor3 = o3
	ibg.BorderSizePixel = 0

	local icr = InstanceNew("UICorner", ibg)
	icr.CornerRadius = UDim.new(0, 6)

	local ist = InstanceNew("UIStroke", ibg)
	ist.Thickness = 1
	ist.Color = st1
	ist.Transparency = 0.85

	bx = InstanceNew("TextBox", ibg)
	bx.BackgroundTransparency = 1
	bx.Position = UDim2.new(0, 10, 0, 0)
	bx.Size = UDim2.new(1, -20, 1, 0)
	bx.ClearTextOnFocus = false
	bx.Font = Enum.Font.Code
	bx.TextSize = 15
	bx.TextColor3 = tx
	bx.TextXAlignment = Enum.TextXAlignment.Left
	bx.PlaceholderText = ":cmd args"
	bx.PlaceholderColor3 = Color3.fromRGB(140, 140, 140)
	bx.Text = ""

	local exe = InstanceNew("TextButton", body)
	exe.Position = UDim2.new(1, -90, 0, 0)
	exe.Size = UDim2.new(0, 90, 1, 0)
	exe.BackgroundColor3 = Color3.fromRGB(235, 235, 235)
	exe.BorderSizePixel = 0
	exe.Font = Enum.Font.SourceSansBold
	exe.TextSize = 16
	exe.TextColor3 = Color3.fromRGB(0, 0, 0)
	exe.Text = "EXECUTE"
	exe.AutoButtonColor = false

	local ecr = InstanceNew("UICorner", exe)
	ecr.CornerRadius = UDim.new(0, 6)

	local est = InstanceNew("UIStroke", exe)
	est.Thickness = 1
	est.Color = st1
	est.Transparency = 0.7

	NAgui.draggerV2(fr, top)

	local min = false
	NAmanage._cb2Min = false
	NAmanage._cb2 = gui
	NAmanage._cb2f = fr
	NAmanage._cb2bx = bx
	NAmanage._cb2Body = body
	NAmanage.CmdBar2ApplySize({ persist = false })

	local function setMin(v)
		min = v and true or false
		NAmanage._cb2Min = min
		if min then
			body.Visible = false
			tw(fr, 0.14, {Size = UDim2.new(NAmanage._cb2sz.X.Scale, NAmanage._cb2sz.X.Offset, 0, 28)})
		else
			body.Visible = true
			tw(fr, 0.14, {Size = NAmanage._cb2sz})
		end
	end

	MouseButtonFix(exe, function()
		run()
	end)

	MouseButtonFix(cls, function()
		show(false)
	end)

	MouseButtonFix(mini, function()
		setMin(not min)
	end)

	exe.MouseEnter:Connect(function()
		tw(exe, 0.08, {BackgroundColor3 = Color3.fromRGB(255, 255, 255)})
	end)
	exe.MouseLeave:Connect(function()
		tw(exe, 0.10, {BackgroundColor3 = Color3.fromRGB(235, 235, 235)})
	end)

	cls.MouseEnter:Connect(function()
		tw(cls, 0.08, {TextColor3 = Color3.fromRGB(255, 255, 255)})
	end)
	cls.MouseLeave:Connect(function()
		tw(cls, 0.10, {TextColor3 = tx2})
	end)

	mini.MouseEnter:Connect(function()
		tw(mini, 0.08, {TextColor3 = Color3.fromRGB(255, 255, 255)})
	end)
	mini.MouseLeave:Connect(function()
		tw(mini, 0.10, {TextColor3 = tx2})
	end)

	show(true)
end)

cmd.add({"url"}, {"url <link>", "Run the script using URL"}, function(...)
	local args = {...}
	local link = Concat(args, " ")

	if not link or link == "" then
		return DoNotif("no link provided", 2)
	end

	local success, result = NACaller(function()
		return game:HttpGet(link)
	end)

	if not success then return end

	local func = loadstring(result)
	if not func then return end

	Spawn(func)
end, true)

cmd.add({"loadstring", "ls", "lstring", "loads", "execute"}, {"loadstring <code> (ls, lstring, loads, execute)", "Run code using loadstring"}, function(...)
	local args = {...}
	local code = Concat(args, " ")

	if not code or code == "" then
		return DoNotif("no code provided", 2)
	end

	local func = loadstring(code)
	if not func then return end

	Spawn(func)
end, true)

NA_SHADER_EFFECT_NAMES = {
	"NAShaderBloom",
	"NAShaderTropic",
	"NAShaderSky",
	"NAShaderBlur",
	"NAShaderEfecto",
	"NAShaderInari",
	"NAShaderNormal",
	"NAShaderSunRays",
	"NAShaderSunset",
	"NAShaderTakayama",
}

NAmanage.NAremoveShaderEffects=function(lighting)
	for _, name in ipairs(NA_SHADER_EFFECT_NAMES) do
		local inst = lighting:FindFirstChild(name)
		if inst then
			inst:Destroy()
		end
	end
end

cmd.add({"shaders", "shader", "rtx", "hd"}, {"shaders (shader, rtx, hd)", "Enable a shader preset for Lighting"}, function()
	local lighting = Lighting or SafeGetService("Lighting")
	if not lighting then
		DoNotif("Lighting service unavailable", 3)
		return
	end

	local st = NAmanage._ensureL()
	st.shader = st.shader or {enabled=false, baseline={}, target={}}
	local shader = st.shader

	st.cancelFor("shader")

	local shaderTarget = {
		Brightness = 2.14;
		ColorShift_Bottom = Color3.fromRGB(11, 0, 20);
		ColorShift_Top = Color3.fromRGB(240, 127, 14);
		OutdoorAmbient = Color3.fromRGB(34, 0, 49);
		ClockTime = 6.7;
		FogColor = Color3.fromRGB(94, 76, 106);
		FogEnd = 1000;
		FogStart = 0;
		ExposureCompensation = 0.24;
		ShadowSoftness = 0;
		Ambient = Color3.fromRGB(59, 33, 27);
	}

	shader.target = shader.target or {}
	for prop, val in pairs(shaderTarget) do
		shader.target[prop] = val
	end
	shader.baseline = shader.baseline or {}

	local shaderEffects = {
		{className="BloomEffect", name="NAShaderBloom", props={Intensity=0.1, Threshold=0, Size=100}},
		{className="Sky", name="NAShaderTropic", props={
			SkyboxUp="http://www.roblox.com/asset/?id=169210149",
			SkyboxLf="http://www.roblox.com/asset/?id=169210133",
			SkyboxBk="http://www.roblox.com/asset/?id=169210090",
			SkyboxFt="http://www.roblox.com/asset/?id=169210121",
			SkyboxDn="http://www.roblox.com/asset/?id=169210108",
			SkyboxRt="http://www.roblox.com/asset/?id=169210143",
			StarCount=100,
		}},
		{className="Sky", name="NAShaderSky", props={
			SkyboxUp="http://www.roblox.com/asset/?id=196263782",
			SkyboxLf="http://www.roblox.com/asset/?id=196263721",
			SkyboxBk="http://www.roblox.com/asset/?id=196263721",
			SkyboxFt="http://www.roblox.com/asset/?id=196263721",
			SkyboxDn="http://www.roblox.com/asset/?id=196263643",
			SkyboxRt="http://www.roblox.com/asset/?id=196263721",
			CelestialBodiesShown=false,
		}},
		{className="BlurEffect", name="NAShaderBlur", props={Size=2}},
		{className="BlurEffect", name="NAShaderEfecto", props={Size=2, Enabled=false}},
		{className="ColorCorrectionEffect", name="NAShaderInari", props={Saturation=0.05, TintColor=Color3.fromRGB(255, 224, 219)}},
		{className="ColorCorrectionEffect", name="NAShaderNormal", props={Enabled=false, Saturation=-0.2, TintColor=Color3.fromRGB(255, 232, 215)}},
		{className="SunRaysEffect", name="NAShaderSunRays", props={Intensity=0.05}},
		{className="Sky", name="NAShaderSunset", props={
			SkyboxUp="rbxassetid://323493360",
			SkyboxLf="rbxassetid://323494252",
			SkyboxBk="rbxassetid://323494035",
			SkyboxFt="rbxassetid://323494130",
			SkyboxDn="rbxassetid://323494368",
			SkyboxRt="rbxassetid://323494067",
			SunAngularSize=14,
		}},
		{className="ColorCorrectionEffect", name="NAShaderTakayama", props={Enabled=false, Saturation=-0.3, Contrast=0.1, TintColor=Color3.fromRGB(235, 214, 204)}},
	}

	local function ensureEffects()
		for _, def in ipairs(shaderEffects) do
			local inst = lighting:FindFirstChild(def.name)
			if not inst or not inst:IsA(def.className) then
				if inst then pcall(function() inst:Destroy() end) end
				inst = InstanceNew(def.className)
				inst.Name = def.name
				inst.Parent = lighting
			elseif inst.Parent ~= lighting then
				pcall(function() inst.Parent = lighting end)
			end
			for prop, val in pairs(def.props) do
				st.safeSet(inst, prop, val)
			end
		end
	end

	local function captureBaseline()
		for prop, _ in pairs(shader.target) do
			if shader.baseline[prop] == nil then
				shader.baseline[prop] = st.safeGet(lighting, prop)
			end
		end
		NAmanage._shaderSettingsBackup = shader.baseline
	end

	if not shader.apply then
		shader.apply = function()
			for prop, val in pairs(shader.target) do
				st.safeSet(lighting, prop, val)
			end
		end
	end

	if not shader.restore then
		shader.restore = function()
			for prop, val in pairs(shader.baseline or {}) do
				if val ~= nil then st.safeSet(lighting, prop, val) end
			end
			NAmanage._shaderSettingsBackup = nil
		end
	end

	if not shader.init then
		shader.init = true
		for prop, _ in pairs(shader.target) do
			local connName = "shader_prop_"..Lower(prop)
			st.hook(connName, function() return lighting:GetPropertyChangedSignal(prop):Connect(function()
					if st.shader and st.shader.enabled then
						if st.safeGet(lighting, prop) ~= st.shader.target[prop] then
							st.safeSet(lighting, prop, st.shader.target[prop])
						end
					else
						if st.shader and st.shader.baseline then
							st.shader.baseline[prop] = st.safeGet(lighting, prop)
							NAmanage._shaderSettingsBackup = st.shader.baseline
						end
					end
				end) end)
		end

		st.hook("shader_effects_loop", function() return RunService.RenderStepped:Connect(function()
				if not (st.shader and st.shader.enabled) then return end
				ensureEffects()
				shader.apply()
			end) end)

		st.hook("shader_effects_removed", function() return lighting.DescendantRemoving:Connect(function(inst)
				if not (st.shader and st.shader.enabled) or not inst then return end
				for _, name in ipairs(NA_SHADER_EFFECT_NAMES) do
					if inst.Name == name then
						Delay(0, ensureEffects)
						break
					end
				end
			end) end)
	end

	captureBaseline()
	shader.enabled = true
	ensureEffects()
	shader.apply()

	DoNotif("Shader preset applied.", 3)
end)

cmd.add({"unshaders", "shadersoff", "rtxoff"}, {"unshaders (shadersoff, rtxoff)", "Disable the shader preset and restore Lighting"}, function()
	local lighting = Lighting or SafeGetService("Lighting")
	if not lighting then
		DoNotif("Lighting service unavailable", 3)
		return
	end

	local st = NAmanage._ensureL()
	if st.shader then
		st.shader.enabled = false
	end

	if st.shader and st.shader.restore then
		st.shader.restore()
	else
		local backup = NAmanage._shaderSettingsBackup
		if backup then
			for prop, value in pairs(backup) do
				st.safeSet(lighting, prop, value)
			end
		end
		NAmanage._shaderSettingsBackup = nil
	end

	NAmanage.NAremoveShaderEffects(lighting)

	DoNotif("Shader preset removed.", 3)
end)

NAmanage.NAibtoolsVectorString=function(vec)
	return Format("Vector3.new(%s,%s,%s)", tostring(vec.X), tostring(vec.Y), tostring(vec.Z))
end

NAmanage.NAibtoolsCreateUI=function(state, actions)
	local gui = InstanceNew("ScreenGui")
	gui.Name = "iBToolsUI"
	NaProtectUI(gui)

	local frame = InstanceNew("Frame", gui)
	frame.Name = "Panel"
	frame.Size = UDim2.new(0, 240, 0, 260)
	frame.Position = UDim2.new(0.05, 0, 0.4, 0)
	frame.BackgroundColor3 = Color3.fromRGB(26, 26, 26)
	frame.BorderSizePixel = 0

	local frameCorner = InstanceNew("UICorner", frame)
	frameCorner.CornerRadius = UDim.new(0, 8)

	local header = InstanceNew("Frame", frame)
	header.Name = "Header"
	header.Size = UDim2.new(1, 0, 0, 36)
	header.BackgroundColor3 = Color3.fromRGB(38, 38, 38)
	header.BorderSizePixel = 0
	header.Active = true

	local title = InstanceNew("TextLabel", header)
	title.BackgroundTransparency = 1
	title.Font = Enum.Font.GothamSemibold
	title.TextSize = 16
	title.TextXAlignment = Enum.TextXAlignment.Left
	title.TextColor3 = Color3.fromRGB(255, 255, 255)
	title.Text = "iBuild Tools"
	title.Size = UDim2.new(1, -40, 1, 0)
	title.Position = UDim2.new(0, 10, 0, 0)

	local statusLabel = InstanceNew("TextLabel", frame)
	statusLabel.Name = "Status"
	statusLabel.BackgroundTransparency = 1
	statusLabel.Font = Enum.Font.Gotham
	statusLabel.TextSize = 14
	statusLabel.TextXAlignment = Enum.TextXAlignment.Left
	statusLabel.TextColor3 = Color3.fromRGB(200, 200, 200)
	statusLabel.Position = UDim2.new(0, 12, 0, 46)
	statusLabel.Size = UDim2.new(1, -24, 0, 20)
	statusLabel.Text = "Target: none"

	local buttonHolder = InstanceNew("Frame", frame)
	buttonHolder.BackgroundTransparency = 1
	buttonHolder.Position = UDim2.new(0, 12, 0, 72)
	buttonHolder.Size = UDim2.new(1, -24, 1, -84)

	local layout = InstanceNew("UIListLayout", buttonHolder)
	layout.Padding = UDim.new(0, 6)
	layout.FillDirection = Enum.FillDirection.Vertical
	layout.HorizontalAlignment = Enum.HorizontalAlignment.Center
	layout.SortOrder = Enum.SortOrder.LayoutOrder
	local DEFAULT_COLOR = Color3.fromRGB(52, 52, 52)
	local HOVER_COLOR = Color3.fromRGB(66, 66, 66)
	local ACTIVE_COLOR = Color3.fromRGB(80, 110, 255)

	local function makeButton(text)
		local btn = InstanceNew("TextButton", buttonHolder)
		btn.Name = text
		btn.Size = UDim2.new(1, 0, 0, 34)
		btn.BackgroundColor3 = DEFAULT_COLOR
		btn.BorderSizePixel = 0
		btn.AutoButtonColor = false
		btn.Font = Enum.Font.GothamSemibold
		btn.TextSize = 14
		btn.TextColor3 = Color3.fromRGB(255, 255, 255)
		btn.Text = text
		local corner = InstanceNew("UICorner", btn)
		corner.CornerRadius = UDim.new(0, 6)
		btn.MouseEnter:Connect(function()
			if btn.BackgroundColor3 ~= ACTIVE_COLOR then
				btn.BackgroundColor3 = HOVER_COLOR
			end
		end)
		btn.MouseLeave:Connect(function()
			if btn.BackgroundColor3 ~= ACTIVE_COLOR then
				btn.BackgroundColor3 = DEFAULT_COLOR
			end
		end)
		return btn
	end

	local modeButtons = {}

	local function refreshModeButtons()
		local selected = actions.getMode and actions.getMode() or nil
		for mode, btn in pairs(modeButtons) do
			if selected == mode then
				btn.BackgroundColor3 = ACTIVE_COLOR
			else
				btn.BackgroundColor3 = DEFAULT_COLOR
			end
		end
	end

	local function createModeButton(label, mode)
		local btn = makeButton(label)
		modeButtons[mode] = btn
		MouseButtonFix(btn, function()
			if actions.setMode then
				actions.setMode(mode)
			end
			refreshModeButtons()
		end)
		return btn
	end

	createModeButton("Delete", "delete")
	createModeButton("Toggle Anchor", "anchor")
	createModeButton("Toggle CanCollide", "collide")

	local undoButton = makeButton("Undo Delete")
	MouseButtonFix(undoButton, function()
		if actions.undo then
			actions.undo()
		end
	end)

	local copyButton = makeButton("Copy Delete Script")
	MouseButtonFix(copyButton, function()
		if actions.copy then
			actions.copy()
		end
	end)

	NAgui.dragger(frame, header)

	state.statusLabel = statusLabel
	state.frame = frame
	state.refreshModeButtons = refreshModeButtons
	refreshModeButtons()

	return gui
end

NAmanage.NAibtoolsCleanup=function(state)
	if not state then
		return
	end
	if state.connections then
		for _, conn in ipairs(state.connections) do
			if conn and conn.Disconnect then
				conn:Disconnect()
			end
		end
		table.clear(state.connections)
	end
	if state.highlight then
		pcall(function()
			state.highlight:Destroy()
		end)
		state.highlight = nil
	end
	if state.gui then
		pcall(function()
			state.gui:Destroy()
		end)
		state.gui = nil
	end
	state.statusLabel = nil
	state.frame = nil
	state.currentPart = nil
	state.refreshModeButtons = nil
end

cmd.add({"ibtools"}, {"ibtools", "Load the iBuild Tools helper tool"}, function()
	if not LocalPlayer then
		DoNotif("Local player not ready.", 3)
		return
	end

	local backpack = getBp()
	if not backpack then
		backpack = LocalPlayer:FindFirstChild("Backpack") or LocalPlayer:WaitForChild("Backpack", 3)
	end
	if not backpack then
		DoNotif("Backpack not available.", 3)
		return
	end

	local state = NAmanage._ibtools
	if state and state.tool and state.tool.Parent then
		DoNotif("iBTools is already loaded.", 3)
		return
	end

	local tool = InstanceNew("Tool", backpack)
	tool.Name = "iBTools"
	tool.RequiresHandle = false

	state = {
		tool = tool,
		history = {},
		saveHistory = {},
		connections = {},
		toolConnections = {},
		currentPart = nil,
		currentMode = "delete",
	}
	NAmanage._ibtools = state

	local function modeLabel()
		local mode = state.currentMode
		if not mode then
			return "none"
		end
		return mode
	end

	local function updateStatus(part)
		if not state.statusLabel then
			return
		end
		local targetText = "none"
		if part then
			if not part.Parent then
				targetText = part.Name.." (stored)"
			else
				local ok, fullName = pcall(part.GetFullName, part)
				targetText = ok and fullName or part.Name
			end
		end
		state.statusLabel.Text = Format("Mode: %s | Target: %s", modeLabel():upper(), targetText)
	end

	local function setTarget(part)
		if part and not part:IsA("BasePart") then
			part = nil
		end
		state.currentPart = part
		if state.highlight then
			state.highlight.Adornee = part
		end
		updateStatus(part)
	end

	local function onEquipped(mouse)
		NAmanage.NAibtoolsCleanup(state)

		local highlight = InstanceNew("SelectionBox")
		highlight.Name = "iBToolsSelection"
		highlight.LineThickness = 0.04
		highlight.Color3 = Color3.fromRGB(0, 170, 255)
		highlight.Adornee = nil
		highlight.Parent = workspace.CurrentCamera or workspace
		state.highlight = highlight

		local function undoLast()
			local record = table.remove(state.history)
			if not record then
				DoNotif("Nothing to undo.", 2)
				return
			end
			local part = record.part
			if part then
				part.Parent = record.parent
				if record.cframe then
					pcall(function()
						part.CFrame = record.cframe
					end)
				end
				setTarget(part)
				local saved = record.data
				if saved then
					for i = #state.saveHistory, 1, -1 do
						if state.saveHistory[i] == saved then
							table.remove(state.saveHistory, i)
							break
						end
					end
				end
				DoNotif("Restored '"..part.Name.."'", 2)
			end
		end

		local function copyScript()
			if #state.saveHistory == 0 then
				DoNotif("No deleted parts to export.", 3)
				return
			end
			local lines = {}
			for _, data in ipairs(state.saveHistory) do
				local pos = data.position
				local vec = NAmanage.NAibtoolsVectorString(pos)
				lines[#lines + 1] = Format(
					"for _,v in ipairs(workspace:FindPartsInRegion3(Region3.new(%s, %s), nil, math.huge)) do if v.Name == %q then v:Destroy() end end",
					vec,
					vec,
					data.name
				)
			end
			local scriptText = Concat(lines, "\n")
			if setclipboard then
				setclipboard(scriptText)
				DoNotif("Copied delete script to clipboard.", 3)
			else
				DoWindow("Copy this script:\n\n"..scriptText)
			end
		end

		local function applyDelete(part)
			if not part or not part.Parent then
				DoNotif("Selected part is no longer available.", 3)
				setTarget(nil)
				return
			end
			local record = {
				part = part,
				parent = part.Parent,
				cframe = part.CFrame,
			}
			local data = {
				name = part.Name,
				position = part.Position,
			}
			record.data = data
			Insert(state.history, record)
			Insert(state.saveHistory, data)
			part.Parent = nil
			setTarget(nil)
			DoNotif("Deleted '"..part.Name.."'", 2)
		end

		local function applyAnchor(part)
			if not part or not part.Parent then
				DoNotif("Selected part is no longer available.", 3)
				setTarget(nil)
				return
			end
			part.Anchored = not part.Anchored
			updateStatus(part)
			DoNotif(Format("%s anchored %s", part.Name, part.Anchored and "enabled" or "disabled"), 2)
		end

		local function applyCollide(part)
			if not part or not part.Parent then
				DoNotif("Selected part is no longer available.", 3)
				setTarget(nil)
				return
			end
			part.CanCollide = not part.CanCollide
			updateStatus(part)
			DoNotif(Format("%s CanCollide %s", part.Name, part.CanCollide and "enabled" or "disabled"), 2)
		end

		local modeHandlers = {
			delete = applyDelete,
			anchor = applyAnchor,
			collide = applyCollide,
		}

		local function setMode(mode)
			if not modeHandlers[mode] then
				return
			end
			state.currentMode = mode
			if state.refreshModeButtons then
				state.refreshModeButtons()
			end
			updateStatus(state.currentPart)
		end

		local function applyMode(part)
			if not part or not part:IsA("BasePart") then
				DoNotif("Aim at a part first.", 3)
				return
			end
			setTarget(part)
			local handler = modeHandlers[state.currentMode or ""]
			if not handler then
				DoNotif("Select a mode first.", 3)
				return
			end
			handler(part)
		end

		local uiActions = {
			setMode = setMode,
			getMode = function()
				return state.currentMode
			end,
			undo = undoLast,
			copy = copyScript,
		}

		state.gui = NAmanage.NAibtoolsCreateUI(state, uiActions)
		if not modeHandlers[state.currentMode or ""] then
			state.currentMode = "delete"
		end
		setMode(state.currentMode)
		updateStatus(state.currentPart)

		local function refreshTarget()
			local target = mouse.Target
			if target and target:IsA("BasePart") then
				setTarget(target)
			end
		end

		refreshTarget()

		Insert(state.connections, mouse.Move:Connect(refreshTarget))
		Insert(state.connections, mouse.Button1Down:Connect(function()
			local target = mouse.Target
			if target and target:IsA("BasePart") then
				applyMode(target)
			end
		end))
	end

	Insert(state.toolConnections, tool.Equipped:Connect(onEquipped))
	Insert(state.toolConnections, tool.Unequipped:Connect(function()
		NAmanage.NAibtoolsCleanup(state)
	end))
	Insert(state.toolConnections, tool.AncestryChanged:Connect(function(_, parent)
		if not parent then
			NAmanage.NAibtoolsCleanup(state)
			if NAmanage._ibtools == state then
				NAmanage._ibtools = nil
			end
		end
	end))

	DoNotif("iBTools loaded. Equip the tool to use it.", 3)
end)

cmd.add({"unibtools"}, {"unibtools", "Remove the iBuild Tools helper tool"}, function()
	local state = NAmanage._ibtools
	if not state then
		DoNotif("iBTools is not active.", 3)
		return
	end
	if state.tool then
		pcall(function()
			state.tool:Destroy()
		end)
	end
	NAmanage.NAibtoolsCleanup(state)
	if state.toolConnections then
		for _, conn in ipairs(state.toolConnections) do
			if conn and conn.Disconnect then
				conn:Disconnect()
			end
		end
		state.toolConnections = nil
	end
	NAmanage._ibtools = nil
	DoNotif("iBTools removed.", 3)
end)

cmd.add({"setfflag", "setff"}, {"setfflag <flag> <value> [save] (setff)", "Set a fast flag (use 'save' to store it)"}, function(flag, value, maybeSave)
	local title = "Set Fast Flag"
	if not flag or flag == "" then
		DoNotif("Usage: setfflag <flag> <value> [save]", 3, title)
		return
	end
	if value == nil then
		DoNotif("Please provide a fast flag value", 3, title)
		return
	end
	local parsedValue = NAFFlags.parseCustomValue and NAFFlags.parseCustomValue(value) or value
	local ok, err = NAFFlags.apply(flag, parsedValue, { allowDisabled = true, silent = true })
	if ok then
		local saveRequested = false
		if type(maybeSave) == "string" then
			local lowerSave = Lower(maybeSave)
			saveRequested = lowerSave == "save" or lowerSave == "persist" or lowerSave == "keep"
		end
		local suffix = ""
		if saveRequested then
			local savedOk, saveErr = NAFFlags.setCustomFlag(flag, parsedValue)
			if not savedOk then
				DoNotif(Format("Applied %s but could not save: %s", tostring(flag), tostring(saveErr or "unknown error")), 4, title)
			else
				suffix = " (saved)"
			end
		end
		DoNotif(Format("Set %s to %s%s", tostring(flag), tostring(parsedValue), suffix), 3, title)
	else
		DoNotif(Format("Failed to set %s: %s", tostring(flag), tostring(err or "unknown error")), 4, title)
	end
end, true)

cmd.add({"addalias"}, {"addalias <command> <alias>", "Adds a persistent alias for an existing command"}, function(original, alias)
	if not original or not alias then
		DoNotif("Usage: addalias <command> <alias>", 2)
		return
	end

	original, alias = original:lower(), alias:lower()

	if not cmds.Commands[original] then
		DoNotif("Command '"..original.."' does not exist", 2)
		return
	end

	if cmds.Commands[alias] or cmds.Aliases[alias] then
		DoNotif("The name '"..alias.."' is already used by another command or alias", 2)
		return
	end

	local command = cmds.Commands[original]
	cmds.Aliases[alias] = {command[1], command[2], command[3]}
	cmds.NASAVEDALIASES[alias] = original

	if FileSupport then
		local aliasMap = NAmanage.readAliasFile()
		aliasMap[alias] = original
		writefile(NAfiles.NAALIASPATH, HttpService:JSONEncode(aliasMap))
	end

	DoNotif("Alias '"..alias.."' has been added for command '"..original.."'", 2)
	if not FileSupport then
		DebugNotif("Alias stored for this session only (no file support detected).")
	end
end, true)

cmd.add({"removealias"}, {"removealias", "Select and remove a saved alias"}, function()
	local combined = {}

	if FileSupport then
		for alias, original in pairs(NAmanage.readAliasFile()) do
			if type(alias) == "string" and type(original) == "string" then
				combined[alias:lower()] = original:lower()
			end
		end
	end

	for alias, original in pairs(cmds.NASAVEDALIASES) do
		if type(alias) == "string" and type(original) == "string" then
			combined[alias:lower()] = original:lower()
		end
	end

	if next(combined) == nil then
		DoNotif("No saved aliases to remove", 2)
		return
	end

	local buttons = {}
	for alias, original in pairs(combined) do
		Insert(buttons, {
			Text = 'Alias: '..alias.." | Command: "..original,
			Callback = function()
				cmds.Aliases[alias] = nil
				cmds.NASAVEDALIASES[alias] = nil
				combined[alias] = nil
				if FileSupport then
					writefile(NAfiles.NAALIASPATH, HttpService:JSONEncode(combined))
				end
				DoNotif(("Removed alias '%s'"):format(alias), 2)
			end
		})
	end

	Window({
		Title = "Remove Alias",
		Description = "Select an alias to remove:",
		Buttons = buttons
	})
end)

cmd.add({"clearaliases"}, {"clearaliases", "Removes all aliases created using addalias."}, function()
	if next(cmds.NASAVEDALIASES) == nil then
		DoNotif("No saved aliases to clear", 2)
		return
	end

	for alias in pairs(cmds.NASAVEDALIASES) do
		cmds.Aliases[alias] = nil
	end

	cmds.NASAVEDALIASES = {}

	if FileSupport then
		writefile(NAfiles.NAALIASPATH, "{}")
	else
		DebugNotif("Aliases cleared for this session (no file support).")
	end

	DoNotif("All aliases have been removed", 2)
end)

cmd.add({"addbutton", "ab"}, {"addbutton <command> <label> [<command2>] (ab)", "Add a mobile button"}, function(arg1, arg2, arg3)
	if not arg1 or not arg2 then
		DoNotif("Usage: ;addbutton <command> <label> [<command2>]", 2)
		return
	end

	local id = NAUserButtonNextId()
	NAUserButtons[id] = {
		Cmd1 = arg1,
		Label = arg2,
		Cmd2 = arg3
	}

	NAmanage.UserButtonsSave("add button")

	NAmanage.RenderUserButtons()

	DoNotif("Added button with id "..id, 2)
end,true)

cmd.add({"removebutton", "rb"}, {"removebutton (rb)", "Remove a user button"}, function()
	if not next(NAUserButtons) then
		DoNotif("No user buttons to remove", 2)
		return
	end

	local function saveAndRender()
		NAmanage.UserButtonsSave("remove button")
		if type(NAmanage.RenderUserButtons) == "function" then
			NAmanage.RenderUserButtons()
		end
	end

	local function getLabel(data, fallback)
		local label = data and data.Label
		if type(label) ~= "string" or label == "" then
			label = fallback
		end
		return label
	end

	local function getCmdDisplay(cmd1, cmd2)
		local cmdDisplay = cmd1 or "?"
		if cmd2 then
			cmdDisplay = cmdDisplay.." / "..cmd2
		end
		return cmdDisplay
	end

	local function removeEntry(id, label)
		NAUserButtons[id] = nil
		originalIO.clearUserButtonState(id)
		saveAndRender()
		DoNotif("Removed user button: ["..id.."] "..label, 2)
	end

	local function removeGroup(id, label)
		NAUserButtons[id] = nil
		originalIO.clearUserButtonState(id)
		saveAndRender()
		DoNotif("Removed group: ["..id.."] "..label, 2)
	end

	local function openGroupChildRemove(groupId)
		local group = NAUserButtons[groupId]
		if not (type(group) == "table" and group.Type == "group") then
			DoNotif("Group not found", 2)
			return
		end

		local children = (type(group.Children) == "table") and group.Children or {}
		if #children == 0 then
			DoNotif("Group has no children", 2)
			return
		end

		local groupLabel = getLabel(group, "Group "..groupId)
		local options = {}

		for childIndex, child in ipairs(children) do
			local childLabel = getLabel(child, "Action "..childIndex)
			local cmdDisplay = getCmdDisplay(child.Cmd1, child.Cmd2)
			local index = childIndex
			Insert(options, {
				Text = "["..index.."] "..childLabel.." ("..cmdDisplay..")",
				Callback = function()
					local groupNow = NAUserButtons[groupId]
					if not (type(groupNow) == "table" and groupNow.Type == "group") then
						DoNotif("Group not found", 2)
						return
					end
					local childrenNow = (type(groupNow.Children) == "table") and groupNow.Children or {}
					if index < 1 or index > #childrenNow then
						DoNotif("Child not found", 2)
						return
					end
					local removed = table.remove(childrenNow, index)
					if #childrenNow == 0 then
						NAUserButtons[groupId] = nil
						originalIO.clearUserButtonState(groupId)
						saveAndRender()
						DoNotif("Removed group: ["..groupId.."] "..groupLabel, 2)
						return
					end
					groupNow.Children = childrenNow
					originalIO.clearUserButtonChildState(groupId, index)
					saveAndRender()
					local removedLabel = (removed and removed.Label) or childLabel
					DoNotif("Removed child: "..tostring(removedLabel), 2)
				end
			})
		end

		Window({
			Title = "Remove Group Child",
			Description = "Select a child to remove from ["..groupId.."] "..groupLabel..":",
			Buttons = options
		})
	end

	local function openGroupMenu(groupId)
		local group = NAUserButtons[groupId]
		if not (type(group) == "table" and group.Type == "group") then
			return
		end

		local groupLabel = getLabel(group, "Group "..groupId)
		local children = (type(group.Children) == "table") and group.Children or {}
		local count = #children
		local options = {}

		Insert(options, {
			Text = "Remove Group (delete all children)",
			Callback = function()
				removeGroup(groupId, groupLabel)
			end
		})

		if count > 0 then
			Insert(options, {
				Text = "Remove Child",
				Callback = function()
					openGroupChildRemove(groupId)
				end
			})

			Insert(options, {
				Text = "Ungroup (keep children)",
				Callback = function()
					local ok, msg = NAmanage.UserButtons_Ungroup(groupId)
					if ok then
						if type(NAmanage.RenderUserButtons) == "function" then
							NAmanage.RenderUserButtons()
						end
						DoNotif(msg or "Ungrouped", 2)
					else
						DoNotif(msg or "Failed to ungroup", 3)
					end
				end
			})
		end

		Window({
			Title = "Manage Group",
			Description = Format("Group [%d] %s (%d child%s)", groupId, groupLabel, count, count == 1 and "" or "ren"),
			Buttons = options
		})
	end

	local ids = {}
	for id, data in pairs(NAUserButtons) do
		if type(id) == "number" and type(data) == "table" then
			Insert(ids, id)
		end
	end
	table.sort(ids)

	local options = {}
	for _, id in ipairs(ids) do
		local data = NAUserButtons[id]
		if data.Type == "group" then
			local label = getLabel(data, "Group "..id)
			local count = (type(data.Children) == "table") and #data.Children or 0
			local mode = (data.GroupMode == "side") and "side" or "dropdown"
			Insert(options, {
				Text = Format("[%d] %s (group: %d, %s)", id, label, count, mode),
				Callback = function()
					openGroupMenu(id)
				end
			})
		else
			local label = getLabel(data, "Button "..id)
			local cmdDisplay = getCmdDisplay(data.Cmd1, data.Cmd2)
			Insert(options, {
				Text = Format("[%d] %s (%s)", id, label, cmdDisplay),
				Callback = function()
					removeEntry(id, label)
				end
			})
		end
	end

	Window({
		Title = "Remove User Button",
		Description = "Select a button or group to manage:",
		Buttons = options
	})
end)

cmd.add({"clearbuttons", "clearbtns", "cb"}, {"clearbuttons (clearbtns, cb)", "Clear all user buttons"}, function()
	if not next(NAUserButtons) then
		DoNotif("No user buttons to clear", 2)
		return
	end

	Window({
		Title = "Clear All Buttons",
		Description = "Are you sure you want to clear all user buttons?",
		Buttons = {
			{
				Text = "Yes",
				Callback = function()
					table.clear(NAUserButtons)
					table.clear(UserButtonToggleState)

					NAmanage.UserButtonsSave("clear buttons")

					NAmanage.RenderUserButtons()

					DoNotif("Cleared all user buttons", 2)
				end
			}
		}
	})
end)

cmd.add({"addautoexec", "aaexec", "addae", "addauto", "aexecadd"}, {"addautoexec <command> [arguments] (aaexec, addae, addauto, aexecadd)", "Add a command to autoexecute"}, function(arg1, ...)
	if not arg1 then
		DoNotif("Usage: ;addautoexec <command> [arguments...]", 2)
		return
	end

	local args = {...}
	local rawName = arg1:lower()
	local canonical = NAmanage.resolveCommandName(rawName)

	if not canonical then
		DoNotif("Command ["..rawName.."] does not exist", 2)
		return
	end

	if NAStuff.AutoExecBlockedCommands[canonical] then
		DoNotif("Command ["..canonical.."] is blocked.", 2)
		return
	end

	local commandName = canonical

	NAEXECDATA = NAEXECDATA or {commands = {}, args = {}}
	if not NAEXECDATA.commands then
		NAEXECDATA.commands = {}
	end
	if not NAEXECDATA.args then
		NAEXECDATA.args = {}
	end

	local exists = false
	for _, cmd in ipairs(NAEXECDATA.commands) do
		if cmd == commandName then
			exists = true
			break
		end
	end
	if not exists then
		Insert(NAEXECDATA.commands, commandName)
	end

	if #args > 0 then
		local argumentString = Concat(args, " ")
		NAEXECDATA.args[commandName] = argumentString
	else
		NAEXECDATA.args[commandName] = ""
	end

	if not NAmanage.AutoExecSave(NAEXECDATA) then
		DebugNotif("Failed to save AutoExec changes; they will reset after this session.")
	end

	DoNotif("Added to AutoExec: "..arg1.." "..(args[1] or ""), 2)
end,true)

cmd.add({"removeautoexec", "raexec", "removeae", "removeauto", "aexecremove"}, {"removeautoexec (raexec, removeae, removeauto, aexecremove)", "Remove a command from autoexecute"}, function()
	if #NAEXECDATA.commands == 0 then
		DoNotif("No AutoExec commands to remove", 2)
		return
	end

	local options = {}
	for i, cmdName in ipairs(NAEXECDATA.commands) do
		local args = NAEXECDATA.args[cmdName]
		local display = args and args ~= "" and (cmdName.." "..args) or cmdName
		local index = i
		Insert(options, {
			Text = display,
			Callback = function()
				local removedCommand = table.remove(NAEXECDATA.commands, index)
				if removedCommand then
					NAEXECDATA.args[removedCommand] = nil
					if not NAmanage.AutoExecSave(NAEXECDATA) then
						DebugNotif("Failed to save AutoExec changes; they will reset after this session.")
					end
					DoNotif("Removed AutoExec command: "..display, 2)
				else
					DoNotif("Unable to remove AutoExec command.", 2)
				end
			end
		})
	end
	Window({
		Title = "Remove AutoExec Command",
		Description = "Select which AutoExec to remove:",
		Buttons = options
	})
end)

cmd.add({"clearautoexec", "caexec", "clearauto", "autoexecclear", "aexecclear", "aeclear"}, {"clearautoexec (caexec, clearauto, autoexecclear, aexecclear, aeclear)", "Clear all AutoExec commands"}, function()
	NAEXECDATA = NAEXECDATA or {commands = {}, args = {}}
	NAEXECDATA.commands = NAEXECDATA.commands or {}
	NAEXECDATA.args = NAEXECDATA.args or {}

	if #NAEXECDATA.commands == 0 then
		DoNotif("No AutoExec commands to clear", 2)
		return
	end

	Window({
		Title = "Clear AutoExec Commands",
		Description = "Are you sure you want to clear all AutoExec commands?",
		Buttons = {
			{
				Text = "Yes",
				Callback = function()
					table.clear(NAEXECDATA.commands)
					table.clear(NAEXECDATA.args)

					if not NAmanage.AutoExecSave(NAEXECDATA) then
						DebugNotif("Failed to save AutoExec changes; they will reset after this session.")
					end

					DoNotif("Cleared all AutoExec commands", 2)
				end
			}
		}
	})
end)

cmd.add({"executor","exec"},{"executor (exec)","Very simple executor"},function()
	loadstring(game:HttpGet("https://raw.githubusercontent.com/ltseverydayyou/Nameless-Admin/main/NAexecutor.lua"))()
end)

cmd.add({"lastcommand","lastcmd"},{"lastcommand (lastcmd)","Re-run your previously executed command"},function()
	local last=NAStuff._lastCommand
	local first = last and last[1]
	local lowerFirst = (type(first) == "string") and Lower(first) or nil
	if not lowerFirst or lowerFirst == "lastcommand" or lowerFirst == "lastcmd" then
		last = NAStuff._prevCommand
		first = last and last[1]
		lowerFirst = (type(first) == "string") and Lower(first) or nil
	end
	if type(last) ~= "table" or not lowerFirst or #last==0 then
		DoNotif("No previous command recorded",2)
		return
	end
	local replay=NAmanage.cloneArgsArray(last)
	if #replay == 0 then
		DoNotif("No previous command recorded",2)
		return
	end
	SpawnCall(function()
		cmd.run(replay)
	end)
end)

cmd.add({"commandloop", "cmdloop"}, {"commandloop <command> {arguments} (cmdloop)", "Run a command on loop"}, function(...)
	local args = {...}
	local commandName = args[1]
	table.remove(args, 1)

	if not commandName then
		DoNotif("Command name is required.",3)
		return
	end

	cmd.loop(commandName, args)
end,true)

cmd.add({"stoploop", "uncmdloop", "sloop", "stopl"}, {"stoploop", "Stop a running loop"}, function()
	cmd.stopLoop()
end)

cmd.add({"scripthub","hub"},{"scripthub (hub)","Thanks to scriptblox/rscripts API"},function()
	loadstring(game:HttpGet("https://raw.githubusercontent.com/ltseverydayyou/Nameless-Admin/main/ScriptHubNA.lua"))()
end)

cmd.addPatched({"resizechat","rc"},{"resizechat (rc)","Makes chat resizable and draggable"},function()
	require(SafeGetService("Chat").ClientChatModules.ChatSettings).WindowResizable=true
	require(SafeGetService("Chat").ClientChatModules.ChatSettings).WindowDraggable=true
end)


local scaleFrame = nil
cmd.add({"uiscale", "uscale", "guiscale", "gscale"}, {"uiscale (uscale)", "Adjust the scale of the "..adminName.." UI"}, function()
	if scaleFrame then scaleFrame:Destroy() scaleFrame=nil end
	scaleFrame = InstanceNew("ScreenGui")
	local frame = InstanceNew("Frame")
	local frameCorner = InstanceNew("UICorner")
	local slider = InstanceNew("Frame")
	local sliderCorner = InstanceNew("UICorner")
	local progress = InstanceNew("Frame")
	local progressCorner = InstanceNew("UICorner")
	local knob = InstanceNew("TextButton")
	local knobCorner = InstanceNew("UICorner")
	local label = InstanceNew("TextLabel")
	local closeButton = InstanceNew("TextButton")
	local closeCorner = InstanceNew("UICorner")

	local sizeRange = {0.5, 2.5}
	local minSize, maxSize = sizeRange[1], sizeRange[2]

	NaProtectUI(scaleFrame)
	frame.Parent = scaleFrame
	frame.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
	frame.Size = UDim2.new(0, 400, 0, 120)
	frame.Position = UDim2.new(0.5,-283/2+5,0.5,-260/2+5)
	frame.BorderSizePixel = 0
	frame.BackgroundTransparency = 0.05

	frameCorner.CornerRadius = UDim.new(0.1, 0)
	frameCorner.Parent = frame

	slider.Parent = frame
	slider.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
	slider.Size = UDim2.new(0.8, 0, 0.2, 0)
	slider.Position = UDim2.new(0.1, 0, 0.5, 0)
	slider.AnchorPoint = Vector2.new(0, 0.5)
	slider.BorderSizePixel = 0

	sliderCorner.CornerRadius = UDim.new(0.5, 0)
	sliderCorner.Parent = slider

	progress.Parent = slider
	progress.BackgroundColor3 = Color3.fromRGB(0, 170, 255)
	progress.Size = UDim2.new((NAUIScale - minSize) / (maxSize - minSize), 0, 1, 0)
	progress.BorderSizePixel = 0

	progressCorner.CornerRadius = UDim.new(0.5, 0)
	progressCorner.Parent = progress

	knob.Parent = slider
	knob.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
	knob.Size = UDim2.new(0, 25, 1.5, 0)
	knob.Position = UDim2.new((NAUIScale - minSize) / (maxSize - minSize), 0, -0.25, 0)
	knob.Text = ""
	knob.BorderSizePixel = 0
	knob.AutoButtonColor = false

	knobCorner.CornerRadius = UDim.new(1, 0)
	knobCorner.Parent = knob

	label.Parent = frame
	label.BackgroundTransparency = 1
	label.Size = UDim2.new(1, 0, 0.3, 0)
	label.Position = UDim2.new(0, 0, 0.1, 0)
	label.Text = "Scale: "..Format("%.2f", NAUIScale)
	label.TextColor3 = Color3.fromRGB(255, 255, 255)
	label.Font = Enum.Font.Gotham
	label.TextSize = 18
	label.TextXAlignment = Enum.TextXAlignment.Center

	closeButton.Parent = frame
	closeButton.BackgroundColor3 = Color3.fromRGB(255, 0, 0)
	closeButton.Size = UDim2.new(0, 30, 0, 30)
	closeButton.Position = UDim2.new(1, -40, 0, 10)
	closeButton.Text = "X"
	closeButton.TextColor3 = Color3.fromRGB(255, 255, 255)
	closeButton.Font = Enum.Font.Gotham
	closeButton.TextSize = 14
	closeButton.BorderSizePixel = 0

	closeCorner.CornerRadius = UDim.new(0.5, 0)
	closeCorner.Parent = closeButton

	local function update(scale)
		opt.NAAUTOSCALER.Scale = scale
		progress.Size = UDim2.new((scale - minSize) / (maxSize - minSize) + 0.05, 0, 1, 0)
		knob.Position = UDim2.new((scale - minSize) / (maxSize - minSize), 0, -0.25, 0)
		label.Text = "Scale: "..Format("%.2f", scale)
	end

	update(NAUIScale)

	local dragging = false
	local dragInput
	local sliderStart, sliderWidth

	knob.InputBegan:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
			dragging = true
			sliderStart = slider.AbsolutePosition.X
			sliderWidth = slider.AbsoluteSize.X
			input.Changed:Connect(function()
				if input.UserInputState == Enum.UserInputState.End then
					dragging = false
					NAmanage.NASettingsSet("uiScale", NAUIScale)
				end
			end)
		end
	end)

	UserInputService.InputChanged:Connect(function(input)
		if dragging and (input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch) then
			local mouseX = input.Position.X
			local relativePosition = (mouseX - sliderStart) / sliderWidth
			local newScale = math.clamp(relativePosition, 0, 1) * (maxSize - minSize) + minSize
			NAUIScale = math.clamp(newScale, minSize, maxSize)
			update(NAUIScale)
		end
	end)

	MouseButtonFix(closeButton,function()
		scaleFrame:Destroy()
	end)

	NAgui.draggerV2(frame)
end)

cmd.add({"prefix"}, {"prefix <symbol>", "Changes the admin prefix"}, function(...)
	local newPrefix = (...)
	if not newPrefix or newPrefix == "" then
		DoNotif("Please enter a valid prefix")
	elseif utf8.len(newPrefix) > 1 then
		DoNotif("Prefix must be a single character (e.g. ; . !)")
	elseif newPrefix:match("[%w]") then
		DoNotif("Prefix cannot contain letters or numbers")
	elseif newPrefix:match("[%[%]%(%)%*%^%$%%{}<>]") then
		DoNotif("That symbol is not allowed as a prefix")
	elseif newPrefix:match("&amp;") or newPrefix:match("&lt;") or newPrefix:match("&gt;") or newPrefix:match("&quot;") or newPrefix:match("&#x27;") or newPrefix:match("&#x60;") then
		DoNotif("Encoded/HTML characters are not allowed as a prefix")
	else
		opt.prefix = newPrefix
		DoNotif("Prefix set to: "..newPrefix)
		if NAmanage.SyncPrefixUI then
			NAmanage.SyncPrefixUI()
		end
	end
end, true)

cmd.add({"saveprefix"}, {"saveprefix <symbol>", "Saves the prefix to a file and applies it"}, function(...)
	local newPrefix = (...)
	if not newPrefix or newPrefix == "" then
		DoNotif("Please enter a valid prefix")
	elseif utf8.len(newPrefix) > 1 then
		DoNotif("Prefix must be a single character (e.g. ; . !)")
	elseif newPrefix:match("[%w]") then
		DoNotif("Prefix cannot contain letters or numbers")
	elseif newPrefix:match("[%[%]%(%)%*%^%$%%{}<>]") then
		DoNotif("That symbol is not allowed as a prefix")
	elseif newPrefix:match("&amp;") or newPrefix:match("&lt;") or newPrefix:match("&gt;") or newPrefix:match("&quot;") or newPrefix:match("&#x27;") or newPrefix:match("&#x60;") then
		DoNotif("Encoded/HTML characters are not allowed as a prefix")
	else
		NAmanage.NASettingsSet("prefix", newPrefix)
		opt.prefix = newPrefix
		DoNotif("Prefix saved to: "..newPrefix)
		if not FileSupport then
			DebugNotif("Prefix will reset when Roblox closes (no file support detected).")
		end
		if NAmanage.SyncPrefixUI then
			NAmanage.SyncPrefixUI()
		end
	end
end, true)

--[ UTILITY ]--

cmd.add({"chatlogs","clogs"},{"chatlogs (clogs)","Open the chat logs"},function()
	NAgui.chatlogs()
end)

cmd.add({"gotocampos","tocampos","tcp"},{"gotocampos (tocampos,tcp)","Teleports you to your camera position works with free cam but freezes you"},function()
	local player=Players.LocalPlayer
	function teleportPlayer()
		local character=player.Character or player.CharacterAdded:wait(1)
		local camera=workspace.CurrentCamera
		local cameraPosition=camera.CFrame.Position
		character:SetPrimaryPartCFrame(CFrame.new(cameraPosition))
	end
	local camera=workspace.CurrentCamera
	repeat Wait() until camera.CFrame~=CFrame.new()

	teleportPlayer()
end)

cmd.add({"teleportgui","tpui","universeviewer","uviewer"},{"teleportgui (tpui,universeviewer,uviewer)","Gives an UI that grabs all places and teleports you by clicking a simple button"},function()
	loadstring(game:HttpGet("https://raw.githubusercontent.com/ltseverydayyou/uuuuuuu/main/Universe%20Viewer"))();
end)

cmd.add({"serverremotespy","srs","sremotespy"},{"serverremotespy (srs,sremotespy)","Gives an UI that logs all the remotes being called from the server (thanks SolSpy lol)"},function()
	loadstring(game:HttpGet("https://raw.githubusercontent.com/ltseverydayyou/uuuuuuu/refs/heads/main/Server%20Spy.lua"))()
end)

cmd.add({"discord", "invite", "support", "help"}, {"discord", "Copy an invite link"}, function()
	if setclipboard then
		Window({
			Title = "Discord",
			Description = inviteLink,
			Buttons = {
				{Text = "Copy Link", Callback = function() setclipboard(inviteLink) end},
				{Text = "Close", Callback = function() end}
			}
		})
	else
		Window({
			Title = "Discord",
			Description = "Your exploit does not support setclipboard.\nPlease manually type the invite link: "..inviteLink,
			Buttons = {
				{Text = "Close", Callback = function() end}
			}
		})
	end
	--DoNotif("not available yet", 2)
end)

clickflingUI = nil
clickflingEnabled = true

cmd.add({"clickfling","mousefling"},{"clickfling (mousefling)","Fling a player by clicking them"},function()
	clickflingEnabled = true
	if clickflingUI then clickflingUI:Destroy() end
	NAlib.disconnect("clickfling_mouse")

	local Mouse = player:GetMouse()
	clickflingUI = InstanceNew("ScreenGui")
	NaProtectUI(clickflingUI)

	local toggleButton = InstanceNew("TextButton")
	toggleButton.Size = UDim2.new(0,120,0,40)
	toggleButton.Text = "ClickFling: ON"
	toggleButton.Position = UDim2.new(0.5,-60,0,10)
	toggleButton.TextScaled = 16
	toggleButton.TextColor3 = Color3.new(1,1,1)
	toggleButton.Font = Enum.Font.GothamBold
	toggleButton.BackgroundColor3 = Color3.fromRGB(40,40,40)
	toggleButton.BackgroundTransparency = 0.2
	toggleButton.Parent = clickflingUI

	local uiCorner = InstanceNew("UICorner")
	uiCorner.CornerRadius = UDim.new(0,8)
	uiCorner.Parent = toggleButton

	NAgui.draggerV2(toggleButton)

	MouseButtonFix(toggleButton,function()
		clickflingEnabled = not clickflingEnabled
		if clickflingEnabled then
			toggleButton.Text = "ClickFling: ON"
		else
			toggleButton.Text = "ClickFling: OFF"
		end
	end)

	local conn = Mouse.Button1Down:Connect(function()
		if not clickflingEnabled then return end
		local Target = Mouse.Target
		local Players = game.GetService(game,"Players")
		if Target and Target.Parent and Target.Parent:IsA("Model") and Players:GetPlayerFromCharacter(Target.Parent) then
			local PlayerName = Players:GetPlayerFromCharacter(Target.Parent).Name
			local playerLocal = Players.LocalPlayer
			local Targets = {PlayerName}
			local Players = game.GetService(game,"Players")
			local Player = Players.LocalPlayer
			local AllBool = false

			local GetPlayer = function(Name)
				Name = Lower(Name)
				if Name == "all" or Name == "others" then
					AllBool = true
					return
				elseif Name == "random" then
					local GetPlayers = Players:GetPlayers()
					if Discover(GetPlayers,Player) then table.remove(GetPlayers,Discover(GetPlayers,Player)) end
					return GetPlayers[math.random(#GetPlayers)]
				end
				for _,x in next,Players:GetPlayers() do
					if x~=Player then
						if Sub(Lower(x.Name),1,#Name)==Name or Sub(Lower(x.DisplayName),1,#Name)==Name then
							return x
						end
					end
				end
			end

			local flingManager = flingManager
			local OrgDestroyHeight = workspace.FallenPartsDestroyHeight

			local SkidFling = function(TargetPlayer)
				local Character = Player.Character
				local Humanoid = getPlrHum(Character)
				local RootPart = Humanoid and Humanoid.RootPart
				local TCharacter = TargetPlayer.Character
				local THumanoid = getPlrHum(TCharacter)
				local TRootPart = THumanoid and THumanoid.RootPart
				local THead = getHead(TCharacter)
				local Accessory = TCharacter:FindFirstChildOfClass("Accessory")
				local Handle = Accessory and Accessory:FindFirstChild("Handle")

				if Character and Humanoid and RootPart then
					if not flingManager.cFlingOldPos or RootPart.Velocity.Magnitude<50 then
						flingManager.cFlingOldPos = RootPart.CFrame
					end
					if THead then
						workspace.CurrentCamera.CameraSubject = THead
					elseif Handle then
						workspace.CurrentCamera.CameraSubject = Handle
					elseif THumanoid and TRootPart then
						workspace.CurrentCamera.CameraSubject = THumanoid
					end
					if not TCharacter:FindFirstChildWhichIsA("BasePart") then return end

					local function FPos(BasePart,Pos,Ang)
						RootPart.CFrame = CFrame.new(BasePart.Position)*Pos*Ang
						Character:SetPrimaryPartCFrame(CFrame.new(BasePart.Position)*Pos*Ang)
						RootPart.Velocity = Vector3.new(9e7,9e7*10,9e7)
						RootPart.RotVelocity = Vector3.new(9e8,9e8,9e8)
					end

					local function SFBasePart(BasePart)
						local TimeToWait = 2
						local Time = tick()
						local Angle = 0
						repeat
							if RootPart and THumanoid then
								if BasePart.Velocity.Magnitude<50 then
									Angle=Angle+100
									FPos(BasePart,CFrame.new(0,1.5,0)+THumanoid.MoveDirection*BasePart.Velocity.Magnitude/1.25,CFrame.Angles(math.rad(Angle),0,0)) Wait()
									FPos(BasePart,CFrame.new(0,-1.5,0)+THumanoid.MoveDirection*BasePart.Velocity.Magnitude/1.25,CFrame.Angles(math.rad(Angle),0,0)) Wait()
									FPos(BasePart,CFrame.new(2.25,1.5,-2.25)+THumanoid.MoveDirection*BasePart.Velocity.Magnitude/1.25,CFrame.Angles(math.rad(Angle),0,0)) Wait()
									FPos(BasePart,CFrame.new(-2.25,-1.5,2.25)+THumanoid.MoveDirection*BasePart.Velocity.Magnitude/1.25,CFrame.Angles(math.rad(Angle),0,0)) Wait()
									FPos(BasePart,CFrame.new(0,1.5,0)+THumanoid.MoveDirection,CFrame.Angles(math.rad(Angle),0,0)) Wait()
									FPos(BasePart,CFrame.new(0,-1.5,0)+THumanoid.MoveDirection,CFrame.Angles(math.rad(Angle),0,0)) Wait()
								else
									FPos(BasePart,CFrame.new(0,1.5,THumanoid.WalkSpeed),CFrame.Angles(math.rad(90),0,0)) Wait()
									FPos(BasePart,CFrame.new(0,-1.5,-THumanoid.WalkSpeed),CFrame.Angles(0,0,0)) Wait()
									FPos(BasePart,CFrame.new(0,1.5,THumanoid.WalkSpeed),CFrame.Angles(math.rad(90),0,0)) Wait()
									FPos(BasePart,CFrame.new(0,1.5,TRootPart.Velocity.Magnitude/1.25),CFrame.Angles(math.rad(90),0,0)) Wait()
									FPos(BasePart,CFrame.new(0,-1.5,-TRootPart.Velocity.Magnitude/1.25),CFrame.Angles(0,0,0)) Wait()
									FPos(BasePart,CFrame.new(0,1.5,TRootPart.Velocity.Magnitude/1.25),CFrame.Angles(math.rad(90),0,0)) Wait()
									FPos(BasePart,CFrame.new(0,-1.5,0),CFrame.Angles(math.rad(90),0,0)) Wait()
									FPos(BasePart,CFrame.new(0,-1.5,0),CFrame.Angles(0,0,0)) Wait()
									FPos(BasePart,CFrame.new(0,-1.5,0),CFrame.Angles(math.rad(-90),0,0)) Wait()
									FPos(BasePart,CFrame.new(0,-1.5,0),CFrame.Angles(0,0,0)) Wait()
								end
							else
								break
							end
						until BasePart.Velocity.Magnitude>500 or BasePart.Parent~=TargetPlayer.Character or TargetPlayer.Parent~=Players or TargetPlayer.Character~=TCharacter or THumanoid.Sit or Humanoid.Health<=0 or tick()>Time+TimeToWait
					end

					workspace.FallenPartsDestroyHeight = 0/0

					local BV = InstanceNew("BodyVelocity")
					BV.Parent = RootPart
					BV.Velocity = Vector3.new(9e8,9e8,9e8)
					BV.MaxForce = Vector3.new(1/0,1/0,1/0)

					Humanoid:SetStateEnabled(Enum.HumanoidStateType.Seated,false)

					if TRootPart and THead then
						if (TRootPart.CFrame.p - THead.CFrame.p).Magnitude>5 then SFBasePart(THead) else SFBasePart(TRootPart) end
					elseif TRootPart then
						SFBasePart(TRootPart)
					elseif THead then
						SFBasePart(THead)
					elseif Handle then
						SFBasePart(Handle)
					end

					BV:Destroy()
					Humanoid:SetStateEnabled(Enum.HumanoidStateType.Seated,true)
					workspace.CurrentCamera.CameraSubject = Humanoid

					repeat
						RootPart.CFrame = flingManager.cFlingOldPos*CFrame.new(0,.5,0)
						Character:SetPrimaryPartCFrame(flingManager.cFlingOldPos*CFrame.new(0,.5,0))
						Humanoid:ChangeState("GettingUp")
						for _,x in next,Character:GetChildren() do
							if x:IsA("BasePart") then
								x.Velocity, x.RotVelocity = Vector3.new(),Vector3.new()
							end
						end
						Wait()
					until (RootPart.Position - flingManager.cFlingOldPos.p).Magnitude<25

					workspace.FallenPartsDestroyHeight = OrgDestroyHeight
				end
			end

			getgenv().Welcome = true
			if Targets[1] then
				for _,x in next,Targets do GetPlayer(x) end
			else
				return
			end

			if AllBool then
				for _,x in next,Players:GetPlayers() do SkidFling(x) end
			end

			for _,x in next,Targets do
				local TP = GetPlayer(x)
				if TP and TP~=Player and TP.UserId~=1414978355 then
					SkidFling(TP)
				end
			end
		end
	end)

	NAlib.connect("clickfling_mouse",conn)
end)

cmd.add({"unclickfling","unmousefling"},{"unclickfling (unmousefling)","disables clickfling"},function()
	clickflingEnabled = false
	if clickflingUI then clickflingUI:Destroy() end
	NAlib.disconnect("clickfling_mouse")
end)

NAStuff.NAundergroundState = NAStuff.NAundergroundState or {}
NAStuff.NA_UNDERGROUND_BIND_NAME = NAStuff.NA_UNDERGROUND_BIND_NAME or "NAundergroundBind"
NAStuff.NA_UNDERGROUND_OFFSET = NAStuff.NA_UNDERGROUND_OFFSET or Vector3.new(0, -15, 0)

if RunService and RunService.UnbindFromRenderStep then
	pcall(RunService.UnbindFromRenderStep, RunService, NAStuff.NA_UNDERGROUND_BIND_NAME)
end
do
	local st = NAStuff.NAundergroundState
	if st.heartbeatConnection then
		pcall(function() st.heartbeatConnection:Disconnect() end)
	end
	if st.highlight and st.highlight.Parent then
		pcall(function() st.highlight:Destroy() end)
	end
	st.Underground = false
	st.UndergroundBind = false
	st.UndergroundCurrent = nil
	st.heartbeatConnection = nil
	st.highlight = nil
end

cmd.add({"offset","offpos","off"},{"offset [x y z|y]","Offsets your character for others (positive Y = up, negative Y = down)"},function(...)
	local state = NAStuff.NAundergroundState

	local function UG_Get(key)
		return state[key]
	end
	local function UG_Set(key, val)
		state[key] = val
		return val
	end

	local function fetchCharPieces()
		local chr = getChar()
		if not chr then
			return nil, nil, nil
		end
		local hum = getHum()
		local root = getRoot(chr)
		if not root then
			for _, part in ipairs(chr:GetChildren()) do
				if part:IsA("BasePart") then
					root = part
					break
				end
			end
		end
		return chr, root, hum
	end

	local character, rootPart, humanoid = fetchCharPieces()
	if not (character and rootPart and humanoid) then
		if type(DoNotif) == "function" then
			DoNotif("Character is not ready yet", 2)
		end
		return
	end

	local defaultOffset = NAStuff.NA_UNDERGROUND_OFFSET or Vector3.new(0, -15, 0)
	local function parseOffsetVector(...)
		local raw = Concat({...}, " ")
		local nums = {}
		for token in tostring(raw):gmatch("[^,%s]+") do
			local n = tonumber(token)
			if n then
				Insert(nums, n)
			end
		end
		if #nums >= 3 then
			return Vector3.new(nums[1], nums[2], nums[3])
		elseif #nums == 2 then
			return Vector3.new(nums[1], nums[2], 0)
		elseif #nums == 1 then
			return Vector3.new(0, nums[1], 0)
		end
		return nil
	end
	local offsetVec = parseOffsetVector(...) or defaultOffset

	local Underground = UG_Get("Underground")
	UG_Set("Underground", not Underground)

	if not Underground then
		UG_Set("UndergroundCurrent", rootPart.CFrame)
		UG_Set("UndergroundOffset", offsetVec)

		local prevHB = UG_Get("heartbeatConnection")
		if prevHB then
			pcall(function() prevHB:Disconnect() end)
		end

		UG_Set("heartbeatConnection", RunService.Heartbeat:Connect(function()
			if not UG_Get("Underground") then
				return
			end

			local _, currentRoot, hum = fetchCharPieces()
			if not currentRoot then
				return
			end

			UG_Set("UndergroundCurrent", currentRoot.CFrame)
			if hum then
				hum.Sit = false
			end

			currentRoot.CFrame = currentRoot.CFrame + (UG_Get("UndergroundOffset") or defaultOffset)
		end))

		if RunService and RunService.UnbindFromRenderStep then
			pcall(RunService.UnbindFromRenderStep, RunService, NAStuff.NA_UNDERGROUND_BIND_NAME)
		end
		UG_Set("UndergroundBind", true)
		RunService:BindToRenderStep(NAStuff.NA_UNDERGROUND_BIND_NAME, Enum.RenderPriority.First.Value, function()
			local current = UG_Get("UndergroundCurrent")
			if UG_Get("Underground") and current then
				local _, r = fetchCharPieces()
				if r then
					r.CFrame = current
				end
			end
		end)

		if type(DoNotif) == "function" then
			DoNotif("Offset enabled (replicates for others)", 2)
		end
		return
	end

	for _ = 1, 10 do
		local _, r = fetchCharPieces()
		if r then
			r.CFrame = UG_Get("UndergroundCurrent") or r.CFrame
		end
		Wait()
	end

	UG_Set("UndergroundCurrent", nil)

	local hb = UG_Get("heartbeatConnection")
	if hb then
		hb:Disconnect()
		UG_Set("heartbeatConnection", nil)
	end
	UG_Set("UndergroundOffset", nil)
	if UG_Get("UndergroundBind") then
		UG_Set("UndergroundBind", false)
		if RunService and RunService.UnbindFromRenderStep then
			pcall(RunService.UnbindFromRenderStep, RunService, NAStuff.NA_UNDERGROUND_BIND_NAME)
		end
	end

	if type(DoNotif) == "function" then
		DoNotif("Offset disabled, you're back to normal", 2)
	end
	return
end)

clickscareUI = nil
clickscareEnabled = true

cmd.add({"clickscare","clickspook"},{"clickscare (clickspook)","Teleports next to a clicked player for a few seconds"},function()
	clickscareEnabled = true
	if clickscareUI then clickscareUI:Destroy() end
	NAlib.disconnect("clickscare_mouse")

	local Mouse = player:GetMouse()
	clickscareUI = InstanceNew("ScreenGui")
	NaProtectUI(clickscareUI)

	local toggleButton = InstanceNew("TextButton")
	toggleButton.Size = UDim2.new(0,120,0,40)
	toggleButton.Text = "ClickScare: ON"
	toggleButton.Position = UDim2.new(0.5,-60,0,10)
	toggleButton.TextScaled = 16
	toggleButton.TextColor3 = Color3.new(1,1,1)
	toggleButton.Font = Enum.Font.GothamBold
	toggleButton.BackgroundColor3 = Color3.fromRGB(40,40,40)
	toggleButton.BackgroundTransparency = 0.2
	toggleButton.Parent = clickscareUI

	local uiCorner = InstanceNew("UICorner")
	uiCorner.CornerRadius = UDim.new(0,8)
	uiCorner.Parent = toggleButton

	NAgui.draggerV2(toggleButton)

	MouseButtonFix(toggleButton,function()
		clickscareEnabled = not clickscareEnabled
		toggleButton.Text = clickscareEnabled and "ClickScare: ON" or "ClickScare: OFF"
	end)

	local conn = Mouse.Button1Down:Connect(function()
		if not clickscareEnabled then return end
		local target = Mouse.Target
		if not (target and target.Parent and target.Parent:IsA("Model")) then return end
		local clickedPlayer = Players:GetPlayerFromCharacter(target.Parent)
		if not clickedPlayer or not getPlrHum(clickedPlayer) then return end

		local char = getChar()
		local root = getRoot(char)
		local oldCF = root.CFrame
		local distancepl = 2
		local targetRoot = getRoot(clickedPlayer.Character)
		if targetRoot then
			root.CFrame = targetRoot.CFrame + targetRoot.CFrame.LookVector * distancepl
			root.CFrame = CFrame.new(root.Position, targetRoot.Position)
			Wait(0.5)
			root.CFrame = oldCF
		end
	end)

	NAlib.connect("clickscare_mouse",conn)
end)

cmd.add({"unclickscare","unclickspook"},{"unclickscare (unclickspook)","Disables clickscare"},function()
	clickscareEnabled = false
	if clickscareUI then clickscareUI:Destroy() end
	NAlib.disconnect("clickscare_mouse")
end)

hoverNameGui = nil
hoverNameLabel = nil
hoverNameSelection = nil

NAmanage.cleanupHoverName=function()
	NAlib.disconnect("hovername_track")
	if hoverNameLabel then
		hoverNameLabel:Destroy()
		hoverNameLabel = nil
	end
	if hoverNameGui then
		hoverNameGui:Destroy()
		hoverNameGui = nil
	end
	if hoverNameSelection then
		hoverNameSelection.Adornee = nil
		hoverNameSelection.Parent = nil
		hoverNameSelection:Destroy()
		hoverNameSelection = nil
	end
end

cmd.add({"hovername","namehover"}, {"hovername", "Shows player's username on hover"}, function()
	NAmanage.cleanupHoverName()

	hoverNameGui = InstanceNew("ScreenGui")
	NaProtectUI(hoverNameGui)

	hoverNameLabel = InstanceNew("TextLabel")
	hoverNameLabel.BackgroundTransparency = 1
	hoverNameLabel.Size = UDim2.new(0,200,0,30)
	hoverNameLabel.Font = Enum.Font.GothamBold
	hoverNameLabel.TextSize = 16
	hoverNameLabel.Text = ""
	hoverNameLabel.TextColor3 = Color3.new(1,1,1)
	hoverNameLabel.TextStrokeTransparency = 0
	hoverNameLabel.TextXAlignment = Enum.TextXAlignment.Left
	hoverNameLabel.Visible = false
	hoverNameLabel.ZIndex = 10
	hoverNameLabel.Parent = hoverNameGui

	hoverNameSelection = InstanceNew("SelectionBox")
	NAProtection(hoverNameSelection)
	hoverNameSelection.LineThickness = 0.03
	hoverNameSelection.Color3 = Color3.new(1,1,1)
	hoverNameSelection.Adornee = nil
	hoverNameSelection.Parent = nil

	local mouse = player and player:GetMouse()
	if not mouse then
		NAmanage.cleanupHoverName()
		return
	end

	local function updateHoverName()
		local target = mouse.Target
		local character
		if target then
			local parent = target.Parent
			if parent then
				local humanoid = parent:FindFirstChildOfClass("Humanoid")
				if not humanoid and parent.Parent then
					humanoid = parent.Parent:FindFirstChildOfClass("Humanoid")
				end
				if humanoid then
					character = humanoid.Parent
				end
			end
		end

		if character and character:IsA("Model") then
			local isPlr = nil
			if Players:GetPlayerFromCharacter(character) then isPlr=Players:GetPlayerFromCharacter(character) end
			local x = mouse.X
			local y = mouse.Y
			local xPos
			if x > 200 then
				xPos = x - 205
				hoverNameLabel.TextXAlignment = Enum.TextXAlignment.Right
			else
				xPos = x + 25
				hoverNameLabel.TextXAlignment = Enum.TextXAlignment.Left
			end
			hoverNameLabel.Position = UDim2.new(0, xPos, 0, y)
			hoverNameLabel.Text = nameChecker(isPlr or character)
			hoverNameLabel.Visible = true
			hoverNameSelection.Parent = character
			hoverNameSelection.Adornee = character
		else
			hoverNameLabel.Visible = false
			hoverNameSelection.Parent = nil
			hoverNameSelection.Adornee = nil
		end
	end

	NAlib.disconnect("hovername_track")
	NAlib.connect("hovername_track", mouse.Move:Connect(updateHoverName))
	updateHoverName()
end)

cmd.add({"unhovername","unnamehover"}, {"unhovername", "Disables hovername"}, function()
	NAmanage.cleanupHoverName()
end)

cmd.add({"resetfilter", "ref"}, {"resetfilter","If Roblox keeps tagging your messages, run this to reset the filter"}, function()
	for Index = 1, 3 do
		Players:Chat(Format("/e hi"))
	end
	return "Filter", "Reset"
end)

NAstatsUI = {}
windowCounter = (windowCounter or 0)
windowRegistry = windowRegistry or {}
StatsService = SafeGetService("Stats")

NAstatsUI.Theme = {
	Colors = {
		Background = Color3.fromRGB(10, 12, 20),
		Primary = Color3.fromRGB(20, 23, 34),
		Secondary = Color3.fromRGB(30, 33, 46),
		Border = Color3.fromRGB(70, 75, 95),
		Accent = Color3.fromRGB(90, 190, 255),
		Text = Color3.fromRGB(235, 238, 250),
		TextMuted = Color3.fromRGB(150, 154, 174),
		TextSubtle = Color3.fromRGB(205, 208, 222),
		Close = Color3.fromRGB(230, 80, 90),
		Minimize = Color3.fromRGB(110, 130, 255),
		Good = Color3.fromRGB(0, 255, 140),
		Warn = Color3.fromRGB(255, 210, 0),
		Bad = Color3.fromRGB(255, 90, 90),
	},
	Fonts = {
		Title = Enum.Font.GothamSemibold,
		Body = Enum.Font.Gotham,
		BodySemibold = Enum.Font.GothamSemibold,
		BodyBold = Enum.Font.GothamBold,
	},
	Radius = {
		Window = UDim.new(0, 14),
		Container = UDim.new(0, 12),
		Button = UDim.new(1, 0),
	},
	Sizes = {
		TopBarHeight = IsOnMobile and 42 or 30,
		ActionButton = IsOnMobile and 24 or 20,
	}
}

NAstatsUI.createInstance = function(className, properties, parent)
	local inst = InstanceNew(className)
	for prop, value in pairs(properties) do
		inst[prop] = value
	end
	if parent then
		inst.Parent = parent
	end
	return inst
end

function NAstatsUI.colorToHex(c)
	return Format("#%02X%02X%02X", math.floor(c.R * 255), math.floor(c.G * 255), math.floor(c.B * 255))
end

function NAstatsUI.ensureSingle(key, buildFn)
	local existing = windowRegistry[key]
	if existing and existing.screenGui and existing.screenGui.Parent then
		existing.bringToFront()
		return existing
	end

	local newUi = buildFn()
	windowRegistry[key] = newUi

	local originalCloseFunction = newUi.closeFunction
	MouseButtonFix(newUi.closeButton, function()
		if windowRegistry[key] == newUi then
			windowRegistry[key] = nil
		end
		if originalCloseFunction then
			originalCloseFunction()
		end
		newUi.screenGui:Destroy()
	end)
	return newUi
end

function NAstatsUI.createWindow(position, baseSize, titleText)
	windowCounter += 1
	local T = NAstatsUI.Theme

	local screenGui = NAstatsUI.createInstance("ScreenGui", {
		ResetOnSpawn = false,
		ZIndexBehavior = Enum.ZIndexBehavior.Sibling,
		DisplayOrder = 100 + windowCounter,
	})
	NaProtectUI(screenGui)

	local holder = NAstatsUI.createInstance("Frame", {
		Name = "Holder",
		BackgroundTransparency = 1,
		AnchorPoint = Vector2.new(0.5, 0.5),
		Position = position or UDim2.new(0.5, 0, 0.3, 0),
		Size = baseSize,
		Parent = screenGui,
	})

	local window = NAstatsUI.createInstance("Frame", {
		Name = "Window",
		BackgroundColor3 = T.Colors.Primary,
		BorderSizePixel = 0,
		Size = UDim2.new(1, 0, 1, 0),
		Parent = holder
	})
	NAstatsUI.createInstance("UICorner", { CornerRadius = T.Radius.Window }, window)
	NAstatsUI.createInstance("UIStroke", {
		Color = T.Colors.Border,
		Thickness = 1.2,
		ApplyStrokeMode = Enum.ApplyStrokeMode.Border
	}, window)
	NAstatsUI.createInstance("UIGradient", {
		Color = ColorSequence.new({
			ColorSequenceKeypoint.new(0, Color3.fromRGB(7, 9, 16)),
			ColorSequenceKeypoint.new(1, T.Colors.Primary),
		}),
		Rotation = 90,
	}, window)

	local topBar = NAstatsUI.createInstance("Frame", {
		Name = "TopBar",
		BackgroundColor3 = Color3.fromRGB(16, 18, 27),
		BorderSizePixel = 0,
		Size = UDim2.new(1, 0, 0, T.Sizes.TopBarHeight),
		ZIndex = 2,
		Parent = window,
	})
	NAstatsUI.createInstance("UICorner", {
		CornerRadius = UDim.new(0, T.Radius.Window.Offset),
	}, topBar)

	NAstatsUI.createInstance("UIPadding", {
		PaddingLeft = UDim.new(0, 10),
		PaddingRight = UDim.new(0, 8),
	}, topBar)

	local title = NAstatsUI.createInstance("TextLabel", {
		Name = "Title",
		BackgroundTransparency = 1,
		Size = UDim2.new(1, -80, 1, 0),
		Font = T.Fonts.Title,
		Text = titleText,
		TextColor3 = T.Colors.Text,
		TextSize = IsOnMobile and 16 or 14,
		TextXAlignment = Enum.TextXAlignment.Left,
		RichText = true,
		ZIndex = 3,
		Parent = topBar,
	})

	local function createActionButton(name, text, color, order)
		local btn = NAstatsUI.createInstance("TextButton", {
			Name = name,
			BackgroundColor3 = color,
			Size = UDim2.fromOffset(T.Sizes.ActionButton, T.Sizes.ActionButton),
			AnchorPoint = Vector2.new(1, 0.5),
			Position = UDim2.new(1, -(4 + (order - 1) * (T.Sizes.ActionButton + 4)), 0.5, 0),
			Font = T.Fonts.BodyBold,
			Text = text,
			TextScaled = true,
			TextColor3 = Color3.new(1, 1, 1),
			ZIndex = 3,
			RichText = true,
			Parent = topBar,
		})
		NAstatsUI.createInstance("UICorner", { CornerRadius = UDim.new(1, 0) }, btn)
		return btn
	end

	local minimizeButton = createActionButton("Minimize", "–", T.Colors.Minimize, 2)
	local closeButton = createActionButton("Close", "X", T.Colors.Close, 1)

	local content = NAstatsUI.createInstance("Frame", {
		Name = "Content",
		BackgroundTransparency = 1,
		Position = UDim2.new(0, 10, 0, T.Sizes.TopBarHeight + 6),
		Size = UDim2.new(1, -20, 1, -(T.Sizes.TopBarHeight + 14)),
		ZIndex = 2,
		Parent = window
	})
	NAstatsUI.createInstance("UIPadding", {
		PaddingLeft = UDim.new(0, 8),
		PaddingRight = UDim.new(0, 8),
		PaddingTop = UDim.new(0, 6),
		PaddingBottom = UDim.new(0, 6),
	}, content)

	NAgui.draggerV2(holder, topBar)
	local collapsed = false
	local baseTitleText = titleText
	local collapsedTitleText = titleText
	local storedSize = baseSize

	MouseButtonFix(minimizeButton, function()
		collapsed = not collapsed
		content.Visible = not collapsed
		if collapsed then
			storedSize = holder.Size
			holder.Size = UDim2.fromOffset(holder.AbsoluteSize.X, T.Sizes.TopBarHeight + 8)
			title.Text = collapsedTitleText
		else
			holder.Size = storedSize
			title.Text = baseTitleText
		end
	end)

	return {
		screenGui = screenGui,
		holder = holder,
		window = window,
		title = title,
		content = content,
		closeButton = closeButton,
		minimizeButton = minimizeButton,
		setBaseTitle = function(t)
			baseTitleText = t
			if not collapsed then
				title.Text = t
			end
		end,
		setCollapsedTitle = function(t)
			collapsedTitleText = t
			if collapsed then
				title.Text = t
			end
		end,
		bringToFront = function()
			windowCounter += 1
			screenGui.DisplayOrder = 100 + windowCounter
		end,
	}
end

function NAstatsUI.createStatDisplay(parent, titleText, subtitleText)
	local T = NAstatsUI.Theme
	local container = NAstatsUI.createInstance("Frame", {
		BackgroundTransparency = 1,
		Size = UDim2.new(1, 0, 1, 0),
		Parent = parent,
	})

	NAstatsUI.createInstance("UIPadding", {
		PaddingTop = UDim.new(0, 2),
		PaddingBottom = UDim.new(0, 2),
		PaddingLeft = UDim.new(0, 4),
		PaddingRight = UDim.new(0, 4),
	}, container)

	local titleHeight = IsOnMobile and 16 or 14
	local valueHeight = IsOnMobile and 26 or 24

	local titleLabel = NAstatsUI.createInstance("TextLabel", {
		Name = "TitleLabel",
		BackgroundTransparency = 1,
		Size = UDim2.new(1, 0, 0, titleHeight),
		Font = T.Fonts.BodySemibold,
		Text = titleText,
		TextSize = IsOnMobile and 13 or 12,
		TextColor3 = T.Colors.TextMuted,
		TextXAlignment = Enum.TextXAlignment.Left,
		TextTruncate = Enum.TextTruncate.AtEnd,
		RichText = true,
		Parent = container,
	})

	local valueLabel = NAstatsUI.createInstance("TextLabel", {
		Name = "ValueLabel",
		BackgroundTransparency = 1,
		Position = UDim2.new(0, 0, 0, titleHeight + 2),
		Size = UDim2.new(1, 0, 0, valueHeight),
		Font = T.Fonts.BodyBold,
		Text = "—",
		TextSize = IsOnMobile and 23 or 21,
		TextColor3 = T.Colors.TextSubtle,
		TextXAlignment = Enum.TextXAlignment.Left,
		TextTruncate = Enum.TextTruncate.AtEnd,
		RichText = true,
		Parent = container,
	})

	local subtitleLabel = NAstatsUI.createInstance("TextLabel", {
		Name = "SubtitleLabel",
		BackgroundTransparency = 1,
		Position = UDim2.new(0, 0, 0, titleHeight + valueHeight + 4),
		Size = UDim2.new(1, 0, 0, IsOnMobile and 16 or 14),
		Font = T.Fonts.Body,
		Text = subtitleText,
		TextSize = IsOnMobile and 12 or 12,
		TextColor3 = T.Colors.TextMuted,
		TextXAlignment = Enum.TextXAlignment.Left,
		TextTruncate = Enum.TextTruncate.AtEnd,
		RichText = true,
		Parent = container,
	})

	return { value = valueLabel, subtitle = subtitleLabel, title = titleLabel }
end

function NAstatsUI.createStatCommand(config)
	return NAstatsUI.ensureSingle(config.key, function()
		local baseHeight = IsOnMobile and 120 or 110
		local baseWidth = IsOnMobile and 230 or 210
		local ui = NAstatsUI.createWindow(config.position, UDim2.new(0, baseWidth, 0, baseHeight), config.title)
		local statDisplay = NAstatsUI.createStatDisplay(ui.content, config.title, config.subtitle)
		local lastUpdate = 0
		local updateInterval = 0.5

		local conn = RunService.RenderStepped:Connect(function(dt)
			local now = os.clock()
			if now - lastUpdate < updateInterval then
				return
			end

			local value, rawValue = config.updateFn(dt)
			local color = config.colorFn(rawValue)

			statDisplay.value.Text = "<b>"..value.."</b>"
			statDisplay.value.TextColor3 = color

			local collapsedText = Format("%s: <font color='%s'>%s</font>", config.title, NAstatsUI.colorToHex(color), value)
			ui.setCollapsedTitle(collapsedText)

			lastUpdate = now
		end)
		NAlib.connect("UI:"..config.key, conn)
		ui.closeFunction = function()
			NAlib.disconnect("UI:"..config.key)
		end

		return ui
	end)
end

function NAstatsUI.createStatBox(parent, titleText)
	local T = NAstatsUI.Theme
	local boxHeight = IsOnMobile and 76 or 68
	local boxWidthScale = IsOnMobile and 1 or 0.5
	local boxWidthOffset = IsOnMobile and 0 or -6

	local box = NAstatsUI.createInstance("Frame", {
		BackgroundColor3 = T.Colors.Secondary,
		Size = UDim2.new(boxWidthScale, boxWidthOffset, 0, boxHeight),
		Parent = parent,
	})
	NAstatsUI.createInstance("UICorner", { CornerRadius = T.Radius.Container }, box)
	NAstatsUI.createInstance("UIStroke", {
		Color = T.Colors.Border,
		Thickness = 1,
		ApplyStrokeMode = Enum.ApplyStrokeMode.Border
	}, box)

	NAstatsUI.createInstance("UIPadding", {
		PaddingTop = UDim.new(0, 8),
		PaddingBottom = UDim.new(0, 8),
		PaddingLeft = UDim.new(0, 10),
		PaddingRight = UDim.new(0, 10),
	}, box)

	local titleHeight = IsOnMobile and 18 or 16
	local valueHeight = IsOnMobile and 22 or 20

	local title = NAstatsUI.createInstance("TextLabel", {
		Name = "Title",
		BackgroundTransparency = 1,
		Position = UDim2.new(0, 0, 0, 0),
		Size = UDim2.new(1, 0, 0, titleHeight),
		Font = T.Fonts.BodySemibold,
		Text = titleText,
		TextSize = IsOnMobile and 14 or 13,
		TextColor3 = T.Colors.TextMuted,
		TextXAlignment = Enum.TextXAlignment.Left,
		TextTruncate = Enum.TextTruncate.AtEnd,
		RichText = true,
		Parent = box,
	})

	local valueLabel = NAstatsUI.createInstance("TextLabel", {
		Name = "Value",
		BackgroundTransparency = 1,
		Position = UDim2.new(0, 0, 0, titleHeight + 2),
		Size = UDim2.new(1, 0, 0, valueHeight),
		Font = T.Fonts.BodyBold,
		Text = "—",
		TextSize = IsOnMobile and 18 or 16,
		TextColor3 = T.Colors.TextSubtle,
		TextXAlignment = Enum.TextXAlignment.Right,
		TextTruncate = Enum.TextTruncate.AtEnd,
		RichText = true,
		Parent = box,
	})

	local barBg = NAstatsUI.createInstance("Frame", {
		Name = "BarBg",
		BackgroundColor3 = Color3.fromRGB(18, 20, 30),
		BorderSizePixel = 0,
		AnchorPoint = Vector2.new(0, 1),
		Position = UDim2.new(0, 0, 1, 0),
		Size = UDim2.new(1, 0, 0, 3),
		Parent = box,
	})
	NAstatsUI.createInstance("UICorner", { CornerRadius = UDim.new(0, 2) }, barBg)

	local bar = NAstatsUI.createInstance("Frame", {
		Name = "Bar",
		BackgroundColor3 = T.Colors.Accent,
		BorderSizePixel = 0,
		Size = UDim2.new(0, 0, 1, 0),
		Parent = barBg,
	})
	NAstatsUI.createInstance("UICorner", { CornerRadius = UDim.new(0, 2) }, bar)

	return box, valueLabel, bar
end

cmd.add({ "ping" }, { "ping", "Shows your network latency" }, function()
	local T = NAstatsUI.Theme
	NAstatsUI.createStatCommand({
		key = "Ping",
		title = "Ping",
		subtitle = "Network latency",
		position = UDim2.new(0.5, 0, 0.22, 0),
		updateFn = function()
			local pingItem = StatsService.Network.ServerStatsItem["Data Ping"]
			local rawPing = tonumber(pingItem:GetValueString():match("%d+")) or 0
			return tostring(rawPing).." ms", rawPing
		end,
		colorFn = function(ping)
			if ping <= 50 then
				return T.Colors.Good
			end
			if ping <= 100 then
				return T.Colors.Warn
			end
			return T.Colors.Bad
		end,
	})
end)

cmd.add({ "fps" }, { "fps", "Shows your frames per second" }, function()
	local T = NAstatsUI.Theme
	local frameHistory = {}

	NAstatsUI.createStatCommand({
		key = "FPS",
		title = "FPS",
		subtitle = "Frames per second",
		position = UDim2.new(0.5, 0, 0.36, 0),
		updateFn = function(dt)
			Insert(frameHistory, dt)
			if #frameHistory > 60 then
				table.remove(frameHistory, 1)
			end

			local sum = 0
			for _, frameTime in ipairs(frameHistory) do
				sum += frameTime
			end
			local avg = sum / math.max(1, #frameHistory)
			local fps = math.floor(1 / avg + 0.5)

			return tostring(fps), fps
		end,
		colorFn = function(fps)
			if fps >= 55 then
				return T.Colors.Good
			end
			if fps >= 30 then
				return T.Colors.Warn
			end
			return T.Colors.Bad
		end,
	})
end)

cmd.add({ "stats" }, { "stats", "Shows both FPS and ping" }, function()
	local existing = windowRegistry["Stats"]
	if existing and existing.screenGui and existing.screenGui.Parent then
		NAlib.disconnect("UI:Stats")
		existing.screenGui:Destroy()
		windowRegistry["Stats"] = nil
	end

	local T = NAstatsUI.Theme
	local height = IsOnMobile and 180 or 150
	local width = IsOnMobile and 300 or 270
	local ui = NAstatsUI.createWindow(UDim2.new(0.5, 0, 0.32, 0), UDim2.new(0, width, 0, height), "Stats")

	windowRegistry["Stats"] = ui

	local grid = NAstatsUI.createInstance("Frame", {
		BackgroundTransparency = 1,
		Size = UDim2.new(1, 0, 1, 0),
		Parent = ui.content
	})

	local layout = NAstatsUI.createInstance("UIListLayout", {
		FillDirection = IsOnMobile and Enum.FillDirection.Vertical or Enum.FillDirection.Horizontal,
		HorizontalAlignment = Enum.HorizontalAlignment.Center,
		VerticalAlignment = Enum.VerticalAlignment.Top,
		SortOrder = Enum.SortOrder.LayoutOrder,
		Padding = UDim.new(0, IsOnMobile and 8 or 10),
		Parent = grid,
	})

	local pingBox, pingValue, pingBar = NAstatsUI.createStatBox(grid, "Ping")
	local fpsBox, fpsValue, fpsBar = NAstatsUI.createStatBox(grid, "FPS")

	pingBox.LayoutOrder = 1
	fpsBox.LayoutOrder = 2

	local frames = {}
	local lastUpdate = 0
	local updateInterval = 0.5

	local pingColorFn = function(p)
		if p <= 50 then
			return T.Colors.Good
		end
		if p <= 100 then
			return T.Colors.Warn
		end
		return T.Colors.Bad
	end

	local fpsColorFn = function(f)
		if f >= 55 then
			return T.Colors.Good
		end
		if f >= 30 then
			return T.Colors.Warn
		end
		return T.Colors.Bad
	end

	local conn = RunService.RenderStepped:Connect(function(dt)
		Insert(frames, dt)
		if #frames > 60 then
			table.remove(frames, 1)
		end
		local t = os.clock()
		if t - lastUpdate < updateInterval then
			return
		end

		local sum = 0
		for i = 1, #frames do
			sum += frames[i]
		end
		local avg = sum / math.max(1, #frames)
		local fps = math.max(1, math.floor(1 / avg + 0.5))

		local pingItem = StatsService.Network.ServerStatsItem["Data Ping"]
		local p = tonumber(pingItem:GetValueString():match("%d+")) or 0

		pingValue.Text = "<b>"..tostring(p).." ms</b>"
		pingValue.TextColor3 = pingColorFn(p)
		fpsValue.Text = "<b>"..tostring(fps).."</b>"
		fpsValue.TextColor3 = fpsColorFn(fps)

		local pingRatio = math.clamp(p == 0 and 0 or 1 - (p / 300), 0, 1)
		local fpsRatio = math.clamp(fps / 120, 0, 1)

		pingBar.Size = UDim2.new(pingRatio, 0, 1, 0)
		pingBar.BackgroundColor3 = pingColorFn(p)
		fpsBar.Size = UDim2.new(fpsRatio, 0, 1, 0)
		fpsBar.BackgroundColor3 = fpsColorFn(fps)

		local collapsedTitle = Format(
			"Stats: <font color='%s'>%d ms</font> | <font color='%s'>%d FPS</font>",
			NAstatsUI.colorToHex(pingColorFn(p)),
			p,
			NAstatsUI.colorToHex(fpsColorFn(fps)),
			fps
		)
		ui.setCollapsedTitle(collapsedTitle)
		lastUpdate = t
	end)
	NAlib.connect("UI:Stats", conn)

	MouseButtonFix(ui.closeButton, function()
		NAlib.disconnect("UI:Stats")
		if windowRegistry["Stats"] == ui then
			windowRegistry["Stats"] = nil
		end
		ui.screenGui:Destroy()
	end)
end)

cmd.add({"commands","cmds"},{"commands","Open the command list"},function()
	NAgui.commands()
end)

cmd.add({"settings"},{"settings","Open the settings menu"},function()
	NAgui.settingss()
end)

cmd.add({"waypoints", "wp"},{"waypoints","Open the waypoints menu"},function()
	NAgui.waypointers()
end)

cmd.add({"binders", "binds"},{"binders","Open the event binder menu"},function()
	NAgui.eventbinders()
end)

cmd.add({"setwaypoint","setwp"},{"setwaypoint <name>", "Store your current position under that name"},function(name)
	if not name or name == "" then
		DoNotif("Usage: setwaypoint <name>")
		return
	end

	local char = getChar() or LocalPlayer.CharacterAdded:Wait()
	local cf
	if char then
		cf = char:GetPivot()
	end

	if not cf then
		DoNotif("Unable to get your character's position.")
		return
	end

	Waypoints[name] = { Components = { cf:GetComponents() } }
	NAmanage.SaveWaypoints()
	NAmanage.UpdateWaypointList()
	DebugNotif(("Waypoint '%s' set."):format(name))
end,true)

cmd.add({"gotowaypoint","gotowp"},{"gotowaypoint <name>", "Teleport to a saved waypoint"},function(name)
	if not name or name == "" then
		DoNotif("Usage: gotowaypoint <name>")
		return
	end
	local entry = Waypoints[name]
	if not entry then
		DoNotif(("No such waypoint '%s'."):format(name))
		return
	end
	local comps = entry.Components
	if type(comps) ~= "table" then
		DoNotif(("Waypoint '%s' is invalid."):format(name))
		return
	end
	local ok, cf = pcall(function()
		return CFrame.new(unpack(comps))
	end)
	if not ok or typeof(cf) ~= "CFrame" then
		DoNotif(("Failed to load waypoint '%s'."):format(name))
		return
	end
	local char = getChar()
	if not char then
		char = LocalPlayer and LocalPlayer.Character or nil
		if not char and LocalPlayer then
			char = LocalPlayer.CharacterAdded:Wait()
		end
	end
	if not char then
		DoNotif("Unable to get your character.")
		return
	end
	char:PivotTo(cf)
	DebugNotif(("Teleported to waypoint '%s'."):format(name))
end,true)

cmd.add({"removewaypoint","removewp","rwp"},{"removewaypoint <name>", "Remove a saved waypoint"},function(name)
	if not name or name == "" then
		DoNotif("Usage: removewaypoint <name>")
		return
	end

	if Waypoints[name] then
		Waypoints[name] = nil
		NAmanage.SaveWaypoints()
		NAmanage.UpdateWaypointList()
		DebugNotif(("Waypoint '%s' removed."):format(name))
	else
		DoNotif(("No such waypoint '%s'."):format(name))
	end
end,true)

debugUI, debugDock, isMinimized = nil, nil, false

cmd.add({"chardebug","cdebug"},{"chardebug (cdebug)","debug your character"},function()
	local CONN_KEY = "CharDebug"
	local RENDER_BIND = "CharDebug"

	local LogService = SafeGetService("LogService")
	local StatsService = SafeGetService("Stats")
	local CoreGui = SafeGetService("CoreGui")

	local UI_BASE = Vector2.new(860, 520)
	local HEADER_H = 48
	local TAB_H = 36
	local BG_COLOR = Color3.fromRGB(20, 20, 20)
	local PANEL_BG = Color3.fromRGB(26, 26, 26)
	local ACCENT = Color3.fromRGB(95, 165, 255)
	local UPDATE_RATE = 1/30
	local MAX_LOGS = 600

	local LocalPlayer = Players.LocalPlayer
	local paused = false
	local fps, fpsAlpha, dtAcc = 0, 0, 0
	local lastDt = UPDATE_RATE
	local activeTab = "Overview"
	local logs, errCount, warnCount, infoCount = {}, 0, 0, 0

	local cam = workspace.CurrentCamera
	local vp = cam and cam.ViewportSize or Vector2.new(1920,1080)
	local w = math.min(UI_BASE.X, vp.X * (IsOnMobile and 0.96 or 0.7))
	local h = math.min(UI_BASE.Y, vp.Y * (IsOnMobile and 0.86 or 0.75))
	local UI_SIZE = Vector2.new(w, h)

	if debugUI then
		if debugDock then
			pcall(function() debugDock:Destroy() end)
			debugDock = nil
		end
		debugUI:Destroy()
		debugUI = nil
		NAlib.disconnect(CONN_KEY)
		RunService:UnbindFromRenderStep(RENDER_BIND)
		return
	end

	local function velOf(r)
		if not r then return Vector3.zero end
		local v = NAlib.isProperty(r,"AssemblyLinearVelocity") or Vector3.zero
		if v.Magnitude == 0 and NAlib.isProperty(r,"Velocity") then v = r.Velocity end
		return v
	end
	local function angVelOf(r)
		if not r then return Vector3.zero end
		local v = NAlib.isProperty(r,"AssemblyAngularVelocity") or Vector3.zero
		if NAlib.isProperty(r,"RotVelocity") then v = r.RotVelocity end
		return v
	end
	local function char() return LocalPlayer.Character end
	local function hum() local c=char() return c and getHum() or nil end
	local function root(c)
		c = c or char()
		return c and (c:FindFirstChild("HumanoidRootPart") or c:FindFirstChild("Torso") or c:FindFirstChild("UpperTorso")) or nil
	end
	local function raycastDown(origin, dist)
		local params = RaycastParams.new()
		params.FilterType = Enum.RaycastFilterType.Exclude
		local c = char()
		params.FilterDescendantsInstances = c and {c} or {}
		return workspace:Raycast(origin, Vector3.new(0,-math.abs(dist or 1000),0), params)
	end
	local function getPingMs()
		local ok,ms = pcall(function()
			local net = StatsService:FindFirstChild("Network")
			if not net then return nil end
			local p = (net:FindFirstChild("ServerStatsItem") and net.ServerStatsItem:FindFirstChild("Data Ping")) or net:FindFirstChild("Data Ping")
			if not p then return nil end
			if p.GetValue then
				local v = p:GetValue()
				if typeof(v) == "number" then return v end
			end
			if p.GetValueString then
				local s = p:GetValueString()
				if type(s) == "string" then
					local n = tonumber((s:gsub("[^%d%.]","")))
					return n
				end
			end
			return nil
		end)
		if ok then return ms end
		return nil
	end
	local function getMem()
		local ok,total = pcall(function() return StatsService:GetTotalMemoryUsageMb() end)
		local tags = {"Internal","Instances","Signals","Physics","GraphicsTexture","LuaHeap","HttpCache","Animation","Pathfinding","Sounds","Terrain","Navigation"}
		local map = {}
		if ok then map.Total = total end
		for _,t in ipairs(tags) do
			local ok2,val = pcall(function() return StatsService:GetMemoryUsageMbForTag(t) end)
			if ok2 then map[t] = val end
		end
		return map
	end
	local function pushLog(msg, t)
		local tag = tostring(t)
		if tag:find("Error") then errCount += 1 elseif tag:find("Warning") then warnCount += 1 else infoCount += 1 end
		Insert(logs, os.date("%X").." | "..tag.." | "..msg)
		if #logs > MAX_LOGS then table.remove(logs,1) end
	end

	local function NewI(c) return InstanceNew(c) end
	local function new(class, props) local inst = NewI(class) for k,v in pairs(props) do inst[k] = v end return inst end

	debugUI = new("ScreenGui",{Name="CharDebugUI",ResetOnSpawn=false,IgnoreGuiInset=true,ZIndexBehavior=Enum.ZIndexBehavior.Sibling,DisplayOrder=1000})
	pcall(function() NaProtectUI(debugUI) end)

	local window = new("Frame",{Name="Window", Size=UDim2.fromOffset(UI_SIZE.X, UI_SIZE.Y), Position=UDim2.new(0.5,-UI_SIZE.X/2,0.5,-UI_SIZE.Y/2), BackgroundColor3=BG_COLOR, BorderSizePixel=0, ClipsDescendants=true, Parent=debugUI, ZIndex=10})
	new("UICorner",{CornerRadius=UDim.new(0,14),Parent=window})
	new("UIStroke",{Thickness=1,ApplyStrokeMode=Enum.ApplyStrokeMode.Border,Color=Color3.fromRGB(35,35,35),Parent=window})

	local hdr = new("Frame",{Name="Header", Size=UDim2.new(1,0,0,HEADER_H), BackgroundColor3=BG_COLOR, BorderSizePixel=0, Parent=window, ZIndex=50})
	local hdrStroke = new("UIStroke",{Thickness=1,ApplyStrokeMode=Enum.ApplyStrokeMode.Border,Color=Color3.fromRGB(45,45,45),Parent=hdr})
	new("UICorner",{CornerRadius=UDim.new(0,14),Parent=hdr})

	local title = new("TextLabel",{Name="Title", Size=UDim2.new(0.5,-12,1,0), Position=UDim2.new(0,12,0,0), BackgroundTransparency=1, Font=Enum.Font.Code, TextSize=18, TextColor3=Color3.new(1,1,1), TextXAlignment=Enum.TextXAlignment.Left, Text="Character Debug", Parent=hdr, ZIndex=60})

	local right = new("Frame",{Name="Right", AnchorPoint=Vector2.new(1,0), Position=UDim2.new(1,-8,0,6), Size=UDim2.new(0,0,1,-12), BackgroundTransparency=1, AutomaticSize=Enum.AutomaticSize.X, Parent=hdr, ZIndex=60})
	new("UIListLayout",{FillDirection=Enum.FillDirection.Horizontal,HorizontalAlignment=Enum.HorizontalAlignment.Right,VerticalAlignment=Enum.VerticalAlignment.Center,Padding=UDim.new(0,6),Parent=right})

	local platformStr = tostring(UserInputService:GetPlatform())
	local status = new("TextLabel",{Name="Status", Size=UDim2.fromOffset(210,HEADER_H-16), BackgroundTransparency=0, BackgroundColor3=Color3.fromRGB(30,30,30), Font=Enum.Font.Code, TextSize=14, TextColor3=Color3.fromRGB(230,230,230), TextXAlignment=Enum.TextXAlignment.Center, Text="FPS: -- | Ping: -- | "..platformStr, Parent=right, ZIndex=61})
	new("UICorner",{CornerRadius=UDim.new(1,8),Parent=status})
	local btnPause = new("TextButton",{Name="Pause", Size=UDim2.fromOffset(74,HEADER_H-16), BackgroundColor3=ACCENT, AutoButtonColor=true, TextColor3=Color3.new(1,1,1), Text="Pause", Font=Enum.Font.Code, TextSize=16, Parent=right, ZIndex=61})
	new("UICorner",{CornerRadius=UDim.new(0,8),Parent=btnPause})
	local btnMin = new("TextButton",{Name="Min", Size=UDim2.fromOffset(44,HEADER_H-16), BackgroundColor3=Color3.fromRGB(45,45,45), AutoButtonColor=true, TextColor3=Color3.new(1,1,1), Text="–", Font=Enum.Font.Code, TextSize=20, Parent=right, ZIndex=61})
	new("UICorner",{CornerRadius=UDim.new(0,8),Parent=btnMin})
	local btnClose = new("TextButton",{Name="Close", Size=UDim2.fromOffset(44,HEADER_H-16), BackgroundColor3=Color3.fromRGB(140,55,55), AutoButtonColor=true, TextColor3=Color3.new(1,1,1), Text="×", Font=Enum.Font.Code, TextSize=20, Parent=right, ZIndex=61})
	new("UICorner",{CornerRadius=UDim.new(0,8),Parent=btnClose})

	NAgui.draggerV2(window, hdr)

	local tabbar = new("ScrollingFrame",{Name="Tabs", Size=UDim2.new(1,0,0,TAB_H), Position=UDim2.new(0,0,0,HEADER_H), BackgroundColor3=Color3.fromRGB(28,28,28), BorderSizePixel=0, Parent=window, ScrollingDirection=Enum.ScrollingDirection.X, ScrollBarThickness=IsOnMobile and 10 or 6, Active=true, CanvasSize=UDim2.new(), ZIndex=30})
	local tabsHolder = new("Frame",{Name="Holder", BackgroundTransparency=1, Size=UDim2.new(0,0,1,0), Parent=tabbar, ZIndex=31})
	local uilist = new("UIListLayout",{FillDirection=Enum.FillDirection.Horizontal,Padding=UDim.new(0,6),HorizontalAlignment=Enum.HorizontalAlignment.Left,VerticalAlignment=Enum.VerticalAlignment.Center,Parent=tabsHolder})

	local content = new("Frame",{Name="Content", Size=UDim2.new(1,0,1,-(HEADER_H+TAB_H)), Position=UDim2.new(0,0,0,HEADER_H+TAB_H), BackgroundTransparency=1, BorderSizePixel=0, Parent=window, ZIndex=20})
	local cardsScroll = new("ScrollingFrame",{Name="CardsScroll", Active=true, ScrollingDirection=Enum.ScrollingDirection.Y, ScrollBarThickness=IsOnMobile and 10 or 6, BackgroundTransparency=1, BorderSizePixel=0, Size=UDim2.fromScale(1,1), Parent=content, ZIndex=21})
	new("UIPadding",{PaddingLeft=UDim.new(0,12),PaddingTop=UDim.new(0,12),Parent=cardsScroll})
	local cardsHolder = new("Frame",{Name="CardsHolder", BackgroundTransparency=1, Size=UDim2.new(1,-24,0,0), Position=UDim2.new(0,12,0,12), Parent=cardsScroll, AutomaticSize=Enum.AutomaticSize.Y, ZIndex=22})
	local grid = new("UIGridLayout",{Parent=cardsHolder, CellPadding=UDim2.new(0,10,0,10), StartCorner=Enum.StartCorner.TopLeft, SortOrder=Enum.SortOrder.LayoutOrder})
	grid.CellSize = IsOnMobile and UDim2.new(1,-10,0,86) or UDim2.new(0.5,-10,0,86)
	cardsScroll.CanvasSize = UDim2.fromOffset(0, grid.AbsoluteContentSize.Y + 24)

	local logsHolder = new("Frame",{Name="LogsHolder", BackgroundTransparency=1, Visible=false, Size=UDim2.fromScale(1,1), Parent=content, ZIndex=21})
	local panel = new("Frame",{Name="LogPanel", BackgroundColor3=PANEL_BG, BorderSizePixel=0, Parent=logsHolder, Size=UDim2.new(1,-24,1,-24), Position=UDim2.new(0,12,0,12), ZIndex=22})
	new("UICorner",{CornerRadius=UDim.new(0,10),Parent=panel})
	new("UIStroke",{Thickness=1,ApplyStrokeMode=Enum.ApplyStrokeMode.Border,Color=Color3.fromRGB(40,40,40),Parent=panel})
	local counts = new("TextLabel",{Name="Counts", BackgroundTransparency=1, Position=UDim2.new(0,10,0,8), Size=UDim2.new(1,-20,0,18), Font=Enum.Font.Code, TextSize=14, TextColor3=Color3.fromRGB(200,200,200), TextXAlignment=Enum.TextXAlignment.Left, Text="Info:0  Warn:0  Error:0", Parent=panel, ZIndex=23})
	local logScroll = new("ScrollingFrame",{Name="Scroll", Active=true, ScrollBarThickness=IsOnMobile and 10 or 6, ScrollingDirection=Enum.ScrollingDirection.Y, BackgroundTransparency=1, BorderSizePixel=0, Size=UDim2.new(1,-20,1,-40), Position=UDim2.new(0,10,0,30), Parent=panel, ZIndex=23})
	local logText = new("TextLabel",{Name="Text", BackgroundTransparency=1, Size=UDim2.new(1,-4,0,0), Position=UDim2.new(0,2,0,0), Font=Enum.Font.Code, TextXAlignment=Enum.TextXAlignment.Left, TextYAlignment=Enum.TextYAlignment.Top, TextWrapped=false, TextScaled=false, TextSize=14, TextColor3=Color3.fromRGB(230,230,230), Text="", Parent=logScroll, AutomaticSize=Enum.AutomaticSize.Y, ZIndex=23})
	new("UITextSizeConstraint",{Parent=logText, MaxTextSize=18, MinTextSize=12})

	local tabsList = {"Overview","Movement","Humanoid","Camera","World","Network","Memory","Anim","Tools","Inputs","Physics","Perf","Logs"}
	local tabBtns = {}
	for _, name in ipairs(tabsList) do
		local b = new("TextButton",{Name=name, Size=UDim2.fromOffset(126, TAB_H-10), BackgroundColor3=(name==activeTab) and ACCENT or Color3.fromRGB(45,45,45), AutoButtonColor=true, TextColor3=Color3.new(1,1,1), Text=name, Font=Enum.Font.Code, TextSize=14, Parent=tabsHolder, ZIndex=32})
		new("UICorner",{CornerRadius=UDim.new(0,8),Parent=b})
		tabBtns[name] = b
	end

	debugDock = new("ScreenGui",{Name="CharDebugDock",ResetOnSpawn=false,IgnoreGuiInset=true,ZIndexBehavior=Enum.ZIndexBehavior.Sibling,DisplayOrder=1100})
	pcall(function() NaProtectUI(debugDock) end)
	local dock = new("Frame",{Name="Dock", Size=UDim2.fromOffset(IsOnMobile and 76 or 64,IsOnMobile and 76 or 64), AnchorPoint=Vector2.new(0,1), Position=UDim2.new(0,16,1,-16), BackgroundColor3=ACCENT, Visible=false, Parent=debugDock, ZIndex=100})
	new("UICorner",{CornerRadius=UDim.new(0,20),Parent=dock})
	local dockLabel = new("TextButton",{Name="Btn", BackgroundTransparency=1, Size=UDim2.fromScale(1,1), Text="CD", Font=Enum.Font.Code, TextSize=20, TextColor3=Color3.new(1,1,1), Parent=dock, ZIndex=101})

	NAgui.draggerV2(dock, dockLabel)

	local cards, values = {}, {}

	local function makeCard(parent, key, height)
		local f = new("Frame",{Name=key, Size=UDim2.fromOffset(400,height or 86), BackgroundColor3=PANEL_BG, BorderSizePixel=0, Parent=parent, ZIndex=22})
		new("UICorner",{CornerRadius=UDim.new(0,10),Parent=f})
		new("UIStroke",{Thickness=1,ApplyStrokeMode=Enum.ApplyStrokeMode.Border,Color=Color3.fromRGB(40,40,40),Parent=f})
		new("TextLabel",{Name="Key", BackgroundTransparency=1, Position=UDim2.new(0,10,0,8), Size=UDim2.new(1,-20,0,16), Font=Enum.Font.Code, TextSize=14, TextColor3=Color3.fromRGB(180,180,180), TextXAlignment=Enum.TextXAlignment.Left, Text=key, Parent=f, ZIndex=23})
		local val = new("TextLabel",{Name="Val", BackgroundTransparency=1, Position=UDim2.new(0,10,0,28), Size=UDim2.new(1,-20,1,-36), Font=Enum.Font.Code, TextSize=16, TextColor3=Color3.new(1,1,1), TextXAlignment=Enum.TextXAlignment.Left, TextWrapped=true, Text="", Parent=f, ZIndex=23})
		return f, val
	end
	local function clearCards() for _,v in pairs(cards) do v:Destroy() end cards, values = {}, {} end
	local function addCard(key, h)
		local card, val = makeCard(cardsHolder, key, h)
		cards[key] = card
		values[key] = val
		card.BackgroundTransparency = 0.35
		TweenService:Create(card, TweenInfo.new(0.18, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {BackgroundTransparency = 0.15}):Play()
	end

	NAlib.connect(CONN_KEY, grid:GetPropertyChangedSignal("AbsoluteContentSize"):Connect(function()
		cardsScroll.CanvasSize = UDim2.fromOffset(0, grid.AbsoluteContentSize.Y + 24)
	end))
	NAlib.connect(CONN_KEY, uilist:GetPropertyChangedSignal("AbsoluteContentSize"):Connect(function()
		local w2 = uilist.AbsoluteContentSize.X + 12
		tabsHolder.Size = UDim2.fromOffset(w2, TAB_H)
		tabbar.CanvasSize = UDim2.fromOffset(w2 + 12, TAB_H)
	end))
	NAlib.connect(CONN_KEY, tabbar.InputChanged:Connect(function(i)
		if i.UserInputType == Enum.UserInputType.MouseWheel then
			local x = math.clamp(tabbar.CanvasPosition.X - i.Position.Z*32, 0, math.max(0, tabbar.CanvasSize.X.Offset - tabbar.AbsoluteSize.X))
			tabbar.CanvasPosition = Vector2.new(x, 0)
		end
	end))

	local function setVal(key, text) local lbl=values[key] if lbl then lbl.Text=text end end
	local function getTool() local c=char() return c and c:FindFirstChildOfClass("Tool") or nil end
	local function statsNetKbps() local i,o; local okI,vI=pcall(function() return StatsService.DataReceiveKbps end); if okI then i=vI end local okO,vO=pcall(function() return StatsService.DataSendKbps end); if okO then o=vO end return i,o end

	local function setTab(name)
		activeTab = name
		for n,b in pairs(tabBtns) do TweenService:Create(b, TweenInfo.new(0.15), {BackgroundColor3 = (n==name) and ACCENT or Color3.fromRGB(45,45,45)}):Play() end
		local showLogs = (name == "Logs")
		cardsScroll.Visible = not showLogs
		logsHolder.Visible = showLogs
		if not showLogs then
			clearCards()
			if name=="Overview" then
				addCard("CharacterStatus")
				addCard("Platform")
				addCard("Username")
				addCard("UserId")
				addCard("Position")
				addCard("Velocity")
				addCard("Speed")
				addCard("AngularVel")
				addCard("Health")
				addCard("State")
				addCard("MoveDirection")
				addCard("FloorMaterial")
				addCard("Tool")
				addCard("FOV")
			elseif name=="Movement" then
				addCard("WalkSpeed")
				addCard("JumpPower")
				addCard("JumpHeight")
				addCard("HipHeight")
				addCard("AutoRotate")
				addCard("AssemblyMass")
				addCard("PlatformStand")
				addCard("Sit")
				addCard("Airborne")
			elseif name=="Humanoid" then
				addCard("RigType")
				addCard("MaxHealth")
				addCard("HealthDisplayType")
				addCard("StatesEnabled",110)
				addCard("SeatPart")
				addCard("MoveTo")
			elseif name=="Camera" then
				addCard("CameraType")
				addCard("Subject")
				addCard("SubjectDistance")
				addCard("CameraCFrame",110)
				addCard("FOV")
			elseif name=="World" then
				addCard("Gravity")
				addCard("ClockTime")
				addCard("Brightness")
				addCard("EnvSpecular")
				addCard("CurrentZone")
			elseif name=="Network" then
				addCard("Ping")
				addCard("DataInKbps")
				addCard("DataOutKbps")
			elseif name=="Memory" then
				addCard("TotalMB")
				addCard("LuaHeapMB")
				addCard("InstancesMB")
				addCard("GraphicsTextureMB")
				addCard("PhysicsMB")
				addCard("TerrainMB")
				addCard("PathfindingMB")
			elseif name=="Anim" then
				addCard("PlayingTracks",130)
			elseif name=="Tools" then
				addCard("EquippedTool")
				addCard("BackpackItems",130)
			elseif name=="Inputs" then
				addCard("KeysDown",130)
				addCard("LastInput")
			elseif name=="Physics" then
				addCard("GroundDist")
				addCard("GroundNormal")
				addCard("SlopeAngle")
				addCard("UnderPart")
				addCard("HumanoidRootCFrame",110)
				addCard("PivotOffset")
			elseif name=="Perf" then
				addCard("HeartbeatDt")
				addCard("ServerTime")
				addCard("TouchingParts")
			end
			cardsScroll.CanvasSize = UDim2.fromOffset(0, grid.AbsoluteContentSize.Y + 24)
		else
			counts.Text = Format("Info:%d  Warn:%d  Error:%d", infoCount, warnCount, errCount)
			logText.Text = (#logs>0) and Concat(logs,"\n") or ""
			local h2 = logText.TextBounds.Y
			logScroll.CanvasSize = UDim2.fromOffset(0, h2)
			logScroll.CanvasPosition = Vector2.new(0, math.max(0, h2 - logScroll.AbsoluteSize.Y))
		end
	end

	for _,b in pairs(tabBtns) do
		NAlib.connect(CONN_KEY, MouseButtonFix(b, function() setTab(b.Name) end))
		NAlib.connect(CONN_KEY, b.MouseEnter:Connect(function() TweenService:Create(b, TweenInfo.new(0.12), {TextTransparency = 0.05}):Play() end))
		NAlib.connect(CONN_KEY, b.MouseLeave:Connect(function() TweenService:Create(b, TweenInfo.new(0.12), {TextTransparency = 0}):Play() end))
	end

	local pressed, lastInput = {}, "-"
	NAlib.connect(CONN_KEY, UserInputService.InputBegan:Connect(function(input,gp)
		if gp then return end
		if input.UserInputType == Enum.UserInputType.Keyboard then
			pressed[input.KeyCode.Name] = true
			lastInput = input.KeyCode.Name
		elseif input.UserInputType == Enum.UserInputType.MouseButton1 then lastInput = "Mouse1"
		elseif input.UserInputType == Enum.UserInputType.MouseButton2 then lastInput = "Mouse2"
		elseif input.UserInputType == Enum.UserInputType.MouseWheel then lastInput = "Wheel" end
	end))
	NAlib.connect(CONN_KEY, UserInputService.InputEnded:Connect(function(input,gp)
		if gp then return end
		if input.UserInputType == Enum.UserInputType.Keyboard then pressed[input.KeyCode.Name] = nil end
	end))
	NAlib.connect(CONN_KEY, LogService.MessageOut:Connect(function(m,t)
		pushLog(m,t)
		if activeTab=="Logs" then
			counts.Text = Format("Info:%d  Warn:%d  Error:%d", infoCount, warnCount, errCount)
			logText.Text = (#logs>0) and Concat(logs,"\n") or ""
			local h2 = logText.TextBounds.Y
			logScroll.CanvasSize = UDim2.fromOffset(0, h2)
			logScroll.CanvasPosition = Vector2.new(0, math.max(0, h2 - logScroll.AbsoluteSize.Y))
		end
	end))

	local function updateOverview(h, r)
		local c = char()
		if not c then
			setVal("CharacterStatus","No character")
		else
			local rr = root(c)
			local hh = hum()
			setVal("CharacterStatus",Format("Char OK | Humanoid:%s | Root:%s", hh and "Yes" or "No", rr and "Yes" or "No"))
		end
		setVal("Platform",platformStr.." | Mobile:"..tostring(IsOnMobile).." | PC:"..tostring(IsOnPC))
		setVal("Username", LocalPlayer and LocalPlayer.Name or "N/A")
		setVal("UserId", LocalPlayer and tostring(LocalPlayer.UserId) or "N/A")
		if r then
			local p = r.Position
			setVal("Position", Format("X: %.2f  Y: %.2f  Z: %.2f", p.X, p.Y, p.Z))
			local v = velOf(r)
			setVal("Velocity", Format("X: %.2f  Y: %.2f  Z: %.2f", v.X, v.Y, v.Z))
			setVal("Speed", Format("%.2f", v.Magnitude))
			local av = angVelOf(r)
			setVal("AngularVel", Format("X: %.2f  Y: %.2f  Z: %.2f", av.X, av.Y, av.Z))
		end
		if h then
			setVal("Health", Format("%.1f / %.1f", h.Health, h.MaxHealth))
			setVal("State", tostring(h:GetState()))
			local md = h.MoveDirection
			setVal("MoveDirection", Format("X: %.2f  Y: %.2f  Z: %.2f", md.X, md.Y, md.Z))
			setVal("FloorMaterial", tostring(h.FloorMaterial))
		end
		local t = getTool()
		setVal("Tool", t and t.Name or "None")
		local cc = workspace.CurrentCamera
		if cc then setVal("FOV", Format("%.1f", cc.FieldOfView)) end
	end
	local function updateMovement(h, r)
		if h then
			setVal("WalkSpeed", Format("%.2f", h.WalkSpeed))
			setVal("JumpPower", Format("%.2f", h.JumpPower))
			local okJH, jh = pcall(function() return h.JumpHeight end)
			setVal("JumpHeight", okJH and Format("%.2f", jh) or "N/A")
			setVal("HipHeight", Format("%.2f", h.HipHeight))
			setVal("AutoRotate", tostring(h.AutoRotate))
			setVal("PlatformStand", tostring(h.PlatformStand))
			setVal("Sit", tostring(h.Sit))
			local st = h:GetState()
			local airborne = st == Enum.HumanoidStateType.Freefall or st == Enum.HumanoidStateType.Jumping
			setVal("Airborne", tostring(airborne))
		end
		if r then setVal("AssemblyMass", Format("%.2f", r.AssemblyMass)) end
	end
	local function updateHumanoid(h)
		if not h then return end
		setVal("RigType", tostring(h.RigType))
		setVal("MaxHealth", Format("%.1f", h.MaxHealth))
		setVal("HealthDisplayType", tostring(h.HealthDisplayType))
		local states = {"Running","RunningNoPhysics","Jumping","Freefall","Landed","Seated","Climbing","Swimming","FallingDown","Ragdoll","GettingUp","Flying"}
		local list = {}
		for _,s in ipairs(states) do local ok,val=pcall(function() return h:GetStateEnabled(Enum.HumanoidStateType[s]) end) Insert(list, Format("%s:%s", s, ok and tostring(val) or "N/A")) end
		setVal("StatesEnabled", Concat(list,"  "))
		local seat = h.SeatPart
		setVal("SeatPart", seat and seat.Name or "None")
		local mpos = h.WalkToPoint
		setVal("MoveTo", Format("X: %.1f  Y: %.1f  Z: %.1f", mpos.X, mpos.Y, mpos.Z))
	end
	local function updateCamera(_, r)
		local cc = workspace.CurrentCamera
		if not cc then return end
		setVal("CameraType", tostring(cc.CameraType))
		local subj = cc.CameraSubject
		setVal("Subject", subj and subj.Name or "None")
		if r then setVal("SubjectDistance", Format("%.2f", (cc.CFrame.Position - r.Position).Magnitude)) else setVal("SubjectDistance", "N/A") end
		local cf = cc.CFrame
		local rx,ry,rz = cf:ToOrientation()
		setVal("CameraCFrame", Format("P(%.1f,%.1f,%.1f)  R(%.2f,%.2f,%.2f)", cf.X, cf.Y, cf.Z, rx, ry, rz))
		setVal("FOV", Format("%.1f", cc.FieldOfView))
	end
	local function updateWorld()
		setVal("Gravity", Format("%.1f", workspace.Gravity))
		setVal("ClockTime", Format("%.2f", Lighting.ClockTime))
		setVal("Brightness", Format("%.2f", Lighting.Brightness))
		local okE, env = pcall(function() return Lighting.EnvironmentSpecularScale end)
		setVal("EnvSpecular", okE and Format("%.2f", env) or "N/A")
		setVal("CurrentZone", "N/A")
	end
	local function updateNetwork()
		local ping = getPingMs()
		setVal("Ping", ping and Format("%.0f ms", ping) or "N/A")
		local inK, outK = statsNetKbps()
		setVal("DataInKbps", inK and Format("%.1f", inK) or "N/A")
		setVal("DataOutKbps", outK and Format("%.1f", outK) or "N/A")
	end
	local function updateMemory()
		local m = getMem()
		setVal("TotalMB", m.Total and Format("%.1f", m.Total) or "N/A")
		setVal("LuaHeapMB", m.LuaHeap and Format("%.1f", m.LuaHeap) or "N/A")
		setVal("InstancesMB", m.Instances and Format("%.1f", m.Instances) or "N/A")
		setVal("GraphicsTextureMB", m.GraphicsTexture and Format("%.1f", m.GraphicsTexture) or "N/A")
		setVal("PhysicsMB", m.Physics and Format("%.1f", m.Physics) or "N/A")
		setVal("TerrainMB", m.Terrain and Format("%.1f", m.Terrain) or "N/A")
		setVal("PathfindingMB", m.Pathfinding and Format("%.1f", m.Pathfinding) or "N/A")
	end
	local function updateAnim(h)
		if not h then setVal("PlayingTracks","None"); return end
		local animator = h:FindFirstChildOfClass("Animator")
		if not animator then setVal("PlayingTracks","None"); return end
		local tracks = animator:GetPlayingAnimationTracks()
		if #tracks == 0 then setVal("PlayingTracks","None"); return end
		local lines = {}
		for _,t in ipairs(tracks) do
			local name = (t.Animation and t.Animation.Name) or t.Name or "Track"
			Insert(lines, Format("%s  w=%.2f  s=%.2f", name, t.WeightCurrent or 0, t.Speed or 1))
		end
		setVal("PlayingTracks", Concat(lines,"  "))
	end
	local function updateTools()
		local t = getTool()
		setVal("EquippedTool", t and t.Name or "None")
		local items, count = {}, 0
		if LocalPlayer.Backpack then
			for _,i in ipairs(LocalPlayer.Backpack:GetChildren()) do
				if i:IsA("Tool") then count += 1; Insert(items, i.Name) end
			end
		end
		setVal("BackpackItems", count > 0 and Concat(items, ", ") or "None")
	end
	local function updateInputs()
		local keys = {} for k,_ in pairs(pressed) do Insert(keys,k) end table.sort(keys)
		setVal("KeysDown", (#keys>0) and Concat(keys,", ") or "None")
		setVal("LastInput", lastInput or "-")
	end
	local function updatePhysics(_, r)
		if not r then
			setVal("GroundDist","N/A"); setVal("GroundNormal","N/A"); setVal("SlopeAngle","N/A"); setVal("UnderPart","N/A"); setVal("HumanoidRootCFrame","N/A"); setVal("PivotOffset","N/A")
			return
		end
		local res = raycastDown(r.Position, 1000)
		if res then
			local d = (r.Position - res.Position).Magnitude
			setVal("GroundDist", Format("%.2f", d))
			setVal("GroundNormal", Format("X: %.2f Y: %.2f Z: %.2f", res.Normal.X, res.Normal.Y, res.Normal.Z))
			local slope = math.deg(math.acos(math.clamp(res.Normal:Dot(Vector3.new(0,1,0)), -1, 1)))
			setVal("SlopeAngle", Format("%.2f°", slope))
			setVal("UnderPart", res.Instance and (res.Instance.Name.." ["..tostring(res.Material).."]") or "None")
		else
			setVal("GroundDist","--"); setVal("GroundNormal","--"); setVal("SlopeAngle","--"); setVal("UnderPart","--")
		end
		local cf = r.CFrame
		local rx,ry,rz = cf:ToOrientation()
		setVal("HumanoidRootCFrame", Format("P(%.1f,%.1f,%.1f)  R(%.2f,%.2f,%.2f)", cf.X, cf.Y, cf.Z, rx, ry, rz))
		local pv = char() and char():GetPivot() or CFrame.identity
		local d2 = cf.Position - pv.Position
		setVal("PivotOffset", Format("Δ(%.2f, %.2f, %.2f)", d2.X, d2.Y, d2.Z))
	end
	local function updatePerf()
		setVal("HeartbeatDt", Format("%.4f s", lastDt))
		setVal("ServerTime", tostring(os.time()))
		local r = root(); local n=0 if r then for _,p in ipairs(r:GetTouchingParts()) do n+=1 end end
		setVal("TouchingParts", tostring(n))
	end
	local function updateLogs()
		counts.Text = Format("Info:%d  Warn:%d  Error:%d", infoCount, warnCount, errCount)
		logText.Text = (#logs>0) and Concat(logs,"\n") or ""
		local h2 = logText.TextBounds.Y
		logScroll.CanvasSize = UDim2.fromOffset(0, h2)
		logScroll.CanvasPosition = Vector2.new(0, math.max(0, h2 - logScroll.AbsoluteSize.Y))
	end

	local function safeFPS(dt)
		if not dt or dt ~= dt or dt <= 0 or dt > 1 then return end
		local inst = 1/dt
		if inst ~= inst or inst == math.huge then return end
		if fpsAlpha == 0 then fps = inst; fpsAlpha = 1 else fps = fps*0.9 + inst*0.1 end
	end

	local function refresh()
		if paused then return end
		local h = hum()
		local r = root()
		if activeTab=="Overview" then updateOverview(h,r)
		elseif activeTab=="Movement" then updateMovement(h,r)
		elseif activeTab=="Humanoid" then updateHumanoid(h)
		elseif activeTab=="Camera" then updateCamera(h,r)
		elseif activeTab=="World" then updateWorld()
		elseif activeTab=="Network" then updateNetwork()
		elseif activeTab=="Memory" then updateMemory()
		elseif activeTab=="Anim" then updateAnim(h)
		elseif activeTab=="Tools" then updateTools()
		elseif activeTab=="Inputs" then updateInputs()
		elseif activeTab=="Physics" then updatePhysics(h,r)
		elseif activeTab=="Perf" then updatePerf()
		elseif activeTab=="Logs" then updateLogs()
		end
		local p = getPingMs()
		local f = (fps ~= fps or fps == math.huge or fps <= 0) and "--" or tostring(math.clamp(math.floor(fps + 0.5), 1, 999))
		local charOk = char() and "OK" or "None"
		status.Text = Format("FPS: %s | Ping: %s | Char:%s", f, p and Format("%d ms", p) or "--", charOk)
	end

	NAlib.connect(CONN_KEY, MouseButtonFix(btnPause, function()
		paused = not paused
		isMinimized = false
		btnPause.Text = paused and "Resume" or "Pause"
		TweenService:Create(btnPause, TweenInfo.new(0.12), {BackgroundColor3 = paused and Color3.fromRGB(120,120,120) or ACCENT}):Play()
	end))

	NAlib.connect(CONN_KEY, MouseButtonFix(btnMin, function()
		if window.Visible then
			isMinimized = true
			local out = TweenService:Create(window, TweenInfo.new(0.18, Enum.EasingStyle.Quad, Enum.EasingDirection.In), {Size = UDim2.fromOffset(UI_SIZE.X*0.96, UI_SIZE.Y*0.96), BackgroundTransparency = 0.4})
			out.Completed:Connect(function()
				window.Visible=false
				dock.Visible=true
				TweenService:Create(dock, TweenInfo.new(0.18, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {Size = UDim2.fromOffset(IsOnMobile and 80 or 70,IsOnMobile and 80 or 70)}):Play()
			end)
			out:Play()
		end
	end))

	NAlib.connect(CONN_KEY, MouseButtonFix(dockLabel, function()
		if not window.Visible then
			isMinimized = false
			dock.Visible=false
			window.Visible=true
			window.Size = UDim2.fromOffset(UI_SIZE.X*0.96, UI_SIZE.Y*0.96)
			window.BackgroundTransparency = 0.4
			TweenService:Create(window, TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {Size = UDim2.fromOffset(UI_SIZE.X, UI_SIZE.Y), BackgroundTransparency = 0}):Play()
			NAmanage.centerFrame(window)
		end
	end))

	NAlib.connect(CONN_KEY, MouseButtonFix(btnClose, function()
		if debugUI then
			debugUI:Destroy()
			debugUI = nil
		end
		if debugDock then
			debugDock:Destroy()
			debugDock = nil
		end
		NAlib.disconnect(CONN_KEY)
		RunService:UnbindFromRenderStep(RENDER_BIND)
	end))

	setTab(activeTab)

	RunService:BindToRenderStep(RENDER_BIND, Enum.RenderPriority.Last.Value, function(dt)
		lastDt = dt
		safeFPS(dt)
		dtAcc += dt
		if dtAcc < UPDATE_RATE then return end
		dtAcc = 0
		refresh()
	end)

	window.Size = UDim2.fromOffset(UI_SIZE.X*0.96, UI_SIZE.Y*0.96)
	NAmanage.centerFrame(window)
	TweenService:Create(window, TweenInfo.new(0.22, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {Size = UDim2.fromOffset(UI_SIZE.X, UI_SIZE.Y)}):Play()
end)

cmd.add({"unchardebug","uncdebug"},{"unchardebug (uncdebug)","disable character debug"},function()
	if debugUI then
		debugUI:Destroy()
		debugUI = nil
	end
	if debugDock then
		debugDock:Destroy()
		debugDock = nil
	end
	isMinimized = false
	NAlib.disconnect("CharDebug")
	SafeGetService("RunService"):UnbindFromRenderStep("CharDebug")
end)

cmd.add({"naked"}, {"naked", "no clothing gang"}, function()
	for _,clothes in ipairs(LocalPlayer.Character:GetChildren()) do
		if clothes:IsA("Shirt") or clothes:IsA("Pants") or clothes:IsA("ShirtGraphic") then
			clothes:Destroy()
		end
	end
end)

Somersault = {btn=nil, key="x", twopi=math.pi*2, flipping=false}

cmd.add({"somersault", "frontflip"}, {"somersault (frontflip)", "Makes you do a clean front flip"}, function(...)
	local function somersaulter()
		if Somersault.flipping then return end
		local c = getChar() or LocalPlayer.CharacterAdded:Wait()
		local hrp = getRoot(c)
		local hum = getHum()
		if not hrp or not hum then return end
		if hum:GetState() ~= Enum.HumanoidStateType.Freefall and hum.FloorMaterial ~= Enum.Material.Air then
			Somersault.flipping = true
			hum.PlatformStand = true
			local axis = -hrp.CFrame.RightVector
			local angSpeed = 20
			local rotated = 0
			hrp.AssemblyLinearVelocity = hrp.CFrame.LookVector * 30 + Vector3.new(0, 30, 0)
			local conn
			conn = RunService.Heartbeat:Connect(function(dt)
				if not hrp.Parent or hum.Health <= 0 then
					if conn then conn:Disconnect() end
					Somersault.flipping = false
					hum.PlatformStand = false
					return
				end
				rotated = rotated + angSpeed * dt
				if rotated >= Somersault.twopi then
					hrp.AssemblyAngularVelocity = Vector3.zero
					hum.PlatformStand = false
					hum:ChangeState(Enum.HumanoidStateType.GettingUp)
					conn:Disconnect()
					Somersault.flipping = false
				else
					hrp.AssemblyAngularVelocity = axis * angSpeed
				end
			end)
		end
	end

	if IsOnMobile then
		if Somersault.btn then
			Somersault.btn:Destroy()
			Somersault.btn = nil
		end

		Somersault.btn = InstanceNew("ScreenGui")
		local flipBtn = InstanceNew("TextButton")
		local corner = InstanceNew("UICorner")
		local aspect = InstanceNew("UIAspectRatioConstraint")

		NaProtectUI(Somersault.btn)
		Somersault.btn.ResetOnSpawn = false

		flipBtn.Parent = Somersault.btn
		flipBtn.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
		flipBtn.BackgroundTransparency = 0.1
		flipBtn.Position = UDim2.new(0.85, 0, 0.5, 0)
		flipBtn.Size = UDim2.new(0.08, 0, 0.1, 0)
		flipBtn.Font = Enum.Font.GothamBold
		flipBtn.Text = "Flip"
		flipBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
		flipBtn.TextSize = 18
		flipBtn.TextWrapped = true
		flipBtn.Active = true
		flipBtn.TextScaled = true

		corner.CornerRadius = UDim.new(0.2, 0)
		corner.Parent = flipBtn

		aspect.Parent = flipBtn
		aspect.AspectRatio = 1.0

		coroutine.wrap(function()
			MouseButtonFix(flipBtn, function()
				somersaulter()
			end)
		end)()

		NAgui.draggerV2(flipBtn)
	else
		NAlib.disconnect("somersault_key")
		NAlib.connect("somersault_key", mouse.KeyDown:Connect(function(KEY)
			if KEY:lower() == Somersault.key then
				somersaulter()
			end
		end))

		DoNotif("Press '"..Somersault.key:upper().."' to flip!", 3)
	end
end, false)

cmd.add({"unsomersault", "unfrontflip"}, {"unsomersault (unfrontflip)", "Disable somersault button and keybind"}, function(...)
	if Somersault.btn then
		Somersault.btn:Destroy()
		Somersault.btn = nil
	end
	NAlib.disconnect("somersault_key")
end, false)

StaffRoles = {"owner", "admin", "staff", "mod", "founder", "manager", "dev", "president", "leader", "supervisor", "chairman", "supervising", "executive", "director", "management", "chairwoman", "chairperson"}

function IsStaff(player)
	local role = ""
	local ok, currentRole = pcall(function()
		return player:GetRoleInGroup(game.CreatorId)
	end)
	if ok and currentRole then
		role = currentRole
	end
	local lowered = Lower(role)
	for _, staffRole in ipairs(StaffRoles) do
		if lowered:find(staffRole) then
			return true, role
		end
	end
	return false, role
end

groupRole = function(player)
	local info = {Role = "Guest", IsStaff = false}
	local isStaff, role = IsStaff(player)
	if player:IsInGroup(1200769) then
		info.Role = "Roblox Employee"
		info.IsStaff = true
		return info
	end
	if role ~= nil and role ~= "" then
		info.Role = role
	end
	info.IsStaff = isStaff
	return info
end
NAmanage.IsStaff = IsStaff

NAStuff.RolewatchData = NAStuff.RolewatchData or {Group = 0, Role = "", RoleLower = "", Leave = false}
NAStuff.RolewatchConnection = NAStuff.RolewatchConnection or nil

function NAmanage.joinRolewatchName(...)
	local pieces = {}
	for i = 1, select("#", ...) do
		local part = select(i, ...)
		if type(part) == "string" and part ~= "" then
			pieces[#pieces + 1] = part
		end
	end
	if #pieces == 0 then
		return nil
	end
	local combined = Concat(pieces, " "):match("^%s*(.-)%s*$")
	return combined ~= "" and combined or nil
end

function NAmanage.handleRolewatchPlayer(player)
	local data = NAStuff.RolewatchData
	if not player or player == LocalPlayer or not data then
		return
	end
	if data.Group == 0 or data.RoleLower == "" then
		return
	end
	local okGroup, inGroup = pcall(player.IsInGroup, player, data.Group)
	if not (okGroup and inGroup) then
		return
	end
	local okRole, playerRole = pcall(player.GetRoleInGroup, player, data.Group)
	if not (okRole and type(playerRole) == "string") then
		return
	end
	if playerRole:lower() ~= data.RoleLower then
		return
	end
	local message = Format("Player \"%s\" joined with role \"%s\".", player.Name, playerRole)
	if data.Leave then
		DoNotif(message, 4, "Rolewatch")
		local exitSucceeded = false
		if cmd and cmd.run then
			local ok = pcall(function()
				cmd.run({"exit"})
			end)
			exitSucceeded = ok
		end
		if not exitSucceeded and LocalPlayer then
			LocalPlayer:Kick(Format("\n\nRolewatch\n%s\n", message))
		end
		return
	end
	DoNotif(message, 4, "Rolewatch")
end

function NAmanage.ensureRolewatchListener()
	if NAStuff.RolewatchConnection then
		return
	end
	NAStuff.RolewatchConnection = Players.PlayerAdded:Connect(NAmanage.handleRolewatchPlayer)
end

NAmanage.ensureRolewatchListener()

cmd.add({"rolewatch"}, {"rolewatch <groupId> <role name>", "Notify if someone from a watched group joins with a specific role"}, function(groupIdArg, ...)
	local groupId = tonumber(groupIdArg)
	local roleName = NAmanage.joinRolewatchName(...)
	if not groupId or not roleName then
		DoNotif("Usage: rolewatch <groupId> <role name>", 4, "Rolewatch")
		return
	end
	local data = NAStuff.RolewatchData
	data.Group = groupId
	data.Role = roleName
	data.RoleLower = roleName:lower()
	DoNotif(Format("Watching group %d for role \"%s\".", groupId, roleName), 3, "Rolewatch")
end, true)

cmd.add({"rolewatchstop"}, {"rolewatchstop", "Disable Rolewatch monitoring"}, function()
	local data = NAStuff.RolewatchData
	data.Group = 0
	data.Role = ""
	data.RoleLower = ""
	data.Leave = false
	DoNotif("Rolewatch disabled.", 3, "Rolewatch")
end)

cmd.add({"rolewatchleave", "unrolewatch"}, {"rolewatchleave (unrolewatch)", "Toggle leaving the server if the watched role joins"}, function()
	local data = NAStuff.RolewatchData
	data.Leave = not data.Leave
	local stateText = data.Leave and "Leave enabled. You will leave if the watched role joins." or "Leave disabled."
	DoNotif(stateText, 3, "Rolewatch")
end)

cmd.add({"joingroup", "groupjoin"}, {"joingroup [groupId] (groupjoin)", "Open the Roblox join prompt for a group"}, function(groupIdArg)
	local supplied = tostring(groupIdArg or "")
	local hasInput = supplied ~= ""
	local targetId = tonumber(groupIdArg)

	if hasInput and (not targetId or targetId <= 0) then
		DoNotif("Please provide a valid numeric group id.", 4)
		return
	end

	if not targetId or targetId <= 0 then
		if game.CreatorType == Enum.CreatorType.Group and tonumber(game.CreatorId) then
			targetId = tonumber(game.CreatorId)
		else
			DoNotif("Provide a group id; this game is not owned by a group.", 4)
			return
		end
	end

	local groupService = SafeGetService("GroupService")
	if not groupService or type(groupService.PromptJoinAsync) ~= "function" then
		DoNotif("GroupService.PromptJoinAsync is unavailable.", 4)
		return
	end

	local ok, res = pcall(function()
		return groupService:PromptJoinAsync(targetId)
	end)

	if ok then
		local groupName = res and res.Name or ("group "..tostring(targetId))
		DebugNotif("Join prompt opened for "..groupName, 3)
	else
		DebugNotif("Failed to open join prompt: "..tostring(res), 4)
	end
end)

cmd.add({"trackstaff"}, {"trackstaff", "Track and notify when a staff member joins the server"}, function()
	NAlib.disconnect("staffNotifier")

	if game.CreatorType == Enum.CreatorType.Group then
		local staffList = {}
		NAlib.connect("staffNotifier", Players.PlayerAdded:Connect(function(player)
			local info = groupRole(player)
			if info.IsStaff then
				DebugNotif(formatUsername(player).." is a "..info.Role)
			end
		end))
		for _, player in pairs(Players:GetPlayers()) do
			local info = groupRole(player)
			if info.IsStaff then
				Insert(staffList, formatUsername(player).." is a "..info.Role)
			end
		end
		DebugNotif(#staffList > 0 and Concat(staffList, ",\n") or "Tracking enabled")
	else
		DebugNotif("Game is not owned by a Group")
	end
end)

cmd.add({"stoptrackstaff", "untrackstaff"}, {"stoptrackstaff (untrackstaff)", "Stop tracking staff members"}, function()
	NAlib.disconnect("staffNotifier")
	DebugNotif("Tracking disabled")
end)

cmd.add({"deletevelocity", "dv", "removevelocity", "removeforces"}, {"deletevelocity (dv, removevelocity, removeforces)", "removes any velocity/force instanceson your character"}, function()
	for _,vel in pairs(LocalPlayer.Character:GetDescendants()) do
		if vel:IsA("BodyVelocity") or vel:IsA("BodyGyro") or vel:IsA("RocketPropulsion") or vel:IsA("BodyThrust") or vel:IsA("BodyAngularVelocity") or vel:IsA("AngularVelocity") or vel:IsA("BodyForce") or vel:IsA("VectorForce") or vel:IsA("LineForce") then
			vel:Destroy()
		end
	end
end)

--Mobile Commands for the screen
if IsOnMobile then
	cmd.add({"sensorrotationscreen","sensorscreen","senscreen"},{"sensorrotationscreen","Changes ScreenOrientation to Sensor"},function()
		PlrGui.ScreenOrientation=Enum.ScreenOrientation.Sensor
	end)

	cmd.add({"landscaperotationscreen","landscapescreen","landscreen"},{"landscaperotationscreen","Changes ScreenOrientation to Landscape Sensor"},function()
		PlrGui.ScreenOrientation=Enum.ScreenOrientation.LandscapeSensor
	end)

	cmd.add({"portraitrotationscreen","portraitscreen","portscreen"},{"portraitrotationscreen","Changes ScreenOrientation to Portrait"},function()
		PlrGui.ScreenOrientation=Enum.ScreenOrientation.Portrait
	end)

	cmd.add({"defaultrotaionscreen","defaultscreen","defscreen"},{"defaultrotaionscreen","Changes ScreenOrientation to Portrait"},function()
		PlrGui.ScreenOrientation=StarterGui.ScreenOrientation
	end)
end

NAmanage.NACommandCount=function()
	local total = 0
	for _ in pairs(cmds.Commands) do
		total += 1
	end

	local pluginTotal, naPluginCount, iyPluginCount = 0, 0, 0
	local pluginRecords = NAmanage and NAmanage._pluginCommandRecords
	if type(pluginRecords) == "table" then
		local seenData = {}
		for pluginKey, record in pairs(pluginRecords) do
			local aliases = type(record) == "table" and record.aliases
			if type(aliases) == "table" then
				for alias, data in pairs(aliases) do
					if data and not seenData[data] and cmds.Commands[alias] == data then
						seenData[data] = true
						pluginTotal += 1
						if type(pluginKey) == "string" then
							if pluginKey:match("%.na$") then
								naPluginCount += 1
							elseif pluginKey:match("%.iy$") then
								iyPluginCount += 1
							end
						end
					end
				end
			end
		end
	end

	local core = total - pluginTotal
	if core < 0 then
		core = total
	end

	return total, core, naPluginCount, iyPluginCount, pluginTotal
end

cmd.add({"commandcount","cc"},{"commandcount (cc)","Counts how many commands NA has"},function()
	local total, core, naPlugins, iyPlugins, pluginTotal = NAmanage.NACommandCount()
	local msg = adminName.." currently has "..core.." core command"..((core == 1) and "" or "s")
	if pluginTotal > 0 then
		local pluginParts = {}
		if naPlugins > 0 then
			Insert(pluginParts, naPlugins.." from .na plugins")
		end
		if iyPlugins > 0 then
			Insert(pluginParts, iyPlugins.." from .iy plugins")
		end
		msg = msg.." + "..pluginTotal.." plugin command"..((pluginTotal == 1) and "" or "s")
		if #pluginParts > 0 then
			msg = msg.." ("..Concat(pluginParts, ", ")..")"
		end
		msg = msg.." = "..total.." total"
	end
	DoNotif(msg)
end)

cmd.add({"flyfling","ff"}, {"flyfling (ff)", "makes you fly and fling"}, function()
	cmd.run({"unwalkfling"})
	cmd.run({"unvfly", ''})
	cmd.run({"walkfling"})
	cmd.run({"vfly"})
end)

cmd.add({"unflyfling","unff"}, {"unflyfling (unff)", "stops fly and fling"}, function()
	cmd.run({"unwalkfling"})
	cmd.run({"unvfly", ''})
end)

hiddenfling = false

cmd.add({"walkfling","wfling","wf"},{"walkfling (wfling,wf)","probably the best fling lol"},function()
	if hiddenfling then return end

	DebugNotif("Walkfling enabled",2)
	hiddenfling = true

	NAlib.disconnect("walkflinger")
	NAlib.connect("walkflinger",RunService.Heartbeat:Connect(function()
		if not hiddenfling then return end

		local lp = Players.LocalPlayer
		if not lp then return end

		local m = getChar()
		local r = m and getRoot(m)
		if r then
			local v = r.Velocity
			r.Velocity = v * 10000 + Vector3.new(0,10000,0)

			RunService.RenderStepped:Wait()
			if r then
				r.Velocity = v
			end

			RunService.RenderStepped:Wait()
			if r then
				r.Velocity = v + Vector3.new(0,0.1,0)
			end
		end
	end))
end)

cmd.add({"unwalkfling","unwfling","unwf"},{"unwalkfling (unwfling,unwf)","stop the walkfling command"},function()
	if not hiddenfling then return end

	DebugNotif("Walkfling disabled",2)
	hiddenfling = false

	NAlib.disconnect("walkflinger")
end)

cmd.add({"rjre","rejoinrefresh"},{"rjre (rejoinrefresh)","Rejoins and teleports you to your previous position"},function()
	if not DONE then
		DONE = true

		local ch = getChar()
		local hrp = ch and getRoot(ch) or getRoot(LocalPlayer)
		if hrp then
			local tpScript = Format([[
local s,err = pcall(function()
	repeat Wait() until game:IsLoaded()
	local plrs = game:GetService("Players")
	local lp = plrs.LocalPlayer
	if not lp then return end

	local gb
	local ok,env = pcall(function()
		return getgenv and getgenv() or _G
	end)
	if ok and env then
		gb = rawget(env,"NA_GRAB_BODY")
	end

	local rec, mdl
	if gb and gb.ensure then
		rec, mdl = gb.ensure(lp)
	end

	local char = mdl or lp.Character or lp.CharacterAdded:Wait()
	if not char then return end

	local root

	if gb and gb.ensure then
		rec, mdl = gb.ensure(char)
		if rec then
			root = rec.root
			if not root and gb.firstPart and mdl then
				root = gb.firstPart(mdl)
			end
		end
	end

	if not root then
		local t0 = tick()
		repeat
			root = char:FindFirstChild("HumanoidRootPart")
			if not root then
				for _,d in ipairs(char:GetDescendants()) do
					if d:IsA("BasePart") then
						root = d
						break
					end
				end
			end
			if root then break end
			Wait(0.1)
		until tick() - t0 > 10
	end

	if not root then return end

	local targetPos = Vector3.new(%s)
	local targetCFrame = CFrame.new(%s)

	local t1 = tick()
	repeat
		root.CFrame = targetCFrame
		Wait(0.1)
	until (root.Position - targetPos).Magnitude < 10 or (tick() - t1 > 5)
end)
]], tostring(hrp.Position), tostring(hrp.CFrame))

			opt.queueteleport(tpScript)
		end

		cmd.run({"rj"})
	end
end)

cmd.add({"cancelteleport","canceltp"},{"cancelteleport (canceltp)","Cancel an in-progress teleport"},function()
	local ok,err=pcall(function()
		TeleportService:TeleportCancel()
	end)
	if ok then
		DoNotif("Cancelled pending teleports.",2)
	else
		DoNotif("Failed to cancel teleport: "..tostring(err),3)
	end
end)

cmd.add({"rejoin","rj"},{"rejoin (rj)","Rejoin the game"},function()
	local plrs=Players
	local tp=TeleportService
	local lp=plrs.LocalPlayer

	NAlib.disconnect("rejoin_tperr")
	NAlib.connect("rejoin_tperr",tp.TeleportInitFailed:Connect(function(player,result,errMsg)
		DoNotif(("Teleport failed [%s]: %s"):format(tostring(result),tostring(errMsg)))
	end))

	tp:TeleportCancel()

	if #plrs:GetPlayers()<=1 then
		local ok,err=pcall(function()
			tp:Teleport(PlaceId,lp)
		end)
		if not ok then DoNotif("Teleport error: "..tostring(err)) end
	else
		local ok,err=pcall(function()
			tp:TeleportToPlaceInstance(PlaceId,game.JobId,lp)
		end)
		if not ok then
			DoNotif("TeleportToPlaceInstance error: "..tostring(err))
			pcall(function() tp:Teleport(PlaceId,lp) end)
		end
	end

	DoNotif("Rejoining...")
end)

cmd.add({"teleporttoplace","toplace","ttp"},{"teleporttoplace (PlaceId) (toplace,ttp)","Teleports you using PlaceId"},function(...)
	args={...}
	pId=tonumber(args[1])
	TeleportService:Teleport(pId)
end,true)

--made by the_king.78
cmd.add({"adonisbypass","bypassadonis","badonis","adonisb"},{"adonisbypass (bypassadonis,badonis,adonisb)","bypasses adonis admin detection"},function()
	--[[local DebugFunc = getinfo or debug.getinfo
	local IsDebug = false
	local hooks = {}

	local DetectedMeth, KillMeth

	for index, value in getgc(true) do
		if typeof(value) == "table" then
			local detected = rawget(value, "Detected")
			local kill = rawget(value, "Kill")

			if typeof(detected) == "function" and not DetectedMeth then
				DetectedMeth = detected

				local hook
				hook = hookfunction(DetectedMeth, function(methodName, methodFunc, methodInfo)
					if methodName ~= "_" then
						if IsDebug then
							--DoNotif("Adonis Detected\nMethod: "..tostring(methodName).."\nInfo: "..tostring(methodFunc))
						end
					end

					return true
				end)

				Insert(hooks, DetectedMeth)
			end

			if rawget(value, "Variables") and rawget(value, "Process") and typeof(kill) == "function" and not KillMeth then
				KillMeth = kill
				local hook
				hook = hookfunction(KillMeth, function(killFunc)
					if IsDebug then
						--DoNotif("Adonis tried to detect: "..tostring(killFunc))
					end
				end)

				Insert(hooks, KillMeth)
			end
		end
	end

	local hook
	hook = hookfunction(getrenv().debug.info, newcclosure(function(...)
		local functionName, functionDetails = ...

		if DetectedMeth and functionName == DetectedMeth then
			if IsDebug or not IsDebug then
				--DoNotif("Adonis was bypassed by the_king.78")
			end

			return coroutine.yield(coroutine.running())
		end

		return hook(...)
	end))]]
	SpawnCall(function()
		local getgc = getgc or debug.getgc
		local hookfunction = hookfunction
		local getrenv = getrenv
		local debugInfo = (getrenv and getrenv().debug and getrenv().debug.info) or debug.info
		local newcclosure = newcclosure or function(f) return f end

		if not (getgc and hookfunction and getrenv and debugInfo) then
			DoNotif("Required exploit functions not available. Skipping Adonis bypass.",3,"Adonis Bypasser")
			return
		end

		local IsDebug = false
		local hooks = {}
		local DetectedMeth, KillMeth
		local AdonisFound = false

		for _, value in getgc(true) do
			if typeof(value) == "table" then
				local hasDetected = typeof(rawget(value, "Detected")) == "function"
				local hasKill = typeof(rawget(value, "Kill")) == "function"
				local hasVars = rawget(value, "Variables") ~= nil
				local hasProcess = rawget(value, "Process") ~= nil

				if hasDetected or (hasKill and hasVars and hasProcess) then
					AdonisFound = true
					break
				end
			end
		end

		if not AdonisFound then
			DoNotif("Adonis not found. Bypass skipped.",3,"Adonis Bypasser")
			return
		end

		for _, value in getgc(true) do
			if typeof(value) == "table" then
				local detected = rawget(value, "Detected")
				local kill = rawget(value, "Kill")

				if typeof(detected) == "function" and not DetectedMeth then
					DetectedMeth = detected
					local hook
					hook = hookfunction(DetectedMeth, function(methodName, methodFunc)
						if methodName ~= "_" and IsDebug then
							DoNotif("Adonis Detected\nMethod: "..methodName.."\nInfo: "..methodFunc,3,"Adonis Bypasser")
						end
						return true
					end)
					Insert(hooks, DetectedMeth)
					DoNotif("Hooked Adonis 'Detected' method.",3,"Adonis Bypasser")
				end

				if rawget(value, "Variables") and rawget(value, "Process") and typeof(kill) == "function" and not KillMeth then
					KillMeth = kill
					local hook
					hook = hookfunction(KillMeth, function(killFunc)
						if IsDebug then
							DoNotif("Adonis tried to kill function: "..killFunc,3,"Adonis Bypasser")
						end
					end)
					Insert(hooks, KillMeth)
					DoNotif("Hooked Adonis 'Kill' method.",3,"Adonis Bypasser")
				end
			end
		end

		if DetectedMeth and debugInfo then
			local hook
			hook = hookfunction(debugInfo, newcclosure(function(...)
				local functionName = ...
				if functionName == DetectedMeth then
					-- warn("Adonis detection intercepted. Bypassed by the_king.78.",3,"Adonis Bypasser")
					return coroutine.yield(coroutine.running())
				end
				return hook(...)
			end))
		end
	end)
end)

--[ LOCALPLAYER ]--
function respawn()
	local oldChar = getChar()
	local rootPart = getRoot(oldChar)
	while not rootPart do Wait(.1) rootPart=getRoot(oldChar) end

	local respawnCFrame = rootPart.CFrame

	local humanoid = getPlrHum(oldChar)
	while not humanoid do Wait(.1) humanoid=getPlrHum(oldChar) end
	humanoid:ChangeState(Enum.HumanoidStateType.Dead)
	humanoid.Health = 0

	local newChar = player.CharacterAdded:Wait()
	while not getRoot(newChar) do Wait(.1) getRoot(newChar) end

	local newRoot = getRoot(newChar)
	if newRoot then
		local startTime = tick()
		local teleportThreshold = 15

		while tick() - startTime < 0.4 do
			if (newRoot.Position - respawnCFrame.Position).Magnitude > teleportThreshold then
				newRoot.CFrame = respawnCFrame
				startTime = tick()
			end
			Wait(0.1)
		end
	end
end

cmd.add({"accountage","accage"},{"accountage <player> (accage)","Tells the account age of a player in the server"},function(...)
	Username=(...)

	target=getPlr(Username)
	for _, plr in next, target do
		teller=plr.AccountAge
		accountage="The account age of "..nameChecker(plr).." is "..teller

		Wait();

		DoNotif(accountage)
	end
end,true)

cmd.add({"hitboxes"},{"hitboxes","shows all the hitboxes"},function()
	settings():GetService("RenderSettings").ShowBoundingBoxes=true
end)

cmd.add({"unhitboxes"},{"unhitboxes","removes the hitboxes outline"},function()
	settings():GetService("RenderSettings").ShowBoundingBoxes=false
end)

cmd.add({"vfly","vehiclefly"},{"vehiclefly (vfly)","be able to fly vehicles"},function(...)
	local arg=(...) or nil
	flyVariables.vFlySpeed=tonumber(arg) or flyVariables.vFlySpeed or 1
	NAmanage.connectVFlyKey()
	NAmanage.activateMode("vfly")
	if not IsOnMobile then
		Wait()
		DebugNotif("Vehicle fly enabled. Press '"..string.upper(flyVariables.vToggleKey).."' to vfly/unvfly.")
	end
end,true)

cmd.add({"unvfly","unvehiclefly"},{"unvfly","disable vehicle fly"},function()
	NAmanage.deactivateMode("vfly")
end)

cmd.add({"equiptools","equipall"},{"equiptools","Equip all of your tools"},function()
	local backpack=getBp()
	if backpack then
		for _,tool in pairs(backpack:GetChildren()) do
			if tool:IsA("Tool") then
				tool.Parent=character
			end
		end
	end
end)

cmd.add({"usetools","uset"},{"usetools (uset)","Equips all tools, uses them, and unequips them"},function()
	local backpack = getBp()
	local character = Players.LocalPlayer.Character
	local equippedTools = {}

	if not backpack or not character then
		DebugNotif("Could not find backpack or character.")
		return
	end

	for _, tool in pairs(character:GetChildren()) do
		if tool:IsA("Tool") then
			Insert(equippedTools, tool)
		end
	end

	for _, tool in pairs(backpack:GetChildren()) do
		if tool:IsA("Tool") and not Discover(equippedTools, tool) then
			tool.Parent = character
		end
	end

	for _, tool in pairs(character:GetChildren()) do
		if tool:IsA("Tool") then
			NACaller(function()
				tool:Activate()
			end)
		end
	end

	Wait(1);

	for _, tool in pairs(character:GetChildren()) do
		if tool:IsA("Tool") and not Discover(equippedTools, tool) then
			tool.Parent = backpack
		end
	end

	for _, tool in pairs(equippedTools) do
		tool.Parent = character
	end
end)

cmd.add({"settweenspeed","tweenspeed"},{"tweenspeed [seconds]","Set how long tween teleport commands take"},function(seconds)
	if not seconds or seconds == "" then
		local current = tonumber(NAStuff.tweenSpeed) or 1
		DoNotif(("Current tween speed: %.2f seconds."):format(current))
		return
	end
	local value = tonumber(seconds)
	if not value then
		DoNotif("Please provide a numeric tween speed (seconds).")
		return
	end
	if value <= 0 then
		DoNotif("Tween speed must be greater than zero.")
		return
	end
	value = math.max(0.05, value)
	NAStuff.tweenSpeed = value
	NAmanage.NASettingsSet("tweenSpeed", value)
	DoNotif(("Tween speed set to %.2f seconds."):format(value))
	if not FileSupport then
		DebugNotif("Tween speed will reset when Roblox closes (no file support detected).")
	end
end)

cmd.add({"tweento","tweengoto","tgoto"},{"tweengoto <player>","Teleportation method that bypasses some anticheats"},function(name)
	local char = getChar()
	for _,plr in ipairs(getPlr(name)) do
		local cfVal = InstanceNew("CFrameValue")
		cfVal.Value = char:GetPivot()
		cfVal.Changed:Connect(function(newCF) char:PivotTo(newCF) end)
		local tw = TweenService:Create(cfVal, TweenInfo.new(NAmanage.resolveTweenDuration(), Enum.EasingStyle.Quad, Enum.EasingDirection.Out),{Value=plr.Character:GetPivot()})
		tw:Play()
		tw.Completed:Connect(function() cfVal:Destroy() end)
	end
end,true)


cmd.add({"reach", "swordreach"}, {"reach [number] (swordreach)", "Extends sword reach in one direction"}, function(reachsize)
	reachsize = tonumber(reachsize) or 15

	local char = getChar()
	local bp = getBp()
	local Tool = char and char:FindFirstChildOfClass("Tool") or bp and bp:FindFirstChildOfClass("Tool")
	if not Tool then return end

	local partSet = {}
	for _, p in ipairs(Tool:GetDescendants()) do
		if p:IsA("BasePart") then
			partSet[p.Name] = true
		end
	end

	local btns = {}
	for partName in pairs(partSet) do
		Insert(btns, {
			Text = partName,
			Callback = function()
				local toolPart = Tool:FindFirstChild(partName)
				if not toolPart then return end

				if not toolPart:FindFirstChild("OGSize3") then
					local val = InstanceNew("Vector3Value", toolPart)
					val.Name = "OGSize3"
					val.Value = toolPart.Size
				end

				if toolPart:FindFirstChild("FunTIMES") then
					toolPart.FunTIMES:Destroy()
				end

				local sb = InstanceNew("SelectionBox")
				sb.Adornee = toolPart
				sb.Name = "FunTIMES"
				sb.LineThickness = 0.01
				sb.Color3 = Color3.fromRGB(255, 0, 0)
				sb.Transparency = 0.7
				sb.Parent = toolPart

				toolPart.Massless = true
				toolPart.Size = Vector3.new(toolPart.Size.X, toolPart.Size.Y, reachsize)
			end
		})
	end

	Window({
		Title = "Reach Menu",
		Description = "Choose part to extend reach",
		Buttons = btns
	})
end, true)

cmd.add({"boxreach"}, {"boxreach [number]", "Creates a box-shaped hitbox around your tool"}, function(reachsize)
	reachsize = tonumber(reachsize) or 15

	local char = getChar()
	local bp = getBp()
	local Tool = char and char:FindFirstChildOfClass("Tool") or bp and bp:FindFirstChildOfClass("Tool")
	if not Tool then return end

	local partSet = {}
	for _, p in ipairs(Tool:GetDescendants()) do
		if p:IsA("BasePart") then
			partSet[p.Name] = true
		end
	end

	local btns = {}
	for partName in pairs(partSet) do
		Insert(btns, {
			Text = partName,
			Callback = function()
				local toolPart = Tool:FindFirstChild(partName)
				if not toolPart then return end

				if not toolPart:FindFirstChild("OGSize3") then
					local val = InstanceNew("Vector3Value", toolPart)
					val.Name = "OGSize3"
					val.Value = toolPart.Size
				end

				if toolPart:FindFirstChild("FunTIMES") then
					toolPart.FunTIMES:Destroy()
				end

				local sb = InstanceNew("SelectionBox")
				sb.Adornee = toolPart
				sb.Name = "FunTIMES"
				sb.LineThickness = 0.01
				sb.Color3 = Color3.fromRGB(0, 0, 255)
				sb.Transparency = 0.7
				sb.Parent = toolPart

				toolPart.Massless = true
				toolPart.Size = Vector3.new(reachsize, reachsize, reachsize)
			end
		})
	end

	Window({
		Title = "Box Reach Menu",
		Description = "Choose part to extend box reach",
		Buttons = btns
	})
end, true)

cmd.add({"resetreach", "normalreach", "unreach"}, {"resetreach (normalreach, unreach)", "Resets tool to normal size"}, function()
	local char = getChar()
	local bp = getBp()
	local Tool = char and char:FindFirstChildOfClass("Tool") or bp and bp:FindFirstChildOfClass("Tool")
	if not Tool then return end

	for _, p in ipairs(Tool:GetDescendants()) do
		if p:IsA("BasePart") then
			if p:FindFirstChild("OGSize3") then
				p.Size = p.OGSize3.Value
				p.OGSize3:Destroy()
			end
			if p:FindFirstChild("FunTIMES") then
				p.FunTIMES:Destroy()
			end
		end
	end
end)

local auraConn,auraViz

cmd.add({"aura"},{"aura [distance]","Continuously damages nearby players with equipped tool"},function(dist)
	dist=tonumber(dist) or 20
	local LocalPlayer=Players.LocalPlayer
	if not firetouchinterest then return DoNotif("firetouchinterest unsupported",2) end
	if auraConn then auraConn:Disconnect() auraConn=nil end
	if auraViz then auraViz:Destroy() auraViz=nil end
	auraViz=InstanceNew("Part")
	auraViz.Shape=Enum.PartType.Ball
	auraViz.Size=Vector3.new(dist*2,dist*2,dist*2)
	auraViz.Transparency=0.8
	auraViz.Color=Color3.fromRGB(255,0,0)
	auraViz.Material=Enum.Material.Neon
	auraViz.Anchored=true
	auraViz.CanCollide=false
	auraViz.Parent=workspace
	local function getHandle()
		local c=getChar() if not c then return end
		local t=c:FindFirstChildWhichIsA("Tool") if not t then return end
		return t:FindFirstChild("Handle") or t:FindFirstChildWhichIsA("BasePart")
	end
	auraConn=RunService.RenderStepped:Connect(function()
		local handle=getHandle()
		local root=getRoot(getChar())
		if not handle or not root then return end
		auraViz.CFrame=root.CFrame
		for _,plr in ipairs(Players:GetPlayers()) do
			if plr~=LocalPlayer and plr.Character then
				local hum=getPlrHum(plr)
				if hum and hum.Health>0 then
					for _,part in ipairs(plr.Character:GetChildren()) do
						if part:IsA("BasePart") and (part.Position-handle.Position).Magnitude<=dist then
							firetouchinterest(handle,part,0)
							Wait();
							firetouchinterest(handle,part,1)
							break
						end
					end
				end
			end
		end
	end)
	DebugNotif("Aura enabled at "..dist,1.2)
end,true)

cmd.add({"unaura"},{"unaura","Stops aura loop and removes visualizer"},function()
	if auraConn then auraConn:Disconnect() auraConn=nil end
	if auraViz then auraViz:Destroy() auraViz=nil end
	DebugNotif("Aura disabled",1.2)
end,true)

cmd.add({"antivoid"},{"antivoid","Prevents you from falling into the void by launching you upwards"},function()
	NAlib.disconnect("antivoid")

	NAlib.connect("antivoid", RunService.RenderStepped:Connect(function()
		local character = getChar()
		local root = character and getRoot(character)
		if root and root.Position.Y <= OrgDestroyHeight + 25 then
			root.Velocity = Vector3.new(root.Velocity.X, root.Velocity.Y + 250, root.Velocity.Z)
		end
	end))

	DebugNotif("AntiVoid Enabled", 3)
end)

cmd.add({"unantivoid"},{"unantivoid","Disables antivoid"},function()
	NAlib.disconnect("antivoid")
	DebugNotif("AntiVoid Disabled", 3)
end)

cmd.add({"fakeout"}, {"fakeout", "tp to void and back"}, function()
	local character = getChar()
	local root = character and getRoot(character)
	if not root then
		DebugNotif("Fakeout failed: unable to find character root", 2)
		return
	end
	local antivoidConnections = connections["antivoid"]
	local antivoidWasActive = false
	if antivoidConnections then
		for _, conn in ipairs(antivoidConnections) do
			if conn.Connected then
				antivoidWasActive = true
				break
			end
		end
	end
	if antivoidWasActive then
		NAlib.disconnect("antivoid")
	end
	local originalDestroyHeight = workspace.FallenPartsDestroyHeight
	local originalCFrame = root.CFrame
	local dropHeight = OrgDestroyHeight or originalDestroyHeight or 0
	workspace.FallenPartsDestroyHeight = 0/1/0
	root.CFrame = CFrame.new(Vector3.new(0, dropHeight - 25, 0))
	Wait(1)
	root.CFrame = originalCFrame
	workspace.FallenPartsDestroyHeight = originalDestroyHeight
	if antivoidWasActive then
		local antivoidCommand = cmds.Commands["antivoid"]
		if antivoidCommand and antivoidCommand[1] then
			antivoidCommand[1]()
		end
	end
end)

cmd.add({"invisfling"}, {"invisfling", "Enables invisible fling (the invis part is patched, try using the god command before using this)"}, function()
	local player = Players.LocalPlayer
	local character = getChar()
	local humanoid = getHum()
	if not (player and character and humanoid) then
		DebugNotif("Invisfling failed: missing character", 2)
		return
	end

	humanoid:SetStateEnabled(Enum.HumanoidStateType.Dead, false)

	local proxyModel = InstanceNew("Model")
	proxyModel.Name = "NA_InvisFlingProxy"
	proxyModel.Parent = character

	local torso = InstanceNew("Part")
	torso.Name = "Torso"
	torso.CanCollide = false
	torso.Anchored = true
	torso.Position = Vector3.new(0, 9999, 0)
	torso.Parent = proxyModel

	local head = InstanceNew("Part")
	head.Name = "Head"
	head.CanCollide = false
	head.Anchored = true
	head.Parent = proxyModel

	local proxyHumanoid = InstanceNew("Humanoid")
	proxyHumanoid.Name = "Humanoid"
	proxyHumanoid.Parent = proxyModel

	player.Character = proxyModel
	Wait(3)
	player.Character = character
	Wait(3)

	character = getChar()
	if not character then
		DebugNotif("Invisfling aborted: character missing", 2)
		return
	end

	local activeHumanoid = getHum()
	if not activeHumanoid then
		activeHumanoid = InstanceNew("Humanoid")
		activeHumanoid.Name = "Humanoid"
		activeHumanoid.Parent = character
	end

	local root = getRoot(character)
	if not root then
		DebugNotif("Invisfling failed: missing root", 2)
		return
	end

	for _, child in ipairs(character:GetChildren()) do
		if child ~= root and child.Name ~= "Humanoid" then
			child:Destroy()
		end
	end

	root.Transparency = 0
	root.Color = Color3.new(1, 1, 1)

	local invisflingStepped
	invisflingStepped = RunService.Stepped:Connect(function()
		local currentChar = getChar()
		local currentRoot = currentChar and getRoot(currentChar)
		if currentRoot then
			currentRoot.CanCollide = false
		else
			invisflingStepped:Disconnect()
		end
	end)

	NAmanage.activateMode("fly")
	workspace.CurrentCamera.CameraSubject = root

	local thrust = InstanceNew("BodyThrust")
	thrust.Parent = root
	thrust.Force = Vector3.new(99999, 99999 * 10, 99999)
	thrust.Location = root.Position
end)

cmd.add({"split"}, {"split", "Destroys waist joint"}, function()
	if not IsR15() then
		DoNotif("This command requires the R15 rig type.", 3, "split")
		return
	end

	local character = getChar()
	if not character then
		DebugNotif("Split failed: no character", 2)
		return
	end

	local upperTorso = getTorso(character)
	local waist = upperTorso and upperTorso:FindFirstChild("Waist")
	if waist then
		waist:Destroy()
		DebugNotif("Waist joint removed.", 2)
	else
		DebugNotif("Split failed: waist joint not found.", 2)
	end
end)
originalFPDH = nil

cmd.add({"antivoid2"}, {"antivoid2", "sets FallenPartsDestroyHeight to -inf"}, function()
	if not originalFPDH then
		originalFPDH = workspace.FallenPartsDestroyHeight
	end

	workspace.FallenPartsDestroyHeight = -9e9
end)

cmd.add({"unantivoid2"}, {"unantivoid2", "reverts FallenPartsDestroyHeight"}, function()
	if originalFPDH ~= nil then
		workspace.FallenPartsDestroyHeight = originalFPDH
		DebugNotif("FallenPartsDestroyHeight reverted to original value | Antivoid2 Disabled",2)
	else
		DebugNotif("Original value was not stored. Cannot revert.",2)
	end
end)

cmd.add({"antivelocity","antivelo","av","velcap"}, {"antivelocity [limit]", "Limits your character's velocity to the provided value"}, function(limitArg)
	local limit = tonumber(limitArg)
	if not limit then
		DebugNotif("Please provide a number for antivelocity.", 3)
		return
	end
	if limit <= 0 then
		DebugNotif("Antivelocity requires a value greater than zero.", 3)
		return
	end

	AntiVelocityLimit = limit
	NAlib.disconnect("antivelocity_limit")

	NAlib.connect("antivelocity_limit", RunService.Heartbeat:Connect(function()
		if not AntiVelocityLimit then
			return
		end

		local character = getChar()
		local root = character and getRoot(character)
		if not root then
			return
		end

		local velocity = root.AssemblyLinearVelocity
		local speed = velocity.Magnitude
		if speed > AntiVelocityLimit then
			if speed > 0 then
				root.AssemblyLinearVelocity = velocity.Unit * AntiVelocityLimit
			else
				root.AssemblyLinearVelocity = Vector3.zero
			end
		end
	end))

	DebugNotif(("Velocity capped at %s studs/sec."):format(tostring(limit)), 3)
end, true)

cmd.add({"unantivelocity","unantivelo","unav","unvelcap"}, {"unantivelocity", "Disables the antivelocity limiter"}, function()
	AntiVelocityLimit = nil
	NAlib.disconnect("antivelocity_limit")
	DebugNotif("Antivelocity disabled.", 2)
end)

comPart, comHL, comConn, comRadius = nil,nil,nil,nil

cmd.add({"showcom","centerofmass","com"},{"showcom [radiusStuds]","Create a glass sphere with a Highlight at your center of mass"},function(...)
	comRadius = tonumber(({...})[1]) or 0.35
	if comConn then comConn:Disconnect() comConn=nil end
	NAlib.disconnect("com_track")

	local function ensureParts()
		if not comPart or not comPart.Parent then
			if comPart then pcall(function() comPart:Destroy() end) end
			comPart = InstanceNew("Part")
			comPart.Shape = Enum.PartType.Ball
			comPart.Anchored = true
			comPart.CanCollide = false
			comPart.CanQuery = false
			comPart.CanTouch = false
			comPart.Massless = true
			comPart.CastShadow = false
			comPart.Material = Enum.Material.Glass
			comPart.Transparency = 0
			local sz = comRadius*2
			comPart.Size = Vector3.new(sz, sz, sz)
			comPart.Parent = workspace
		end
		if not comHL or not comHL.Parent or comHL.Adornee ~= comPart then
			if comHL then pcall(function() comHL:Destroy() end) end
			comHL = InstanceNew("Highlight")
			comHL.Adornee = comPart
			comHL.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
			comHL.FillTransparency = 0.25
			comHL.OutlineTransparency = 0
			comHL.FillColor = Color3.fromRGB(255, 255, 0)
			comHL.OutlineColor = Color3.fromRGB(255, 255, 0)
			comHL.Parent = comPart
		end
	end

	comConn = RunService.Heartbeat:Connect(function()
		ensureParts()
		local char = getChar()
		local root = char and (getRoot(char) or char:FindFirstChildWhichIsA("BasePart"))
		if root and root:IsDescendantOf(workspace) and comPart and comPart.Parent then
			local pos = root.AssemblyCenterOfMass or root.Position
			comPart.Anchored = true
			comPart.CanCollide = false
			comPart.Material = Enum.Material.Glass
			comPart.Transparency = 0
			local sz = comRadius*2
			if comPart.Size.X ~= sz then comPart.Size = Vector3.new(sz, sz, sz) end
			comPart.CFrame = CFrame.new(pos)
		end
	end)

	NAlib.connect("com_track", comConn)
end,true)

cmd.add({"hidecom","unshowcom","uncom"},{"hidecom","Remove COM tracker"},function()
	NAlib.disconnect("com_track")
	if comConn then comConn:Disconnect() comConn=nil end
	if comHL then pcall(function() comHL:Destroy() end) comHL=nil end
	if comPart then pcall(function() comPart:Destroy() end) comPart=nil end
end)

cmd.add({"droptool"}, {"dropatool", "Drop one of your tools"}, function()
	local backpack = getBp()
	local toolToDrop = nil

	for _, tool in ipairs(getChar():GetChildren()) do
		if tool:IsA("Tool") and NAlib.isProperty(tool, "CanBeDropped") == true then
			toolToDrop = tool
			break
		end
	end

	Wait()

	if backpack and not toolToDrop then
		for _, tool in ipairs(backpack:GetChildren()) do
			if tool:IsA("Tool") and NAlib.isProperty(tool, "CanBeDropped") == true then
				tool.Parent = getChar()
				toolToDrop = tool
				break
			end
		end
	end

	if toolToDrop then
		toolToDrop.Parent = workspace
		DebugNotif("Dropped: "..toolToDrop.Name, 4)
	else
		DebugNotif("No droppable tool found", 4)
	end
end)

cmd.add({"droptools"}, {"dropalltools", "Drop all of your tools"}, function()
	local backpack = getBp()
	local character = getChar()
	if not character then
		return DebugNotif("Character not available", 4)
	end

	local queue = {}
	local function collect(from)
		if not from then return end
		for _, tool in ipairs(from:GetChildren()) do
			if tool:IsA("Tool") and NAlib.isProperty(tool, "CanBeDropped") == true then
				Insert(queue, tool)
			end
		end
	end

	collect(character)
	collect(backpack)

	if #queue == 0 then
		return DebugNotif("No droppable tools found", 4)
	end

	local dropped = 0

	for _, tool in ipairs(queue) do
		if tool and tool.Parent then
			if tool.Parent == backpack then
				tool.Parent = character
				Wait()
			end

			if tool.Parent == character then
				tool.Parent = workspace
				dropped += 1
				Wait(.05)
			end
		end
	end

	if dropped > 0 then
		DebugNotif("Dropped "..dropped.." tool(s)", 4)
	else
		DebugNotif("No droppable tools found", 4)
	end
end)

cmd.add({"notools"},{"notools","Remove your tools"},function()
	for _,tool in pairs(getChar():GetDescendants()) do
		if tool:IsA("Tool") then
			tool:Destroy()
		end
	end
	for _,tool in pairs(getBp():GetDescendants()) do
		if tool:IsA("Tool") then
			tool:Destroy()
		end
	end
end)

-- leg resize sureeee
cmd.addPatched({"breaklayeredclothing","blc"},{"breaklayeredclothing (blc)","Streches your layered clothing"},function()
	Wait();

	DoNotif("Break layered clothing executed,if you havent already equip shirt,jacket,pants and shoes (Layered Clothing ones)")
	local swimming=false
	oldgrav=workspace.Gravity
	workspace.Gravity=0
	local char=getChar()
	local swimDied=function()
		workspace.Gravity=oldgrav
		swimming=false
	end
	Humanoid=char:FindFirstChildWhichIsA("Humanoid")
	gravReset=Humanoid.Died:Connect(swimDied)
	enums=Enum.HumanoidStateType:GetEnumItems()
	table.remove(enums,Discover(enums,Enum.HumanoidStateType.None))
	for i,v in pairs(enums) do
		Humanoid:SetStateEnabled(v,false)
	end
	Humanoid:ChangeState(Enum.HumanoidStateType.Swimming)
	swimbeat=RunService.Heartbeat:Connect(function()
		pcall(function()
			getRoot(char).Velocity=((Humanoid.MoveDirection~=Vector3.new() or UserInputService:IsKeyDown(Enum.KeyCode.Space)) and getRoot(char).Velocity or Vector3.new())
		end)
	end)
	swimming=true
	Clip=false
	Wait(0.1)
	function NoclipLoop()
		if Clip==false and char~=nil then
			for _,child in pairs(char:GetDescendants()) do
				if child:IsA("BasePart") and child.CanCollide==true then
					child.CanCollide=false
				end
			end
		end
	end
	Noclipping=RunService.Stepped:Connect(NoclipLoop)
	loadstring(game:HttpGet('https://raw.githubusercontent.com/ltseverydayyou/Nameless-Admin/main/leg%20resize'))()
end)

cmd.add({"fpsbooster","lowgraphics","boostfps","lowg"},{"fpsbooster","Enables maximum-performance low graphics mode, run again to restore"},function()
	local g=getgenv and getgenv() or _G
	if g.NA_FPS_ACTIVE then
		g.NA_FPS_ACTIVE=false
		if g.NA_FPS_UNHOOK then g.NA_FPS_UNHOOK() end
		return
	end

	local w=workspace
	local st=(NAmanage and NAmanage._ensureL and NAmanage._ensureL()) or {safeGet=function(i,p)local ok,v=pcall(function()return i[p]end)return ok and v or nil end,safeSet=function(i,p,v)NAlib.setProperty(i,p,v)end}
	local opt=opt or {hiddenprop=function() end}

	local function setHiddenOrNormal(inst,prop,val)
		local ok=false
		if opt and opt.hiddenprop then ok=pcall(function() opt.hiddenprop(inst,prop,val) end) end
		if not ok then st.safeSet(inst,prop,val) end
	end

	local active=false
	local cons={}
	local watchers=setmetatable({}, {__mode="k"})
	local function connect(sig,fn)local c=sig:Connect(fn);Insert(cons,c);return c end
	local function disconnectAll()
		for _,c in ipairs(cons) do pcall(function() c:Disconnect() end) end
		cons={}
		watchers=setmetatable({}, {__mode="k"})
	end
	local function forceProperty(inst,prop,desired)
		if not inst then return end
		local bucket=watchers[inst]
		if not bucket then
			bucket={}
			watchers[inst]=bucket
		end
		local function apply()
			if not active then return end
			local current=st.safeGet(inst,prop)
			if current~=nil and current~=desired then
				st.safeSet(inst,prop,desired)
			end
		end
		apply()
		if bucket[prop] then return end
		local ok,conn=pcall(function()
			return inst:GetPropertyChangedSignal(prop):Connect(function()
				apply()
			end)
		end)
		if ok and conn then
			bucket[prop]=conn
			Insert(cons,conn)
		end
	end

	local A="NA_FPS_"
	local function remember(inst,prop,val)
		local key=A..prop
		if inst:GetAttribute(key)==nil then
			if typeof(val)=="EnumItem" then inst:SetAttribute(key,val.Name) else inst:SetAttribute(key,val) end
		end
	end
	local function recall(inst,prop) return inst:GetAttribute(A..prop) end
	local function clearAttr(inst,prop) inst:SetAttribute(A..prop,nil) end
	local function isCharacterOrNPC(inst)local a=inst while a do if a:IsA("Model") and a:FindFirstChildOfClass("Humanoid") then return true end a=a.Parent end return false end
	local function isClothingLike(inst) return inst:IsA("Shirt") or inst:IsA("Pants") or inst:IsA("ShirtGraphic") or inst:IsA("Accessory") or inst:IsA("Clothing") or inst:IsA("HumanoidDescription") end

	local originals={quality=nil,lighting={},terrain={},workspace={},postFx={},postFxCam={}}
	local function snapshotEnv()
		if originals.quality==nil then pcall(function() originals.quality=settings().Rendering.QualityLevel end) end
		for _,p in ipairs({"GlobalShadows","FogEnd","Brightness","Ambient","OutdoorAmbient","LightingStyle","Technology"}) do
			if originals.lighting[p]==nil then originals.lighting[p]=st.safeGet(Lighting,p) end
		end
		for _,e in ipairs(Lighting:GetChildren()) do
			if e:IsA("BlurEffect") or e:IsA("SunRaysEffect") or e:IsA("ColorCorrectionEffect") or e:IsA("BloomEffect") or e:IsA("DepthOfFieldEffect") or e:IsA("Atmosphere") then
				if originals.postFx[e]==nil then local en=st.safeGet(e,"Enabled"); originals.postFx[e]=(en==nil) and true or en end
			end
		end
		local cam=w.CurrentCamera
		if cam then
			for _,e in ipairs(cam:GetChildren()) do
				if e:IsA("BlurEffect") or e:IsA("SunRaysEffect") or e:IsA("ColorCorrectionEffect") or e:IsA("BloomEffect") or e:IsA("DepthOfFieldEffect") or e:IsA("Atmosphere") then
					if originals.postFxCam[e]==nil then local en=st.safeGet(e,"Enabled"); originals.postFxCam[e]=(en==nil) and true or en end
				end
			end
		end
		local T=w:FindFirstChildOfClass("Terrain")
		if T then
			for _,p in ipairs({"Decoration","WaterWaveSize","WaterWaveSpeed","WaterReflectance","WaterTransparency"}) do
				if originals.terrain[p]==nil then originals.terrain[p]=st.safeGet(T,p) end
			end
		end
		for _,p in ipairs({"StreamingEnabled","StreamingPauseMode","StreamOutBehavior","TargetRadius"}) do
			if originals.workspace[p]==nil then originals.workspace[p]=st.safeGet(w,p) end
		end
	end

	local function applyEnv()
		pcall(function() settings().Rendering.QualityLevel=Enum.QualityLevel.Level01 end)
		st.safeSet(Lighting,"GlobalShadows",false)
		st.safeSet(Lighting,"FogEnd",math.huge)
		st.safeSet(Lighting,"Brightness",0)
		st.safeSet(Lighting,"Ambient",Color3.new(0.4,0.4,0.4))
		st.safeSet(Lighting,"OutdoorAmbient",Color3.new(0.4,0.4,0.4))
		setHiddenOrNormal(Lighting,"LightingStyle",Enum.LightingStyle.Soft)
		setHiddenOrNormal(Lighting,"Technology",Enum.Technology.Compatibility)
		local T=w:FindFirstChildOfClass("Terrain")
		if T then
			st.safeSet(T,"Decoration",false)
			st.safeSet(T,"WaterWaveSize",0)
			st.safeSet(T,"WaterWaveSpeed",0)
			st.safeSet(T,"WaterReflectance",0)
			st.safeSet(T,"WaterTransparency",0)
		end
		st.safeSet(w,"StreamingEnabled",true)
		pcall(function() w.StreamOutBehavior=Enum.StreamOutBehavior.LowMemory or Enum.StreamOutBehavior.Default end)
		st.safeSet(w,"StreamingPauseMode",Enum.StreamingPauseMode.Default)
		st.safeSet(w,"TargetRadius",96)
		for _,e in ipairs(Lighting:GetChildren()) do if e:IsA("PostEffect") then st.safeSet(e,"Enabled",false) end if e:IsA("Atmosphere") then if st.safeGet(e,"Density")~=nil then st.safeSet(e,"Density",0) end end end
		local cam=w.CurrentCamera
		if cam then for _,e in ipairs(cam:GetChildren()) do if e:IsA("PostEffect") then st.safeSet(e,"Enabled",false) end if e:IsA("Atmosphere") then if st.safeGet(e,"Density")~=nil then st.safeSet(e,"Density",0) end end end end
	end

	local function restoreEnv()
		pcall(function() if originals.quality~=nil then settings().Rendering.QualityLevel=originals.quality end end)
		for p,v in pairs(originals.lighting) do
			if v~=nil then
				if p=="LightingStyle" then
					setHiddenOrNormal(Lighting,p,typeof(v)=="EnumItem" and v or Enum.LightingStyle[v] or Enum.LightingStyle.Soft)
				elseif p=="Technology" then
					setHiddenOrNormal(Lighting,p,typeof(v)=="EnumItem" and v or Enum.Technology[v] or Enum.Technology.Compatibility)
				else
					st.safeSet(Lighting,p,v)
				end
			end
		end
		for e,wasEnabled in pairs(originals.postFx) do if e and e.Parent and st.safeGet(e,"Enabled")~=nil then st.safeSet(e,"Enabled",wasEnabled) end end
		for e,wasEnabled in pairs(originals.postFxCam) do if e and e.Parent and st.safeGet(e,"Enabled")~=nil then st.safeSet(e,"Enabled",wasEnabled) end end
		local T=w:FindFirstChildOfClass("Terrain")
		if T then for p,v in pairs(originals.terrain) do if v~=nil then st.safeSet(T,p,v) end end end
		for p,v in pairs(originals.workspace) do if v~=nil then st.safeSet(w,p,v) end end
	end

	local function optimizeInstance(inst)
		if not active then return end
		if isCharacterOrNPC(inst) then return end
		if isClothingLike(inst) then return end
		if inst:IsA("BasePart") then
			remember(inst,"Material",inst.Material)
			remember(inst,"MaterialVariant",st.safeGet(inst,"MaterialVariant"))
			remember(inst,"Reflectance",inst.Reflectance)
			remember(inst,"CastShadow",inst.CastShadow)
			st.safeSet(inst,"Material",Enum.Material.Plastic)
			st.safeSet(inst,"MaterialVariant","")
			st.safeSet(inst,"Reflectance",0)
			st.safeSet(inst,"CastShadow",false)
			if inst:IsA("MeshPart") then
				if st.safeGet(inst,"TextureID")~=nil then remember(inst,"TextureID",inst.TextureID); st.safeSet(inst,"TextureID","") end
			end
		end
		if inst:IsA("SpecialMesh") then remember(inst,"TextureId",inst.TextureId); st.safeSet(inst,"TextureId","") end
		if inst:IsA("Decal") or inst:IsA("Texture") then remember(inst,"Transparency",inst.Transparency); st.safeSet(inst,"Transparency",1) end
		if inst:IsA("ParticleEmitter") or inst:IsA("Trail") or inst:IsA("Fire") or inst:IsA("Smoke") or inst:IsA("Sparkles") then remember(inst,"Enabled",inst.Enabled); st.safeSet(inst,"Enabled",false) end
		if inst:IsA("Beam") then remember(inst,"Enabled",st.safeGet(inst,"Enabled")); if st.safeGet(inst,"Enabled")~=nil then st.safeSet(inst,"Enabled",false) end end
		if inst:IsA("PointLight") or inst:IsA("SurfaceLight") or inst:IsA("SpotLight") then remember(inst,"Enabled",inst.Enabled); st.safeSet(inst,"Enabled",false) end
		if inst:IsA("SurfaceAppearance") or inst:IsA("Highlight") then remember(inst,"Enabled",st.safeGet(inst,"Enabled")); if st.safeGet(inst,"Enabled")~=nil then st.safeSet(inst,"Enabled",false) end end
		if inst:IsA("PostEffect") then
			local enabledValue=st.safeGet(inst,"Enabled")
			if enabledValue~=nil then remember(inst,"Enabled",enabledValue) end
			forceProperty(inst,"Enabled",false)
		end
		if inst:IsA("Atmosphere") then
			local density=st.safeGet(inst,"Density")
			if density~=nil then remember(inst,"Density",density); forceProperty(inst,"Density",0) end
			local haze=st.safeGet(inst,"Haze")
			if haze~=nil then remember(inst,"Haze",haze); forceProperty(inst,"Haze",0) end
			local glare=st.safeGet(inst,"Glare")
			if glare~=nil then remember(inst,"Glare",glare); forceProperty(inst,"Glare",0) end
		end
		if inst:IsA("Explosion") then remember(inst,"BlastPressure",inst.BlastPressure); remember(inst,"BlastRadius",inst.BlastRadius); st.safeSet(inst,"BlastPressure",1); st.safeSet(inst,"BlastRadius",1) end
	end

	local function restoreInstance(inst)
		if inst:IsA("BasePart") then
			local m=recall(inst,"Material"); if m~=nil then st.safeSet(inst,"Material",Enum.Material[m] or inst.Material) clearAttr(inst,"Material") end
			local mv=recall(inst,"MaterialVariant"); if mv~=nil then st.safeSet(inst,"MaterialVariant",mv) clearAttr(inst,"MaterialVariant") end
			local r=recall(inst,"Reflectance"); if r~=nil then st.safeSet(inst,"Reflectance",r) clearAttr(inst,"Reflectance") end
			local cs=recall(inst,"CastShadow"); if cs~=nil then st.safeSet(inst,"CastShadow",cs) clearAttr(inst,"CastShadow") end
			if inst:IsA("MeshPart") then local tx=recall(inst,"TextureID"); if tx~=nil then st.safeSet(inst,"TextureID",tx) clearAttr(inst,"TextureID") end end
		end
		if inst:IsA("SpecialMesh") then local t=recall(inst,"TextureId"); if t~=nil then st.safeSet(inst,"TextureId",t) clearAttr(inst,"TextureId") end end
		if inst:IsA("Decal") or inst:IsA("Texture") then local t=recall(inst,"Transparency"); if t~=nil then st.safeSet(inst,"Transparency",t) clearAttr(inst,"Transparency") end end
		if inst:IsA("ParticleEmitter") or inst:IsA("Trail") or inst:IsA("Fire") or inst:IsA("Smoke") or inst:IsA("Sparkles") then local e=recall(inst,"Enabled"); if e~=nil then st.safeSet(inst,"Enabled",e) clearAttr(inst,"Enabled") end end
		if inst:IsA("Beam") then local e=recall(inst,"Enabled"); if e~=nil then st.safeSet(inst,"Enabled",e) clearAttr(inst,"Enabled") end end
		if inst:IsA("PointLight") or inst:IsA("SurfaceLight") or inst:IsA("SpotLight") then local e=recall(inst,"Enabled"); if e~=nil then st.safeSet(inst,"Enabled",e) clearAttr(inst,"Enabled") end end
		if inst:IsA("SurfaceAppearance") or inst:IsA("Highlight") then local e=recall(inst,"Enabled"); if e~=nil then st.safeSet(inst,"Enabled",e) clearAttr(inst,"Enabled") end end
		if inst:IsA("PostEffect") then local e=recall(inst,"Enabled"); if e~=nil then st.safeSet(inst,"Enabled",e) clearAttr(inst,"Enabled") end end
		if inst:IsA("Atmosphere") then
			local d=recall(inst,"Density"); if d~=nil then st.safeSet(inst,"Density",d) clearAttr(inst,"Density") end
			local h=recall(inst,"Haze"); if h~=nil then st.safeSet(inst,"Haze",h) clearAttr(inst,"Haze") end
			local g=recall(inst,"Glare"); if g~=nil then st.safeSet(inst,"Glare",g) clearAttr(inst,"Glare") end
		end
		if inst:IsA("Explosion") then local bp=recall(inst,"BlastPressure"); if bp~=nil then st.safeSet(inst,"BlastPressure",bp) clearAttr(inst,"BlastPressure") end local br=recall(inst,"BlastRadius"); if br~=nil then st.safeSet(inst,"BlastRadius",br) clearAttr(inst,"BlastRadius") end end
	end

	local function sweepAll() for _,v in ipairs(w:GetDescendants()) do Defer(function() optimizeInstance(v) end) end end
	local function restoreAll() for _,v in ipairs(w:GetDescendants()) do Defer(function() restoreInstance(v) end) end end

	local function enable()
		if active then return end
		active=true
		snapshotEnv()
		applyEnv()
		for _,v in ipairs(Lighting:GetDescendants()) do Defer(function() optimizeInstance(v) end) end
		sweepAll()
		Insert(cons, connect(w.DescendantAdded,function(v) Defer(function() optimizeInstance(v) end) end))
		Insert(cons, connect(Lighting.DescendantAdded,function(v) Defer(function() optimizeInstance(v) end) end))
		Insert(cons, connect(w:GetPropertyChangedSignal("CurrentCamera"),function()
			local cam=w.CurrentCamera
			if not cam then return end
			for _,e in ipairs(cam:GetChildren()) do Defer(function() optimizeInstance(e) end) end
			Insert(cons, connect(cam.ChildAdded,function(e) Defer(function() optimizeInstance(e) end) end))
		end))
		local cam=w.CurrentCamera
		if cam then
			for _,e in ipairs(cam:GetChildren()) do Defer(function() optimizeInstance(e) end) end
			Insert(cons, connect(cam.ChildAdded,function(e) Defer(function() optimizeInstance(e) end) end))
		end
	end

	local function disable()
		if not active then return end
		active=false
		disconnectAll()
		restoreAll()
		restoreEnv()
	end

	g.NA_FPS_UNHOOK=function() disable() g.NA_FPS_UNHOOK=nil end
	enable()
	g.NA_FPS_ACTIVE=true
end)

cmd.add({"antilag","boostfps"},{"antilag (boostfps)","Low Graphics"},function()
	local sGUI = InstanceNew("ScreenGui")
	NaProtectUI(sGUI)
	sGUI.Name = "AntiLagGUI"
	sGUI.ResetOnSpawn = false

	local frame = InstanceNew("Frame")
	frame.AnchorPoint = Vector2.new(0.5, 0)
	frame.Size = UDim2.new(0.3, 0, 0.5, 0)
	frame.Position = UDim2.new(0.5, 0, 0.35, 0)
	frame.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
	frame.BorderSizePixel = 0
	frame.Parent = sGUI

	local topbar = InstanceNew("Frame")
	topbar.Name = "TopBar"
	topbar.Size = UDim2.new(1, 0, 0, 30)
	topbar.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
	topbar.BorderSizePixel = 0
	topbar.Parent = frame

	local title = InstanceNew("TextLabel")
	title.Text = "AntiLag Settings"
	title.Font = Enum.Font.SourceSansBold
	title.TextSize = 18
	title.TextColor3 = Color3.new(1,1,1)
	title.BackgroundTransparency = 1
	title.Size = UDim2.new(1, -60, 1, 0)
	title.Position = UDim2.new(0, 10, 0, 0)
	title.TextXAlignment = Enum.TextXAlignment.Left
	title.Parent = topbar

	local closeBtn = InstanceNew("TextButton")
	closeBtn.Size = UDim2.new(0, 24, 0, 24)
	closeBtn.Position = UDim2.new(1, -28, 0, 3)
	closeBtn.BackgroundColor3 = Color3.fromRGB(180, 40, 40)
	closeBtn.Text = "X"
	closeBtn.TextColor3 = Color3.new(1, 1, 1)
	closeBtn.Font = Enum.Font.SourceSansBold
	closeBtn.TextSize = 16
	closeBtn.Parent = topbar

	local minimizeBtn = InstanceNew("TextButton")
	minimizeBtn.Size = UDim2.new(0, 24, 0, 24)
	minimizeBtn.Position = UDim2.new(1, -56, 0, 3)
	minimizeBtn.BackgroundColor3 = Color3.fromRGB(100, 100, 100)
	minimizeBtn.Text = "-"
	minimizeBtn.TextColor3 = Color3.new(1, 1, 1)
	minimizeBtn.Font = Enum.Font.SourceSansBold
	minimizeBtn.TextSize = 16
	minimizeBtn.Parent = topbar

	local content = InstanceNew("Frame")
	content.Name = "Content"
	content.Size = UDim2.new(1, 0, 1, -30)
	content.Position = UDim2.new(0, 0, 0, 30)
	content.BackgroundTransparency = 1
	content.Parent = frame

	local scrollingFrame = InstanceNew("ScrollingFrame", content)
	scrollingFrame.Size = UDim2.new(1, 0, 1, -60)
	scrollingFrame.Position = UDim2.new(0, 0, 0, 0)
	scrollingFrame.CanvasSize = UDim2.new(0, 0, 0, 0)
	scrollingFrame.ScrollBarThickness = 6
	scrollingFrame.BackgroundTransparency = 1

	local layout = InstanceNew("UIListLayout", scrollingFrame)
	layout.Padding = UDim.new(0, 5)
	layout.SortOrder = Enum.SortOrder.LayoutOrder

	local padding = InstanceNew("UIPadding", scrollingFrame)
	padding.PaddingTop = UDim.new(0, 10)
	padding.PaddingBottom = UDim.new(0, 10)
	padding.PaddingLeft = UDim.new(0, 10)
	padding.PaddingRight = UDim.new(0, 10)

	local defaultSettings = {
		Players = {
			["Ignore Me"] = true,
			["Ignore Others"] = true
		},
		Meshes = {
			Destroy = false,
			LowDetail = true
		},
		Images = {
			Invisible = true,
			LowDetail = true,
			Destroy = true
		},
		Other = {
			["No Particles"] = true,
			["No Camera Effects"] = true,
			["No Explosions"] = true,
			["No Clothes"] = true,
			["Low Water Graphics"] = true,
			["No Shadows"] = true,
			["Low Rendering"] = true,
			["Low Quality Parts"] = true
		}
	}

	local userSettings = table.clone(defaultSettings)

	local function updateCanvas()
		Wait()
		scrollingFrame.CanvasSize = UDim2.new(0, 0, 0, layout.AbsoluteContentSize.Y + 20)
	end

	local function createSection(sectionName, keys)
		local dropdown = InstanceNew("TextButton")
		dropdown.Size = UDim2.new(1, -10, 0, 32)
		dropdown.BackgroundColor3 = Color3.fromRGB(45, 45, 45)
		dropdown.TextColor3 = Color3.new(1, 1, 1)
		dropdown.Font = Enum.Font.SourceSansBold
		dropdown.TextSize = 20
		dropdown.Text = "▼ "..sectionName
		dropdown.AutoButtonColor = false
		dropdown.Parent = scrollingFrame

		local container = InstanceNew("Frame")
		container.Size = UDim2.new(1, -10, 0, 0)
		container.BackgroundTransparency = 1
		container.ClipsDescendants = true
		container.Parent = scrollingFrame

		local subLayout = InstanceNew("UIListLayout", container)
		subLayout.Padding = UDim.new(0, 4)
		subLayout.SortOrder = Enum.SortOrder.LayoutOrder

		local isOpen = false

		local function updateDropdown()
			container.Size = UDim2.new(1, -10, 0, isOpen and #keys * 36 or 0)
			dropdown.Text = (isOpen and "▲ " or "▼ ")..sectionName
			updateCanvas()
		end

		for _, key in pairs(keys) do
			local btn = InstanceNew("TextButton")
			btn.Size = UDim2.new(1, 0, 0, 32)
			btn.TextColor3 = Color3.new(1, 1, 1)
			btn.Font = Enum.Font.SourceSans
			btn.TextSize = 18
			btn.AutoButtonColor = false
			btn.Text = key..": "..tostring(userSettings[sectionName][key])
			btn.BackgroundColor3 = userSettings[sectionName][key] and Color3.fromRGB(0, 200, 0) or Color3.fromRGB(120, 30, 30)
			btn.Parent = container

			MouseButtonFix(btn,function()
				userSettings[sectionName][key] = not userSettings[sectionName][key]
				btn.Text = key..": "..tostring(userSettings[sectionName][key])
				btn.BackgroundColor3 = userSettings[sectionName][key] and Color3.fromRGB(0, 200, 0) or Color3.fromRGB(120, 30, 30)
			end)
		end

		MouseButtonFix(dropdown,function()
			isOpen = not isOpen
			updateDropdown()
		end)

		updateDropdown()
	end

	for section, data in pairs(userSettings) do
		local keys = {}
		for k in pairs(data) do Insert(keys, k) end
		createSection(section, keys)
	end

	local runBtn = InstanceNew("TextButton")
	runBtn.Size = UDim2.new(1, -20, 0, 45)
	runBtn.Position = UDim2.new(0, 10, 1, -50)
	runBtn.BackgroundColor3 = Color3.fromRGB(0, 170, 0)
	runBtn.TextColor3 = Color3.new(1, 1, 1)
	runBtn.Font = Enum.Font.SourceSansBold
	runBtn.TextSize = 20
	runBtn.Text = "Run AntiLag"
	runBtn.Parent = content

	MouseButtonFix(runBtn,function()
		getgenv().Settings = userSettings
		sGUI:Destroy()
		loadstring(game:HttpGet("https://raw.githubusercontent.com/ltseverydayyou/uuuuuuu/main/low%20detail"))()
	end)

	MouseButtonFix(closeBtn,function()
		sGUI:Destroy()
	end)

	local minimized = false
	MouseButtonFix(minimizeBtn,function()
		minimized = not minimized
		content.Visible = not minimized
		minimizeBtn.Text = minimized and "+" or "-"
	end)
	NAgui.draggerV2(frame)
end)

NAStuff.annoyLoop = false

cmd.add({"annoy"}, {"annoy <player>", "Annoys the given player"}, function(...)
	if NAStuff.annoyLoop then
		DoNotif("Already annoying someone. Use :unannoy first.", 3)
		return
	end

	NAStuff.annoyLoop = false
	Wait(0.2)
	NAStuff.annoyLoop = true

	local user = ...
	local targets = getPlr(user)

	if #targets == 0 then
		DoNotif("No target found.", 3)
		return
	end

	local target = targets[1]
	if not target.Character or not getRoot(target.Character) then
		DoNotif("Target has no character or root part.", 3)
		annoyLoop = false
		return
	end

	local myChar = getChar()
	local myRoot = myChar and getRoot(myChar)
	local originalCFrame = myRoot and myRoot.CFrame

	if not myRoot then
		DoNotif("Your character has no root part.", 3)
		annoyLoop = false
		return
	end

	math.randomseed(tick())

	repeat
		Wait(0.05)

		local targetChar = target.Character
		local targetRoot = targetChar and getRoot(targetChar)
		myChar = getChar()
		myRoot = myChar and getRoot(myChar)

		if not targetRoot or not myRoot then
			break
		end

		local offset = Vector3.new(math.random(-3,3), math.random(0,2), math.random(-3,3))
		myRoot.CFrame = targetRoot.CFrame + offset

		RunService.RenderStepped:Wait()
	until not NAStuff.annoyLoop

	if myRoot and originalCFrame then
		myRoot.CFrame = originalCFrame
	end
end, true)

cmd.add({"unannoy"}, {"unannoy", "Stops the annoy command"}, function()
	NAStuff.annoyLoop = false
end)

cmd.add({"deleteinvisparts","deleteinvisibleparts","dip"},{"deleteinvisparts (deleteinvisibleparts,dip)","Deletes invisible parts"},function()
	for i,v in pairs(workspace:GetDescendants()) do
		if v:IsA("BasePart") and v.Transparency==1 and v.CanCollide then
			v:Destroy()
		end
	end
end)

NAStuff.shownParts = {}

cmd.add({"invisibleparts","invisparts"},{"invisibleparts (invisparts)","Shows invisible parts"},function()
	for _, v in ipairs(workspace:GetDescendants()) do
		if v:IsA("BasePart") and v.Transparency == 1 then
			local alreadyShown = false
			for _, p in ipairs(NAStuff.shownParts) do
				if p == v then
					alreadyShown = true
					break
				end
			end
			if not alreadyShown then
				Insert(NAStuff.shownParts, v)
			end
			v.Transparency = 0
		end
	end
end)

cmd.add({"uninvisibleparts","uninvisparts"},{"uninvisibleparts (uninvisparts)","Makes parts affected by invisparts return to normal"},function()
	for _, v in ipairs(NAStuff.shownParts) do
		if v and v:IsA("BasePart") then
			v.Transparency = 1
		end
	end
	table.clear(NAStuff.shownParts)
end)

cmd.add({"datalimit"},{"datalimit <kbps>","Set outgoing bandwidth limit in KBps"},function(value)
	local limit=tonumber(value)
	if not limit then
		DoNotif("Usage: datalimit <number>",2)
		return
	end
	local networkClient=SafeGetService("NetworkClient")
	if not networkClient then
		DoNotif("NetworkClient unavailable",3)
		return
	end
	local ok,err=pcall(function()
		networkClient:SetOutgoingKBPSLimit(limit)
	end)
	if ok then
		DoNotif("Outgoing limit set to "..tostring(limit).." kbps",2)
	else
		DoNotif("Failed to set limit: "..tostring(err),3)
	end
end,true)

cmd.add({"removeads","adblock"},{"removeads (adblock)","Continuously removes billboard advertisements"},function()
	if NAStuff._removeAdsLoop and NAStuff._removeAdsLoop.active then
		DoNotif("Remove Ads already enabled",2)
		return
	end
	local state={active=true}
	NAStuff._removeAdsLoop=state
	DoNotif("Remove Ads enabled",2)
	SpawnCall(function()
		while state.active do
			pcall(function()
				for _,obj in ipairs(workspace:GetDescendants()) do
					if obj:IsA("PackageLink") then
						local parent=obj.Parent
						if parent then
							if parent:FindFirstChild("ADpart") then
								parent:Destroy()
							elseif parent:FindFirstChild("AdGuiAdornee") then
								local grand=parent.Parent
								if grand then
									grand:Destroy()
								else
									parent:Destroy()
								end
							end
						end
					end
				end
			end)
			Wait(0.75)
		end
	end)
end)

cmd.add({"unremoveads","noadblock","disableads"},{"unremoveads (noadblock,disableads)","Stop removing billboard advertisements"},function()
	local state=NAStuff._removeAdsLoop
	if not state or not state.active then
		DoNotif("Remove Ads is not active",2)
		NAStuff._removeAdsLoop=nil
		return
	end
	state.active=false
	NAStuff._removeAdsLoop=nil
	DoNotif("Remove Ads disabled",2)
end)

cmd.add({"replicationlag", "backtrack"}, {"replicationlag (backtrack)", "Set IncomingReplicationLag"}, function(num)
	settings():GetService("NetworkSettings").IncomingReplicationLag = tonumber(num) or 0
end, true)

cmd.add({"sleepon"}, {"sleepon", "Enable AllowSleep"}, function()
	settings():GetService("PhysicsSettings").AllowSleep = true
end)

cmd.add({"unsleepon"}, {"unsleepon", "Disable AllowSleep"}, function()
	settings():GetService("PhysicsSettings").AllowSleep = false
end)

cmd.add({"throttle"}, {"throttle", "Set PhysicsEnvironmentalThrottle (1 = default, 2 = disabled)"}, function(num)
	settings():GetService("PhysicsSettings").PhysicsEnvironmentalThrottle = tonumber(num) or 1
end, true)

cmd.add({"quality","qualitylevel"},{"quality <1-21>","Manage rendering quality settings"},function(...)
	local args = {...}
	local target = args[1]
	local buttons = {}
	for _, ql in ipairs(Enum.QualityLevel:GetEnumItems()) do
		Insert(buttons, {
			Text = ql.Name,
			Callback = function()
				settings().Rendering.QualityLevel = ql
			end
		})
	end
	if target and target ~= "" then
		local key = tostring(target)
		local n = tonumber(key)
		if n then
			n = math.clamp(math.floor(n), 1, 21)
			key = Format("Level%02d", n)
		else
			local l = Lower(key)
			if l == "auto" or l == "automatic" then
				key = "Automatic"
			end
		end
		local found = false
		for _, btn in ipairs(buttons) do
			if Match(Lower(btn.Text), Lower(key)) then
				btn.Callback()
				DebugNotif("Quality set to "..btn.Text, 3)
				found = true
				break
			end
		end
		if not found then
			DebugNotif("No matching quality level for: "..target, 3)
		end
	else
		Window({
			Title = "Rendering Quality Options",
			Buttons = buttons
		})
	end
end)

cmd.add({"logphysics"}, {"logphysics", "Enable Physics Error Logging"}, function()
	settings():GetService("NetworkSettings").PrintPhysicsErrors = true
	NAmanage.jlCfg.PhysicsLog = true
	NAmanage.jlSave()
end)

cmd.add({"nologphysics"}, {"nologphysics", "Disable Physics Error Logging"}, function()
	settings():GetService("NetworkSettings").PrintPhysicsErrors = false
	NAmanage.jlCfg.PhysicsLog = false
	NAmanage.jlSave()
end)

cmd.add({"norender"},{"norender","Disable 3d Rendering to decrease the amount of CPU the client uses"},function()
	RunService:Set3dRenderingEnabled(false)
end)

cmd.add({"render"},{"render","Enable 3d Rendering"},function()
	RunService:Set3dRenderingEnabled(true)
end)

cmd.add({"noreset","disablereset"},{"noreset","disable reset button"},function()
	StarterGui:SetCore("ResetButtonCallback",false)
end,true)

cmd.add({"resetbtn","enablereset"},{"resetbtn","enable reset button"},function()
	StarterGui:SetCore("ResetButtonCallback",true)
end,true)

oofing = false

cmd.add({"loopoof"},{"loopoof","Loops everyone's character sounds (everyone can hear)"},function()
	oofing = true
	repeat Wait(0.1)
		for _, player in ipairs(Players:GetPlayers()) do
			local char = player.Character
			local head = getHead(char)
			if head then
				for _, child in ipairs(head:GetChildren()) do
					if child:IsA("Sound") and not child.Playing then
						child.Playing = true
					end
				end
			end
		end
	until not oofing
end)

cmd.add({"unloopoof"},{"unloopoof","Stops the oof chaos"},function()
	oofing = false
end)

cmd.add({"strengthen"},{"strengthen","Makes your character more dense (CustomPhysicalProperties)"},function(...)
	local args={...}
	for _,child in pairs(getChar():GetDescendants()) do
		if child:IsA("BasePart") then
			if args[1] then
				child.CustomPhysicalProperties=PhysicalProperties.new(args[1],0.3,0.5)
			else
				child.CustomPhysicalProperties=PhysicalProperties.new(100,0.3,0.5)
			end
		end
	end
end,true)

cmd.add({"unweaken","unstrengthen"},{"unweaken (unstrengthen)","Sets your characters CustomPhysicalProperties to default"},function()
	for _,child in pairs(getChar():GetDescendants()) do
		if child:IsA("BasePart") then
			child.CustomPhysicalProperties=PhysicalProperties.new(0.7,0.3,0.5)
		end
	end
end)

cmd.add({"weaken"},{"weaken","Makes your character less dense"},function(...)
	local args={...}
	for _,child in pairs(getChar():GetDescendants()) do
		if child:IsA("BasePart") then
			if args[1] then
				child.CustomPhysicalProperties=PhysicalProperties.new(-args[1],0.3,0.5)
			else
				child.CustomPhysicalProperties=PhysicalProperties.new(0,0.3,0.5)
			end
		end
	end
end,true)

cmd.add({"seat"}, {"seat", "Finds a seat and automatically sits on it"}, function()
	local character = getChar()
	local humanoid = getHum()
	local root = character and getRoot(character)

	if not humanoid or not root then
		DoNotif("Your character or humanoid is invalid", 3)
		return
	end

	local seats = {}
	for _, v in ipairs(game:GetDescendants()) do
		if v:IsA("Seat") and not v.Occupant then
			Insert(seats, v)
		end
	end

	if #seats == 0 then
		DebugNotif("No available seats found in the game", 3)
		return
	end

	table.sort(seats, function(a, b)
		return (a.Position - root.Position).Magnitude < (b.Position - root.Position).Magnitude
	end)

	local seat = seats[1]
	if seat then
		seat:Sit(humanoid)
		DebugNotif("Sat in the nearest seat", 2)
	else
		DebugNotif("Failed to sit in a seat", 3)
	end
end)

cmd.add({"vehicleseat", "vseat"}, {"vehicleseat (vseat)", "Sits you in a vehicle seat, useful for trying to find cars in games"}, function()
	local character = getChar()
	local humanoid = getHum()
	local root = character and getRoot(character)

	if not humanoid or not root then
		DoNotif("Your character or humanoid is invalid", 3)
		return
	end

	local vehicleSeats = {}
	for _, v in ipairs(game:GetDescendants()) do
		if v:IsA("VehicleSeat") and not v.Occupant then
			Insert(vehicleSeats, v)
		end
	end

	if #vehicleSeats == 0 then
		DebugNotif("No available VehicleSeats found in the game", 3)
		return
	end

	table.sort(vehicleSeats, function(a, b)
		return (a.Position - root.Position).Magnitude < (b.Position - root.Position).Magnitude
	end)

	local vseat = vehicleSeats[1]
	if vseat then
		vseat:Sit(humanoid)
		DebugNotif("Sat in the nearest VehicleSeat", 2)
	else
		DebugNotif("Failed to sit in a VehicleSeat", 3)
	end
end)
cmd.add({"copytools","ctools"},{"copytools <player> (ctools)","Copies the tools the given player has"},function(...)
	local targets = getPlr(...)
	local lp = Players.LocalPlayer
	if not lp then return end
	local backpack = lp:FindFirstChildOfClass("Backpack")
	if not backpack then return end
	for _,plr in ipairs(targets) do
		local tBackpack = plr:FindFirstChildOfClass("Backpack")
		if tBackpack then
			for _,tool in ipairs(tBackpack:GetChildren()) do
				if tool:IsA("Tool") or tool:IsA("HopperBin") then
					tool:Clone().Parent = backpack
				end
			end
		end
	end
end,true)
cmd.add({"localtime", "yourtime"}, {"localtime (yourtime)", "Shows your current time"}, function()
	local time = os.date("*t")
	local clock = Format("%02d:%02d:%02d", time.hour, time.min, time.sec)
	DoNotif("Your Local Time Is: "..clock)
end)
cmd.add({"localdate", "yourdate"}, {"localdate (yourdate)", "Shows your current date"}, function()
	local time = os.date("*t")
	local dateStr = Format("%02d/%02d/%04d", time.day, time.month, time.year)
	DoNotif("Your Local Date Is: "..dateStr)
end)
cmd.add({"servertime", "svtime"}, {"servertime (svtime)", "Shows the server's current time"}, function()
	local time = os.date("!*t")
	local clock = Format("%02d:%02d:%02d", time.hour, time.min, time.sec)
	DoNotif("Server (UTC) Time Is: "..clock)
end)
cmd.add({"serverdate", "svdate"}, {"serverdate (svdate)", "Shows the server's current date"}, function()
	local time = os.date("!*t")
	local dateStr = Format("%02d/%02d/%04d", time.day, time.month, time.year)
	DoNotif("Server (UTC) Date Is: "..dateStr)
end)
cmd.add({"datetime", "localdatetime"}, {"datetime (localdatetime)", "Shows your full local date and time"}, function()
	local time = os.date("*t")
	local dateTime = Format("%02d/%02d/%04d %02d:%02d:%02d", time.day, time.month, time.year, time.hour, time.min, time.sec)
	DoNotif("Your Local Date & Time: "..dateTime)
end)
cmd.add({"uptime"}, {"uptime", "Shows how long the game/session has been running"}, function()
	local uptime = os.clock() - NASESSIONSTARTEDIDK
	local hours = math.floor(uptime / 3600)
	local minutes = math.floor((uptime % 3600) / 60)
	local seconds = math.floor(uptime % 60)
	local uptimeStr = Format("%02d:%02d:%02d", hours, minutes, seconds)
	DoNotif("Uptime: "..uptimeStr)
end)
cmd.add({"timestamp", "epoch"}, {"timestamp (epoch)", "Shows current Unix timestamp"}, function()
	local timestamp = os.time()
	DoNotif("Current Unix Timestamp: "..timestamp)
end)
cmd.add({"cartornado", "ctornado"}, {"cartornado (ctornado)", "Tornados a car just sit in the car"}, function()
	local Player = Players.LocalPlayer

	repeat RunService.RenderStepped:Wait() until Player.Character
	local Character = Player.Character

	local SPart = InstanceNew("Part")
	SPart.Anchored = true
	SPart.CanCollide = true
	SPart.Size = Vector3.new(1, 100, 1)
	SPart.Transparency = 0.4
	SPart.Parent = workspace

	RunService.Stepped:Connect(function()
		local hum = Character and getHum()
		if hum and Character.PrimaryPart then
			local rayOrigin = Character.PrimaryPart.Position + Character.PrimaryPart.CFrame.LookVector * 6
			local rayDir = Vector3.new(0, -4, 0)
			local ray = Ray.new(rayOrigin, rayDir)
			local part = workspace:FindPartOnRayWithIgnoreList(ray, {Character})
			if part then
				SPart.CFrame = Character.PrimaryPart.CFrame + Character.PrimaryPart.CFrame.LookVector * 6
			end
		end
	end)

	SPart.Touched:Connect(function(hit)
		if not hit:IsA("Seat") then return end

		local torso = getTorso(Character)
		if not torso then return end

		local hum = getHum()
		if not hum then return end

		local flyv = InstanceNew("BodyVelocity")
		local flyg = InstanceNew("BodyGyro")
		local speed = 50
		local lastSpeed = speed
		local maxSpeed = 100
		local isRunning = false
		local f = 0
		local isFlying = true

		flyv.Parent = torso
		flyv.MaxForce = Vector3.new(math.huge, math.huge, math.huge)

		flyg.Parent = torso
		flyg.MaxTorque = Vector3.new(9e9, 9e9, 9e9)
		flyg.P = 1000
		flyg.D = 50

		hum.PlatformStand = true

		hum.Changed:Connect(function()
			isRunning = hum.MoveDirection.Magnitude > 0
		end)

		SpawnCall(function()
			while isFlying do
				flyg.CFrame = workspace.CurrentCamera.CFrame * CFrame.Angles(-math.rad(f * 50 * speed / maxSpeed), 0, 0)
				flyv.Velocity = workspace.CurrentCamera.CFrame.LookVector * speed
				Wait(0.1)

				if speed < 0 then
					speed = 0
					f = 0
				end

				if isRunning then
					speed = lastSpeed
				else
					if speed ~= 0 then
						lastSpeed = speed
					end
					speed = 0
				end
			end
		end)

		Wait(0.3)
		hit:Sit(hum)
		SPart:Destroy()

		local seat = hum.SeatPart
		if not seat then return end

		local vehicleModel = seat.Parent
		while vehicleModel and not vehicleModel:IsA("Model") do
			vehicleModel = vehicleModel.Parent
		end

		if vehicleModel then
			for _, v in pairs(vehicleModel:GetDescendants()) do
				if v:IsA("BasePart") and v.CanCollide then
					v.CanCollide = false
				end
			end
		end

		Wait(0.2)
		speed = 80

		local spin = InstanceNew("BodyAngularVelocity")
		spin.MaxTorque = Vector3.new(0, math.huge, 0)
		spin.AngularVelocity = Vector3.new(0, 2000, 0)
		spin.Parent = Character.PrimaryPart
	end)
end)

cmd.add({"unspam","unlag","unchatspam","unanimlag","unremotespam"},{"unspam","Stop all attempts to lag/spam"},function()
	NAlib.disconnect("spam")
end)

cmd.add({"UNCTest","UNC"},{"UNCTest (UNC)","Test how many functions your executor supports"},function()
	loadstring(game:HttpGet("https://raw.githubusercontent.com/ltseverydayyou/uuuuuuu/main/UNC%20test"))()
end)

cmd.add({"vulnerabilitytest","vulntest"},{"vulnerabilitytest (vulntest)","Test if your executor is Vulnerable"},function()
	loadstring(game:HttpGet("https://raw.githubusercontent.com/ltseverydayyou/uuuuuuu/main/VulnTest.lua"))()
end)

cmd.add({"respawn", "re"}, {"respawn (re)", "Respawn your character"}, function()
	respawn()
end)

cmd.add({"antisit"},{"antisit","Prevents the player from sitting"},function()
	local function noSit(character)
		local humanoid = getPlrHum(character)
		while not humanoid do Wait(.1) humanoid = getPlrHum(character) end
		humanoid.Sit = false
		humanoid:SetStateEnabled(Enum.HumanoidStateType.Seated, false)
	end

	if LocalPlayer.Character then
		noSit(LocalPlayer.Character)
	end

	NAlib.disconnect("antisit_conn")
	NAlib.connect("antisit_conn", LocalPlayer.CharacterAdded:Connect(noSit))

	DebugNotif("Anti sit enabled", 3)
end)

cmd.add({"unantisit"},{"unantisit","Allows the player to sit again"},function()
	local character = LocalPlayer.Character
	local humanoid = getHum()
	while not humanoid do Wait(.1) humanoid = getHum() end
	humanoid.Sit = false
	humanoid:SetStateEnabled(Enum.HumanoidStateType.Seated, true)

	NAlib.disconnect("antisit_conn")
	DebugNotif("Anti sit disabled", 3)
end)

NAmanage.AntiKick_EnsureHook = function()
	if NAStuff.AntiKickHooked then return end
	local getRawMetatable = (debug and debug.getmetatable) or getrawmetatable
	local setReadOnly = setreadonly or (make_writeable and function(t, ro) if ro then make_readonly(t) else make_writeable(t) end end)
	if not getRawMetatable or not setReadOnly or not newcclosure or not hookfunction then return end
	local meta = getRawMetatable(game)
	if not meta then return end
	local player = Players.LocalPlayer
	if not player then return end
	NAStuff.AntiKickOrig.namecall = meta.__namecall
	NAStuff.AntiKickOrig.index = meta.__index
	NAStuff.AntiKickOrig.newindex = meta.__newindex
	for _, Kick in next, { player.Kick, player.kick } do
		if Kick and type(Kick)=="function" then
			local originalKick
			originalKick = hookfunction(Kick, newcclosure(function(self, ...)
				if self==player then
					local msg = tostring((select(1, ...)) or "No message")
					Defer(DebugNotif, "Kick blocked (hook)", 2)
					if NAStuff.AntiKickMode=="error" then
						error("Kick blocked: "..msg, 0)
					else
						return
					end
				end
				return originalKick(self, ...)
			end))
			NAStuff.AntiKickOrig.kicks[Kick] = originalKick
		end
	end
	setReadOnly(meta, false)
	meta.__namecall = newcclosure(function(self, ...)
		local method = getnamecallmethod()
		if self==player and method and method:lower()=="kick" then
			local msg = tostring((select(1, ...)) or "No message")
			Defer(DebugNotif, "Kick blocked (__namecall)", 2)
			if NAStuff.AntiKickMode=="error" then
				error("Kick blocked: "..msg, 0)
			else
				return
			end
		end
		return NAStuff.AntiKickOrig.namecall(self, ...)
	end)
	meta.__index = newcclosure(function(self, key)
		if self==player then
			local k=tostring(key):lower()
			if k:find("kick") or k:find("destroy") then
				Defer(DebugNotif, "Blocked access: "..tostring(key), 2)
				if NAStuff.AntiKickMode=="error" then
					return function() error("Blocked method: "..tostring(key),0) end
				else
					return function() end
				end
			end
		end
		return NAStuff.AntiKickOrig.index(self, key)
	end)
	meta.__newindex = newcclosure(function(self, key, value)
		if self==player then
			local k=tostring(key):lower()
			if k:find("kick") or k:find("destroy") then
				Defer(DebugNotif, "Blocked overwrite: "..tostring(key), 2)
				return
			end
		end
		return NAStuff.AntiKickOrig.newindex(self, key, value)
	end)
	setReadOnly(meta, true)
	NAStuff.AntiKickHooked = true
	Defer(DebugNotif, "Anti-Kick active", 2)
end

NAmanage.AntiTeleport_EnsureHook = function()
	if NAStuff.AntiTeleportHooked then return end
	local getRawMetatable = (debug and debug.getmetatable) or getrawmetatable
	local setReadOnly = setreadonly or (make_writeable and function(t, ro) if ro then make_readonly(t) else make_writeable(t) end end)
	if not getRawMetatable or not setReadOnly or not newcclosure or not hookfunction then return end
	local meta = getRawMetatable(game)
	if not meta then return end
	if not TeleportService then return end
	NAStuff.AntiTeleportOrig.namecall = meta.__namecall
	NAStuff.AntiTeleportOrig.index = meta.__index
	NAStuff.AntiTeleportOrig.newindex = meta.__newindex
	local methods = {"Teleport","TeleportToPlaceInstance","TeleportAsync","TeleportPartyAsync","TeleportToPrivateServer"}
	for _,m in ipairs(methods) do
		local fn = TeleportService[m]
		if typeof(fn)=="function" then
			local orig
			orig = hookfunction(fn, newcclosure(function(self, ...)
				if self==TeleportService then
					Defer(DebugNotif, "Teleport blocked (hook)", 2)
					if NAStuff.AntiTeleportMode=="error" then
						error("Teleport blocked",0)
					else
						return nil
					end
				end
				return orig(self,...)
			end))
			NAStuff.AntiTeleportOrig.funcs[m] = orig
		end
	end
	setReadOnly(meta,false)
	meta.__namecall = newcclosure(function(self, ...)
		local method = getnamecallmethod()
		if self==TeleportService and typeof(method)=="string" and Lower(method):find("teleport") then
			Defer(DebugNotif, "Teleport blocked (__namecall)", 2)
			if NAStuff.AntiTeleportMode=="error" then
				error("Teleport blocked",0)
			else
				return nil
			end
		end
		return NAStuff.AntiTeleportOrig.namecall(self,...)
	end)
	meta.__index = newcclosure(function(self, key)
		if self==TeleportService then
			local k = Lower(tostring(key))
			if k:find("teleport") then
				Defer(DebugNotif, "Blocked access: "..tostring(key), 2)
				if NAStuff.AntiTeleportMode=="error" then
					return function() error("Blocked method: "..tostring(key),0) end
				else
					return function() end
				end
			end
		end
		return NAStuff.AntiTeleportOrig.index(self,key)
	end)
	meta.__newindex = newcclosure(function(self, key, value)
		if self==TeleportService then
			local k = Lower(tostring(key))
			if k:find("teleport") then
				Defer(DebugNotif, "Blocked overwrite: "..tostring(key), 2)
				return
			end
		end
		return NAStuff.AntiTeleportOrig.newindex(self,key,value)
	end)
	setReadOnly(meta,true)
	NAStuff.AntiTeleportHooked = true
	Defer(DebugNotif, "Anti-Teleport active", 2)
end

cmd.add({"antikick","nokick","bypasskick","bk"},{"antikick (nokick, bypasskick, bk)","Bypass Kick on Most Games"},function(mode)
	local m = mode and Lower(tostring(mode)) or nil
	local function apply()
		NAmanage.AntiKick_EnsureHook()
		DebugNotif("Anti-Kick: "..(NAStuff.AntiKickMode=="error" and "Error" or "Fake Success"),2)
	end
	if m=="error" or m=="fail" then
		NAStuff.AntiKickMode = "error"
		apply()
	elseif m=="success" or m=="ok" or m=="fake" then
		NAStuff.AntiKickMode = "fakeok"
		apply()
	else
		Window({
			Title = "Anti-Kick Mode",
			Buttons = {
				{ Text = "Fake Success", Callback = function() NAStuff.AntiKickMode="fakeok"; apply() end },
				{ Text = "Error",        Callback = function() NAStuff.AntiKickMode="error";  apply() end }
			}
		})
	end
end,true)

cmd.add({"antiteleport","noteleport","blocktp"},{"antiteleport (noteleport, blocktp)","Prevents TeleportService from moving you to another place"},function(mode)
	local m = mode and Lower(tostring(mode)) or nil
	local function apply()
		NAmanage.AntiTeleport_EnsureHook()
		DebugNotif("Anti-Teleport: "..(NAStuff.AntiTeleportMode=="error" and "Error" or "Fake Success"),2)
	end
	if m=="error" or m=="fail" then
		NAStuff.AntiTeleportMode = "error"
		apply()
	elseif m=="success" or m=="ok" or m=="fake" then
		NAStuff.AntiTeleportMode = "fakeok"
		apply()
	else
		Window({
			Title = "Anti-Teleport Mode",
			Buttons = {
				{ Text = "Fake Success", Callback = function() NAStuff.AntiTeleportMode="fakeok"; apply() end },
				{ Text = "Error",        Callback = function() NAStuff.AntiTeleportMode="error";  apply() end }
			}
		})
	end
end,true)

cmd.add({"unantikick","unnokick","unbypasskick","unbk"},{"unantikick","Disables Anti-Kick protection"},function()
	local getRawMetatable = (debug and debug.getmetatable) or getrawmetatable
	local setReadOnly = setreadonly or (make_writeable and function(t, ro) if ro then make_readonly(t) else make_writeable(t) end end)
	local meta = getRawMetatable(game)
	if not meta or not NAStuff.AntiKickOrig or not NAStuff.AntiKickOrig.namecall then
		DoNotif("Anti-Kick not active or missing references",3)
		return
	end
	local player = Players.LocalPlayer
	for k,orig in pairs(NAStuff.AntiKickOrig.kicks or {}) do
		pcall(function() hookfunction(k, orig) end)
	end
	setReadOnly(meta,false)
	meta.__namecall = NAStuff.AntiKickOrig.namecall
	meta.__index = NAStuff.AntiKickOrig.index
	meta.__newindex = NAStuff.AntiKickOrig.newindex
	setReadOnly(meta,true)
	NAStuff.AntiKickHooked = false
	DebugNotif("Anti-Kick Disabled",2)
end)

cmd.add({"unantiteleport","unnoteleport","unblocktp"},{"unantiteleport","Disables Anti-Teleport protection"},function()
	local getRawMetatable = (debug and debug.getmetatable) or getrawmetatable
	local setReadOnly = setreadonly or (make_writeable and function(t, ro) if ro then make_readonly(t) else make_writeable(t) end end)
	local meta = getRawMetatable(game)
	if not meta or not NAStuff.AntiTeleportOrig or not NAStuff.AntiTeleportOrig.namecall then
		DoNotif("Anti-Teleport not active or missing references",3)
		return
	end
	for name,orig in pairs(NAStuff.AntiTeleportOrig.funcs or {}) do
		local fn = TeleportService[name]
		if typeof(fn)=="function" and orig then
			pcall(function() hookfunction(fn, orig) end)
		end
	end
	setReadOnly(meta,false)
	meta.__namecall = NAStuff.AntiTeleportOrig.namecall
	meta.__index = NAStuff.AntiTeleportOrig.index
	meta.__newindex = NAStuff.AntiTeleportOrig.newindex
	setReadOnly(meta,true)
	NAStuff.AntiTeleportHooked = false
	DebugNotif("Anti-Teleport Disabled",2)
end)

NAStuff.ATPC = {
	state = false,
	plr = Players.LocalPlayer,
	gui = nil,
	btn = nil,
	allowed = {},
	old = {},
	parts = {}
}

local function AntiOn()
	if type(Get) == "function" then
		local ok, v = pcall(Get, "AntiCFrame")
		if ok then return v end
	end
	return NAStuff.ATPC.state
end

NAStuff.ATPC._syncBtn = function()
	local b = NAStuff.ATPC.btn
	if not b then return end
	if NAStuff.ATPC.state then
		b.Text = "UNACFTP"
		b.BackgroundColor3 = Color3.fromRGB(0,170,0)
	else
		b.Text = "ACFTP"
		b.BackgroundColor3 = Color3.fromRGB(170,0,0)
	end
end

NAStuff.ATPC._buildGUI = function()
	if not IsOnMobile then return end
	if NAStuff.ATPC.gui then
		NAStuff.ATPC.gui:Destroy()
		NAStuff.ATPC.gui = nil
		NAStuff.ATPC.btn = nil
	end

	local g = InstanceNew("ScreenGui")
	NaProtectUI(g)
	g.ResetOnSpawn = false

	local b = InstanceNew("TextButton")
	local c = InstanceNew("UICorner")
	local a = InstanceNew("UIAspectRatioConstraint")

	b.Parent = g
	b.BackgroundTransparency = 0.1
	b.Position = UDim2.new(0.9,0,0.4,0)
	b.Size = UDim2.new(0.08,0,0.1,0)
	b.Font = Enum.Font.GothamBold
	b.TextColor3 = Color3.fromRGB(255,255,255)
	b.TextScaled = true
	b.TextWrapped = true
	b.Active = true

	c.CornerRadius = UDim.new(0.2,0)
	c.Parent = b

	a.Parent = b
	a.AspectRatio = 1

	NAStuff.ATPC.gui = g
	NAStuff.ATPC.btn = b
	NAStuff.ATPC._syncBtn()

	MouseButtonFix(b, function()
		if NAStuff.ATPC.state then
			NAStuff.ATPC.Disable()
		else
			NAStuff.ATPC.Enable()
		end
	end)

	NAgui.draggerV2(b)
end

NAStuff.ATPC._hookChar = function(char)
	local allowed = NAStuff.ATPC.allowed
	local old = NAStuff.ATPC.old
	local parts = NAStuff.ATPC.parts

	local function hookPart(p)
		if not p or not p.Parent or not p:IsA("BasePart") then return end
		if allowed[p] ~= nil then return end

		allowed[p] = false
		old[p] = p.CFrame
		Insert(parts, p)

		local sig = p:GetPropertyChangedSignal("CFrame")
		local con = sig:Connect(function()
			if not NAStuff.ATPC.state then return end
			if not NAlib.isConnected("AntiCFrame") then return end
			if not AntiOn() then return end
			if not p.Parent then return end
			if allowed[p] then return end

			local o = old[p]
			if not o then return end

			allowed[p] = true
			p.CFrame = o
			Wait()
			allowed[p] = false
		end)

		NAlib.connect("AntiCFrame", con)
	end

	for _, d in ipairs(char:GetDescendants()) do
		if d:IsA("BasePart") then
			hookPart(d)
		end
	end

	local addCon = char.DescendantAdded:Connect(function(d)
		if not NAStuff.ATPC.state then return end
		if d:IsA("BasePart") then
			hookPart(d)
		end
	end)
	NAlib.connect("AntiCFrame", addCon)

	Spawn(function()
		while NAStuff.ATPC.state and NAlib.isConnected("AntiCFrame") and char and char.Parent do
			for _, p in ipairs(parts) do
				if p and p.Parent and not allowed[p] then
					old[p] = p.CFrame
				end
			end
			Wait()
		end
	end)
end

NAStuff.ATPC.Enable = function()
	if NAStuff.ATPC.state then return end

	local plr = Players.LocalPlayer
	if not plr then
		DoNotif("Anti CFrame Teleport failed (no player)")
		return
	end

	local char = getChar() or plr.Character
	if not char or not char.Parent then
		DoNotif("Anti CFrame Teleport failed (no character)")
		return
	end

	NAStuff.ATPC.state = true
	NAStuff.ATPC.allowed = {}
	NAStuff.ATPC.old = {}
	NAStuff.ATPC.parts = {}

	if type(Refresh) == "function" then
		pcall(Refresh, "AntiCFrame", true)
	end

	NAlib.disconnect("AntiCFrame")
	NAStuff.ATPC._hookChar(char)
	NAStuff.ATPC._syncBtn()
	DoNotif("Anti CFrame Teleport has been enabled")
end

NAStuff.ATPC.Disable = function()
	if not NAStuff.ATPC.state then return end

	NAStuff.ATPC.state = false

	if type(Add) == "function" then
		pcall(Add, "AntiCFrame", false)
	end

	NAlib.disconnect("AntiCFrame")
	NAStuff.ATPC.allowed = {}
	NAStuff.ATPC.old = {}
	NAStuff.ATPC.parts = {}
	NAStuff.ATPC._syncBtn()
	DoNotif("Anti CFrame Teleport has been disabled")
end

cmd.add({ "anticframeteleport","acframetp","acftp" }, { "anticframeteleport (acframetp,acftp)","Prevents client teleports" }, function()
	NAStuff.ATPC.Enable()
	if IsOnMobile then
		if not NAStuff.ATPC.gui then
			NAStuff.ATPC._buildGUI()
		end
	end
end)

cmd.add({ "unanticframeteleport","unacframetp","unacftp" }, { "unanticframeteleport (unacframetp,unacftp)","Disables Anti CFrame Teleport" }, function()
	NAStuff.ATPC.Disable()
	if NAStuff.ATPC.gui then
		NAStuff.ATPC.gui:Destroy()
		NAStuff.ATPC.gui = nil
		NAStuff.ATPC.btn = nil
	end
end)

cmd.add({"lay"},{"lay","zzzzzzzz"},function()
	local Human=getHum()
	if not Human then return end
	Human.Sit=true
	Wait(.1)
	Human.RootPart.CFrame=Human.RootPart.CFrame*CFrame.Angles(math.pi*.5,0,0)
	for _,v in ipairs(Human:GetPlayingAnimationTracks()) do
		v:Stop()
	end
end)

cmd.add({"trip"},{"trip","get up NOW"},function()
	getHum():ChangeState(0)
	getRoot(getChar()).Velocity=getRoot(getChar()).CFrame.LookVector*25
end)

cmd.add({"antitrip"}, {"antitrip", "no tripping today bruh"}, function()
	local LocalPlayer=Players.LocalPlayer
	local states={Enum.HumanoidStateType.FallingDown,Enum.HumanoidStateType.Ragdoll,Enum.HumanoidStateType.PlatformStanding}
	shared.__antitrip=shared.__antitrip or {saved={}}
	local STORE=shared.__antitrip
	local function saveAndDisableStates(h)
		local saved={}
		for _,st in ipairs(states) do
			local ok,was=pcall(function() return h:GetStateEnabled(st) end)
			if ok then
				saved[st]=was
				pcall(function() h:SetStateEnabled(st,false) end)
			end
		end
		STORE.saved[h]=saved
	end
	local function recover(hum,root)
		pcall(function() root.AssemblyLinearVelocity=Vector3.zero end)
		pcall(function() hum.PlatformStand=false end)
		pcall(function() hum:ChangeState(Enum.HumanoidStateType.Running) end)
	end
	local function doTRIPPER(char)
		local hum=getPlrHum(char)
		local root=getRoot(char)
		while not (hum and root) do Wait(0.1) hum=getPlrHum(char) root=getRoot(char) end
		saveAndDisableStates(hum)
		NAlib.disconnect("trip_fall")
		NAlib.connect("trip_fall",hum.FallingDown:Connect(function()
			recover(hum,root)
		end))
		NAlib.disconnect("trip_state")
		NAlib.connect("trip_state",hum.StateChanged:Connect(function(_,new)
			if new==Enum.HumanoidStateType.FallingDown or new==Enum.HumanoidStateType.Ragdoll or new==Enum.HumanoidStateType.PlatformStanding then
				recover(hum,root)
			end
		end))
		NAlib.disconnect("trip_step")
		NAlib.connect("trip_step",RunService.RenderStepped:Connect(function()
			local s=hum:GetState()
			if s==Enum.HumanoidStateType.FallingDown or s==Enum.HumanoidStateType.Ragdoll or s==Enum.HumanoidStateType.PlatformStanding then
				recover(hum,root)
			end
		end))
		hum.Destroying:Connect(function() STORE.saved[hum]=nil end)
	end
	if LocalPlayer and LocalPlayer.Character then
		doTRIPPER(LocalPlayer.Character)
	end
	NAlib.disconnect("trip_char")
	NAlib.connect("trip_char",(LocalPlayer and LocalPlayer.CharacterAdded):Connect(function(char)
		doTRIPPER(char)
	end))
	DebugNotif("Antitrip Enabled",2)
end)

cmd.add({"unantitrip"}, {"unantitrip", "tripping allowed now"}, function()
	NAlib.disconnect("trip_fall")
	NAlib.disconnect("trip_state")
	NAlib.disconnect("trip_step")
	NAlib.disconnect("trip_char")
	local STORE=shared.__antitrip
	if STORE and STORE.saved then
		for hum,saved in pairs(STORE.saved) do
			if hum and hum.Parent and saved then
				for st,was in pairs(saved) do
					pcall(function() hum:SetStateEnabled(st,was) end)
				end
			end
		end
		STORE.saved={}
	end
	local char=getChar()
	if char then
		local hum=getPlrHum(char)
		if hum then
			pcall(function() hum.PlatformStand=false end)
		end
	end
	DebugNotif("Antitrip Disabled",2)
end)

cmd.add({"checkrfe"},{"checkrfe","Checks if the game has respect filtering enabled off"},function()
	DoNotif(SafeGetService("SoundService").RespectFilteringEnabled and "Respect Filtering Enabled is on" or "Respect Filtering Enabled is off")
end)

cmd.add({"sit"},{"sit","Sit your player"},function()
	local hum=getHum()
	if hum then
		hum.Sit=true
	end
end)

cmd.add({"oldroblox"},{"oldroblox","Old skybox and studs"},function()
	if Lighting:GetAttribute("NAOldRbx_Enabled") then return end
	Lighting:SetAttribute("NAOldRbx_Enabled", true)

	local studTex = (getcustomasset and getcustomasset(NAfiles.NAASSETSFILEPATH.."/"..NAImageAssets.Stud)) or "rbxassetid://48715260"
	local inletTex = (getcustomasset and getcustomasset(NAfiles.NAASSETSFILEPATH.."/"..NAImageAssets.Inlet)) or "rbxassetid://20299774"
	local skyA = {
		bk = (getcustomasset and getcustomasset(NAfiles.NAASSETSFILEPATH.."/"..NAImageAssets.bk)) or "rbxassetid://161781263",
		dn = (getcustomasset and getcustomasset(NAfiles.NAASSETSFILEPATH.."/"..NAImageAssets.dn)) or "rbxassetid://161781258",
		ft = (getcustomasset and getcustomasset(NAfiles.NAASSETSFILEPATH.."/"..NAImageAssets.ft)) or "rbxassetid://161781261",
		lf = (getcustomasset and getcustomasset(NAfiles.NAASSETSFILEPATH.."/"..NAImageAssets.lf)) or "rbxassetid://161781267",
		rt = (getcustomasset and getcustomasset(NAfiles.NAASSETSFILEPATH.."/"..NAImageAssets.rt)) or "rbxassetid://161781268",
		up = (getcustomasset and getcustomasset(NAfiles.NAASSETSFILEPATH.."/"..NAImageAssets.up)) or "rbxassetid://161781260",
	}

	local function ensureSky()
		local s = Lighting:FindFirstChild("NAOldRobloxSky")
		if s then return s end
		local sky = InstanceNew("Sky")
		sky.Name = "NAOldRobloxSky"
		sky.SkyboxBk = skyA.bk
		sky.SkyboxDn = skyA.dn
		sky.SkyboxFt = skyA.ft
		sky.SkyboxLf = skyA.lf
		sky.SkyboxRt = skyA.rt
		sky.SkyboxUp = skyA.up
		sky.Parent = Lighting
		return sky
	end

	local function applyToPart(v)
		if not v or not v.Parent or not v:IsA("BasePart") then return end
		if v:GetAttribute("NAOldRbx_Applied") then return end
		v:SetAttribute("NAOldRbx_Applied", true)
		if v:GetAttribute("NAOldRbx_OrigMatName") == nil then
			local ok, name = pcall(function() return v.Material.Name end)
			if ok then v:SetAttribute("NAOldRbx_OrigMatName", name) end
		end

		local stud = v:FindFirstChild("NAOldRobloxStud")
		if not stud then
			stud = InstanceNew("Texture")
			stud.Name = "NAOldRobloxStud"
			stud.Parent = v
		end
		stud.Texture = studTex
		stud.Face = Enum.NormalId.Top
		stud.StudsPerTileU = 1
		stud.StudsPerTileV = 1
		stud.Transparency = v.Transparency

		local inlet = v:FindFirstChild("NAOldRobloxInlet")
		if not inlet then
			inlet = InstanceNew("Texture")
			inlet.Name = "NAOldRobloxInlet"
			inlet.Parent = v
		end
		inlet.Texture = inletTex
		inlet.Face = Enum.NormalId.Bottom
		inlet.StudsPerTileU = 1
		inlet.StudsPerTileV = 1
		inlet.Transparency = v.Transparency

		v.Material = Enum.Material.Plastic
	end

	Lighting:SetAttribute("NAOldRbx_PrevClockTime", Lighting.ClockTime)
	Lighting:SetAttribute("NAOldRbx_PrevGlobalShadows", Lighting.GlobalShadows)
	local ok,outlines = pcall(function() return Lighting.Outlines end)
	if ok then Lighting:SetAttribute("NAOldRbx_HadOutlines", true) Lighting:SetAttribute("NAOldRbx_PrevOutlines", outlines) end

	local stash = workspace:FindFirstChild("NAOldRbx_SkyStash") or InstanceNew("Folder")
	stash.Name = "NAOldRbx_SkyStash"
	stash.Parent = workspace
	for _,v in ipairs(Lighting:GetChildren()) do
		if v:IsA("Sky") then
			local c = v:Clone()
			c.Parent = stash
			v:Destroy()
		end
	end

	Lighting.ClockTime = 12
	pcall(function() Lighting.GlobalShadows = false end)
	pcall(function() Lighting.Outlines = false end)
	ensureSky()

	local RS = SafeGetService("RunService")

	local q = {head = 1, tail = 0, data = {}}
	local function qpush(x) q.tail += 1; q.data[q.tail] = x end
	local function qpop() local i = q.head; if i > q.tail then return nil end; local x = q.data[i]; q.data[i] = nil; q.head = i + 1; return x end
	for _,child in ipairs(workspace:GetChildren()) do qpush(child) end

	NAlib.disconnect("oldrbx_tick")
	NAlib.connect("oldrbx_tick", RS.Heartbeat:Connect(function()
		if not Lighting:GetAttribute("NAOldRbx_Enabled") then return end
		local budgetNodes = 200
		local i = 0
		while i < budgetNodes do
			local node = qpop()
			if not node then break end
			if node.Parent then
				if node:IsA("BasePart") then
					applyToPart(node)
					i += 1
				end
				for _,c in ipairs(node:GetChildren()) do
					qpush(c)
				end
			end
		end
	end))

	NAlib.disconnect("oldrbx_desc")
	NAlib.connect("oldrbx_desc", workspace.DescendantAdded:Connect(function(obj)
		if not Lighting:GetAttribute("NAOldRbx_Enabled") then return end
		if obj:IsA("BasePart") then
			qpush(obj)
		end
	end))

	NAlib.disconnect("oldrbx_skywatch")
	NAlib.connect("oldrbx_skywatch", Lighting.ChildAdded:Connect(function(obj)
		if not Lighting:GetAttribute("NAOldRbx_Enabled") then return end
		if obj:IsA("Sky") and obj.Name ~= "NAOldRobloxSky" then
			local c = obj:Clone()
			c.Parent = stash
			obj:Destroy()
			ensureSky()
		end
	end))

	NAlib.disconnect("oldrbx_skyguard")
	NAlib.connect("oldrbx_skyguard", Lighting.ChildRemoved:Connect(function(obj)
		if not Lighting:GetAttribute("NAOldRbx_Enabled") then return end
		if obj:IsA("Sky") and not Lighting:FindFirstChild("NAOldRobloxSky") then
			ensureSky()
		end
	end))
end)

cmd.add({"unoldroblox"},{"unoldroblox","Restore skybox and studs"},function()
	if not Lighting:GetAttribute("NAOldRbx_Enabled") then return end

	NAlib.disconnect("oldrbx_desc")
	NAlib.disconnect("oldrbx_skywatch")
	NAlib.disconnect("oldrbx_skyguard")
	NAlib.disconnect("oldrbx_tick")

	local RS = SafeGetService("RunService")

	local rq = {head = 1, tail = 0, data = {}}
	local function rpush(x) rq.tail += 1; rq.data[rq.tail] = x end
	local function rpop() local i = rq.head; if i > rq.tail then return nil end; local x = rq.data[i]; rq.data[i] = nil; rq.head = i + 1; return x end
	for _,child in ipairs(workspace:GetChildren()) do rpush(child) end

	NAlib.disconnect("oldrbx_untick")
	NAlib.connect("oldrbx_untick", RS.Heartbeat:Connect(function()
		local budgetNodes = 200
		local i = 0
		while i < budgetNodes do
			local node = rpop()
			if not node then break end
			if node.Parent then
				if node:IsA("BasePart") and node:GetAttribute("NAOldRbx_Applied") then
					local a = node:FindFirstChild("NAOldRobloxStud"); if a then a:Destroy() end
					local b = node:FindFirstChild("NAOldRobloxInlet"); if b then b:Destroy() end
					local matName = node:GetAttribute("NAOldRbx_OrigMatName")
					if typeof(matName) == "string" then
						local mat = Enum.Material[matName]
						if mat then pcall(function() node.Material = mat end) end
					end
					node:SetAttribute("NAOldRbx_Applied", nil)
					node:SetAttribute("NAOldRbx_OrigMatName", nil)
					i += 1
				end
				for _,c in ipairs(node:GetChildren()) do
					rpush(c)
				end
			end
		end

		if rq.head > rq.tail then
			NAlib.disconnect("oldrbx_untick")

			for _,v in ipairs(Lighting:GetChildren()) do
				if v:IsA("Sky") and v.Name == "NAOldRobloxSky" then
					v:Destroy()
				end
			end
			local stash = workspace:FindFirstChild("NAOldRbx_SkyStash")
			if stash then
				for _,c in ipairs(stash:GetChildren()) do
					if c:IsA("Sky") then
						c.Parent = Lighting
					end
				end
				stash:Destroy()
			end

			local prevClock = Lighting:GetAttribute("NAOldRbx_PrevClockTime")
			local prevShadows = Lighting:GetAttribute("NAOldRbx_PrevGlobalShadows")
			if typeof(prevClock) == "number" then pcall(function() Lighting.ClockTime = prevClock end) end
			if typeof(prevShadows) == "boolean" then pcall(function() Lighting.GlobalShadows = prevShadows end) end
			if Lighting:GetAttribute("NAOldRbx_HadOutlines") then
				local prevOut = Lighting:GetAttribute("NAOldRbx_PrevOutlines")
				pcall(function() Lighting.Outlines = prevOut end)
			end

			Lighting:SetAttribute("NAOldRbx_Enabled", nil)
			Lighting:SetAttribute("NAOldRbx_PrevClockTime", nil)
			Lighting:SetAttribute("NAOldRbx_PrevGlobalShadows", nil)
			Lighting:SetAttribute("NAOldRbx_HadOutlines", nil)
			Lighting:SetAttribute("NAOldRbx_PrevOutlines", nil)
		end
	end))
end)

cmd.add({"f3x","fex"},{"f3x (fex)","F3X for client"},function()
	loadstring(game:GetObjects("rbxassetid://6695644299")[1].Source)()
end)

cmd.add({"harked","comet"},{"harked (comet)","Executes Comet which is like harked"},function()
	loadstring(game:HttpGet("https://raw.githubusercontent.com/ltseverydayyou/Nameless-Admin/main/comet"))();
end)

cmd.add({"triggerbot", "tbot"}, {"triggerbot (tbot)", "Executes a script that automatically clicks the mouse when the mouse is on a player"}, function()
	local ToggleKey = Enum.KeyCode.Z
	local FieldOfView = 10

	local UIS = UserInputService
	local Camera = workspace.CurrentCamera

	local Player = Players.LocalPlayer
	local Mouse = Player:GetMouse()
	local Toggled = false
	local Mode = "FFA"
	local LastMode = nil

	local GUI = InstanceNew("ScreenGui")
	local On = InstanceNew("TextLabel")
	local uicorner = InstanceNew("UICorner")
	NaProtectUI(GUI)
	On.Parent = GUI
	On.BackgroundColor3 = Color3.fromRGB(12, 4, 20)
	On.BackgroundTransparency = 0.14
	On.BorderSizePixel = 0
	On.Position = UDim2.new(0.88, 0, 0.33, 0)
	On.Size = UDim2.new(0, 160, 0, 20)
	On.Font = Enum.Font.SourceSans
	On.Text = "TriggerBot On: false (Key: Q)"
	On.TextColor3 = Color3.new(1, 1, 1)
	On.TextScaled = true
	On.TextSize = 14
	On.TextWrapped = true
	uicorner.Parent = On

	local function IsInFieldOfView(target)
		local targetPosition = target.Position
		local screenPoint, onScreen = Camera:WorldToScreenPoint(targetPosition)
		if onScreen then
			local mousePosition = Vector2.new(Mouse.X, Mouse.Y)
			local targetScreenPosition = Vector2.new(screenPoint.X, screenPoint.Y)
			local distance = (mousePosition - targetScreenPosition).Magnitude
			return distance <= FieldOfView
		end
		return false
	end

	local function IsEnemy(otherPlayer)
		if Mode == "FFA" then
			return true
		else
			return otherPlayer.Team ~= nil and Player.Team ~= nil and otherPlayer.Team ~= Player.Team
		end
	end

	local function GetClosestPlayer()
		for _, otherPlayer in pairs(Players:GetPlayers()) do
			if otherPlayer ~= Player and IsEnemy(otherPlayer) and otherPlayer.Character then
				for _, part in pairs(otherPlayer.Character:GetChildren()) do
					if part:IsA("BasePart") and IsInFieldOfView(part) then
						return otherPlayer
					end
				end
			end
		end
		return nil
	end

	local function Click()
		mouse1click()
	end

	local function CheckMode()
		if #Players:GetPlayers() > 0 and Players.LocalPlayer.Team == nil then
			Mode = "FFA"
		else
			Mode = "Team"
		end

		if Mode ~= LastMode then
			DoNotif("Mode changed to: "..Mode)
			LastMode = Mode
		end
	end

	UIS.InputBegan:Connect(function(input, processed)
		if not processed and input.KeyCode == ToggleKey then
			Toggled = not Toggled
			On.Text = "TriggerBot On: "..tostring(Toggled).." (Key: "..ToggleKey.Name..")"
		end
	end)

	RunService.RenderStepped:Connect(function()
		CheckMode()
		if Toggled then
			local targetPlayer = GetClosestPlayer()
			if getPlrHum(targetPlayer) then
				local humanoid = getPlrHum(targetPlayer)
				if humanoid.Health > 0 then
					Click()
				end
			end
		end
	end)

	On.Text = "TriggerBot On: "..tostring(Toggled).." (Key: "..ToggleKey.Name..")"

	DebugNotif("Advanced Trigger Bot Loaded")
end)

NAStuff.stationaryRespawn = NAStuff.stationaryRespawn or false
NAStuff.hasPosition = NAStuff.hasPosition or false
NAStuff.spawnPosition = NAStuff.spawnPosition or CFrame.new()

NAStuff.spawnActive = NAStuff.spawnActive or false
NAStuff.spawnStart = NAStuff.spawnStart or 0
NAStuff.lastChar = NAStuff.lastChar or nil

cmd.add({"setspawn","spawnpoint","ss"},{"setspawn (spawnpoint, ss)","Sets your spawn point to the current character's position"},function()
	if NAlib.isConnected("spawnCONNECTION") and NAlib.isConnected("spawnCHARCON") then
		return DoNotif("spawn point is already running",3)
	end

	local ch = getChar()
	local r = ch and getRoot(ch)
	if not r then
		return DoNotif("failed to get character root",3)
	end

	NAStuff.spawnPosition = r.CFrame
	NAStuff.hasPosition = true
	NAStuff.stationaryRespawn = true
	DebugNotif("Spawn has been set")

	NAStuff.lastChar = ch
	NAStuff.spawnActive = false
	NAStuff.spawnStart = 0

	local function handleRespawn()
		if not NAStuff.stationaryRespawn or not NAStuff.hasPosition then return end

		local hum = getHum()
		local ch2 = getChar()
		if not hum or not ch2 then return end

		if hum.Health <= 0 then
			NAStuff.spawnActive = false
			NAStuff.spawnStart = 0
			return
		end

		local r2 = getRoot(ch2)
		if not r2 then return end

		if ch2 ~= NAStuff.lastChar then
			NAStuff.lastChar = ch2
			NAStuff.spawnActive = true
			NAStuff.spawnStart = 0
		end

		if not NAStuff.spawnActive then return end

		r2.CFrame = NAStuff.spawnPosition

		local d = (r2.Position - NAStuff.spawnPosition.Position).Magnitude
		local now = tick()

		if d < 5 then
			if NAStuff.spawnStart == 0 then
				NAStuff.spawnStart = now
			elseif now - NAStuff.spawnStart >= 1.5 then
				NAStuff.spawnActive = false
				NAStuff.spawnStart = 0
			end
		else
			NAStuff.spawnStart = 0
		end
	end

	NAlib.connect("spawnCONNECTION",RunService.RenderStepped:Connect(handleRespawn))

	NAlib.connect("spawnCHARCON",LocalPlayer.CharacterAdded:Connect(function(ch2)
		NAStuff.lastChar = ch2
		NAStuff.spawnActive = true
		NAStuff.spawnStart = 0
	end))
end)

cmd.add({"disablespawn","unsetspawn","ds"},{"disablespawn (unsetspawn, ds)","Disables the previously set spawn point"},function()
	DebugNotif("Spawn point has been disabled")
	NAlib.disconnect("spawnCONNECTION")
	NAlib.disconnect("spawnCHARCON")
	NAStuff.stationaryRespawn = false
	NAStuff.hasPosition = false
	NAStuff.spawnActive = false
	NAStuff.spawnStart = 0
	NAStuff.lastChar = nil
	NAStuff.spawnPosition = CFrame.new()
end)

NAStuff.adb_on = NAStuff.adb_on or false
NAStuff.adb_done = NAStuff.adb_done or 0

originalIO.adb_try=function()
	if not deathCFrame then return false end
	local t0 = tick()
	local ok0 = 0

	while NAStuff.adb_on and tick() - t0 < 10 do
		local ch = getChar()
		local r = ch and getRoot(ch)
		local h = ch and getHum(ch)

		if r and h and h.Health > 0 then
			r.CFrame = deathCFrame

			local d = (r.Position - deathCFrame.Position).Magnitude
			local now = tick()

			if d < 6 then
				if ok0 == 0 then
					ok0 = now
				elseif now - ok0 >= 1.25 then
					return true
				end
			else
				ok0 = 0
			end
		end

		Wait(0.1)
	end

	return false
end

cmd.add({"autoflashback","autodeathpos","deathback","adeath","db"},{"autoflashback","Auto-teleports you to your last death point on respawn"},function()
	if NAlib.isConnected("adb_ca") then
		return DoNotif("auto deathpos is already running",3)
	end

	NAStuff.adb_on = true

	NAlib.connect("adb_ca", LocalPlayer.CharacterAdded:Connect(function()
		if not NAStuff.adb_on then return end
		if tick() < (NAStuff.adb_done or 0) then return end
		if not deathCFrame then return end

		Spawn(function()
			local ok = originalIO.adb_try()
			if ok then
				NAStuff.adb_done = tick() + 4
			end
		end)
	end))

	DebugNotif("Auto deathpos enabled",2)
end)

cmd.add({"unautoflashback","undeathback","unadeath","undb"},{"unautoflashback","Disables auto deathpos"},function()
	DebugNotif("Auto deathpos disabled",2)
	NAlib.disconnect("adb_ca")
	NAStuff.adb_on = false
	NAStuff.adb_done = 0
end)

cmd.add({"flashback", "deathpos", "deathtp"}, {"flashback (deathpos, deathtp)", "Teleports you to your last death point"}, function()
	if deathCFrame then
		local character = getChar()
		if character and getRoot(character) then
			getRoot(character).CFrame = deathCFrame
		else
			DebugNotif("Could not teleport, root is missing", 3)
		end
	else
		DebugNotif("No available death location to teleport to! You need to die first", 3)
	end
end)

cmd.add({"tospawn", "ts"}, {"tospawn (ts)", "Teleports you to a SpawnLocation"}, function()
	local character = getChar()
	if not character then
		return DebugNotif("Character not found", 3)
	end
	local root = getRoot(character)
	if not root then
		return DebugNotif("Root not found", 3)
	end
	local closestSpawn = nil
	local shortestDistance = math.huge
	local rootPosition = root.Position
	for _, descendant in ipairs(workspace:GetDescendants()) do
		if descendant:IsA("SpawnLocation") then
			local distance = (descendant.Position - rootPosition).Magnitude
			if distance < shortestDistance then
				shortestDistance = distance
				closestSpawn = descendant
			end
		end
	end
	if not closestSpawn then
		return DebugNotif("No SpawnLocation found in workspace", 3)
	end
	root.CFrame = closestSpawn.CFrame * CFrame.new(0, 5, 0)
end)

cmd.add({"hamster"}, {"hamster <number>", "Hamster ball"}, function(...)
	local Camera = workspace.CurrentCamera

	local SPEED_MULTIPLIER = (...) or 30
	local JUMP_POWER = 60
	local JUMP_GAP = 0.3

	local character = SafeGetService("Players").LocalPlayer.Character

	for i, v in ipairs(character:GetDescendants()) do
		if v:IsA("BasePart") then
			v.CanCollide = false
		end
	end

	local ball = getRoot(character)
	ball.Shape = Enum.PartType.Ball
	ball.Size = Vector3.new(5, 5, 5)
	local humanoid = getHum()

	local params = RaycastParams.new()
	params.FilterType = Enum.RaycastFilterType.Blacklist
	params.FilterDescendantsInstances = {character}

	NAlib.connect("hamster_render", RunService.RenderStepped:Connect(function(delta)
		ball.CanCollide = true
		humanoid.PlatformStand = true
		if UserInputService:GetFocusedTextBox() then return end

		local moveVec = GetCustomMoveVector()

		if moveVec.Magnitude > 0 then
			local right = Camera.CFrame.RightVector
			local forward = Camera.CFrame.LookVector
			ball.RotVelocity = ball.RotVelocity + (right * moveVec.Z * delta * SPEED_MULTIPLIER)
			ball.RotVelocity = ball.RotVelocity + (forward * moveVec.X * delta * SPEED_MULTIPLIER)
		end
	end))

	UserInputService.JumpRequest:Connect(function()
		local result = workspace:Raycast(
			ball.Position,
			Vector3.new(0, -((ball.Size.Y / 2) + JUMP_GAP), 0),
			params
		)
		if result then
			ball.Velocity = ball.Velocity + Vector3.new(0, JUMP_POWER, 0)
		end
	end)

	humanoid.Died:Connect(function()
		NAlib.disconnect("hamster_render")
	end)

	Camera.CameraSubject = ball
end, true)

cmd.add({"antiafk","noafk"},{"antiafk (noafk)","Prevents you from being kicked for being AFK"},function()
	if NAlib.isConnected("antiAFK") or NAlib.isConnected("antiAFK_scan") then
		return DebugNotif("Anti AFK is already enabled")
	end

	local GETCONS = getconnections or get_signal_cons or (syn and syn.getconnections)
	local rng = Random.new()
	local KEY = Enum.KeyCode.F15

	local function antiAFKHandler()
		if not GETCONS then
			local VIM = SafeGetService("VirtualInputManager")
			if not VIM then return end
			VIM:SendKeyEvent(true, KEY, false, game)
			Wait(rng:NextNumber(0.04, 0.08))
			VIM:SendKeyEvent(false, KEY, false, game)
			Wait(rng:NextNumber(55, 75))
		end
	end

	if GETCONS then
		local myConn = Players.LocalPlayer.Idled:Connect(antiAFKHandler)
		NAlib.connect("antiAFK", myConn)
		local function nukeOtherIdled()
			local ok, conns = pcall(GETCONS, Players.LocalPlayer.Idled)
			if not ok or type(conns) ~= "table" then return end
			for _, c in ipairs(conns) do
				local f
				pcall(function() f = c.Function end)
				if f ~= antiAFKHandler then
					if c and c.Disable then pcall(function() c:Disable() end) end
					if c and c.Disconnect then pcall(function() c:Disconnect() end) end
				end
			end
		end
		nukeOtherIdled()
		--[[local acc = 0
		local scanConn = RunService.Heartbeat:Connect(function(dt)
			acc += dt
			if acc >= 2 + rng:NextNumber(0, 0.75) then
				acc = 0
				nukeOtherIdled()
			end
		end)]]
		NAlib.connect("antiAFK_scan", scanConn)
		DebugNotif("Anti AFK enabled")
	else
		local function enable()
			local myConn = Players.LocalPlayer.Idled:Connect(antiAFKHandler)
			NAlib.connect("antiAFK", myConn)
			SpawnCall(antiAFKHandler)
			DebugNotif("Anti AFK enabled")
		end
		Window({
			Title = "This Anti AFK uses VirtualInputManager key events and may be detected in some games.\nEnable anyway?",
			Buttons = {
				{ Text = "Enable Anyway", Callback = enable },
				{ Text = "Cancel", Callback = function() DebugNotif("Anti AFK cancelled") end }
			}
		})
	end
end)

cmd.add({"unantiafk","unnoafk"},{"unantiafk (unnoafk)","Allows you to be kicked for being AFK"},function()
	local was = false
	if NAlib.isConnected("antiAFK") then
		NAlib.disconnect("antiAFK"); was = true
	end
	if NAlib.isConnected("antiAFK_scan") then
		NAlib.disconnect("antiAFK_scan"); was = true
	end
	if was then
		DebugNotif("Anti AFK has been disabled")
	else
		DebugNotif("Anti AFK is already disabled")
	end
end)

NAStuff.tpUI = nil
NAStuff.tpTools = {}

NAmanage._tpTargetFromMouse=function(mouse, char)
	if not mouse then
		return nil
	end

	local hit = mouse.Hit
	if typeof(hit) == "CFrame" then
		return hit
	end

	local unitRay = mouse.UnitRay
	if unitRay and workspace and workspace.Raycast then
		local params = RaycastParams.new()
		params.FilterType = Enum.RaycastFilterType.Blacklist
		if char then
			params.FilterDescendantsInstances = { char }
		end
		local result = workspace:Raycast(unitRay.Origin, unitRay.Direction * 512, params)
		if result and result.Position then
			return CFrame.new(result.Position)
		end
	end

	return nil
end

NAmanage.safePivotModel = function(model, cf)
	if not (model and typeof(cf) == "CFrame") then
		return false
	end

	local function updateUndergroundState()
		local st = NAStuff and NAStuff.NAundergroundState
		if not (st and st.Underground) then
			return
		end
		local myChar = (typeof(getChar) == "function") and getChar()
		if myChar and typeof(model) == "Instance" and (model == myChar or model:IsDescendantOf(myChar)) then
			st.UndergroundCurrent = cf
		end
	end

	local ok = pcall(function()
		model:PivotTo(cf)
	end)
	if ok then
		updateUndergroundState()
		return true
	end

	local root = model.PrimaryPart or getRoot(model)
	if not root then
		for _, part in ipairs(model:GetDescendants()) do
			if part:IsA("BasePart") then
				root = part
				break
			end
		end
	end
	if not root then
		return false
	end

	local okRoot = pcall(function()
		root.Anchored = false
		root.CFrame = cf
	end)
	if okRoot then
		updateUndergroundState()
	end
	return okRoot
end

NAmanage.clearAllTP = function()
	if NAStuff.tpUI then
		NAStuff.tpUI:Destroy()
		NAStuff.tpUI = nil
	end
	for _, t in ipairs(NAStuff.tpTools) do
		t:Destroy()
	end
	NAStuff.tpTools = {}
	NAlib.disconnect("tp_down")
	NAlib.disconnect("tp_up")
end

NAmanage.makeClickTweenUI = function()
	NAmanage.clearAllTP()
	local TweenService = SafeGetService("TweenService")
	local player = Players.LocalPlayer
	local mouse = player:GetMouse()

	NAStuff.tpUI = InstanceNew("ScreenGui")
	NaProtectUI(NAStuff.tpUI)

	local clickTpButton = InstanceNew("TextButton")
	clickTpButton.Size = UDim2.new(0,130,0,40)
	clickTpButton.AnchorPoint = Vector2.new(0.5,0)
	clickTpButton.Position = UDim2.new(0.45,0,0.1,0)
	clickTpButton.Text = "Enable Click TP"
	clickTpButton.TextColor3 = Color3.fromRGB(255,255,255)
	clickTpButton.BackgroundColor3 = Color3.fromRGB(50,50,50)
	clickTpButton.BorderSizePixel = 0
	clickTpButton.Parent = NAStuff.tpUI

	local tweenTpButton = clickTpButton:Clone()
	tweenTpButton.Position = UDim2.new(0.55,0,0.1,0)
	tweenTpButton.Text = "Enable Tween TP"
	tweenTpButton.Parent = NAStuff.tpUI

	InstanceNew("UICorner", clickTpButton)
	InstanceNew("UICorner", tweenTpButton)

	local clickEnabled = false
	local tweenEnabled = false
	local initialPos
	local dragThreshold = 10
	local ctCFVal

	MouseButtonFix(clickTpButton, function()
		clickEnabled = not clickEnabled
		tweenEnabled = false
		if ctCFVal then
			ctCFVal:Destroy()
			ctCFVal = nil
		end
		clickTpButton.Text = clickEnabled and "Disable Click TP" or "Enable Click TP"
		tweenTpButton.Text = "Enable Tween TP"
	end)

	MouseButtonFix(tweenTpButton, function()
		tweenEnabled = not tweenEnabled
		clickEnabled = false
		if not tweenEnabled and ctCFVal then
			ctCFVal:Destroy()
			ctCFVal = nil
		end
		tweenTpButton.Text = tweenEnabled and "Disable Tween TP" or "Enable Tween TP"
		clickTpButton.Text = "Enable Click TP"
	end)

	NAlib.connect("tp_down", mouse.Button1Down:Connect(function()
		initialPos = Vector2.new(mouse.X, mouse.Y)
	end))

	NAlib.connect("tp_up", mouse.Button1Up:Connect(function()
		if not initialPos then return end
		local char = player.Character
		if not char then
			initialPos = nil
			return
		end
		local currentPos = Vector2.new(mouse.X, mouse.Y)
		if (currentPos - initialPos).Magnitude <= dragThreshold then
			local hit = NAmanage._tpTargetFromMouse(mouse, char)
			if not hit then
				initialPos = nil
				return
			end
			local target = hit + Vector3.new(0,2.5,0)
			if clickEnabled then
				NAmanage.safePivotModel(char, CFrame.new(target.p))
			elseif tweenEnabled then
				if ctCFVal then
					ctCFVal:Destroy()
					ctCFVal = nil
				end
				local cfVal = InstanceNew("CFrameValue")
				ctCFVal = cfVal
				cfVal.Value = char:GetPivot()
				cfVal.Changed:Connect(function(newCF)
					NAmanage.safePivotModel(char, newCF)
				end)
				local tw = TweenService:Create(cfVal, TweenInfo.new(NAmanage.resolveTweenDuration(), Enum.EasingStyle.Quad, Enum.EasingDirection.Out),{Value=CFrame.new(target.p)})
				tw:Play()
				tw.Completed:Connect(function()
					if cfVal then
						cfVal:Destroy()
						if ctCFVal == cfVal then
							ctCFVal = nil
						end
					end
				end)
			end
		end
		initialPos = nil
	end))

	NAgui.draggerV2(clickTpButton)
	NAgui.draggerV2(tweenTpButton)
end

NAmanage.makeClickTweenTools = function()
	NAmanage.clearAllTP()
	local TweenService = SafeGetService("TweenService")
	local player = Players.LocalPlayer

	local function newTool(name, tween)
		local tool = InstanceNew("Tool")
		tool.Name = name
		tool.RequiresHandle = false
		tool.CanBeDropped = false
		tool.Parent = player.Backpack
		tool.Activated:Connect(function()
			local mouse = player:GetMouse()
			local char = player.Character
			if not (mouse and char) then
				return
			end
			local hit = NAmanage._tpTargetFromMouse(mouse, char)
			if not hit then
				return
			end
			local target = hit + Vector3.new(0,2.5,0)
			if tween then
				local cfVal = InstanceNew("CFrameValue")
				cfVal.Value = char:GetPivot()
				cfVal.Changed:Connect(function(newCF)
					NAmanage.safePivotModel(char, newCF)
				end)
				local tw = TweenService:Create(cfVal, TweenInfo.new(NAmanage.resolveTweenDuration(), Enum.EasingStyle.Quad, Enum.EasingDirection.Out),{Value=CFrame.new(target.p)})
				tw:Play()
				tw.Completed:Connect(function()
					cfVal:Destroy()
				end)
			else
				NAmanage.safePivotModel(char, CFrame.new(target.p))
			end
		end)
		Insert(NAStuff.tpTools, tool)
	end

	newTool("Click TP", false)
	newTool("Tween TP", true)
end

cmd.add({"clicktp","tptool"},{"clicktp (tptool)","Teleport where your mouse is"},function()
	Window({
		Title = "Choose Teleport Mode",
		Description = "Would you like to use on-screen buttons, or equipable Tools in your Backpack?",
		Buttons = {
			{Text="UI Buttons",Callback=NAmanage.makeClickTweenUI},
			{Text="Backpack Tools",Callback=NAmanage.makeClickTweenTools}
		}
	})
end)

cmd.add({"unclicktp","untptool"},{"unclicktp (untptool)","Remove teleport buttons or tools"},function()
	NAmanage.clearAllTP()
end)

cmd.add({"olddex"},{"olddex","Using this you can see the parts / guis / scripts etc with this. A really good and helpful script."},function()
	loadstring(game:HttpGet("https://raw.githubusercontent.com/ltseverydayyou/uuuuuuu/refs/heads/main/DexByMoonMobile"))()
end)

cmd.add({"dex"},{"dex","Better version of dex"},function()
	loadstring(game:HttpGet("https://raw.githubusercontent.com/ltseverydayyou/uuuuuuu/refs/heads/main/DexPlusBackup.luau"))()
end)

cmd.add({"minimap"},{"minimap","just a minimap lol"},function()
	loadstring(game:HttpGet("https://raw.githubusercontent.com/ltseverydayyou/uuuuuuu/refs/heads/main/minimap.luau"))()
end)

cmd.add({"animationplayer","animplayer", "aplayer","animp"},{"animationplayer","dropdown menu with all the animations the game has to be played"},function()
	loadstring(game:HttpGet("https://raw.githubusercontent.com/ltseverydayyou/uuuuuuu/refs/heads/main/AnimPlayer.luau"))();
end)

cmd.add({"Decompiler"},{"Decompiler","Allows you to decompile LocalScript/ModuleScript's using konstant"},function()
	Spawn(function()
		assert(getscriptbytecode, "Exploit not supported.")

		local API: string = "http://api.plusgiant5.com/"

		local last_call = 0
		function call(konstantType: string, scriptPath: Script | ModuleScript | LocalScript): string
			local success: boolean, bytecode: string = NACaller(getscriptbytecode, scriptPath)

			if (not success) then
				return
			end

			local time_elapsed = os.clock() - last_call
			if time_elapsed <= .5 then
				Wait(.5 - time_elapsed)
			end
			local httpResult = opt.NAREQUEST({
				Url = API..konstantType,
				Body = bytecode,
				Method = "POST",
				Headers = {
					["Content-Type"] = "text/plain"
				},
			})
			last_call = os.clock()

			if (httpResult.StatusCode ~= 200) then
				return
			else
				return httpResult.Body
			end
		end

		function decompile(scriptPath: Script | ModuleScript | LocalScript): string
			return call("/konstant/decompile", scriptPath)
		end

		function disassemble(scriptPath: Script | ModuleScript | LocalScript): string
			return call("/konstant/disassemble", scriptPath)
		end

		getgenv().decompile = decompile
		getgenv().disassemble = disassemble

		-- by lovrewe
	end)
	--loadstring(game:HttpGet("https://raw.githubusercontent.com/ltseverydayyou/uuuuuuu/refs/heads/main/WompWomp.lua"))()
end)

cmd.add({"getidfromusername","gidu"},{"getidfromusername (gidu)","Copy a user's UserId by Username"}, function(thingy)
	local s,idd=NACaller(function()
		return Players:GetUserIdFromNameAsync(tostring(thingy))
	end)

	if not s then return DoNotif("err: "..tostring(idd)) end

	if not setclipboard then return DoNotif("no setclipboard") end
	setclipboard(tostring(idd))

	DebugNotif("Copied "..tostring(thingy).."'s UserId: "..tostring(idd))
end,true)

cmd.add({"getuserfromid","guid"},{"getuserfromid (guid)","Copy a user's Username by ID"}, function(thingy)
	local s,naem=NACaller(function()
		return Players:GetNameFromUserIdAsync(thingy)
	end)

	if not s then return DoNotif("err: "..tostring(naem)) end

	if not setclipboard then return DoNotif("no setclipboard") end
	setclipboard(tostring(naem))

	DebugNotif("Copied "..tostring(naem).."'s Username with ID of "..tostring(thingy))
end,true)

cmd.add({"ownerid"},{"ownerid","masks you as the game owner's ID and Username"},function()
	local ownerUserId, ownerName
	if game.CreatorType == Enum.CreatorType.User then
		ownerUserId = game.CreatorId
	elseif game.CreatorType == Enum.CreatorType.Group then
		local ok, info = pcall(function() return SafeGetService("GroupService"):GetGroupInfoAsync(game.CreatorId) end)
		if ok and info then
			if info.Owner and info.Owner.Id then ownerUserId = info.Owner.Id end
			if not ownerUserId and info.OwnerId then ownerUserId = info.OwnerId end
		end
	end
	if not ownerUserId then DebugNotif("Owner not found",3) return end
	local ok2, nameOrErr = pcall(function() return Players:GetNameFromUserIdAsync(ownerUserId) end)
	if ok2 and nameOrErr and nameOrErr ~= "" then ownerName = nameOrErr else ownerName = "unknown" end
	opt.hiddenprop(LocalPlayer, "UserId", ownerUserId)
	opt.hiddenprop(LocalPlayer, "Name", ownerName)
end)

cmd.add({"userid"},{"userid <id>","changes your UserId to any ID you enter"},function(...)
	local arg = ({...})[1]
	if not arg or arg == "" then
		DebugNotif("usage: userid <userId|username>",3)
		return nil
	end
	local text = tostring(arg):gsub("^%s+",""):gsub("%s+$","")
	local resolvedId

	local asNum = tonumber(text)
	if asNum then
		if asNum < 1 or asNum ~= math.floor(asNum) then
			DebugNotif("invalid userId",3)
			return nil
		end
		local ok, _ = pcall(function() return Players:GetNameFromUserIdAsync(asNum) end)
		if not ok then
			DebugNotif("invalid userId (not found)",3)
			return nil
		end
		resolvedId = asNum
	else
		local uname = text:gsub("^@","")
		local ok, uid = pcall(function() return Players:GetUserIdFromNameAsync(uname) end)
		if not ok or not uid then
			DebugNotif("invalid username",3)
			return nil
		end
		local ok2, _ = pcall(function() return Players:GetNameFromUserIdAsync(uid) end)
		if not ok2 then
			DebugNotif("resolved user invalid",3)
			return nil
		end
		resolvedId = uid
	end

	if resolvedId then
		opt.hiddenprop(LocalPlayer, "UserId", resolvedId)
		return resolvedId
	end

	return nil
end)

cmd.add({"username","name"},{"username <name>","changes your Username to any name you enter"},function(...)
	local arg = ({...})[1]
	if not arg or arg == "" then
		return DebugNotif("missing argument",3)
	end
	opt.hiddenprop(LocalPlayer, "Name", arg)
end)

cmd.add({"synapsedex","sdex"},{"synapsedex (sdex)","Loads SynapseX's dex explorer"},function()
	local rng=Random.new()

	local charset={}
	for i=48,57 do Insert(charset,string.char(i)) end
	for i=65,90 do Insert(charset,string.char(i)) end
	for i=97,122 do Insert(charset,string.char(i)) end
	function RandomCharacters(length)
		if length>0 then
			return RandomCharacters(length-1)..charset[rng:NextInteger(1,#charset)]
		else
			return ""
		end
	end

	local Dex=game:GetObjects("rbxassetid://9553291002")[1]
	Dex.Name=RandomCharacters(rng:NextInteger(5,20))
	NaProtectUI(Dex)

	function Load(Obj,Url)
		function GiveOwnGlobals(Func,Script)
			local Fenv={}
			local RealFenv={script=Script}
			local FenvMt={}
			FenvMt.__index=function(a,b)
				if RealFenv[b]==nil then
					return getfenv()[b]
				else
					return RealFenv[b]
				end
			end
			FenvMt.__newindex=function(a,b,c)
				if RealFenv[b]==nil then
					getfenv()[b]=c
				else
					RealFenv[b]=c
				end
			end
			setmetatable(Fenv,FenvMt)
			setfenv(Func,Fenv)
			return Func
		end

		function LoadScripts(Script)
			if Script.ClassName=="Script" or Script.ClassName=="LocalScript" then
				Spawn(function()
					GiveOwnGlobals(loadstring(Script.Source,"="..Script:GetFullName()),Script)()
				end)
			end
			for i,v in pairs(Script:GetChildren()) do
				LoadScripts(v)
			end
		end

		LoadScripts(Obj)
	end

	Load(Dex)
end)

cmd.add({"antifling"},{"antifling","makes other players non-collidable with you"},function()
	NAlib.disconnect("antifling")
	NAlib.disconnect("antifling_players")

	NAStuff._afTracked = NAStuff._afTracked or setmetatable({}, {__mode = "k"})
	NAStuff._afOrigCan = NAStuff._afOrigCan or setmetatable({}, {__mode = "k"})
	NAStuff._afSignals = NAStuff._afSignals or setmetatable({}, {__mode = "k"})

	local tracked = NAStuff._afTracked
	local orig = NAStuff._afOrigCan
	local sigs = NAStuff._afSignals

	local lp = Players.LocalPlayer
	if not lp then
		DebugNotif("Antifling: LocalPlayer missing")
		return
	end

	local function clearPart(p)
		if tracked[p] then
			tracked[p] = nil
		end
		if orig[p] ~= nil then
			orig[p] = nil
		end
		if sigs[p] then
			local c = sigs[p]
			sigs[p] = nil
			if c and c.Disconnect then
				c:Disconnect()
			end
		end
	end

	local function apply(p)
		if not (p and typeof(p) == "Instance" and p:IsA("BasePart")) or tracked[p] then
			return
		end
		tracked[p] = true
		if orig[p] == nil then
			orig[p] = NAlib.isProperty(p, "CanCollide")
		end
		if not sigs[p] then
			sigs[p] = p:GetPropertyChangedSignal("CanCollide"):Connect(function()
				if tracked[p] and NAlib.isProperty(p, "CanCollide") ~= false then
					NAlib.setProperty(p, "CanCollide", false)
				end
			end)
		end
		if NAlib.isProperty(p, "CanCollide") ~= false then
			NAlib.setProperty(p, "CanCollide", false)
		end
	end

	local function seedChar(char)
		if not char then
			return
		end
		for _, d in ipairs(char:GetDescendants()) do
			if d:IsA("BasePart") then
				apply(d)
			end
		end
		NAlib.connect("antifling", char.DescendantAdded:Connect(function(inst)
			if inst:IsA("BasePart") then
				apply(inst)
			end
		end))
		NAlib.connect("antifling", char.DescendantRemoving:Connect(function(inst)
			if inst:IsA("BasePart") then
				clearPart(inst)
			end
		end))
	end

	local function cleanupChar(char)
		if not char then
			return
		end
		for _, d in ipairs(char:GetDescendants()) do
			if tracked[d] then
				clearPart(d)
			end
		end
	end

	local function hookOther(plr)
		if plr == lp then
			return
		end
		if plr.Character then
			seedChar(plr.Character)
		end
		NAlib.connect("antifling_players", plr.CharacterAdded:Connect(function(char)
			seedChar(char)
		end))
		NAlib.connect("antifling_players", plr.CharacterRemoving:Connect(function(char)
			cleanupChar(char)
		end))
	end

	for _, pl in ipairs(Players:GetPlayers()) do
		hookOther(pl)
	end

	NAlib.connect("antifling_players", Players.PlayerAdded:Connect(hookOther))
	NAlib.connect("antifling_players", Players.PlayerRemoving:Connect(function(pl)
		if pl == lp then
			return
		end
		cleanupChar(pl.Character)
	end))

	local lastKey = nil
	local quotaPerStep = 256

	NAlib.connect("antifling", RunService.Stepped:Connect(function()
		local t = tracked
		if not t then
			return
		end

		local quota = quotaPerStep

		local k = lastKey
		if k ~= nil and t[k] == nil then
			k = nil
		end

		while quota > 0 do
			k = next(t, k)
			if not k then
				lastKey = nil
				break
			end

			local p = k

			if typeof(p) == "Instance" and p:IsA("BasePart") and p.Parent then
				if NAlib.isProperty(p, "CanCollide") ~= false then
					NAlib.setProperty(p, "CanCollide", false)
				end
				lastKey = p
			else
				clearPart(p)
				lastKey = nil
			end

			quota = quota - 1
		end
	end))

	DebugNotif("Antifling Enabled")
end)

cmd.add({"unantifling"},{"unantifling","restores collision for other players"},function()
	NAlib.disconnect("antifling")
	NAlib.disconnect("antifling_players")

	local tracked = NAStuff._afTracked or {}
	local orig = NAStuff._afOrigCan or {}
	local sigs = NAStuff._afSignals or {}

	for p in pairs(tracked) do
		if typeof(p) == "Instance" and p:IsA("BasePart") then
			local v = orig[p]
			if v == nil then
				v = true
			end
			NAlib.setProperty(p, "CanCollide", v)
		end
	end

	for _, c in pairs(sigs) do
		if c and c.Disconnect then
			c:Disconnect()
		end
	end

	for k in pairs(sigs) do
		sigs[k] = nil
	end
	for k in pairs(tracked) do
		tracked[k] = nil
	end
	for k in pairs(orig) do
		orig[k] = nil
	end

	DebugNotif("Antifling Disabled")
end)

cmd.add({"gravitygun"},{"gravitygun","Probably the best gravity gun script thats fe"},function()
	Wait();
	DoNotif("Wait a few seconds for it to load",2.5)
	loadstring(game:HttpGet("https://raw.githubusercontent.com/ltseverydayyou/Nameless-Admin/main/gravity%20gun"))()
end)

cmd.add({"lockws","lockworkspace"},{"lockws (lockworkspace)","Locks the whole workspace"},function()
	for _, inst in ipairs(workspace:GetDescendants()) do
		if NAlib.isProperty(inst, "Locked") ~= nil then
			NAlib.setProperty(inst, "Locked", true)
		end
	end
end)

cmd.add({"unlockws","unlockworkspace"},{"unlockws (unlockworkspace)","Unlocks everything in Workspace"},function()
	for _, inst in ipairs(workspace:GetDescendants()) do
		if NAlib.isProperty(inst, "Locked") ~= nil then
			NAlib.setProperty(inst, "Locked", false)
		end
	end
end)

vspeedBTN = nil

cmd.add({"vehiclespeed", "vspeed"}, {"vehiclespeed <amount> (vspeed)", "Change the vehicle speed"}, function(amount)
	NAlib.disconnect("vehicleloopspeed")

	if vspeedBTN then
		vspeedBTN:Destroy()
		vspeedBTN = nil
	end

	local intens = tonumber(amount) or 1

	NAlib.connect("vehicleloopspeed", RunService.Stepped:Connect(function()
		local subject = workspace.CurrentCamera.CameraSubject
		if subject and subject:IsA("Humanoid") and subject.SeatPart then
			subject.SeatPart:ApplyImpulse(subject.SeatPart.CFrame.LookVector * Vector3.new(intens, 0, intens))
		elseif subject and subject:IsA("BasePart") then
			subject:ApplyImpulse(subject.CFrame.LookVector * Vector3.new(intens, 0, intens))
		end
	end))

	DebugNotif("Vehicle speed set to "..intens)

	Wait()

	vspeedBTN = InstanceNew("ScreenGui")
	local btn = InstanceNew("TextButton")
	local speedBox = InstanceNew("TextBox")
	local toggleBtn = InstanceNew("TextButton")
	local corner = InstanceNew("UICorner")
	local corner2 = InstanceNew("UICorner")
	local corner3 = InstanceNew("UICorner")
	local aspect = InstanceNew("UIAspectRatioConstraint")
	local vstopBtn = InstanceNew("TextButton")
	local vstopCorner = InstanceNew("UICorner")

	NaProtectUI(vspeedBTN)

	btn.Parent = vspeedBTN
	btn.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
	btn.BackgroundTransparency = 0.1
	btn.Position = UDim2.new(0.9, 0, 0.4, 0)
	btn.Size = UDim2.new(0.08, 0, 0.1, 0)
	btn.Font = Enum.Font.GothamBold
	btn.Text = "vSpeed"
	btn.TextColor3 = Color3.fromRGB(255, 255, 255)
	btn.TextScaled = true
	btn.TextWrapped = true
	btn.Active = true

	corner.CornerRadius = UDim.new(0.2, 0)
	corner.Parent = btn

	aspect.Parent = btn
	aspect.AspectRatio = 1.0

	speedBox.Parent = vspeedBTN
	speedBox.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
	speedBox.BackgroundTransparency = 0.1
	speedBox.AnchorPoint = Vector2.new(0.5, 0)
	speedBox.Position = UDim2.new(0.5, 0, 0, 10)
	speedBox.Size = UDim2.new(0, 75, 0, 35)
	speedBox.Font = Enum.Font.GothamBold
	speedBox.Text = tostring(intens)
	speedBox.TextColor3 = Color3.fromRGB(255, 255, 255)
	speedBox.TextSize = 18
	speedBox.TextWrapped = true
	speedBox.ClearTextOnFocus = false
	speedBox.PlaceholderText = "Speed"
	speedBox.Visible = false

	corner2.CornerRadius = UDim.new(0.2, 0)
	corner2.Parent = speedBox

	toggleBtn.Parent = btn
	toggleBtn.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
	toggleBtn.BackgroundTransparency = 0.1
	toggleBtn.Position = UDim2.new(0.8, 0, -0.1, 0)
	toggleBtn.Size = UDim2.new(0.4, 0, 0.4, 0)
	toggleBtn.Font = Enum.Font.SourceSans
	toggleBtn.Text = "+"
	toggleBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
	toggleBtn.TextScaled = true
	toggleBtn.TextWrapped = true
	toggleBtn.Active = true
	toggleBtn.AutoButtonColor = true

	corner3.CornerRadius = UDim.new(1, 0)
	corner3.Parent = toggleBtn

	vstopBtn.Parent = vspeedBTN
	vstopBtn.BackgroundColor3 = Color3.fromRGB(80, 80, 80)
	vstopBtn.BackgroundTransparency = 0.1
	vstopBtn.Position = UDim2.new(0.9, 0, 0.52, 0)
	vstopBtn.Size = UDim2.new(0.08, 0, 0.1, 0)
	vstopBtn.Font = Enum.Font.GothamBold
	vstopBtn.Text = "vSTOP"
	vstopBtn.TextColor3 = Color3.new(1, 1, 1)
	vstopBtn.TextScaled = true
	vstopBtn.TextWrapped = true
	vstopBtn.Active = true
	vstopBtn.AutoButtonColor = true

	vstopCorner.CornerRadius = UDim.new(0.2, 0)
	vstopCorner.Parent = vstopBtn

	MouseButtonFix(toggleBtn, function()
		speedBox.Visible = not speedBox.Visible
		toggleBtn.Text = speedBox.Visible and "-" or "+"
	end)

	local vSpeedOn = true
	btn.Text = "vSpeed ON"
	btn.BackgroundColor3 = Color3.fromRGB(0, 170, 0)

	MouseButtonFix(btn, function()
		vSpeedOn = not vSpeedOn

		if vSpeedOn then
			local newIntens = tonumber(speedBox.Text) or 1
			intens = newIntens

			NAlib.disconnect("vehicleloopspeed")
			NAlib.connect("vehicleloopspeed", RunService.Stepped:Connect(function()
				local subject = workspace.CurrentCamera.CameraSubject
				if subject and subject:IsA("Humanoid") and subject.SeatPart then
					subject.SeatPart:ApplyImpulse(subject.SeatPart.CFrame.LookVector * Vector3.new(intens, 0, intens))
				elseif subject and subject:IsA("BasePart") then
					subject:ApplyImpulse(subject.CFrame.LookVector * Vector3.new(intens, 0, intens))
				end
			end))

			btn.Text = "vSpeed ON"
			btn.BackgroundColor3 = Color3.fromRGB(0, 170, 0)
		else
			NAlib.disconnect("vehicleloopspeed")

			local subject = workspace.CurrentCamera.CameraSubject
			if subject then
				local root
				if subject:IsA("Humanoid") and subject.SeatPart then
					root = subject.SeatPart
				elseif subject:IsA("BasePart") then
					root = subject
				end

				if root then
					SpawnCall(function()
						for i = 1, 10 do
							if root:IsDescendantOf(game) then
								root.AssemblyLinearVelocity=root.AssemblyLinearVelocity * .8
								root.AssemblyAngularVelocity=root.AssemblyAngularVelocity * .8
								Wait(0.05)
							end
						end
					end)
				end
			end

			btn.Text = "vSpeed"
			btn.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
		end
	end)

	MouseButtonFix(vstopBtn, function()
		local subject = workspace.CurrentCamera.CameraSubject
		if subject then
			local root
			if subject:IsA("Humanoid") and subject.SeatPart then
				root = subject.SeatPart
			elseif subject:IsA("BasePart") then
				root = subject
			end

			if root then
				local model = root:FindFirstAncestorOfClass("Model")
				if model then
					for _, part in ipairs(model:GetDescendants()) do
						if part:IsA("BasePart") then
							part.AssemblyLinearVelocity = Vector3.zero
							part.AssemblyAngularVelocity = Vector3.zero
						end
						if part:IsA("VehicleSeat") then
							part.Throttle = 0
							part.Steer = 0
						end
					end
				else
					root.AssemblyLinearVelocity = Vector3.zero
					root.AssemblyAngularVelocity = Vector3.zero
				end
			end
		end
	end)

	speedBox.FocusLost:Connect(function()
		if not vSpeedOn then return end
		local newIntens = tonumber(speedBox.Text) or 1
		intens = newIntens

		NAlib.disconnect("vehicleloopspeed")
		NAlib.connect("vehicleloopspeed", RunService.Stepped:Connect(function()
			local subject = workspace.CurrentCamera.CameraSubject
			if subject and subject:IsA("Humanoid") and subject.SeatPart then
				subject.SeatPart:ApplyImpulse(subject.SeatPart.CFrame.LookVector * Vector3.new(intens, 0, intens))
			elseif subject and subject:IsA("BasePart") then
				subject:ApplyImpulse(subject.CFrame.LookVector * Vector3.new(intens, 0, intens))
			end
		end))

		DebugNotif("vSpeed updated to "..intens, 2)
	end)

	NAgui.draggerV2(btn)
	NAgui.draggerV2(speedBox)
	NAgui.draggerV2(vstopBtn)
end, true)

cmd.add({"unvehiclespeed", "unvspeed"}, {"unvehiclespeed (unvspeed)", "Stops the vehiclespeed command"}, function()
	NAlib.disconnect("vehicleloopspeed")

	if vspeedBTN then
		vspeedBTN:Destroy()
		vspeedBTN = nil
	end

	local subject = workspace.CurrentCamera.CameraSubject
	if subject then
		local root
		if subject:IsA("Humanoid") and subject.SeatPart then
			root = subject.SeatPart
		elseif subject:IsA("BasePart") then
			root = subject
		end

		if root then
			local model = root:FindFirstAncestorOfClass("Model")
			if model then
				for _, part in ipairs(model:GetDescendants()) do
					if part:IsA("BasePart") then
						part.AssemblyLinearVelocity = Vector3.zero
						part.AssemblyAngularVelocity = Vector3.zero
					end
					if part:IsA("VehicleSeat") then
						part.Throttle = 0
						part.Steer = 0
					end
				end
			else
				root.AssemblyLinearVelocity = Vector3.zero
				root.AssemblyAngularVelocity = Vector3.zero
			end
		end
	end

	DebugNotif("Vehicle speed disabled")
end)

active=false
players=Players
camera=workspace.CurrentCamera

uis=UserInputService

active=false
function UpdateAutoRotate(BOOL)
	humanoid.AutoRotate=BOOL
end

GameSettings = UserSettings():GetService("UserGameSettings")

OriginalRotationType = nil
ShiftLockEnabled = false

function EnableShiftLock()
	if ShiftLockEnabled then return end

	local success, currentRotation = NACaller(function()
		return GameSettings.RotationType
	end)

	if success then
		OriginalRotationType = currentRotation
	end

	NAlib.connect("shiftlock_loop", RunService.RenderStepped:Connect(function()
		NACaller(function()
			GameSettings.RotationType = Enum.RotationType.CameraRelative
		end)
	end))

	ShiftLockEnabled = true
	DebugNotif("ShiftLock Enabled", 2)
end

function DisableShiftLock()
	if not ShiftLockEnabled then return end

	NAlib.disconnect("shiftlock_loop")

	NACaller(function()
		GameSettings.RotationType = OriginalRotationType or Enum.RotationType.MovementRelative
	end)

	ShiftLockEnabled = false
	DebugNotif("ShiftLock Disabled", 2)
end

cmd.add({"shiftlock","sl"}, {"shiftlock (sl)", "Toggles shiftlock"}, function()
	if IsOnMobile then
		loadstring(game:HttpGet("https://raw.githubusercontent.com/ltseverydayyou/uuuuuuu/refs/heads/main/shiftlock"))()
	else
		EnableShiftLock()
	end
end)

cmd.add({"unshiftlock","unsl"}, {"unshiftlock (unsl)", "Disables shiftlock"}, function()
	if IsOnPC then
		DisableShiftLock()
	end
end)

-- if you're reading this use the command 'cmdloop enable' to enable the command loop
-- example 'cmdloop enable shiftlock hidden' (hides notification to display) or set hidden to just anything as long as argument 2 is not empty 💀

cmd.add({"enable"}, {"enable", "Enables a specific CoreGui"}, function(...)
	local args = {...}
	local enableName = args[1]
	local hiddenNotif = args[2]
	local buttons = {}

	for _, coreGuiType in ipairs(Enum.CoreGuiType:GetEnumItems()) do
		Insert(buttons, {
			Text = coreGuiType.Name,
			Callback = function()
				StarterGui:SetCoreGuiEnabled(coreGuiType, true)
				if coreGuiType == Enum.CoreGuiType.Chat or coreGuiType == Enum.CoreGuiType.All then
					NAStuff.ChatSettings.coreGuiChat = true
					NAmanage.SaveTextChatSettings()
					NAmanage.ApplyTextChatSettings()
				end
			end
		})
	end

	Insert(buttons, {
		Text = "Shiftlock",
		Callback = function()
			LocalPlayer.DevEnableMouseLock = true
		end
	})

	Insert(buttons, {
		Text = "Reset",
		Callback = function()
			StarterGui:SetCore("ResetButtonCallback", true)
		end
	})

	if enableName and enableName ~= "" then
		local found = false
		for _, button in ipairs(buttons) do
			if Match(button.Text:lower(), enableName:lower()) then
				button.Callback()
				if not hiddenNotif then
					DebugNotif("CoreGui Enabled: "..button.Text.." has been enabled.", 3)
				end
				found = true
				break
			end
		end
		if not found then
			DebugNotif("No matching CoreGui element found for: "..enableName, 3)
		end
	else
		Window({
			Title = "Enable a Specific Core Gui Element",
			Buttons = buttons
		})
	end
end, true)

cmd.add({"disable"}, {"disable", "Disables a specific CoreGui"}, function(...)
	local args = {...}
	local disableName = args[1]
	local hiddenNotif = args[2] -- scuffed way lmao
	local buttons = {}

	for _, coreGuiType in ipairs(Enum.CoreGuiType:GetEnumItems()) do
		Insert(buttons, {
			Text = coreGuiType.Name,
			Callback = function()
				StarterGui:SetCoreGuiEnabled(coreGuiType, false)
			end
		})
	end

	Insert(buttons, {
		Text = "Shiftlock",
		Callback = function()
			LocalPlayer.DevEnableMouseLock = false
		end
	})

	Insert(buttons, {
		Text = "Reset",
		Callback = function()
			StarterGui:SetCore("ResetButtonCallback", false)
		end
	})

	if disableName and disableName ~= "" then
		local found = false
		for _, button in ipairs(buttons) do
			if Match(button.Text:lower(), disableName:lower()) then
				button.Callback()
				if not hiddenNotif then
					DebugNotif("CoreGui Disabled: "..button.Text.." has been disabled.", 3)
				end
				found = true
				break
			end
		end
		if not found then
			DebugNotif("No matching CoreGui element found for: "..disableName, 3)
		end
	else
		Window({
			Title = "Disable a Specific Core Gui Element",
			Buttons = buttons
		})
	end
end,true)

cmd.add({"reverb","reverbcontrol"},{"reverb (reverbcontrol)","Manage sound reverb settings"},function(...)
	local args = {...}
	local target = args[1]
	local buttons = {}
	for _, rt in ipairs(Enum.ReverbType:GetEnumItems()) do
		Insert(buttons, {
			Text = rt.Name,
			Callback = function()
				SafeGetService("SoundService").AmbientReverb = rt
			end
		})
	end
	if target and target ~= "" then
		local found = false
		for _, btn in ipairs(buttons) do
			if Match(Lower(btn.Text), Lower(target)) then
				btn.Callback()
				DebugNotif("Reverb set to "..btn.Text, 3)
				found = true
				break
			end
		end
		if not found then
			DebugNotif("No matching reverb type for: "..target, 3)
		end
	else
		Window({
			Title = "Sound Reverb Options",
			Buttons = buttons
		})
	end
end)

cmd.add({"cam","camera","cameratype"},{"cam (camera, cameratype)","Manage camera type settings"},function(...)
	local args = {...}
	local target = args[1]
	local buttons = {}
	for _, ct in ipairs(Enum.CameraType:GetEnumItems()) do
		Insert(buttons, {
			Text = ct.Name,
			Callback = function()
				workspace.CurrentCamera.CameraType = ct
			end
		})
	end
	if target and target ~= "" then
		local found = false
		for _, btn in ipairs(buttons) do
			if Match(Lower(btn.Text), Lower(target)) then
				btn.Callback()
				DebugNotif("Camera type set to "..btn.Text, 3)
				found = true
				break
			end
		end
		if not found then
			DebugNotif("No matching camera type for: "..target, 3)
		end
	else
		Window({
			Title = "Camera Type Options",
			Buttons = buttons
		})
	end
end)

alignmentButtonsGui = nil

cmd.add({"alignmentkeys","alignkeys","ak"},{"alignmentkeys","Enable alignment keys"}, function()
	local function onInput(input, gameProcessed)
		if gameProcessed then return end
		if input.KeyCode == Enum.KeyCode.Comma and workspace.CurrentCamera then
			workspace.CurrentCamera:PanUnits(-1)
		elseif input.KeyCode == Enum.KeyCode.Period and workspace.CurrentCamera then
			workspace.CurrentCamera:PanUnits(1)
		end
	end
	if not NAlib.isConnected("align_input") then
		NAlib.connect("align_input", UserInputService.InputBegan:Connect(onInput))
	end
	if IsOnMobile and not alignmentButtonsGui then
		alignmentButtonsGui = InstanceNew("ScreenGui")
		alignmentButtonsGui.Name = "AlignButtons"
		alignmentButtonsGui.ResetOnSpawn = false
		NaProtectUI(alignmentButtonsGui)

		local btnSize = UDim2.new(0.1, 0, 0.1, 0)

		local leftButton = InstanceNew("TextButton")
		leftButton.Name = "PanLeft"
		leftButton.Text = "<"
		leftButton.TextScaled = true
		leftButton.Size = btnSize
		leftButton.Position = UDim2.new(0.45, 0, 0.05, 0)
		leftButton.AnchorPoint = Vector2.new(0.5, 0.5)
		leftButton.BackgroundColor3 = Color3.new(0, 0, 0)
		leftButton.BorderSizePixel = 0
		leftButton.TextColor3 = Color3.new(1, 1, 1)
		leftButton.Parent = alignmentButtonsGui

		local leftUICorner = InstanceNew("UICorner")
		leftUICorner.CornerRadius = UDim.new(1, 0)
		leftUICorner.Parent = leftButton

		local rightButton = InstanceNew("TextButton")
		rightButton.Name = "PanRight"
		rightButton.Text = ">"
		rightButton.TextScaled = true
		rightButton.Size = btnSize
		rightButton.Position = UDim2.new(0.55, 0, 0.05, 0)
		rightButton.AnchorPoint = Vector2.new(0.5, 0.5)
		rightButton.BackgroundColor3 = Color3.new(0, 0, 0)
		rightButton.BorderSizePixel = 0
		rightButton.TextColor3 = Color3.new(1, 1, 1)
		rightButton.Parent = alignmentButtonsGui

		local rightUICorner = InstanceNew("UICorner")
		rightUICorner.CornerRadius = UDim.new(1, 0)
		rightUICorner.Parent = rightButton

		NAgui.draggerV2(leftButton)
		NAgui.draggerV2(rightButton)

		NAlib.connect("align_mobile_left", MouseButtonFix(leftButton,function()
			if workspace.CurrentCamera then
				workspace.CurrentCamera:PanUnits(-1)
			end
		end))
		NAlib.connect("align_mobile_right", MouseButtonFix(rightButton,function()
			if workspace.CurrentCamera then
				workspace.CurrentCamera:PanUnits(1)
			end
		end))
	end
end)

cmd.add({"disablealignmentkeys","disablealignkeys","dak"},{"disablealignmentkeys","Disable alignment keys"}, function()
	NAlib.disconnect("align_input")
	if IsOnMobile and alignmentButtonsGui then
		NAlib.disconnect("align_mobile_left")
		NAlib.disconnect("align_mobile_right")
		alignmentButtonsGui:Destroy()
		alignmentButtonsGui = nil
		mobileLeftConn = nil
		mobileRightConn = nil
	end
end)

cmd.add({"esp"}, {"esp","locate where the players are"}, function()
	ESPPlayersEnabled = true
	NAmanage.ESP_RecomputeEnabled()
	chamsEnabled = false
	ESPAutoTrackAll = true
	for _, player in pairs(Players:GetPlayers()) do
		if player ~= Players.LocalPlayer then
			NAmanage.ESP_Add(player, true)
		end
	end
end)

cmd.add({"chams"}, {"chams","ESP but without the text :shock:"}, function()
	ESPPlayersEnabled = true
	NAmanage.ESP_RecomputeEnabled()
	chamsEnabled = true
	ESPAutoTrackAll = true
	for _, player in pairs(Players:GetPlayers()) do
		if player ~= Players.LocalPlayer then
			NAmanage.ESP_Add(player, true)
		end
	end
end)

cmd.add({"locate"}, {"locate <username1> <username2> etc (optional)", "locate where the specified player(s) are"}, function(...)
	ESPPlayersEnabled = true
	NAmanage.ESP_RecomputeEnabled()
	chamsEnabled = false
	local tokens = {...}
	local providedArgCount = select("#", ...)
	if providedArgCount == 0 then tokens = {"all"} end
	local shouldAuto = (providedArgCount == 0)
	if not shouldAuto then
		for _, token in ipairs(tokens) do
			local lower = tostring(token):lower()
			if lower == "all" or lower == "others" then
				shouldAuto = true
				break
			end
		end
	end
	ESPAutoTrackAll = shouldAuto
	for _, token in ipairs(tokens) do
		for _, target in ipairs(getPlr(token)) do
			if target and target ~= Players.LocalPlayer then
				NAmanage.ESP_Add(target, true)
			end
		end
	end
end, true)

NAStuff.NPC_SCAN_KEY = NAStuff.NPC_SCAN_KEY or "npc_esp_scan"
NAStuff.npcESPList = NAStuff.npcESPList or getgenv().npcESPList or {}
getgenv().npcESPList = NAStuff.npcESPList
NAStuff.npcCandidates = NAStuff.npcCandidates or {}

NAmanage.ClearNpcTables = function()
	for inst in pairs(NAStuff.npcCandidates) do
		NAStuff.npcCandidates[inst] = nil
	end
	for inst in pairs(NAStuff.npcESPList) do
		NAStuff.npcESPList[inst] = nil
		NAmanage.ESP_Disconnect(inst)
	end
end

NAmanage.AddNpcCandidate = function(inst)
	if inst and inst:IsA("Model") and CheckIfNPC(inst) then
		NAStuff.npcCandidates[inst] = true
	end
end

NAmanage.RemoveNpcCandidate = function(inst)
	if not inst then
		return
	end
	if inst:IsA("Model") then
		NAStuff.npcCandidates[inst] = nil
	end
	if NAStuff.npcESPList[inst] then
		NAStuff.npcESPList[inst] = nil
		NAmanage.ESP_Disconnect(inst)
	end
end

NAmanage.SeedNpcCandidates = function()
	for inst in pairs(NAStuff.npcCandidates) do
		NAStuff.npcCandidates[inst] = nil
	end
	for _, inst in ipairs(workspace:GetDescendants()) do
		NAmanage.AddNpcCandidate(inst)
	end
end

cmd.add({"npcesp","espnpc"},{"npcesp (espnpc)","locate where the npcs are"},function()
	NPCESPenabled = true
	NAmanage.ESP_RecomputeEnabled()
	chamsEnabled = false
	ESPAutoTrackAll = false
	NAmanage.ClearNpcTables()
	NAmanage.SeedNpcCandidates()
	if not NAlib.isConnected(NAStuff.NPC_SCAN_KEY) then
		local acc = 0
		NAlib.connect(NAStuff.NPC_SCAN_KEY, RunService.Heartbeat:Connect(function(dt)
			if not NPCESPenabled then return end
			acc = acc + dt
			if acc < (NAStuff.NPC_ESP_ScanInterval or 0.6) then return end
			acc = 0

			local plr = Players.LocalPlayer
			local char = plr and plr.Character
			local root = char and getRoot(char)
			if not root then return end

			local found = {}
			local cnt = 0
			local maxCnt = NAStuff.NPC_ESP_MaxCount or 200
			local maxDist = NAStuff.NPC_ESP_MaxDist or 400

			for inst in pairs(NAStuff.npcCandidates) do
				if inst and inst.Parent then
					if not (CheckIfNPC(inst) and NAmanage.IsValidESPModel(inst, true)) then
						NAStuff.npcCandidates[inst] = nil
						NAStuff.npcESPList[inst] = nil
						NAmanage.ESP_Disconnect(inst)
						continue
					end
					local rp = getRoot(inst)
					if rp then
						local d = (rp.Position - root.Position).Magnitude
						if d <= maxDist then
							found[inst] = true
							if not NAStuff.npcESPList[inst] then
								NAStuff.npcESPList[inst] = true
								NAmanage.ESP_Add(inst, false, true)
							end
							cnt += 1
							if cnt >= maxCnt then
								break
							end
						end
					end
				else
					NAStuff.npcCandidates[inst] = nil
				end
			end

			for inst in pairs(NAStuff.npcESPList) do
				if not found[inst] then
					NAStuff.npcESPList[inst] = nil
					NAmanage.ESP_Disconnect(inst)
				end
			end
		end))
		NAlib.connect(NAStuff.NPC_SCAN_KEY, workspace.DescendantAdded:Connect(function(inst)
			if inst:IsA("Model") then
				NAmanage.AddNpcCandidate(inst)
			elseif inst:IsA("Humanoid") then
				local parent = inst.Parent
				if parent and parent:IsA("Model") then
					NAmanage.AddNpcCandidate(parent)
				end
			end
		end))
		NAlib.connect(NAStuff.NPC_SCAN_KEY, workspace.DescendantRemoving:Connect(function(inst)
			if inst:IsA("Model") then
				NAmanage.RemoveNpcCandidate(inst)
			elseif inst:IsA("Humanoid") then
				local parent = inst.Parent
				if parent and parent:IsA("Model") then
					NAmanage.RemoveNpcCandidate(parent)
				end
			end
		end))
	end
	NAmanage.ESP_StartGlobal()
end)

cmd.add({"unnpcesp","unespnpc"},{"unnpcesp (unespnpc)","stop locating npcs"},function()
	NPCESPenabled = false
	NAmanage.ESP_RecomputeEnabled()
	if NAlib.isConnected(NAStuff.NPC_SCAN_KEY) then
		NAlib.disconnect(NAStuff.NPC_SCAN_KEY)
	end
	NAmanage.ClearNpcTables()
	NAStuff.npcESPList = {}
	getgenv().npcESPList = NAStuff.npcESPList
	if not (ESPPlayersEnabled or chamsEnabled or NPCESPenabled) then
		NAmanage.ESP_StopGlobal()
	end
end)

cmd.add({"unesp","unchams"},{"unesp (unchams)","Disables esp/chams"},function()
	ESPPlayersEnabled = false
	NAmanage.ESP_RecomputeEnabled()
	chamsEnabled = false
	ESPAutoTrackAll = false
	NAmanage.ESP_ClearPlayers()
	if not (NPCESPenabled or chamsEnabled) then
		NAmanage.ESP_StopGlobal()
	end
end)

cmd.add({"unlocate"},{"unlocate <username1> <username2>"},function(...)
	for _, name in ipairs({...}) do
		for _, plr in ipairs(getPlr(name)) do
			NAmanage.ESP_Disconnect(plr)
		end
	end
end, true)

cmd.add({"crash"},{"crash","crashes ur client lol (why would you even use this tho)"},function()
	while true do end
end)

VVVVVVVVVVVCARRR = {}

cmd.add({"vehiclenoclip", "vnoclip"}, {"vehiclenoclip (vnoclip)", "Disables vehicle collision"}, function()
	VVVVVVVVVVVCARRR = {}

	local hum = getHum()
	if not hum then return DoNotif("no humanoid found",2) end
	local seat = hum and hum.SeatPart

	local model = seat.Parent
	while model and not model:IsA("Model") do
		model = model.Parent
	end

	Wait(0.1)
	cmd.run({"noclip"})

	for _, pp in ipairs(model:GetDescendants()) do
		if pp:IsA("BasePart") and pp.CanCollide then
			Insert(VVVVVVVVVVVCARRR, pp)
			pp.CanCollide = false
		end
	end
end)

cmd.add({"vehicleclip", "vclip", "unvnoclip", "unvehiclenoclip"}, {"vehicleclip (vclip, unvnoclip, unvehiclenoclip)", "Enables vehicle collision"}, function()
	cmd.run({"clip"})

	for _, pppp in ipairs(VVVVVVVVVVVCARRR) do
		if pppp and pppp:IsA("BasePart") then
			pppp.CanCollide = true
		end
	end

	VVVVVVVVVVVCARRR = {}
end)

cmd.add({"handlekill", "hkill"}, {"handlekill <player> (hkill)", "Kills a player using a tool that deals damage on touch"}, function(...)
	local LocalPlayer = Players.LocalPlayer

	if not firetouchinterest then
		return DoNotif('Your exploit does not support firetouchinterest to run this command')
	end

	local function zeTOOL()
		local character = LocalPlayer.Character
		if not character then return nil, nil end
		local tool = character:FindFirstChildWhichIsA("Tool")
		if not tool then return nil, nil end
		local handle = tool:FindFirstChild("Handle")
		return tool, handle
	end

	local Tool, Handle = zeTOOL()
	if not Tool or not Handle then
		return DoNotif('You need to hold a "Tool" that does damage on touch')
	end

	local username = ...
	local targets = getPlr(username)
	if #targets == 0 then
		return DoNotif("No target found",2)
	end

	for _, targetPlayer in ipairs(targets) do
		SpawnCall(function()
			while Tool and getPlrChar(LocalPlayer) and getPlrChar(targetPlayer) and Tool.Parent == LocalPlayer.Character do
				local humanoid = getPlrHum(targetPlayer)
				if not humanoid or humanoid.Health <= 0 then
					break
				end

				for _, part in ipairs(getPlrChar(targetPlayer):GetChildren()) do
					if part:IsA("BasePart") then
						firetouchinterest(Handle, part, 0)
						Wait()
						firetouchinterest(Handle, part, 1)
					end
				end

				RunService.Stepped:Wait()
			end
		end)
	end
end, true)

cmd.add({"creep"}, {"creep <player>", "Teleports from a player behind them and under the floor to the top"}, function(...)
	local username = ...
	local targets = getPlr(username)
	if #targets == 0 then
		DoNotif("No target found.", 3)
		return
	end

	local target = targets[1]
	local character = getChar()
	if not character then
		DoNotif("Your character is invalid.", 3)
		return
	end

	local root = getRoot(character)
	if not root then
		DoNotif("Your character's root is invalid.", 3)
		return
	end

	if not target.Character or not getPlrHum(target) or not getPlrHum(target).RootPart then
		DoNotif("Target's character is invalid.", 3)
		return
	end

	root.CFrame = getPlrHum(target).RootPart.CFrame * CFrame.new(0, -10, 4)
	Wait()

	if NAlib.isConnected("noclip") then
		NAlib.disconnect("noclip")
	end

	NAlib.connect("noclip", RunService.Stepped:Connect(function()
		local char = getChar()
		if not char then return end
		for _, part in ipairs(char:GetDescendants()) do
			if part:IsA("BasePart") then
				part.CanCollide = false
			end
		end
	end))
	Wait()

	root.Anchored = true
	Wait()

	local tweenService = TweenService
	local tweenInfo = TweenInfo.new(1000, Enum.EasingStyle.Linear)
	local tween = tweenService:Create(root, tweenInfo, {CFrame = CFrame.new(0, 10000, 0)})
	tween:Play()
	Wait(1.5)
	tween:Pause()

	root.Anchored = false
	Wait()

	NAlib.disconnect("noclip")
end, true)

cmd.add({"netless","net"},{"netless (net)","Executes netless which makes scripts more stable"},function()
	for i,v in next,getChar():GetDescendants() do
		if v:IsA("BasePart") and v.Name~="HumanoidRootPart" then
			RunService.Stepped:Connect(function()
				v.Velocity=Vector3.new(-30,0,0)
			end)
		end
	end

	Wait();

	DebugNotif("Netless has been activated,re-run this script if you die")
end)

cmd.add({"reset","die"},{"reset (die)","Makes your health be 0"},function()
	getHum():ChangeState(Enum.HumanoidStateType.Dead)
	getHum().Health=0
end)


-- ts got patched gg
NAStuff.desyncOn = NAStuff.desyncOn or false

cmd.addPatched({"desync", "ngrep"},{"desync (ngrep)","Toggle NextGenReplicator desync / sync (run again to disable)"},function()
	if type(setfflag) ~= "function" then
		DoNotif("Your executor does not support setfflag. Cannot toggle desync", 3)
		return
	end

	if not NAStuff.desyncOn then
		local ok, err = pcall(function()
			setfflag("NextGenReplicatorEnabledWrite4", "false")
			setfflag("NextGenReplicatorEnabledWrite4", "true")
		end)

		if ok then
			NAStuff.desyncOn = true
			DoNotif("NextGenReplicator desync / server authority enabled. Run the command again to disable it", 4)
		else
			DoNotif("Failed to apply NextGenReplicator flags: "..tostring(err), 4)
		end
	else
		local ok, err = pcall(function()
			setfflag("NextGenReplicatorEnabledWrite4", "true")
			setfflag("NextGenReplicatorEnabledWrite4", "false")
		end)

		if ok then
			NAStuff.desyncOn = false
			DoNotif("NextGenReplicator sync restored (desync disabled)", 3)
		else
			DoNotif("Failed to restore NextGenReplicator flags: "..tostring(err), 4)
		end
	end
end)

cmd.add({"runanim", "playanim", "anim"}, {"runanim <id> [speed] (playanim,anim)", "Plays an animation by ID with optional speed multiplier"}, function(id, speed)
	local hum = getHum()
	if not hum then return end
	id = tostring(id)
	speed = tonumber(speed) or 1
	local animator = hum:FindFirstChildOfClass("Animator") or InstanceNew("Animator", hum)
	local anim = InstanceNew("Animation")
	anim.AnimationId = "rbxassetid://"..id
	local track = animator:LoadAnimation(anim)
	track:Play()
	track:AdjustSpeed(speed)
	Delay(track.Length / speed, function()
		track:Stop()
		track:Destroy()
		anim:Destroy()
	end)
end, true)

NAStuff.storedAnims = {}
builderAnim = nil

cmd.add({"animbuilder","abuilder"},{"animbuilder (abuilder)","Opens animation builder GUI"},function()
	if builderAnim then NACaller(function() builderAnim:Destroy() end) builderAnim = nil end
	local p = Players.LocalPlayer

	local function getData()
		local hum = getHum()
		if not hum then return end
		local animate = hum.Parent:FindFirstChild("Animate")
		if not animate then return end
		return hum, animate
	end

	local uid = p.UserId
	if not NAStuff.storedAnims[uid] then
		local _, animate0 = getData()
		if not animate0 then return end
		local store = {}
		for _, v in pairs(animate0:GetChildren()) do
			if v:IsA("StringValue") then
				local a = v:FindFirstChildWhichIsA("Animation")
				if a then store[v.Name:lower()] = a.AnimationId end
			end
		end
		NAStuff.storedAnims[uid] = store
	end

	builderAnim = InstanceNew("ScreenGui")
	NaProtectUI(builderAnim)
	builderAnim.Name = "AnimationBuilder"

	local main = InstanceNew("Frame", builderAnim)
	main.Size = UDim2.new(0.46,0,0.56,0)
	main.Position = UDim2.new(0.27,0,0.22,0)
	main.BackgroundColor3 = Color3.fromRGB(28,28,32)
	main.BackgroundTransparency = 0.08
	main.BorderSizePixel = 0
	main.ClipsDescendants = true
	InstanceNew("UICorner", main).CornerRadius = UDim.new(0, 14)
	local mainStroke = InstanceNew("UIStroke", main)
	mainStroke.Color = Color3.fromRGB(60,60,65)
	mainStroke.Thickness = 1
	mainStroke.Transparency = 0.2

	local headerH = 56
	local header = InstanceNew("Frame", main)
	header.Size = UDim2.new(1,0,0,headerH)
	header.BackgroundColor3 = Color3.fromRGB(24,24,26)
	header.BackgroundTransparency = 0.12
	InstanceNew("UICorner", header).CornerRadius = UDim.new(0, 14)
	local headerPad = InstanceNew("UIPadding", header)
	headerPad.PaddingLeft = UDim.new(0, 10)
	headerPad.PaddingRight = UDim.new(0, 10)

	local row = InstanceNew("Frame", header)
	row.BackgroundTransparency = 1
	row.Size = UDim2.new(1,0,1,0)
	local rowLayout = InstanceNew("UIListLayout", row)
	rowLayout.FillDirection = Enum.FillDirection.Horizontal
	rowLayout.HorizontalAlignment = Enum.HorizontalAlignment.Left
	rowLayout.VerticalAlignment = Enum.VerticalAlignment.Center
	rowLayout.Padding = UDim.new(0,8)

	local title = InstanceNew("TextLabel", row)
	title.Size = UDim2.new(0.8, 0, 1, 0)
	title.BackgroundTransparency = 1
	title.Text = "Animation Builder"
	title.TextColor3 = Color3.fromRGB(240,240,240)
	title.Font = Enum.Font.GothamBold
	title.TextScaled = true
	do local ts = InstanceNew("UITextSizeConstraint", title) ts.MinTextSize = 12 ts.MaxTextSize = 20 end
	title.TextXAlignment = Enum.TextXAlignment.Left

	local closeBtn = InstanceNew("TextButton", row)
	closeBtn.Size = UDim2.new(0.2, 0, 0.82, 0)
	closeBtn.BackgroundTransparency = 1
	closeBtn.Text = "X"
	closeBtn.TextColor3 = Color3.fromRGB(255, 90, 90)
	closeBtn.Font = Enum.Font.Gotham
	closeBtn.TextScaled = true
	do local ts = InstanceNew("UITextSizeConstraint", closeBtn) ts.MinTextSize = 12 ts.MaxTextSize = 22 end

	local body = InstanceNew("Frame", main)
	body.BackgroundTransparency = 1
	body.Size = UDim2.new(1,0,1,-headerH-58)
	body.Position = UDim2.new(0,0,0,headerH)

	local scroll = InstanceNew("ScrollingFrame", body)
	scroll.Size = UDim2.new(1,0,1,0)
	scroll.BackgroundTransparency = 1
	scroll.ScrollBarThickness = 6
	scroll.AutomaticCanvasSize = Enum.AutomaticSize.Y
	scroll.CanvasSize = UDim2.new(0,0,0,0)
	local pad = InstanceNew("UIPadding", scroll)
	pad.PaddingLeft = UDim.new(0,10)
	pad.PaddingRight = UDim.new(0,10)
	pad.PaddingTop = UDim.new(0,10)
	pad.PaddingBottom = UDim.new(0,10)
	local list = InstanceNew("UIListLayout", scroll)
	list.Padding = UDim.new(0, 8)
	list.SortOrder = Enum.SortOrder.LayoutOrder

	local footer = InstanceNew("Frame", main)
	footer.Size = UDim2.new(1,0,0,50)
	footer.Position = UDim2.new(0,0,1,-50)
	footer.BackgroundTransparency = 1
	local footerPad = InstanceNew("UIPadding", footer)
	footerPad.PaddingLeft = UDim.new(0,10)
	footerPad.PaddingRight = UDim.new(0,10)
	footerPad.PaddingBottom = UDim.new(0,8)
	local footerRow = InstanceNew("Frame", footer)
	footerRow.BackgroundTransparency = 1
	footerRow.Size = UDim2.new(1,0,1,0)
	local fl = InstanceNew("UIListLayout", footerRow)
	fl.FillDirection = Enum.FillDirection.Horizontal
	fl.HorizontalAlignment = Enum.HorizontalAlignment.Center
	fl.VerticalAlignment = Enum.VerticalAlignment.Center
	fl.Padding = UDim.new(0,10)

	local save = InstanceNew("TextButton", footerRow)
	save.Size = UDim2.new(0.48,0,1,0)
	save.BackgroundColor3 = Color3.fromRGB(60,140,80)
	save.BackgroundTransparency = 0.1
	save.Text = "💾 Save"
	save.TextColor3 = Color3.new(1,1,1)
	save.Font = Enum.Font.GothamSemibold
	save.TextScaled = true
	do InstanceNew("UICorner", save).CornerRadius = UDim.new(0,10) end
	do local ts = InstanceNew("UITextSizeConstraint", save) ts.MinTextSize = 12 ts.MaxTextSize = 20 end

	local revert = InstanceNew("TextButton", footerRow)
	revert.Size = UDim2.new(0.48,0,1,0)
	revert.BackgroundColor3 = Color3.fromRGB(160,80,80)
	revert.BackgroundTransparency = 0.1
	revert.Text = "↩️ Revert"
	revert.TextColor3 = Color3.new(1,1,1)
	revert.Font = Enum.Font.GothamSemibold
	revert.TextScaled = true
	do InstanceNew("UICorner", revert).CornerRadius = UDim.new(0,10) end
	do local ts = InstanceNew("UITextSizeConstraint", revert) ts.MinTextSize = 12 ts.MaxTextSize = 20 end

	local states = {"Idle","Walk","Run","Jump","Fall","Climb","Swim","Sit"}
	local inputs = {}

	local function makeRow(name)
		local r = InstanceNew("Frame", scroll)
		r.Size = UDim2.new(1,0,0,54)
		r.BackgroundColor3 = Color3.fromRGB(36,36,40)
		r.BackgroundTransparency = 0.12
		InstanceNew("UICorner", r).CornerRadius = UDim.new(0,10)
		local rs = InstanceNew("UIStroke", r)
		rs.Color = Color3.fromRGB(60,60,65)
		rs.Thickness = 1
		rs.Transparency = 0.2

		local inner = InstanceNew("Frame", r)
		inner.BackgroundTransparency = 1
		inner.Size = UDim2.new(1,-16,1,-12)
		inner.Position = UDim2.new(0,8,0,6)

		local hl = InstanceNew("UIListLayout", inner)
		hl.FillDirection = Enum.FillDirection.Horizontal
		hl.HorizontalAlignment = Enum.HorizontalAlignment.Left
		hl.VerticalAlignment = Enum.VerticalAlignment.Center
		hl.Padding = UDim.new(0,8)

		local label = InstanceNew("TextLabel", inner)
		label.Size = UDim2.new(0.28,0,1,0)
		label.BackgroundTransparency = 1
		label.Text = name
		label.TextColor3 = Color3.new(1,1,1)
		label.Font = Enum.Font.GothamSemibold
		label.TextXAlignment = Enum.TextXAlignment.Left
		label.TextScaled = true
		do local ts = InstanceNew("UITextSizeConstraint", label) ts.MinTextSize = 12 ts.MaxTextSize = 18 end

		local boxHolder = InstanceNew("Frame", inner)
		boxHolder.Size = UDim2.new(0.72,0,1,0)
		boxHolder.BackgroundTransparency = 1

		local box = InstanceNew("TextBox", boxHolder)
		box.AnchorPoint = Vector2.new(0.5,0.5)
		box.Position = UDim2.new(0.5,0,0.5,0)
		box.Size = UDim2.new(1,0,1,0)
		box.Text = ""
		box.PlaceholderText = "rbxassetid (numbers only)"
		box.ClearTextOnFocus = false
		box.TextColor3 = Color3.new(1,1,1)
		box.BackgroundColor3 = Color3.fromRGB(50,50,55)
		box.BackgroundTransparency = 0.15
		box.Font = Enum.Font.Gotham
		box.TextScaled = true
		do InstanceNew("UICorner", box).CornerRadius = UDim.new(0,8) end
		do local ts = InstanceNew("UITextSizeConstraint", box) ts.MinTextSize = 11 ts.MaxTextSize = 18 end

		box:GetPropertyChangedSignal("Text"):Connect(function()
			local clean = box.Text:gsub("%D","")
			if box.Text ~= clean then box.Text = clean end
		end)

		inputs[Lower(name)] = box
	end

	for _, n in ipairs(states) do makeRow(n) end

	local function applyAnims(mode)
		local _, animate = getData()
		if not animate then DoNotif("No Animate object found") return end
		for _, k in ipairs(states) do
			local key = Lower(k)
			local sv = animate:FindFirstChild(key)
			if sv and sv:IsA("StringValue") then
				local anim = sv:FindFirstChildWhichIsA("Animation")
				if anim then
					if mode == "save" then
						local id = tonumber(inputs[key].Text)
						if id then
							anim.AnimationId = "rbxassetid://"..id
						end
					else
						local raw = NAStuff.storedAnims[uid] and NAStuff.storedAnims[uid][key]
						if raw then
							anim.AnimationId = raw
							local num = raw:match("%d+")
							if num then inputs[key].Text = num end
						end
					end
				end
			end
		end
		if mode == "save" then DoNotif("Saved animations") else DoNotif("Reverted animations") end
	end

	local function prefill()
		for _, k in ipairs(states) do
			local key = Lower(k)
			local raw = NAStuff.storedAnims[uid] and NAStuff.storedAnims[uid][key]
			if raw then
				local num = raw:match("%d+")
				if num then inputs[key].Text = num end
			else
				inputs[key].Text = ""
			end
		end
	end
	prefill()

	MouseButtonFix(closeBtn, function()
		local t = TweenService:Create(main, TweenInfo.new(0.25, Enum.EasingStyle.Quint, Enum.EasingDirection.InOut), {
			Size = UDim2.new(0.02,0,0.02,0),
			Position = UDim2.new(0.99,0,0.01,0)
		})
		t:Play(); t.Completed:Wait()
		NACaller(function() builderAnim:Destroy() end)
		builderAnim = nil
	end)

	MouseButtonFix(save, function() applyAnims("save") end)
	MouseButtonFix(revert, function() applyAnims("revert") end)

	NAgui.dragger(main, header)
end)

cmd.add({"setkiller", "killeranim"}, {"setkiller (killeranim)", "Sets killer animation set"}, function()
	if not IsR6() then DoNotif("command requires R6") return end
	local hum = getHum()
	if not hum then return end

	local animate = hum.Parent:FindFirstChild("Animate")
	if not animate then return end

	if not NAStuff.storedAnims[hum] then
		local store = {}
		for _, obj in pairs(animate:GetChildren()) do
			if obj:IsA("StringValue") then
				local anim = obj:FindFirstChildWhichIsA("Animation")
				if anim then
					store[obj.Name] = anim.AnimationId
				end
			end
		end
		NAStuff.storedAnims[hum] = store
	end

	local function setAnim(name, id)
		local obj = animate:FindFirstChild(name)
		if obj and obj:IsA("StringValue") then
			local anim = obj:FindFirstChildWhichIsA("Animation")
			if anim then
				anim.AnimationId = "rbxassetid://"..tostring(id)
			end
		end
	end

	setAnim("walk", 252557606)
	setAnim("run", 252557606)
	setAnim("jump", 165167557)
	setAnim("fall", 97170520)
end)

cmd.add({"setpsycho", "psychoanim"}, {"setpsycho (psychoanim)", "Sets psycho animation set"}, function()
	if not IsR6() then DoNotif("command requires R6") return end
	local hum = getHum()
	if not hum then return end

	local animate = hum.Parent:FindFirstChild("Animate")
	if not animate then return end

	if not NAStuff.storedAnims[hum] then
		local store = {}
		for _, obj in pairs(animate:GetChildren()) do
			if obj:IsA("StringValue") then
				local anim = obj:FindFirstChildWhichIsA("Animation")
				if anim then
					store[obj.Name] = anim.AnimationId
				end
			end
		end
		NAStuff.storedAnims[hum] = store
	end

	local function setAnim(name, id)
		local obj = animate:FindFirstChild(name)
		if obj and obj:IsA("StringValue") then
			local anim = obj:FindFirstChildWhichIsA("Animation")
			if anim then
				anim.AnimationId = "rbxassetid://"..tostring(id)
			end
		end
	end

	setAnim("idle", 33796059)
	setAnim("walk", 95415492)
	setAnim("run", 95415492)
	setAnim("jump", 165167557)
	setAnim("fall", 97170520)

	local animator = hum:FindFirstChildOfClass("Animator")
	if not animator then return end

	SpawnCall(function()
		while hum and hum.Parent and hum.Health > 0 do
			for _, track in pairs(animator:GetPlayingAnimationTracks()) do
				if track.Animation.AnimationId == "rbxassetid://33796059" and track.Speed < 50 then
					track:AdjustSpeed(50)
				end
			end
			Wait(0.2)
		end
	end)
end)

cmd.add({"resetanims", "defaultanims", "animsreset"}, {"resetanims (defaultanims,animsreset)", "Restores your previous animations"}, function()
	if not IsR6() then DoNotif("command requires R6") return end
	local hum = getHum()
	if not hum then return end

	local animate = hum.Parent:FindFirstChild("Animate")
	if not animate then return end

	local store = NAStuff.storedAnims[hum]
	if not store then return end

	for name, id in pairs(store) do
		local obj = animate:FindFirstChild(name)
		if obj and obj:IsA("StringValue") then
			local anim = obj:FindFirstChildWhichIsA("Animation")
			if anim then
				anim.AnimationId = id
			end
		end
	end

	NAStuff.storedAnims[hum] = nil
end)

cmd.add({"animcopycore","animcopy","copyanim","copyan"}, {"animcopycore <target>","Copy core animations from target"}, function(targetArg)
	if not targetArg or targetArg == "" then return end
	local targets = getPlr(targetArg)
	local target = targets and targets[1]
	if not target then return end
	local myChar = getChar()
	local targetChar = getPlrChar(target)
	if not (myChar and targetChar) then return end
	local myHum = getPlrHum(myChar)
	local targetHum = getPlrHum(targetChar)
	if not (myHum and targetHum) then return end
	local myAnimate = myChar:FindFirstChild("Animate")
	local targetAnimate = targetChar:FindFirstChild("Animate")
	if not (myAnimate and targetAnimate) then return end
	local function mapAnims(root)
		local t = {}
		for _, inst in ipairs(root:GetDescendants()) do
			if inst:IsA("Animation") then
				local k = Lower(((inst.Parent and inst.Parent.Name) or "root").."|"..inst.Name)
				t[k] = inst
			end
		end
		return t
	end
	local function refresh(hum)
		local char = hum and hum.Parent
		local animScr = char and char:FindFirstChild("Animate")
		if animScr and NAlib.isProperty(animScr, "Disabled") ~= nil then
			animScr.Disabled = true
			animScr.Disabled = false
		else
			pcall(function() hum:ChangeState(Enum.HumanoidStateType.Jumping) end)
		end
	end
	local function captureDefaults()
		if NAStuff.SavedDefaultMap then return end
		if not myAnimate then return end
		NAStuff.SavedDefaultMap = {}
		for _, a in ipairs(myAnimate:GetDescendants()) do
			if a:IsA("Animation") then
				local parentName = Lower((a.Parent and a.Parent.Name) or "root")
				if NAStuff.CORE_FOLDERS[parentName] then
					local key = Lower(parentName.."|"..a.Name)
					NAStuff.SavedDefaultMap[key] = a.AnimationId
				end
			end
		end
	end
	captureDefaults()
	local src = mapAnims(targetAnimate)
	local dst = mapAnims(myAnimate)
	for key, dstAnim in pairs(dst) do
		local folder = Match(key, "([^|]+)|")
		if NAStuff.CORE_FOLDERS[folder or ""] then
			local srcAnim = src[key]
			if srcAnim and srcAnim.AnimationId ~= "" and dstAnim.AnimationId ~= srcAnim.AnimationId then
				dstAnim.AnimationId = srcAnim.AnimationId
			end
		end
	end
	refresh(myHum)
end)

cmd.add({"syncanim","animsync"}, {"syncanim <target>","Mirror target animations (live)"}, function(targetArg)
	if not targetArg or targetArg == "" then return end
	local targets = getPlr(targetArg)
	local target = targets and targets[1]
	if not target then return end

	local myChar = getChar()
	local targetChar = getPlrChar(target)
	if not (myChar and targetChar) then return end

	local myHum = getPlrHum(myChar)
	local targetHum = getPlrHum(targetChar)
	if not (myHum and targetHum) then return end
	if myHum.RigType ~= targetHum.RigType then return end

	local function getAnimator(hum, create)
		if not hum then return nil end
		local a = hum:FindFirstChildOfClass("Animator")
		if a then return a end
		if create then return InstanceNew("Animator", hum) end
	end

	local myAnimator = getAnimator(myHum, true)
	local targetAnimator = getAnimator(targetHum, false)
	if not targetAnimator then return end

	NAlib.disconnect(NAStuff.SYNC_TAG)

	local myAnimate = myChar:FindFirstChild("Animate")
	if myAnimate and NAlib.isProperty(myAnimate, "Disabled") ~= nil then
		NAStuff.Sync_AnimatePrevDisabled = myAnimate.Disabled
		myAnimate.Disabled = true
	end

	for _, tr in ipairs(myAnimator:GetPlayingAnimationTracks()) do pcall(function() tr:Stop(0) end) end

	local active = {}
	local inverse = {}
	local stopped = false

	local function reactivateDefaults()
		local anim = myChar and myChar:FindFirstChild("Animate")
		if anim and NAlib.isProperty(anim, "Disabled") ~= nil then
			anim.Disabled = false
			anim.Disabled = true
			anim.Disabled = false
		end
		pcall(function() myHum:ChangeState(Enum.HumanoidStateType.Jumping) end)
	end

	local function stopAndRestore()
		if stopped then return end
		stopped = true
		for _, tr in ipairs(myAnimator:GetPlayingAnimationTracks()) do pcall(function() tr:Stop(0) end) end
		if myAnimate and NAlib.isProperty(myAnimate, "Disabled") ~= nil then
			myAnimate.Disabled = false
		end
		reactivateDefaults()
		NAStuff.Sync_AnimatePrevDisabled = nil
		NAlib.disconnect(NAStuff.SYNC_TAG)
	end

	local function allowOnlyMirrored()
		table.clear(inverse)
		for _, mt in pairs(active) do inverse[mt] = true end
		for _, tr in ipairs(myAnimator:GetPlayingAnimationTracks()) do
			if not inverse[tr] then pcall(function() tr:Stop(0) end) end
		end
		if myAnimate and NAlib.isProperty(myAnimate, "Disabled") ~= nil and not myAnimate.Disabled then
			myAnimate.Disabled = true
		end
	end

	local function mirrorTrack(tTrack)
		if not tTrack or not tTrack.Animation or tTrack.Animation.AnimationId == "" then return end
		local mt = active[tTrack]
		if mt and mt.IsPlaying then return end
		for _, tr in ipairs(myAnimator:GetPlayingAnimationTracks()) do pcall(function() tr:Stop(0) end) end
		local animClone = InstanceNew("Animation")
		animClone.AnimationId = tTrack.Animation.AnimationId
		mt = myAnimator:LoadAnimation(animClone)
		active[tTrack] = mt
		pcall(function()
			mt.Looped = tTrack.Looped
			mt:Play(0, 1, (type(tTrack.Speed)=="number" and tTrack.Speed) or 1)
			pcall(function() mt.TimePosition = tTrack.TimePosition end)
			mt:AdjustWeight(1)
		end)
		NAlib.connect(NAStuff.SYNC_TAG, tTrack.Stopped:Connect(function()
			local mine = active[tTrack]
			if mine then pcall(function() mine:Stop(0) end) active[tTrack] = nil end
		end))
	end

	for _, tTrack in ipairs(targetAnimator:GetPlayingAnimationTracks()) do
		mirrorTrack(tTrack)
	end
	allowOnlyMirrored()

	NAlib.connect(NAStuff.SYNC_TAG, targetHum.AnimationPlayed:Connect(function(tTrack)
		mirrorTrack(tTrack)
		allowOnlyMirrored()
	end))

	NAlib.connect(NAStuff.SYNC_TAG, RunService.Heartbeat:Connect(function()
		if stopped then return end
		allowOnlyMirrored()
		for tTrack, myTrack in pairs(active) do
			if not tTrack or not myTrack then
				active[tTrack] = nil
			else
				if not tTrack.IsPlaying then
					pcall(function() myTrack:Stop(0) end)
					active[tTrack] = nil
				else
					pcall(function()
						if type(tTrack.Speed) == "number" then myTrack:AdjustSpeed(tTrack.Speed) end
						if math.abs(myTrack.TimePosition - tTrack.TimePosition) > 0.15 then
							myTrack.TimePosition = tTrack.TimePosition
						end
						if myTrack.Looped ~= tTrack.Looped then myTrack.Looped = tTrack.Looped end
						myTrack:AdjustWeight(1)
					end)
				end
			end
		end
	end))

	NAlib.connect(NAStuff.SYNC_TAG, myChar.AncestryChanged:Connect(function() stopAndRestore() end))
	NAlib.connect(NAStuff.SYNC_TAG, targetChar.AncestryChanged:Connect(function() stopAndRestore() end))

	if typeof(target) == "Instance" and target:IsA("Player") then
		NAlib.connect(NAStuff.SYNC_TAG, Players.PlayerRemoving:Connect(function(plr)
			if plr == target then
				stopAndRestore()
			end
		end))
	end
end)

cmd.add({"syncstop","stopsync","syncend","endsync","syncoff"}, {"syncstop","Stop live sync and restore defaults"}, function()
	NAlib.disconnect(NAStuff.SYNC_TAG)
	local myChar = getChar()
	local myHum = getPlrHum(myChar)
	if myHum then
		local myAnimator = myHum:FindFirstChildOfClass("Animator")
		if myAnimator then
			for _, tr in ipairs(myAnimator:GetPlayingAnimationTracks()) do pcall(function() tr:Stop(0) end) end
		end
	end
	local myAnimate = myChar and myChar:FindFirstChild("Animate")
	if myAnimate and NAlib.isProperty(myAnimate, "Disabled") ~= nil then
		myAnimate.Disabled = false
		myAnimate.Disabled = true
		myAnimate.Disabled = false
	end
	NAStuff.Sync_AnimatePrevDisabled = nil
	pcall(function() myHum:ChangeState(Enum.HumanoidStateType.Jumping) end)
end)

cmd.add({"animresetcore","animreset","resetanim","resetan"}, {"animresetcore","Reset core animations to saved"}, function()
	local myChar = getChar()
	local myHum = getPlrHum(myChar)
	local myAnimate = myChar and myChar:FindFirstChild("Animate")
	if not (myHum and myAnimate and NAStuff.SavedDefaultMap) then return end
	local function mapAnims(root)
		local t = {}
		for _, inst in ipairs(root:GetDescendants()) do
			if inst:IsA("Animation") then
				local k = Lower(((inst.Parent and inst.Parent.Name) or "root").."|"..inst.Name)
				t[k] = inst
			end
		end
		return t
	end
	local function refresh(hum)
		local char = hum and hum.Parent
		local animScr = char and char:FindFirstChild("Animate")
		if animScr and NAlib.isProperty(animScr, "Disabled") ~= nil then
			animScr.Disabled = true
			animScr.Disabled = false
		else
			pcall(function() hum:ChangeState(Enum.HumanoidStateType.Jumping) end)
		end
	end
	local dst = mapAnims(myAnimate)
	for key, id in pairs(NAStuff.SavedDefaultMap) do
		local dstAnim = dst[key]
		if dstAnim and dstAnim.AnimationId ~= id then
			dstAnim.AnimationId = id
		end
	end
	refresh(myHum)
end)

cmd.add({"unsyncreset","unsync","unsres","unsr"}, {"unsyncreset","Stop sync and reset saved"}, function()
	NAlib.disconnect(NAStuff.SYNC_TAG)
	local myChar = getChar()
	local myHum = getPlrHum(myChar)
	if myHum then
		local myAnimator = myHum:FindFirstChildOfClass("Animator")
		if myAnimator then
			for _, tr in ipairs(myAnimator:GetPlayingAnimationTracks()) do pcall(function() tr:Stop(0) end) end
		end
	end
	local myAnimate = myChar and myChar:FindFirstChild("Animate")
	if myAnimate and NAlib.isProperty(myAnimate, "Disabled") ~= nil then
		if NAStuff.Sync_AnimatePrevDisabled ~= nil then
			myAnimate.Disabled = NAStuff.Sync_AnimatePrevDisabled
		else
			myAnimate.Disabled = false
		end
		NAStuff.Sync_AnimatePrevDisabled = nil
	end
	if not (myHum and myAnimate and NAStuff.SavedDefaultMap) then return end
	local function mapAnims(root)
		local t = {}
		for _, inst in ipairs(root:GetDescendants()) do
			if inst:IsA("Animation") then
				local k = Lower(((inst.Parent and inst.Parent.Name) or "root").."|"..inst.Name)
				t[k] = inst
			end
		end
		return t
	end
	local function refresh(hum)
		local char = hum and hum.Parent
		local animScr = char and char:FindFirstChild("Animate")
		if animScr and NAlib.isProperty(animScr, "Disabled") ~= nil then
			animScr.Disabled = true
			animScr.Disabled = false
		else
			pcall(function() hum:ChangeState(Enum.HumanoidStateType.Jumping) end)
		end
	end
	local dst = mapAnims(myAnimate)
	for key, id in pairs(NAStuff.SavedDefaultMap) do
		local dstAnim = dst[key]
		if dstAnim and dstAnim.AnimationId ~= id then
			dstAnim.AnimationId = id
		end
	end
	refresh(myHum)
end)

cmd.add({"mimic","mirror","mclone","mcopy","mimi"}, {"mimic <target> [delay]","Clone target movement with optional delay"}, function(targetArg, delayArg)
	if not targetArg or targetArg == "" then return end
	local delay = tonumber(delayArg) or 0
	if delay < 0 then delay = 0 end

	local targets = getPlr(targetArg)
	local target = targets and targets[1]
	if not target then return end

	local myChar = getChar()
	local targetChar = getPlrChar(target)
	if not (myChar and targetChar) then return end

	local myHum = getPlrHum(myChar)
	local targetHum = getPlrHum(targetChar)
	if not (myHum and targetHum) then return end
	if myHum.RigType ~= targetHum.RigType then return end

	NAlib.disconnect(NAStuff.MIMIC_TAG)

	local myAnimator = myHum:FindFirstChildOfClass("Animator") or InstanceNew("Animator", myHum)
	for _, tr in ipairs(myAnimator:GetPlayingAnimationTracks()) do pcall(function() tr:Stop(0) end) end

	local myAnimate = myChar:FindFirstChild("Animate")
	if myAnimate and NAlib.isProperty(myAnimate, "Disabled") ~= nil then
		NAStuff.Mimic_AnimatePrevDisabled = myAnimate.Disabled
		myAnimate.Disabled = true
	end

	local targetAnimator = targetHum:FindFirstChildOfClass("Animator")
	if not targetAnimator then return end

	local myRoot = getRoot(myChar)
	local targetRoot = getRoot(targetChar)
	if not (myRoot and targetRoot) then return end

	local prevAutoRotate = myHum.AutoRotate
	myHum.AutoRotate = false

	local function now() return os.clock() end

	local events, evHead = {}, 1
	local slots = {}
	local inverse = {}

	local function addEvent(e) events[#events+1] = e end
	local function newId() NAStuff.mimic_uid += 1 return NAStuff.mimic_uid end

	local function stopAndRestore()
		for _, s in pairs(slots) do
			if s.mt then pcall(function() s.mt:Stop(0) end) end
		end
		for _, tr in ipairs(myAnimator:GetPlayingAnimationTracks()) do pcall(function() tr:Stop(0) end) end
		myHum.AutoRotate = prevAutoRotate
		local a = myChar and myChar:FindFirstChild("Animate")
		if a and NAlib.isProperty(a, "Disabled") ~= nil then
			if NAStuff.Mimic_AnimatePrevDisabled ~= nil then a.Disabled = NAStuff.Mimic_AnimatePrevDisabled else a.Disabled = false end
			a.Disabled = true; a.Disabled = false
		end
		NAStuff.Mimic_AnimatePrevDisabled = nil
		events, evHead, slots = {}, 1, {}
		table.clear(inverse)
		NAlib.disconnect(NAStuff.MIMIC_TAG)
	end

	local function allowOnlyMirrored()
		table.clear(inverse)
		for _, s in pairs(slots) do if s.alive and s.mt and s.mt.IsPlaying then inverse[s.mt] = true end end
		for _, tr in ipairs(myAnimator:GetPlayingAnimationTracks()) do
			if not inverse[tr] then pcall(function() tr:Stop(0) end) end
		end
		if myAnimate and NAlib.isProperty(myAnimate, "Disabled") ~= nil and not myAnimate.Disabled then
			myAnimate.Disabled = true
		end
	end

	local function scheduleTrackStart(tt, tStamp)
		if not tt or not tt.Animation or tt.Animation.AnimationId == "" then return end
		local spd = (type(tt.Speed) == "number" and tt.Speed) or 1
		local baseTP = tt.TimePosition or 0
		addEvent({t = tStamp + delay, kind = "start", track = tt, animId = tt.Animation.AnimationId, speed = spd, baseTP = baseTP, looped = tt.Looped})
		NAlib.connect(NAStuff.MIMIC_TAG, tt:GetPropertyChangedSignal("Speed"):Connect(function()
			local s = (type(tt.Speed) == "number" and tt.Speed) or 1
			addEvent({t = now() + delay, kind = "speed", track = tt, speed = s})
		end))
		NAlib.connect(NAStuff.MIMIC_TAG, tt.Stopped:Connect(function()
			addEvent({t = now() + delay, kind = "stop", track = tt})
		end))
	end

	if delay == 0 then
		for _, tt in ipairs(targetAnimator:GetPlayingAnimationTracks()) do
			scheduleTrackStart(tt, now())
		end
	else
		for _, tt in ipairs(targetAnimator:GetPlayingAnimationTracks()) do
			local spd = (type(tt.Speed) == "number" and tt.Speed) or 1
			local inferredStart = now() - (tt.TimePosition or 0)/math.max(spd, 1e-6)
			addEvent({t = inferredStart + delay, kind = "start", track = tt, animId = tt.Animation.AnimationId, speed = spd, baseTP = 0, looped = tt.Looped})
			NAlib.connect(NAStuff.MIMIC_TAG, tt:GetPropertyChangedSignal("Speed"):Connect(function()
				local s = (type(tt.Speed) == "number" and tt.Speed) or 1
				addEvent({t = now() + delay, kind = "speed", track = tt, speed = s})
			end))
			NAlib.connect(NAStuff.MIMIC_TAG, tt.Stopped:Connect(function()
				addEvent({t = now() + delay, kind = "stop", track = tt})
			end))
		end
	end

	NAlib.connect(NAStuff.MIMIC_TAG, targetHum.AnimationPlayed:Connect(function(tt)
		scheduleTrackStart(tt, now())
	end))

	NAlib.connect(NAStuff.MIMIC_TAG, targetChar.ChildAdded:Connect(function(child)
		if child:IsA("Tool") then
			local bp = getBp()
			if bp then
				local match = bp:FindFirstChild(child.Name)
				if match and match:IsA("Tool") then pcall(function() myHum:EquipTool(match) end) end
			end
		end
	end))
	NAlib.connect(NAStuff.MIMIC_TAG, targetChar.ChildRemoved:Connect(function(child)
		if child:IsA("Tool") then pcall(function() myHum:UnequipTools() end) end
	end))

	local poseQ, poseHead = {}, 1
	local lastLook = Vector3.new(0,0,-1)

	NAlib.connect(NAStuff.MIMIC_TAG, RunService.Heartbeat:Connect(function()
		if not (targetChar and targetChar.Parent and targetRoot and targetRoot.Parent) then stopAndRestore() return end
		if not (myChar and myChar.Parent and myRoot and myRoot.Parent) then stopAndRestore() return end

		local lv = targetRoot.CFrame.LookVector
		local flat = Vector3.new(lv.X, 0, lv.Z)
		if flat.Magnitude >= 1e-4 then lastLook = flat.Unit end
		Insert(poseQ, {t = now(), pos = targetRoot.Position, look = lastLook, vel = targetRoot.AssemblyLinearVelocity, angY = targetRoot.AssemblyAngularVelocity.Y})
		local cutoff = now() - delay
		local snap
		while poseHead <= #poseQ and poseQ[poseHead].t <= cutoff do snap = poseQ[poseHead]; poseHead += 1 end
		if snap then
			local cf = CFrame.lookAt(snap.pos, snap.pos + snap.look)
			pcall(function()
				myRoot.CFrame = cf
				myRoot.AssemblyLinearVelocity = snap.vel
				myRoot.AssemblyAngularVelocity = Vector3.new(0, snap.angY, 0)
			end)
			if poseHead > 64 then
				local newBuf = {}
				for i = poseHead, #poseQ do newBuf[#newBuf+1] = poseQ[i] end
				poseQ, poseHead = newBuf, 1
			end
		end

		while evHead <= #events and events[evHead].t <= now() do
			local e = events[evHead]; evHead += 1
			if e.kind == "start" then
				if e.animId and e.animId ~= "" then
					local id = newId()
					local a = InstanceNew("Animation"); a.AnimationId = e.animId
					local mt = myAnimator:LoadAnimation(a)
					pcall(function() mt:Play(0, 1, 1) end)
					pcall(function() mt:AdjustSpeed(0) end)
					pcall(function() mt.TimePosition = e.baseTP or 0 end)
					slots[id] = {
						mt = mt,
						looped = e.looped and true or false,
						len = mt.Length or 0,
						baseTP = e.baseTP or 0,
						startLocal = e.t,
						segments = { {t = e.t, speed = e.speed or 1} },
						track = e.track,
						alive = true,
					}
				end
			elseif e.kind == "speed" then
				for _, s in pairs(slots) do
					if s.alive and s.track == e.track then
						Insert(s.segments, {t = e.t, speed = e.speed or 1})
					end
				end
			elseif e.kind == "stop" then
				for id, s in pairs(slots) do
					if s.alive and s.track == e.track then
						if s.mt then pcall(function() s.mt:Stop(0) end) end
						s.alive = false
						slots[id] = nil
					end
				end
			end
		end
		if evHead > 128 then
			local ne = {}
			for i = evHead, #events do ne[#ne+1] = events[i] end
			events, evHead = ne, 1
		end

		for id, s in pairs(slots) do
			if not s.alive or not s.mt then slots[id] = nil
			else
				if s.len == 0 then s.len = s.mt.Length or 0 end
				local tnow = now()
				local tp = s.baseTP
				for i = 1, #s.segments do
					local st = s.segments[i].t
					local sp = s.segments[i].speed or 1
					local en = (i < #s.segments) and s.segments[i+1].t or tnow
					if en > st then tp = tp + (en - st) * sp end
				end
				if s.looped and s.len and s.len > 0 then
					tp = tp % s.len
				elseif s.len and s.len > 0 then
					if tp > s.len - 1/30 then tp = s.len - 1/30 end
					if tp < 0 then tp = 0 end
				end
				pcall(function()
					if math.abs((s.mt.TimePosition or 0) - tp) > 0.02 then s.mt.TimePosition = tp end
				end)
			end
		end

		allowOnlyMirrored()
	end))

	NAlib.connect(NAStuff.MIMIC_TAG, myChar.AncestryChanged:Connect(function() stopAndRestore() end))
	NAlib.connect(NAStuff.MIMIC_TAG, targetChar.AncestryChanged:Connect(function() stopAndRestore() end))
	if typeof(target) == "Instance" and target:IsA("Player") then
		NAlib.connect(NAStuff.MIMIC_TAG, Players.PlayerRemoving:Connect(function(plr)
			if plr == target then stopAndRestore() end
		end))
	end
end)

cmd.add({"mstop","moff","stopmimic","mend"}, {"mstop","Stop mimic and restore defaults"}, function()
	NAlib.disconnect(NAStuff.MIMIC_TAG)
	local myChar = getChar()
	local myHum = getPlrHum(myChar)
	local myAnimator = myHum and myHum:FindFirstChildOfClass("Animator")
	if myAnimator then for _, tr in ipairs(myAnimator:GetPlayingAnimationTracks()) do pcall(function() tr:Stop(0) end) end end
	if myHum then myHum.AutoRotate = true end
	local a = myChar and myChar:FindFirstChild("Animate")
	if a and NAlib.isProperty(a, "Disabled") ~= nil then
		if NAStuff.Mimic_AnimatePrevDisabled ~= nil then a.Disabled = NAStuff.Mimic_AnimatePrevDisabled else a.Disabled = false end
		a.Disabled = true; a.Disabled = false
	end
	NAStuff.Mimic_AnimatePrevDisabled = nil
end)

cmd.add({"bubblechat","bchat"},{"bubblechat (bchat)","Enables BubbleChat"},function()
	NAStuff.ChatSettings.bubbles.enabled = true
	NAmanage.SaveTextChatSettings()
	NAmanage.ApplyTextChatSettings()
end)

cmd.add({"unbubblechat","unbchat"},{"unbubblechat (unbchat)","Disabled BubbleChat"},function()
	NAStuff.ChatSettings.bubbles.enabled = false
	NAmanage.SaveTextChatSettings()
	NAmanage.ApplyTextChatSettings()
end)

cmd.add({"hideicon","iconhide"},{"hideicon","Hides the NA icon"},function()
	if NAmanage.IconSetInvisible then
		NAmanage.IconSetInvisible(true)
	end
end)

cmd.add({"showicon","iconshow"},{"showicon","Shows the NA icon"},function()
	if NAmanage.IconSetInvisible then
		NAmanage.IconSetInvisible(false)
	end
end)

cmd.add({"lockiconposition","lockicon"},{"lockiconposition","Locks the NA icon's position (can't be dragged)"},function()
	if NAgui.setIconLocked then
		NAgui.setIconLocked(true)
	end
end)

cmd.add({"unlockiconposition","unlockicon"},{"unlockiconposition","Unlocks the NA icon's position (can be dragged again)"},function()
	if NAgui.setIconLocked then
		NAgui.setIconLocked(false)
	end
end)

cmd.add({"saveinstance","savegame"},{"saveinstance (savegame)","if it bugs out try removing stuff from your AutoExec folder"},function()
	--saveinstance({})
	if saveinstance then saveinstance() return end
	local Params={
		RepoURL="https://raw.githubusercontent.com/luau/SynSaveInstance/main/",
		SSI="saveinstance",
	}
	local synsaveinstance=loadstring(game:HttpGet(Params.RepoURL..Params.SSI..".luau",true),Params.SSI)()
	local Options={}
	if identifyexecutor()=="Fluxus" then
		Options={ IgnoreSpecialProperties=true }
	end
	synsaveinstance(Options)
end)

cmd.add({"admin","whitelist"},{"admin <player>","Whitelist the user to have access to *your* client-side commands, anything they type runs on *you*, not on themselves"},function(...)
	function ChatMessage(Message,Whisper)
		NAlib.LocalPlayerChat(Message,Whisper or "All")
	end
	local Player=getPlr(...)
	for _, plr in next, Player do
		if plr~=nil and not Admin[plr.UserId] then
			Admin[plr.UserId]={plr=plr}
			ChatMessage("["..adminName.."] You've got admin. Prefix: ';'",plr.Name)
			Wait(0.2)
			DoNotif(nameChecker(plr).." has now been whitelisted to use commands",15)
		else
			DoNotif("No player found")
		end
	end
end,true)

cmd.add({"unadmin"},{"unadmin <player>","removes someone from being admin"},function(...)
	function ChatMessage(Message,Whisper)
		NAlib.LocalPlayerChat(Message,Whisper or "All")
	end
	local Player=getPlr(...)
	for _, plr in next, Player do
		if plr~=nil and Admin[plr.UserId] then
			Admin[plr.UserId]=nil
			ChatMessage("You can no longer use commands",plr.Name)
			DoNotif(nameChecker(plr).." is no longer an admin",15)
		else
			DoNotif("Player not found")
		end
	end
end,true)

cmd.add({"partname","partpath","partgrabber"},{"partname (partpath,partgrabber)","gives a ui and allows you click on a part to grab it's path"},function()
	loadstring(game:HttpGet("https://raw.githubusercontent.com/ltseverydayyou/Nameless-Admin/main/PartGrabber.lua"))()
end)

cmd.add({"jobid"},{"jobid","Copies your job id"},function()
	if setclipboard then
		setclipboard(tostring(JobId))
		Wait();

		DebugNotif("Copied your jobid ("..JobId..")")
	else
		DoNotif("Your executor does not support setclipboard")
	end
end)

cmd.add({"joinjobid","joinjid","jjobid","jjid"},{"joinjobid <jobid> (joinjid,jjobid,jjid)","Joins the job id you put in"},function(...)
	zeId={...}
	id=zeId[1]
	TeleportService:TeleportToPlaceInstance(PlaceId,id)
end,true)

NAStuff.srv = NAStuff.srv or {}

NAStuff.srvWorker = NAStuff.srvWorker or "https://solaraserverhop.ltseverydayyou.workers.dev"

NAStuff.srv.b = NAStuff.srv.b or {
	"https://games.roblox.com",
	"https://games.roproxy.com",
	"https://roxytheproxy.com/games.roblox.com",
}

NAStuff.srv.j = NAStuff.srv.j or function(self, s)
	if type(s) ~= "string" or #s == 0 then
		return nil
	end
	local ok, js = pcall(function()
		return HttpService:JSONDecode(s)
	end)
	if ok and type(js) == "table" then
		return js
	end
	return nil
end

NAStuff.srv.pg = NAStuff.srv.pg or function(self, cid)
	local q = "?sortOrder=Asc&limit=100"
	if cid and cid ~= "" then
		q = q.."&cursor="..HttpService:UrlEncode(cid)
	end

	for _, b in ipairs(self.b) do
		local url = b.."/v1/games/"..tostring(PlaceId).."/servers/Public"..q
		local ok, body = pcall(function()
			return game:HttpGetAsync(url)
		end)
		if ok and type(body) == "string" and #body > 0 then
			local js = self:j(body)
			if type(js) == "table" and type(js.data) == "table" then
				return js.data, js.nextPageCursor
			end
		end
	end

	local wq = "placeId="..tostring(PlaceId)
	if cid and cid ~= "" then
		wq = wq.."&cursor="..HttpService:UrlEncode(cid)
	end

	local wurl = NAStuff.srvWorker.."/servers?"..wq
	local wok, wbody = pcall(function()
		return game:HttpGetAsync(wurl)
	end)
	if wok and type(wbody) == "string" and #wbody > 0 then
		local ok2, js = pcall(function()
			return HttpService:JSONDecode(wbody)
		end)
		if ok2 and type(js) == "table" and type(js.data) == "table" then
			return js.data, js.nextPageCursor
		end
	end

	return nil, nil
end

NAStuff.srv.scan = NAStuff.srv.scan or function(self, mode)
	local id, bp, bg = nil, nil, nil
	local cid, pgc = nil, 0

	while pgc < 8 do
		pgc += 1
		local dat, nxt = self:pg(cid)
		if type(dat) ~= "table" then
			break
		end

		for _, s in ipairs(dat) do
			if type(s) == "table" and s.id and s.id ~= JobId then
				local pl = tonumber(s.playing)
				local mx = tonumber(s.maxPlayers)
				local pn = tonumber(s.ping)

				if pl and mx and mx > pl then
					if mode == "high" then
						if not bp or pl > bp then
							bp, id = pl, s.id
						end
					elseif mode == "low" then
						if not bp or pl < bp then
							bp, id = pl, s.id
						end
					elseif mode == "ping" then
						if pn and (not bg or pn < bg) then
							bg, id, bp = pn, s.id, pl
						end
					end
				end
			end
		end

		if not nxt or nxt == "" then
			break
		end
		cid = nxt
	end

	return id, bp, bg
end

cmd.add({"serverhop","shop"},{"serverhop (shop)","serverhop"},function()
	Wait()
	DebugNotif("Searching")

	local id, pl = NAStuff.srv:scan("high")
	if id then
		DebugNotif("serverhopping | Player Count: "..tostring(pl or "?"))
		TeleportService:TeleportToPlaceInstance(PlaceId, id)
	else
		DebugNotif("No server found")
	end
end)

cmd.add({"smallserverhop","sshop"},{"smallserverhop (sshop)","serverhop to a small server"},function()
	Wait()
	DebugNotif("Searching")

	local id, pl = NAStuff.srv:scan("low")
	if id then
		DebugNotif("serverhopping | Player Count: "..tostring(pl or "?"))
		TeleportService:TeleportToPlaceInstance(PlaceId, id)
	else
		DebugNotif("No server found")
	end
end)

cmd.add({"pingserverhop","pshop"},{"pingserverhop (pshop)","serverhop to a server with the best ping"},function()
	Wait()
	DebugNotif("Searching for server with best ping")

	local id, pl, pn = NAStuff.srv:scan("ping")
	if id and pn then
		DebugNotif(Format("Serverhopping | Ping: %s ms | Players: %s", tostring(pn), tostring(pl or "?")))
		TeleportService:TeleportToPlaceInstance(PlaceId, id)
	else
		DebugNotif("No server with ping found")
	end
end)

cmd.add({"autorejoin", "autorj"}, {"autorejoin (autorj)", "Rejoins the server if you get kicked / disconnected"}, function()
	NAlib.disconnect("autorejoin")

	local function handleRejoin()
		if #Players:GetPlayers() <= 1 then
			Players.LocalPlayer:Kick("Rejoining...")
			Wait(.05)
			TeleportService:Teleport(PlaceId, Players.LocalPlayer)
		else
			TeleportService:TeleportToPlaceInstance(PlaceId, JobId, Players.LocalPlayer)
		end
	end

	NAlib.connect("autorejoin", GuiService.ErrorMessageChanged:Connect(handleRejoin))

	DebugNotif("Auto Rejoin is now enabled!")
end)

cmd.add({"unautorejoin", "unautorj"}, {"unautorejoin (unautorj)", "Disables auto rejoin command"}, function()
	if NAlib.isConnected("autorejoin") then
		NAlib.disconnect("autorejoin")
		DebugNotif("Auto Rejoin is now disabled!")
	else
		DebugNotif("Auto Rejoin is already disabled!")
	end
end)

cmd.add({"functionspy"},{"functionspy","Check console"},function()
	local toLog={
		debug.getconstants;
		getconstants;
		debug.getconstant;
		getconstant;
		debug.setconstant;
		setconstant;
		debug.getupvalues;
		debug.getupvalue;
		getupvalues;
		getupvalue;
		debug.setupvalue;
		setupvalue;
		getsenv;
		getreg;
		getgc;
		getconnections;
		firesignal;
		fireclickdetector;
		fireproximityprompt;
		firetouchinterest;
		gethiddenproperty;
		sethiddenproperty;
		hookmetamethod;
		setnamecallmethod;
		getrawmetatable;
		setrawmetatable;
		setreadonly;
		isreadonly;
		debug.setmetatable;
	}

	local FunctionSpy=InstanceNew("ScreenGui")
	local Main=InstanceNew("Frame")
	local LeftPanel=InstanceNew("ScrollingFrame")
	local UIListLayout=InstanceNew("UIListLayout")
	local example=InstanceNew("TextButton")
	local name=InstanceNew("TextLabel")
	local UIPadding=InstanceNew("UIPadding")
	local FakeTitle=InstanceNew("TextButton")
	local Title=InstanceNew("TextLabel")
	local clear=InstanceNew("ImageButton")
	local RightPanel=InstanceNew("ScrollingFrame")
	local output=InstanceNew("TextLabel")
	local clear_2=InstanceNew("TextButton")
	local copy=InstanceNew("TextButton")

	NaProtectUI(FunctionSpy)
	FunctionSpy.Name="FunctionSpy"
	FunctionSpy.ZIndexBehavior=Enum.ZIndexBehavior.Sibling

	Main.Name="Main"
	Main.Parent=FunctionSpy
	Main.BackgroundColor3=Color3.fromRGB(33,33,33)
	Main.BorderSizePixel=0
	Main.Position=UDim2.new(0,10,0,36)
	Main.Size=UDim2.new(0,536,0,328)

	LeftPanel.Name="LeftPanel"
	LeftPanel.Parent=Main
	LeftPanel.Active=true
	LeftPanel.BackgroundColor3=Color3.fromRGB(45,45,45)
	LeftPanel.BorderSizePixel=0
	LeftPanel.Size=UDim2.new(0.349999994,0,1,0)
	LeftPanel.CanvasSize=UDim2.new(0,0,0,0)
	LeftPanel.HorizontalScrollBarInset=Enum.ScrollBarInset.ScrollBar
	LeftPanel.ScrollBarThickness=3

	UIListLayout.Parent=LeftPanel
	UIListLayout.SortOrder=Enum.SortOrder.LayoutOrder
	UIListLayout.Padding=UDim.new(0,7)

	example.Name="example"
	example.Parent=LeftPanel
	example.BackgroundColor3=Color3.fromRGB(31,31,31)
	example.BorderSizePixel=0
	example.Position=UDim2.new(4.39481269e-08,0,0,0)
	example.Size=UDim2.new(0,163,0,19)
	example.Visible=false
	example.Font=Enum.Font.SourceSans
	example.Text=""
	example.TextColor3=Color3.fromRGB(0,0,0)
	example.TextSize=14.000
	example.TextXAlignment=Enum.TextXAlignment.Left

	name.Name="name"
	name.Parent=example
	name.BackgroundColor3=Color3.fromRGB(255,255,255)
	name.BackgroundTransparency=1.000
	name.BorderSizePixel=0
	name.Position=UDim2.new(0,10,0,0)
	name.Size=UDim2.new(1,-10,1,0)
	name.Font=Enum.Font.SourceSans
	name.TextColor3=Color3.fromRGB(255,255,255)
	name.TextSize=14.000
	name.TextXAlignment=Enum.TextXAlignment.Left

	UIPadding.Parent=LeftPanel
	UIPadding.PaddingBottom=UDim.new(0,7)
	UIPadding.PaddingLeft=UDim.new(0,7)
	UIPadding.PaddingRight=UDim.new(0,7)
	UIPadding.PaddingTop=UDim.new(0,7)

	FakeTitle.Name="FakeTitle"
	FakeTitle.Parent=Main
	FakeTitle.BackgroundColor3=Color3.fromRGB(40,40,40)
	FakeTitle.BorderSizePixel=0
	FakeTitle.Position=UDim2.new(0,225,0,-26)
	FakeTitle.Size=UDim2.new(0.166044772,0,0,26)
	FakeTitle.Font=Enum.Font.GothamMedium
	FakeTitle.Text="FunctionSpy"
	FakeTitle.TextColor3=Color3.fromRGB(255,255,255)
	FakeTitle.TextSize=14.000

	Title.Name="Title"
	Title.Parent=Main
	Title.BackgroundColor3=Color3.fromRGB(40,40,40)
	Title.BorderSizePixel=0
	Title.Position=UDim2.new(0,0,0,-26)
	Title.Size=UDim2.new(1,0,0,26)
	Title.Font=Enum.Font.GothamMedium
	Title.Text="FunctionSpy"
	Title.TextColor3=Color3.fromRGB(255,255,255)
	Title.TextSize=14.000
	Title.TextWrapped=true

	clear.Name="clear"
	clear.Parent=Title
	clear.BackgroundTransparency=1.000
	clear.Position=UDim2.new(1,-28,0,2)
	clear.Size=UDim2.new(0,24,0,24)
	clear.ZIndex=2
	clear.Image=getcustomasset and getcustomasset(NAfiles.NAASSETSFILEPATH.."/"..NAImageAssets.Sheet) or "rbxassetid://3926305904"
	clear.ImageRectOffset=Vector2.new(924,724)
	clear.ImageRectSize=Vector2.new(36,36)

	RightPanel.Name="RightPanel"
	RightPanel.Parent=Main
	RightPanel.Active=true
	RightPanel.BackgroundColor3=Color3.fromRGB(35,35,35)
	RightPanel.BorderSizePixel=0
	RightPanel.Position=UDim2.new(0.349999994,0,0,0)
	RightPanel.Size=UDim2.new(0.649999976,0,1,0)
	RightPanel.CanvasSize=UDim2.new(0,0,0,0)
	RightPanel.HorizontalScrollBarInset=Enum.ScrollBarInset.ScrollBar
	RightPanel.ScrollBarThickness=3

	output.Name="output"
	output.Parent=RightPanel
	output.BackgroundColor3=Color3.fromRGB(255,255,255)
	output.BackgroundTransparency=1.000
	output.BorderColor3=Color3.fromRGB(27,42,53)
	output.BorderSizePixel=0
	output.Position=UDim2.new(0,10,0,10)
	output.Size=UDim2.new(1,-10,0.75,-10)
	output.Font=Enum.Font.GothamMedium
	output.Text=""
	output.TextColor3=Color3.fromRGB(255,255,255)
	output.TextSize=14.000
	output.TextXAlignment=Enum.TextXAlignment.Left
	output.TextYAlignment=Enum.TextYAlignment.Top

	clear_2.Name="clear"
	clear_2.Parent=RightPanel
	clear_2.BackgroundColor3=Color3.fromRGB(30,30,30)
	clear_2.BorderSizePixel=0
	clear_2.Position=UDim2.new(0.0631457642,0,0.826219559,0)
	clear_2.Size=UDim2.new(0,140,0,33)
	clear_2.Font=Enum.Font.SourceSans
	clear_2.Text="Clear logs"
	clear_2.TextColor3=Color3.fromRGB(255,255,255)
	clear_2.TextSize=14.000

	copy.Name="copy"
	copy.Parent=RightPanel
	copy.BackgroundColor3=Color3.fromRGB(30,30,30)
	copy.BorderSizePixel=0
	copy.Position=UDim2.new(0.545350134,0,0.826219559,0)
	copy.Size=UDim2.new(0,140,0,33)
	copy.Font=Enum.Font.SourceSans
	copy.Text="Copy info"
	copy.TextColor3=Color3.fromRGB(255,255,255)
	copy.TextSize=14.000

	--Scripts:

	function AKIHDI_fake_script()
		_G.functionspy={
			instance=Main.Parent;
			logging=true;
			connections={};
		}

		_G.functionspy.shutdown=function()
			for i,v in pairs(_G.functionspy.connections) do
				v:Disconnect()
			end
			_G.functionspy.connections={}
			_G.functionspy=nil
			Main.Parent:Destroy()
		end

		local connections={}

		local currentInfo=nil

		function log(name,text)
			local btn=Main.LeftPanel.example:Clone()
			btn.Parent=Main.LeftPanel
			btn.Name=name
			btn.name.Text=name
			btn.Visible=true
			Insert(connections, MouseButtonFix(btn, function()
				Main.RightPanel.output.Text=text
				currentInfo=text
			end))
		end

		MouseButtonFix(Main.RightPanel.copy, function()
			if currentInfo~=nil then
				setclipboard(tostring(currentInfo))
			end
		end)

		MouseButtonFix(Main.RightPanel.clear, function()
			for i,v in pairs(connections) do
				v:Disconnect()
			end
			for i,v in pairs(Main.LeftPanel:GetDescendants()) do
				if v:IsA("TextButton") and v.Visible==true then
					v:Destroy()
				end
			end
			Main.RightPanel.output.Text=""
			currentInfo=nil
		end)

		local hooked={}
		local Seralize=loadstring(game:HttpGet('https://api.irisapp.ca/Scripts/SeralizeTable.lua',true))()
		for i,v in next,toLog do
			if type(v)=="string" then
				local suc,err=NACaller(function()
					local func=loadstring("return "..v)()
					hooked[i]=hookfunction(func,function(...)
						local args={...}
						if _G.functionspy then
							NACaller(function()
								out=""
								out=out..(v..",Args-> {")..("\n"):format()
								for l,k in pairs(args) do
									if type(k)=="function" then
										out=out..("    ["..tostring(l).."] "..tostring(k)..",Type-> "..type(k)..",Name-> "..getinfo(k).name)..("\n"):format()
									elseif type(k)=="table" then
										out=out..("    ["..tostring(l).."] "..tostring(k)..",Type-> "..type(k)..",Data-> "..Seralize(k))..("\n"):format()
									elseif type(k)=="boolean" then
										out=out..("    ["..tostring(l).."] Value-> "..tostring(k).."-> "..type(k))..("\n"):format()
									elseif type(k)=="nil" then
										out=out..("    ["..tostring(l).."] null")..("\n"):format()
									elseif type(k)=="number" then
										out=out..("    ["..tostring(l).."] Value-> "..tostring(k)..",Type-> "..type(k))..("\n"):format()
									else
										out=out..("    ["..tostring(l).."] Value-> "..tostring(k)..",Type-> "..type(k))..("\n"):format()
									end
								end
								out=out..("},Result-> "..tostring(nil))..("\n"):format()
								if _G.functionspy.logging==true then
									log(v,out)
								end
							end)
						end
						return hooked[i](...)
					end)
				end)
				if not suc then
					warn("Something went wrong while hooking "..v..". Error: "..err)
				end
			elseif type(v)=="function" then
				local suc,err=NACaller(function()
					hooked[i]=hookfunction(v,function(...)
						local args={...}
						if _G.functionspy then
							NACaller(function() 
								out=""
								out=out..(getinfo(v).name..",Args-> {")..("\n"):format()
								for l,k in pairs(args) do
									if type(k)=="function" then
										out=out..("    ["..tostring(l).."] "..tostring(k)..",Type-> "..type(k)..",Name-> "..getinfo(k).name)..("\n"):format()
									elseif type(k)=="table" then
										out=out..("    ["..tostring(l).."] "..tostring(k)..",Type-> "..type(k)..",Data-> "..Seralize(k))..("\n"):format()
									elseif type(k)=="boolean" then
										out=out..("    ["..tostring(l).."] Value-> "..tostring(k).."-> "..type(k))..("\n"):format()
									elseif type(k)=="nil" then
										out=out..("    ["..tostring(l).."] null")..("\n"):format()
									elseif type(k)=="number" then
										out=out..("    ["..tostring(l).."] Value-> "..tostring(k)..",Type-> "..type(k))..("\n"):format()
									else
										out=out..("    ["..tostring(l).."] Value-> "..tostring(k)..",Type-> "..type(k))..("\n"):format()
									end
								end
								out=out..("},Result-> "..tostring(nil))..("\n"):format()
								if _G.functionspy.logging==true then
									log(getinfo(v).name,out)
								end
							end)
						end
						return hooked[i](...)
					end)
				end)
				if not suc then
					warn("Something went wrong while hooking "..getinfo(v).name..". Error: "..err)
				end
			end
		end

	end
	coroutine.wrap(AKIHDI_fake_script)()
	function KVVJTK_fake_script()
		local UIS=UserInputService
		local frame=FakeTitle.Parent
		local dragToggle=nil
		local dragSpeed=0.25
		local dragStart=nil
		local startPos=nil

		function updateInput(input)
			local delta=input.Position-dragStart
			local position=UDim2.new(startPos.X.Scale,startPos.X.Offset+delta.X,
				startPos.Y.Scale,startPos.Y.Offset+delta.Y)
			TweenService:Create(frame,TweenInfo.new(dragSpeed),{Position=position}):Play()
		end

		Insert(_G.functionspy.connections,frame.Title.InputBegan:Connect(function(input)
			if (input.UserInputType==Enum.UserInputType.MouseButton1 or input.UserInputType==Enum.UserInputType.Touch) then 
				dragToggle=true
				dragStart=input.Position
				startPos=frame.Position
				input.Changed:Connect(function()
					if input.UserInputState==Enum.UserInputState.End then
						dragToggle=false
					end
				end)
			end
		end))

		Insert(_G.functionspy.connections,UIS.InputChanged:Connect(function(input)
			if input.UserInputType==Enum.UserInputType.MouseMovement or input.UserInputType==Enum.UserInputType.Touch then
				if dragToggle then
					updateInput(input)
				end
			end
		end))

	end
	coroutine.wrap(KVVJTK_fake_script)()
	function BIPVKVC_fake_script()
		local script=InstanceNew('LocalScript',FakeTitle)

		Insert(_G.functionspy.connections,FakeTitle.MouseEnter:Connect(function()
			if _G.functionspy.logging==true then
				TweenService:Create(FakeTitle.Parent.Title,TweenInfo.new(0.3),{TextColor3=Color3.new(0,1,0)}):Play()
			elseif _G.functionspy.logging==false then
				TweenService:Create(FakeTitle.Parent.Title,TweenInfo.new(0.3),{TextColor3=Color3.new(1,0,0)}):Play()
			end
		end))

		Insert(_G.functionspy.connections,FakeTitle.MouseMoved:Connect(function()
			if _G.functionspy.logging==true then
				TweenService:Create(FakeTitle.Parent.Title,TweenInfo.new(0.3),{TextColor3=Color3.new(0,1,0)}):Play()
			elseif _G.functionspy.logging==false then
				TweenService:Create(FakeTitle.Parent.Title,TweenInfo.new(0.3),{TextColor3=Color3.new(1,0,0)}):Play()
			end
		end))

		Insert(_G.functionspy.connections, MouseButtonFix(FakeTitle, function()
			_G.functionspy.logging=not _G.functionspy.logging
			if _G.functionspy.logging==true then
				TweenService:Create(FakeTitle.Parent.Title,TweenInfo.new(0.3),{TextColor3=Color3.new(0,1,0)}):Play()
			elseif _G.functionspy.logging==false then
				TweenService:Create(FakeTitle.Parent.Title,TweenInfo.new(0.3),{TextColor3=Color3.new(1,0,0)}):Play()
			end
		end))

		Insert(_G.functionspy.connections,FakeTitle.MouseLeave:Connect(function()
			TweenService:Create(FakeTitle.Parent.Title,TweenInfo.new(0.3),{TextColor3=Color3.new(1,1,1)}):Play()
		end))
	end
	coroutine.wrap(BIPVKVC_fake_script)()
	function PRML_fake_script()
		MouseButtonFix(clear, function()
			_G.functionspy.shutdown()
		end)
	end
	coroutine.wrap(PRML_fake_script)()
end)

cmd.add({"fly"},{"fly [speed]","Enable flight"},function(...)
	local arg=(...) or nil
	flyVariables.flySpeed=tonumber(arg) or flyVariables.flySpeed or 1
	NAmanage.connectFlyKey()
	NAmanage.activateMode("fly")
	if not IsOnMobile then
		Wait()
		DebugNotif("Fly enabled. Press '"..string.upper(flyVariables.toggleKey).."' to fly/unfly.")
	end
end,true)

cmd.add({"unfly"},{"unfly","Disable flight"},function()
	NAmanage.deactivateMode("fly")
end)

cmd.add({"cframefly","cfly"},{"cframefly [speed] (cfly)","Enable CFrame-based flight"},function(...)
	local arg=(...) or nil
	flyVariables.cFlySpeed=tonumber(arg) or flyVariables.cFlySpeed or 1
	flyVariables.flySpeed=flyVariables.cFlySpeed
	NAmanage.connectCFlyKey()
	NAmanage.activateMode("cfly")
	if not IsOnMobile then
		Wait()
		DebugNotif("CFrame Fly enabled. Press '"..string.upper(flyVariables.cToggleKey).."' to cfly/uncfly.")
	end
end,true)

cmd.add({"uncframefly","uncfly"},{"uncfly","Disable CFrame-based flight"},function()
	NAmanage.deactivateMode("cfly")
end)

--[[if IsOnPC then
	cmd.add({"cflybind", "cframeflybind", "bindcfly"}, {"cflybind [key] (cframeflybind, bindcfly)", "Set custom keybind for CFrame fly"}, function(...)
		local newKey = (...) or ""
		newKey = newKey:lower()
		if newKey == "" then
			DoNotif("Please provide a keybind.")
			return
		end

		flyVariables.cToggleKey = newKey

		if flyVariables.cKeybindConn then
			flyVariables.cKeybindConn:Disconnect()
			flyVariables.cKeybindConn = nil
		end

		connectCFlyKey()
		DoNotif("CFrame fly keybind set to '"..flyVariables.cToggleKey:upper().."'")
	end,true)
end]]

cmd.add({"tfly","tweenfly"},{"tfly [speed] (tweenfly)","Enables smooth flying"},function(...)
	local arg=(...) or nil
	flyVariables.TflySpeed=tonumber(arg) or flyVariables.TflySpeed or 1
	NAmanage.connectTFlyKey()
	NAmanage.activateMode("tfly")
	if not IsOnMobile then
		Wait()
		DebugNotif("TFly enabled. Press '"..string.upper(flyVariables.tflyToggleKey).."' to tfly/untfly.")
	end
end,true)

cmd.add({"untfly","untweenfly"},{"untfly","Disables tween flying"},function()
	NAmanage.deactivateMode("tfly")
end)

--[[if IsOnPC then
	cmd.add({"tflykeybind", "bindtfly", "tflybind"}, {"tflykeybind [key] (bindtfly, tflybind)", "Set keybind for tfly toggle"}, function(...)
		local key = (...) or ""
		if key == "" then
			DoNotif("Please provide a key.")
			return
		end
		flyVariables.tflyToggleKey = key:lower()
		if flyVariables.tflyKeyConn then flyVariables.tflyKeyConn:Disconnect() end
		flyVariables.tflyKeyConn = mouse.KeyDown:Connect(function(k)
			if k:lower() == flyVariables.tflyToggleKey then
				toggleTFly()
			end
		end)
		DoNotif("TFly keybind set to '"..flyVariables.tflyToggleKey:upper().."'")
	end, true)
end]]

-- idk what i am doing lol (bored af :P)

cmd.add({"noclip","nclip","nc"},{"noclip","Disable your player's collision"},function()
	NAStuff._ncColl = setmetatable({}, {__mode="k"})
	local collMap = NAStuff._ncColl

	NAlib.disconnect("noclip")
	NAlib.connect("noclip", RunService.Stepped:Connect(function()
		local char = getChar()
		if not char then return end
		for _,p in pairs(char:GetDescendants()) do
			if p:IsA("BasePart") then
				local currentState = NAlib.isProperty(p, "CanCollide")
				if collMap and collMap[p] == nil and currentState ~= nil then
					collMap[p] = currentState
				end
				if currentState ~= false then
					NAlib.setProperty(p,"CanCollide", false)
				end
			end
		end
	end))
end)

cmd.add({"clip","unnoclip","stopclip","unnclip","unnc"},{"clip","Enable your player's collision"},function()
	NAlib.disconnect("noclip")

	local collMap = NAStuff._ncColl
	if collMap then
		for part, wasCollidable in pairs(collMap) do
			if part and part:IsA("BasePart") and wasCollidable ~= nil then
				NAlib.setProperty(part, "CanCollide", wasCollidable)
			end
		end
	end
	NAStuff._ncColl = nil
end)

cmd.add({"antianchor","aa"},{"antianchor","Prevent your parts from being anchored"},function()
	NAlib.disconnect("antianchor")
	NAlib.disconnect("antianchor_char")
	NAStuff._aaTracked = NAStuff._aaTracked or setmetatable({}, {__mode="k"})
	NAStuff._aaOrig = NAStuff._aaOrig or setmetatable({}, {__mode="k"})
	NAStuff._aaSignals = NAStuff._aaSignals or setmetatable({}, {__mode="k"})
	local tracked, orig, signals = NAStuff._aaTracked, NAStuff._aaOrig, NAStuff._aaSignals
	local lp = Players.LocalPlayer
	local enforce = function(p)
		if not (p and p:IsA("BasePart")) then return end
		if orig[p] == nil then orig[p] = NAlib.isProperty(p,"Anchored") end
		tracked[p] = true
		if NAlib.isProperty(p,"Anchored") ~= false then NAlib.setProperty(p,"Anchored", false) end
		if not signals[p] then
			local c = p:GetPropertyChangedSignal("Anchored"):Connect(function()
				if NAlib.isProperty(p,"Anchored") ~= false then NAlib.setProperty(p,"Anchored", false) end
			end)
			signals[p] = c
			NAlib.connect("antianchor", c)
		end
	end
	local seed = function(char)
		if not char then return end
		for _,d in ipairs(char:GetDescendants()) do
			if d:IsA("BasePart") then enforce(d) end
		end
		NAlib.connect("antianchor", char.DescendantAdded:Connect(function(inst)
			if inst:IsA("BasePart") then enforce(inst) end
		end))
		NAlib.connect("antianchor", char.DescendantRemoving:Connect(function(inst)
			if signals[inst] then signals[inst]:Disconnect(); signals[inst] = nil end
			tracked[inst] = nil
			orig[inst] = nil
		end))
	end
	if lp.Character then seed(lp.Character) end
	NAlib.connect("antianchor_char", lp.CharacterAdded:Connect(function(char)
		for _,c in pairs(signals) do if c then c:Disconnect() end end
		for k in pairs(signals) do signals[k]=nil end
		for k in pairs(tracked) do tracked[k]=nil end
		for k in pairs(orig) do orig[k]=nil end
		Wait(); seed(char)
	end))
	NAlib.connect("antianchor_char", lp.CharacterRemoving:Connect(function()
		for _,c in pairs(signals) do if c then c:Disconnect() end end
		for k in pairs(signals) do signals[k]=nil end
		for k in pairs(tracked) do tracked[k]=nil end
		for k in pairs(orig) do orig[k]=nil end
	end))
	NAlib.connect("antianchor", RunService.Stepped:Connect(function()
		local char = lp.Character
		if not char then return end
		for p in pairs(tracked) do
			if typeof(p)=="Instance" and p:IsA("BasePart") and p:IsDescendantOf(char) then
				if p.Anchored ~= false then NAlib.setProperty(p,"Anchored", false) end
			end
		end
	end))
end)

cmd.add({"unantianchor","unaa"},{"unantianchor","Allow your parts to be anchored"},function()
	local tracked = NAStuff._aaTracked or {}
	local orig = NAStuff._aaOrig or {}
	local signals = NAStuff._aaSignals or {}
	NAlib.disconnect("antianchor")
	NAlib.disconnect("antianchor_char")
	for _,c in pairs(signals) do if c then c:Disconnect() end end
	for p in pairs(tracked) do
		if typeof(p)=="Instance" and p:IsA("BasePart") then
			local v = orig[p]; if v == nil then v = false end
			NAlib.setProperty(p,"Anchored", v)
		end
	end
	for k in pairs(signals) do signals[k]=nil end
	for k in pairs(tracked) do tracked[k]=nil end
	for k in pairs(orig) do orig[k]=nil end
end)

originalPos = nil
platformPart = nil
activationTime = nil

cmd.add({"antibang"}, {"antibang", "prevents users to bang you (still WORK IN PROGRESS)"}, function()
	NAlib.disconnect("antibang_loop")

	local root = getRoot(LocalPlayer.Character)
	if not root then return end

	originalPos = root.CFrame
	local orgHeight = workspace.FallenPartsDestroyHeight
	local anims = {"rbxassetid://5918726674", "rbxassetid://148840371", "rbxassetid://698251653", "rbxassetid://72042024", "rbxassetid://189854234", "rbxassetid://106772613", "rbxassetid://10714360343", "rbxassetid://95383980"}
	local inVoid = false
	local targetPlayer = nil
	local toldNotif = false
	local activationTime = nil
	local backshotState = {}

	LocalPlayer.CharacterAdded:Connect(function(char)
		Wait(1)
		root = getRoot(char)
	end)

	local function startAntibang(player)
		if not player then
			return
		end

		inVoid = true
		activationTime = tick()
		targetPlayer = player
		workspace.FallenPartsDestroyHeight = 0/1/0

		if platformPart then
			platformPart:Destroy()
		end

		platformPart = InstanceNew("Part")
		platformPart.Size = Vector3.new(9999, 1, 9999)
		platformPart.Anchored = true
		platformPart.CanCollide = true
		platformPart.Transparency = 1
		platformPart.Position = Vector3.new(0, orgHeight - 30, 0)
		platformPart.Parent = workspace
		root.CFrame = CFrame.new(Vector3.new(0, orgHeight - 25, 0))

		if not toldNotif then
			toldNotif = true
			DebugNotif("Antibang activated | Target: "..nameChecker(targetPlayer), 2)
		end
	end

	local function detectBackshot(player, back, deltaTime)
		local char = player.Character
		local ehrp = char and getRoot(char)
		local ehum = char and getHum(char)
		local data = backshotState[player]
		local ok = false
		local triggered = false
		local dt = deltaTime or 0

		if ehrp and ehum and root then
			local dist = (ehrp.Position - root.Position).Magnitude
			if dist < 10 then
				local dirToThem = (ehrp.Position - root.Position).Unit
				local backDot = back:Dot(dirToThem)
				if backDot > 0.5 then
					local toMe = (root.Position - ehrp.Position).Unit
					local faceDot = ehrp.CFrame.LookVector:Dot(toMe)
					if faceDot > 0.4 then
						local mv = ehum.MoveDirection
						if mv.Magnitude > 0.1 then
							ok = true
							local mvDot = mv.Unit:Dot(back)
							data = data or {lastSign = 0, flips = 0, t = 0}
							backshotState[player] = data

							local sign = 0
							if mvDot > 0.3 then
								sign = 1
							elseif mvDot < -0.3 then
								sign = -1
							end

							if sign ~= 0 and sign ~= data.lastSign then
								data.flips += 1
								data.lastSign = sign
							end

							data.t += dt
							if data.t >= 1 then
								if data.flips >= 3 then
									triggered = true
								end
								data.flips = 0
								data.t = 0
							end
						end
					end
				end
			end
		end

		if not ok and data then
			data.lastSign = 0
			data.flips = 0
			data.t = 0
		end

		return triggered
	end

	NAlib.connect("antibang_loop", RunService.Stepped:Connect(function(_, dt)
		if not root then
			return
		end

		local back = -root.CFrame.LookVector

		for _, p in pairs(SafeGetService("Players"):GetPlayers()) do
			if p ~= LocalPlayer then
				local char = p.Character
				local targetRoot = char and getRoot(char)
				if targetRoot then
					if not inVoid and detectBackshot(p, back, dt) then
						startAntibang(p)
					end

					if (targetRoot.Position - root.Position).Magnitude <= 10 then
						local humanoid = getPlrHum(p)
						if humanoid then
							local tracks = humanoid:GetPlayingAnimationTracks()
							for _, t in pairs(tracks) do
								if Discover(anims, t.Animation.AnimationId) then
									if not inVoid then
										startAntibang(p)
									end
								end
							end
						end
					end
				end
			end
		end

		if inVoid then
			if (not targetPlayer or not targetPlayer.Character or not getPlrHum(targetPlayer) or getPlrHum(targetPlayer).Health <= 0)
				or (activationTime and tick() - activationTime >= 10) then
				inVoid = false
				targetPlayer = nil
				root.CFrame = originalPos
				root.Anchored = true
				Wait()
				root.Anchored = false
				workspace.FallenPartsDestroyHeight = orgHeight
				if platformPart then
					platformPart:Destroy()
					platformPart = nil
				end
				if toldNotif then
					toldNotif = false
					if activationTime and tick() - activationTime >= 10 then
						DebugNotif("Antibang deactivated (timeout)", 2)
					else
						DebugNotif("Antibang deactivated", 2)
					end
				end
			end
		end
	end))

	DebugNotif("Antibang Enabled", 3)
end)

cmd.add({"unantibang"}, {"unantibang", "disables antibang"}, function()
	NAlib.disconnect("antibang_loop")
	if platformPart then
		platformPart:Destroy()
		platformPart = nil
	end
	DebugNotif("Antibang Disabled", 3)
end)

cmd.add({"orbit"}, {"orbit <player> <distance>", "Orbit around a player"}, function(p, d)
	NAlib.disconnect("orbit")
	local targets = getPlr(p)
	if #targets == 0 then return end
	local target = targets[1]
	local tchar = target.Character
	local char = getChar()
	if not tchar or not char then return end
	local thrp = getRoot(tchar)
	local hrp = getRoot(char)
	if not thrp or not hrp then return end
	local dist = tonumber(d) or 4
	local sineX, sineZ = 0, math.pi / 2
	NAlib.connect("orbit", RunService.Stepped:Connect(function()
		if not (thrp.Parent and hrp.Parent) then
			NAlib.disconnect("orbit")
			return
		end
		sineX, sineZ = sineX + 0.05, sineZ + 0.05
		local sinX, sinZ = math.sin(sineX), math.sin(sineZ)
		hrp.Velocity = Vector3.zero
		hrp.CFrame = CFrame.new(sinX * dist, 0, sinZ * dist) * (hrp.CFrame - hrp.CFrame.p) + thrp.CFrame.p
	end))
end, true)

cmd.add({"uporbit"}, {"uporbit <player> <distance>", "Orbit around a player on the Y axis"}, function(p, d)
	NAlib.disconnect("orbit")
	local targets = getPlr(p)
	if #targets == 0 then return end
	local target = targets[1]
	local tchar = target.Character
	local char = getChar()
	if not tchar or not char then return end
	local thrp = getRoot(tchar)
	local hrp = getRoot(char)
	if not thrp or not hrp then return end
	local dist = tonumber(d) or 4
	local sineX, sineY = 0, math.pi / 2
	NAlib.connect("orbit", RunService.Stepped:Connect(function()
		if not (thrp.Parent and hrp.Parent) then
			NAlib.disconnect("orbit")
			return
		end
		sineX, sineY = sineX + 0.05, sineY + 0.05
		local sinX, sinY = math.sin(sineX), math.sin(sineY)
		hrp.Velocity = Vector3.zero
		hrp.CFrame = CFrame.new(sinX * dist, sinY * dist, 0) * (hrp.CFrame - hrp.CFrame.p) + thrp.CFrame.p
	end))
end, true)

cmd.add({"unorbit"}, {"unorbit", "Stop orbiting"}, function()
	NAlib.disconnect("orbit")
end)

fcBTNTOGGLE = nil

cmd.add({"freecam","fc","fcam"},{"freecam [speed] (fc,fcam)","Enable free camera"},function(...)
	argg = (...)
	local function normalizeLegacySpeed(value)
		local n = tonumber(value)
		if not n then
			return nil
		end
		return math.clamp(n, 0.05, 20)
	end

	local legacySpeed = normalizeLegacySpeed(argg) or normalizeLegacySpeed(NAStuff.FreecamSpeed) or 5
	local navSpeed = legacySpeed / 5
	local speed = legacySpeed
	NAStuff.FreecamSpeed = legacySpeed
	pcall(NAmanage.NASettingsSet, "freecamSpeed", legacySpeed)

	if NAFreecam and NAFreecam.IsEnabled() then
		NAFreecam.Stop()
		camera.CameraSubject = getChar()
		SpawnCall(function() cmd.run({"unfr"}) end)
	end

	if NAlib.isConnected("freecam") then
		NAlib.disconnect("freecam")
		camera.CameraSubject = getChar()
		SpawnCall(function() cmd.run({"unfr"}) end)
	end

	if fcBTNTOGGLE then
		fcBTNTOGGLE:Destroy()
		fcBTNTOGGLE = nil
	end

	local function runFREECAM()
		local cf = InstanceNew("CFrameValue")
		local camPart = InstanceNew("Part")
		camPart.Transparency = 1
		camPart.Anchored = true
		camPart.CFrame = camera.CFrame

		NAlib.connect("freecam", RunService.RenderStepped:Connect(function(dt)
			local primaryPart = camPart
			camera.CameraSubject = primaryPart

			local moveVec = GetCustomMoveVector()

			local x = moveVec.X * speed
			local y = moveVec.Y * speed
			local z = moveVec.Z * speed

			primaryPart.CFrame = CFrame.new(
				primaryPart.CFrame.p,
				(camera.CFrame * CFrame.new(0, 0, -100)).p
			)

			local moveDir = CFrame.new(x, y, z)
			cf.Value = cf.Value:lerp(moveDir, 0.2)
			primaryPart.CFrame = primaryPart.CFrame:lerp(primaryPart.CFrame * cf.Value, 0.2)
		end))
	end

	if IsOnMobile then
		if fcBTNTOGGLE then
			fcBTNTOGGLE:Destroy()
			fcBTNTOGGLE = nil
		end

		fcBTNTOGGLE = InstanceNew("ScreenGui")
		local btn = InstanceNew("TextButton")
		local speedBox = InstanceNew("TextBox")
		local toggleBtn = InstanceNew("TextButton")
		local corner = InstanceNew("UICorner")
		local corner2 = InstanceNew("UICorner")
		local corner3 = InstanceNew("UICorner")
		local aspect = InstanceNew("UIAspectRatioConstraint")

		NaProtectUI(fcBTNTOGGLE)
		fcBTNTOGGLE.ResetOnSpawn = false

		btn.Parent = fcBTNTOGGLE
		btn.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
		btn.BackgroundTransparency = 0.1
		btn.Position = UDim2.new(0.9, 0, 0.5, 0)
		btn.Size = UDim2.new(0.08, 0, 0.1, 0)
		btn.Font = Enum.Font.GothamBold
		btn.Text = "FC"
		btn.TextColor3 = Color3.fromRGB(255, 255, 255)
		btn.TextSize = 18
		btn.TextWrapped = true
		btn.Active = true
		btn.TextScaled = true

		corner.CornerRadius = UDim.new(0.2, 0)
		corner.Parent = btn

		aspect.Parent = btn
		aspect.AspectRatio = 1.0

		speedBox.Parent = fcBTNTOGGLE
		speedBox.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
		speedBox.BackgroundTransparency = 0.1
		speedBox.AnchorPoint = Vector2.new(0.5, 0)
		speedBox.Position = UDim2.new(0.5, 0, 0, 10)
		speedBox.Size = UDim2.new(0, 75, 0, 35)
		speedBox.Font = Enum.Font.GothamBold
		speedBox.Text = tostring(speed)
		speedBox.TextColor3 = Color3.fromRGB(255, 255, 255)
		speedBox.TextSize = 18
		speedBox.TextWrapped = true
		speedBox.ClearTextOnFocus = false
		speedBox.PlaceholderText = "Speed"
		speedBox.Visible = false

		corner2.CornerRadius = UDim.new(0.2, 0)
		corner2.Parent = speedBox

		toggleBtn.Parent = btn
		toggleBtn.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
		toggleBtn.BackgroundTransparency = 0.1
		toggleBtn.Position = UDim2.new(0.9, 0, -0.1, 0)
		toggleBtn.Size = UDim2.new(0.4, 0, 0.4, 0)
		toggleBtn.Font = Enum.Font.SourceSans
		toggleBtn.Text = "+"
		toggleBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
		toggleBtn.TextSize = 14
		toggleBtn.TextWrapped = true
		toggleBtn.Active = true
		toggleBtn.AutoButtonColor = true

		corner3.CornerRadius = UDim.new(1, 0)
		corner3.Parent = toggleBtn

		MouseButtonFix(toggleBtn, function()
			speedBox.Visible = not speedBox.Visible
			toggleBtn.Text = speedBox.Visible and "-" or "+"
		end)

		local function applyMobileFreecamSpeed()
			local newSpeed = normalizeLegacySpeed(speedBox.Text) or speed
			speed = newSpeed
			speedBox.Text = tostring(speed)
			NAStuff.FreecamSpeed = speed
			pcall(NAmanage.NASettingsSet, "freecamSpeed", speed)
			if NAFreecam and NAFreecam.IsEnabled and NAFreecam.IsEnabled() and NAFreecam.SetSpeed then
				NAFreecam.SetSpeed(speed / 5)
			end
		end

		local function startMobileFreecam()
			applyMobileFreecamSpeed()
			if flyVariables.mOn then
				return
			end
			flyVariables.mOn = true
			btn.Text = "UNFC"
			btn.BackgroundColor3 = Color3.fromRGB(0, 170, 0)
			SpawnCall(function() cmd.run({"fr",''}) end)
			if NAFreecam then
				NAFreecam.Start(speed and (speed / 5) or nil)
			else
				runFREECAM()
			end
		end

		speedBox.FocusLost:Connect(applyMobileFreecamSpeed)

		coroutine.wrap(function()
			MouseButtonFix(btn, function()
				applyMobileFreecamSpeed()
				if not flyVariables.mOn then
					startMobileFreecam()
				else
					flyVariables.mOn = false
					btn.Text = "FC"
					btn.BackgroundColor3 = Color3.fromRGB(170, 0, 0)
					if NAFreecam and NAFreecam.IsEnabled() then
						NAFreecam.Stop()
					end
					if NAlib.isConnected("freecam") then
						NAlib.disconnect("freecam")
					end
					camera.CameraSubject = getChar()
					SpawnCall(function() cmd.run({"unfr"}) end)
					DebugNotif("Freecam disabled", 2)
				end
			end)
		end)()

		NAgui.draggerV2(btn)
		NAgui.draggerV2(speedBox)

		startMobileFreecam()
	else
		if not IsOnPC then
			return DebugNotif("Freecam is only available on PC and mobile", 3)
		end

		DebugNotif("Roblox-style freecam enabled (WASD + mouse, Q/E up/down, arrows change speed)", 3)
		if NAFreecam then
			NAFreecam.Start(navSpeed)
		else
			runFREECAM()
		end
	end
end, true)

cmd.add({"unfreecam","unfc","unfcam"},{"unfreecam (unfc,unfcam)","Disable free camera"},function()
	if NAFreecam and NAFreecam.IsEnabled() then
		NAFreecam.Stop()
	end
	NAlib.disconnect("freecam")
	camera.CameraSubject = getChar()
	SpawnCall(function() cmd.run({"unfr"}) end)
	if fcBTNTOGGLE then fcBTNTOGGLE:Destroy() fcBTNTOGGLE = nil end
	DebugNotif("Freecam disabled", 2)
end)

cmd.add({"nohats","drophats"},{"nohats (drophats)","Drop all of your hats"},function()
	for _,hat in pairs(getChar():GetChildren()) do
		if hat:IsA("Accoutrement") then
			hat:FindFirstChildWhichIsA("Weld",true):Destroy()
		end
	end
end)

cmd.add({"permadeath", "pdeath"}, {"permadeath (pdeath)", "be death permanently"}, function()
	if not replicatesignal then
		return DoNotif("Your executor does not support 'replicatesignal'")
	end

	replicatesignal(LocalPlayer.ConnectDiedSignalBackend)
	Wait(Players.RespawnTime + 0.1)

	local humanoid = getHum()
	if humanoid then
		humanoid:ChangeState(Enum.HumanoidStateType.Dead)
	end
end)

cmd.add({"unpermadeath", "unpdeath"}, {"unpermadeath (unpdeath)", "no perma death"}, function()
	if not replicatesignal then
		return DoNotif("Your executor does not support 'replicatesignal'")
	end

	replicatesignal(LocalPlayer.ConnectDiedSignalBackend)
end)

cmd.add({"instantrespawn", "instantr", "irespawn"}, {"instantrespawn (instantr, irespawn)", "respawn instantly"}, function()
	if not replicatesignal then
		return DoNotif("Your executor does not support 'replicatesignal'")
	end

	replicatesignal(LocalPlayer.ConnectDiedSignalBackend)

	local rootPart = LocalPlayer.Character and getRoot(LocalPlayer.Character)
	local cam = workspace.CurrentCamera

	Wait(Players.RespawnTime - 0.165)

	local humanoid = getHum()
	if humanoid then
		humanoid:ChangeState(Enum.HumanoidStateType.Dead)
	end

	Wait(0.5)

	if rootPart then
		getRoot(LocalPlayer.Character).CFrame = rootPart.CFrame
	end

	workspace.CurrentCamera = cam
end)

function getAllTools()
	local tools={}
	local backpack=localPlayer:FindFirstChildWhichIsA("Backpack")
	if backpack then
		for i,v in pairs(backpack:GetChildren()) do
			if v:IsA("Tool") then
				Insert(tools,v)
			end
		end
	end
	for i,v in pairs(character:GetChildren()) do
		if v:IsA("Tool") then
			Insert(tools,v)
		end
	end
	return tools
end

cmd.add({"circlemath", "cm"}, {"circlemath <mode> <size>", "Gay circle math\nModes: a,b,c,d,e"}, function(mode, size)
	local mode = mode or "a"
	local backpack = getBp()
	NAlib.disconnect("cm")
	if backpack and character.Parent then
		local tools = getAllTools()
		for i, tool in pairs(tools) do
			local cpos, g = (math.pi*2)*(i/#tools), CFrame.new()
			local tcon = {}
			tool.Parent = backpack

			if mode == "a" then
				size = tonumber(size) or 2
				g = (
					CFrame.new(0, 0, size)*
						CFrame.Angles(rad(90), 0, cpos)
				)
			elseif mode == "b" then
				size = tonumber(size) or 2
				g = (
					CFrame.new(i - #tools/2, 0, 0)*
						CFrame.Angles(rad(90), 0, 0)
				)
			elseif mode == "c" then
				size = tonumber(size) or 2
				g = (
					CFrame.new(cpos/3, 0, 0)*
						CFrame.Angles(rad(90), 0, cpos*2)
				)
			elseif mode == "d" then
				size = tonumber(size) or 2
				g = (
					CFrame.new(clamp(tan(cpos), -3, 3), 0, 0)*
						CFrame.Angles(rad(90), 0, cpos)
				)
			elseif mode == "e" then
				size = tonumber(size) or 2
				g = (
					CFrame.new(0, 0, clamp(tan(cpos), -5, 5))*
						CFrame.Angles(rad(90), 0, cpos)
				)
			end
			tool.Grip = g
			tool.Parent = character

			tcon[#tcon] = NAlib.connect("cm", mouse.Button1Down:Connect(function()
				tool:Activate()
			end))
			tcon[#tcon] = NAlib.connect("cm", tool.Changed:Connect(function(p)
				if p == "Grip" and tool.Grip ~= g then
					tool.Grip = g
				end
			end))

			NAlib.connect("cm", tool.AncestryChanged:Connect(function()
				for i = 1, #tcon do
					tcon[i]:Disconnect()
				end
			end))
		end
	end
end,true)

GRIPUITHINGYIDFK = nil

cmd.add({"grippos", "setgrip"}, {"grippos (setgrip)", "Opens a UI to manually input grip offset and rotation."}, function()
	local plr = LocalPlayer
	if GRIPUITHINGYIDFK then return end

	GRIPUITHINGYIDFK = InstanceNew("ScreenGui")
	GRIPUITHINGYIDFK.Name = "GripAdjustUI"
	GRIPUITHINGYIDFK.ResetOnSpawn = false
	NaProtectUI(GRIPUITHINGYIDFK)

	local frame = InstanceNew("Frame")
	frame.Size = UDim2.new(0, 320, 0, 270)
	frame.Position = UDim2.new(0.5, -160, 0.5, -135)
	frame.BackgroundColor3 = Color3.fromRGB(35, 35, 45)
	frame.BorderSizePixel = 0
	frame.Parent = GRIPUITHINGYIDFK

	local corner = InstanceNew("UICorner", frame)
	corner.CornerRadius = UDim.new(0, 6)

	local gradient = InstanceNew("UIGradient", frame)
	gradient.Rotation = 90
	gradient.Color = ColorSequence.new{
		ColorSequenceKeypoint.new(0, Color3.fromRGB(50, 50, 60)),
		ColorSequenceKeypoint.new(1, Color3.fromRGB(25, 25, 30))
	}

	local titleBar = InstanceNew("Frame")
	titleBar.Size = UDim2.new(1, 0, 0, 30)
	titleBar.BackgroundColor3 = Color3.fromRGB(60, 60, 75)
	titleBar.BorderSizePixel = 0
	titleBar.Parent = frame

	local barCorner = InstanceNew("UICorner", titleBar)
	barCorner.CornerRadius = UDim.new(0, 6)

	local title = InstanceNew("TextLabel")
	title.Size = UDim2.new(1, 0, 1, 0)
	title.BackgroundTransparency = 1
	title.Text = "Grip Position Editor"
	title.TextColor3 = Color3.fromRGB(255, 255, 255)
	title.Font = Enum.Font.GothamBold
	title.TextSize = 16
	title.Parent = titleBar

	local preview = InstanceNew("TextButton")
	preview.Size = UDim2.new(0, 260, 0, 28)
	preview.Position = UDim2.new(0, 30, 0, 180)
	preview.Text = "🔍 Preview"
	preview.Font = Enum.Font.GothamBold
	preview.TextSize = 15
	preview.BackgroundColor3 = Color3.fromRGB(75, 75, 95)
	preview.TextColor3 = Color3.new(1, 1, 1)
	preview.Parent = frame
	InstanceNew("UICorner", preview)

	local labels = {"X", "Y", "Z", "RX", "RY", "RZ"}
	local textBoxes = {}

	for i, label in ipairs(labels) do
		local xOffset = ((i - 1) % 3) * 100
		local yOffset = 40 + math.floor((i - 1) / 3) * 50

		local labelUI = InstanceNew("TextLabel")
		labelUI.Size = UDim2.new(0, 40, 0, 25)
		labelUI.Position = UDim2.new(0, 10 + xOffset, 0, yOffset)
		labelUI.BackgroundTransparency = 1
		labelUI.Text = label
		labelUI.TextColor3 = Color3.fromRGB(255, 255, 255)
		labelUI.Font = Enum.Font.Gotham
		labelUI.TextSize = 14
		labelUI.Parent = frame

		local box = InstanceNew("TextBox")
		box.Size = UDim2.new(0, 50, 0, 25)
		box.Position = UDim2.new(0, 50 + xOffset, 0, yOffset)
		box.PlaceholderText = "0"
		box.Text = ""
		box.Font = Enum.Font.Gotham
		box.TextSize = 14
		box.BackgroundColor3 = Color3.fromRGB(45, 45, 55)
		box.TextColor3 = Color3.fromRGB(255, 255, 255)
		box.BorderSizePixel = 0
		box.ClearTextOnFocus = false
		box.Parent = frame

		local boxCorner = InstanceNew("UICorner", box)
		boxCorner.CornerRadius = UDim.new(0, 4)

		textBoxes[label] = box
	end

	local function getVal(name)
		return tonumber(textBoxes[name].Text) or 0
	end

	local function closeUI()
		if GRIPUITHINGYIDFK then
			GRIPUITHINGYIDFK:Destroy()
			GRIPUITHINGYIDFK = nil
		end
	end

	local function applyGrip()
		local char = getChar()
		local tool = char and char:FindFirstChildOfClass("Tool")
		local backpack = getBp() or LocalPlayer:FindFirstChild("Backpack")
		if not tool or not backpack then return end

		local pos = Vector3.new(getVal("X"), getVal("Y"), getVal("Z"))
		local rot = Vector3.new(getVal("RX"), getVal("RY"), getVal("RZ"))
		local gripCFrame = CFrame.new(pos) * CFrame.Angles(math.rad(rot.X), math.rad(rot.Y), math.rad(rot.Z))

		tool.Parent = backpack
		Wait()
		tool.Grip = gripCFrame
		tool.Parent = char

		local fix
		fix = tool.Changed:Connect(function(prop)
			if prop == "Grip" and tool.Grip ~= gripCFrame then
				tool.Grip = gripCFrame
			end
		end)

		tool.AncestryChanged:Connect(function()
			if fix then fix:Disconnect() end
		end)
	end

	local confirm = InstanceNew("TextButton")
	confirm.Size = UDim2.new(0, 130, 0, 32)
	confirm.Position = UDim2.new(0, 20, 0, 215)
	confirm.Text = "Apply"
	confirm.Font = Enum.Font.GothamBold
	confirm.TextSize = 16
	confirm.BackgroundColor3 = Color3.fromRGB(0, 170, 80)
	confirm.TextColor3 = Color3.new(1, 1, 1)
	confirm.Parent = frame
	InstanceNew("UICorner", confirm)

	local cancel = InstanceNew("TextButton")
	cancel.Size = UDim2.new(0, 130, 0, 32)
	cancel.Position = UDim2.new(0, 170, 0, 215)
	cancel.Text = "Cancel"
	cancel.Font = Enum.Font.GothamBold
	cancel.TextSize = 16
	cancel.BackgroundColor3 = Color3.fromRGB(180, 40, 40)
	cancel.TextColor3 = Color3.new(1, 1, 1)
	cancel.Parent = frame
	InstanceNew("UICorner", cancel)

	MouseButtonFix(confirm, function()
		applyGrip()
		closeUI()
	end)

	MouseButtonFix(preview, applyGrip)
	MouseButtonFix(cancel, closeUI)

	NAgui.draggerV2(frame)
end)

cmd.add({"seizure"}, {"seizure", "Gives you a seizure"}, function()
	SpawnCall(function()
		if getgenv().Lzzz == true then return end

		local Anim = InstanceNew("Animation")
		if IsR15() then
			Anim.AnimationId = "rbxassetid://507767968"
		else
			Anim.AnimationId = "rbxassetid://180436148"
		end
		local k = getHum():LoadAnimation(Anim)
		getgenv().ssss = LocalPlayer:GetMouse()
		getgenv().Lzzz = false

		if Lzzz == false then
			getgenv().Lzzz = true
			if IsR15() then
				Anim.AnimationId = "rbxassetid://507767968"
			else
				Anim.AnimationId = "rbxassetid://180436148"
			end
			getgenv().currentnormal = workspace.Gravity
			workspace.Gravity = 196.2
			LocalPlayer.Character:PivotTo(LocalPlayer.Character:GetPivot() * CFrame.Angles(2, 0, 0))
			Wait(0.5)
			if getHum() and getHum().PlatformStand then getHum().PlatformStand = true end
			LocalPlayer.Character.Animate.Disabled = true

			k:Play()
			k:AdjustSpeed(10)

			LocalPlayer.Character.Animate.Disabled = true
		else
			getgenv().Lzzz = false
			if IsR15() then
				Anim.AnimationId = "rbxassetid://507767968"
			else
				Anim.AnimationId = "rbxassetid://180436148"
			end
			workspace.Gravity = currentnormal
			if getHum() and getHum().PlatformStand then getHum().PlatformStand = false end
			getHum().Jump = true
			k:Stop()

			LocalPlayer.Character.Animate.Disabled = false
			RunService.Heartbeat:Wait()
			for i = 1,10 do
				getRoot(LocalPlayer.Character).AssemblyLinearVelocity = Vector3.new(0, 0, 0)
				Wait(0.1)
			end
		end

		RunService.RenderStepped:Connect(function()
			if Lzzz == true then
				getRoot(LocalPlayer.Character).CFrame = getRoot(LocalPlayer.Character).CFrame * CFrame.new(
					.075 * math.sin(45 * tick()),
					.075 * math.sin(45 * tick()),
					.075 * math.sin(45 * tick())
				)
			end
		end)
	end)
end)

cmd.add({"unseizure"}, {"unseizure", "Stops you from having a seizure not in real life noob"}, function()
	SpawnCall(function()
		if getgenv().Lzzz ~= true then return end

		local Anim = InstanceNew("Animation")
		if IsR15() then
			Anim.AnimationId = "rbxassetid://507767968"
		else
			Anim.AnimationId = "rbxassetid://180436148"
		end

		local k = getHum():LoadAnimation(Anim)

		getgenv().Lzzz = false
		workspace.Gravity = currentnormal
		if getHum() and getHum().PlatformStand then getHum().PlatformStand = false end
		getHum().Jump = true
		k:Stop()

		LocalPlayer.Character.Animate.Disabled = false

		RunService.Heartbeat:Wait()
		for i = 1, 10 do
			getRoot(LocalPlayer.Character).AssemblyLinearVelocity = Vector3.new(0, 0, 0)
			Wait(0.1)
		end
	end)
end)

FakeLagCfg = { interval = 0.05, jitter = 0.02, duration = nil }

cmd.add({"fakelag", "flag"}, {"fakelag (flag)", "fake lag"}, function(interval, jitter, duration)
	if type(interval) == "number" then FakeLagCfg.interval = math.max(0, interval) end
	if type(jitter) == "number" then FakeLagCfg.jitter = math.max(0, jitter) end
	if type(duration) == "number" then FakeLagCfg.duration = (duration > 0) and duration or nil end
	if FakeLag then return end
	FakeLag = true
	NAlib.disconnect("FakeLag")

	local function nextInterval()
		local b = tonumber(FakeLagCfg.interval) or 0.05
		local j = tonumber(FakeLagCfg.jitter) or 0
		if j <= 0 then return math.max(0, b) end
		return math.max(0, b + Random.new():NextNumber(-j, j))
	end

	local startTs = time()
	local state = false
	local nextFlipAt = time()

	NAlib.connect("FakeLag", RunService.Heartbeat:Connect(function()
		if not FakeLag then
			NAlib.disconnect("FakeLag")
			local r = getRoot(getChar())
			if r then NAlib.setProperty(r, "Anchored", false) end
			return
		end
		if FakeLagCfg.duration and (time() - startTs) > FakeLagCfg.duration then
			FakeLag = false
			NAlib.disconnect("FakeLag")
			local r = getRoot(getChar())
			if r then NAlib.setProperty(r, "Anchored", false) end
			return
		end
		local now = time()
		if now >= nextFlipAt then
			local r = getRoot(getChar())
			if r and r.Parent then
				state = not state
				NAlib.setProperty(r, "Anchored", state)
				nextFlipAt = now + nextInterval()
			else
				FakeLag = false
				NAlib.disconnect("FakeLag")
			end
		end
	end))
end)

cmd.add({"unfakelag", "unflag"}, {"unfakelag (unflag)", "stops the fake lag command"}, function()
	if not FakeLag and not NAlib.isConnected("FakeLag") then return end
	FakeLag = false
	NAlib.disconnect("FakeLag")
	local r = getRoot(getChar())
	if r then NAlib.setProperty(r, "Anchored", false) end
end)

r=math.rad
center=CFrame.new(1.5,0.5,-1.5)

cmd.add({"hide", "unshow"}, {"hide <player> (unshow)", "places the selected player to lighting"}, function(...)
	Wait()
	DebugNotif("Hid the player")
	local Username = (...)
	local target = getPlr(Username)
	for _, plr in next, target do
		if plr and plr.Character then
			local A_1 = "/mute "..plr.Name
			local A_2 = "All"
			NAlib.LocalPlayerChat(A_1, A_2)
			plr.Character.Parent = Lighting
		end
	end
end, true)

cmd.add({"unhide", "show"}, {"show <player> (unhide)", "places the selected player back to workspace"}, function(...)
	Wait()
	DebugNotif("Unhid the player")
	local Username = (...)
	local target = getPlr(Username)
	for _, plr in next, target do
		if plr and plr.Character then
			local A_1 = "/unmute "..plr.Name
			local A_2 = "All"
			NAlib.LocalPlayerChat(A_1, A_2)
			plr.Character.Parent = workspace
		end
	end
end, true)


if IsOnPC then
	cmd.add({"aimbot","aimbotui","aimbotgui"},{"aimbot (aimbotui,aimbotgui)","aimbot and yeah"},function()
		loadstring(game:HttpGet("https://raw.githubusercontent.com/ltseverydayyou/uuuuuuu/refs/heads/main/NewAimbot.lua"))()
		--loadstring(game:HttpGet("https://raw.githubusercontent.com/ltseverydayyou/uuuuuuu/refs/heads/main/Aimbot.lua",true))()
	end)
end

NAmanage.grabAllTools=function(range)
	local char = getChar()
	local hum = char and getHum()
	local root = char and getRoot(char)
	if not hum or not root then return 0 end

	range = tonumber(range)
	local useRange = range and range > 0

	local count = 0
	for _, tool in ipairs(workspace:GetDescendants()) do
		if tool:IsA("Tool") then
			if useRange then
				local handle = tool:FindFirstChild("Handle") or tool:FindFirstChildWhichIsA("BasePart")
				if handle and (handle.Position - root.Position).Magnitude <= range then
					if NACaller(function() hum:EquipTool(tool) end) then
						count += 1
					end
				end
			else
				if NACaller(function() hum:EquipTool(tool) end) then
					count += 1
				end
			end
		end
	end
	return count
end

cmd.add({"grabtools","gtools","gtls"},{"grabtools [range]","Grabs dropped tools"},function(...)
	local firstArg = ...
	local range = tonumber(firstArg)

	local count = NAmanage.grabAllTools(range)
	if count > 0 then
		if range and range > 0 then
			DebugNotif(("Grabbed %d tools within %d studs"):format(count, range), 2)
		else
			DebugNotif(("Grabbed %d tools"):format(count), 2)
		end
	else
		DebugNotif("No tools to grab", 2)
	end
end)

cmd.add({"loopgrabtools","lgtools","lgtls"},{"loopgrabtools [range]","Loop grabs dropped tools"},function(...)
	if loopgrab then
		DebugNotif("Loop grab already running", 2)
		return
	end
	local firstArg = ...
	local range = tonumber(firstArg)

	loopgrab = true
	DebugNotif("Started loop grabbing tools", 2)
	SpawnCall(function()
		while loopgrab do
			NAmanage.grabAllTools(range)
			Wait(1)
		end
		DebugNotif("Stopped loop grabbing tools", 2)
	end)
end)

cmd.add({"unloopgrabtools"},{"unloopgrabtools","Stops the loop grab command"},function()
	if not loopgrab then
		DebugNotif("Loop grab is not running", 2)
		return
	end
	loopgrab = false
end)

cmd.add({"dance"},{"dance","Does a random dance"},function()
	dances={"248263260","27789359","45834924","28488254","33796059","30196114","52155728"}
	if getChar():FindFirstChildOfClass('Humanoid').RigType==Enum.HumanoidRigType.R15 then
		dances={"4555808220","4555782893","3333432454","4049037604"}
	end
	if theanim then
		theanim:Stop()
		theanim:Destroy()
		local animation=InstanceNew("Animation")
		animation.AnimationId="rbxassetid://"..dances[math.random(1,#dances)]
		theanim=getChar():FindFirstChildOfClass('Humanoid'):LoadAnimation(animation)
		theanim:Play()
	else
		local animation=InstanceNew("Animation")
		animation.AnimationId="rbxassetid://"..dances[math.random(1,#dances)]
		theanim=getChar():FindFirstChildOfClass('Humanoid'):LoadAnimation(animation)
		theanim:Play()
	end
end)

cmd.add({"undance"},{"undance","Stops the dance command"},function()
	theanim:Stop()
	theanim:Destroy()
end)

cmd.add({"animspoofer","animationspoofer","spoofanim","animspoof"},{"animspoofer (animationspoofer, spoofanim, animspoof)","Loads up an animation spoofer,spoofs animations that use rbxassetid"},function()
	loadstring(game:HttpGet("https://raw.githubusercontent.com/ltseverydayyou/Nameless-Admin/main/Animation%20Spoofer"))()
end)

cmd.add({"badgeviewer", "badgeview", "bviewer","badgev","bv"},{"badgeviewer (badgeview, bviewer, badgev, bv)","loads up a badge viewer UI that views all badges in the game you're in"},function()
	local BadgeService = SafeGetService("BadgeService")
	local Player = Players.LocalPlayer

	local COLORS = {
		PANEL = Color3.fromRGB(28, 28, 32),
		TOP = Color3.fromRGB(24, 24, 26),
		TEXT = Color3.fromRGB(240, 240, 240),
		MUTED = Color3.fromRGB(180, 180, 185),
		STROKE = Color3.fromRGB(60, 60, 65),
		OWNED = Color3.fromRGB(65, 200, 120),
		BAD = Color3.fromRGB(255, 90, 90),
		BUTTON = Color3.fromRGB(34, 34, 38),
		BUTTON_DARK = Color3.fromRGB(44, 44, 48),
	}

	local OWNERSHIP_CACHE = getgenv().__BadgeOwnershipCache or {}
	getgenv().__BadgeOwnershipCache = OWNERSHIP_CACHE
	local CACHE_TTL_SECS = 600

	local function cacheGet(userId, badgeId)
		local u = OWNERSHIP_CACHE[userId]
		if not u then return nil end
		local e = u[badgeId]
		if not e then return nil end
		if os.time() - e.t > CACHE_TTL_SECS then return nil end
		return e.v
	end

	local function cachePut(userId, badgeId, value)
		OWNERSHIP_CACHE[userId] = OWNERSHIP_CACHE[userId] or {}
		OWNERSHIP_CACHE[userId][badgeId] = { v = value, t = os.time() }
	end

	local function hasBadgeWithRetry(userId, badgeId)
		local cached = cacheGet(userId, badgeId)
		if cached ~= nil then
			return true, cached
		end
		local tries, delay = 0, 0.5
		while tries < 5 do
			tries += 1
			local ok, has = pcall(BadgeService.UserHasBadgeAsync, BadgeService, userId, badgeId)
			if ok then
				has = has == true
				cachePut(userId, badgeId, has)
				return true, has
			end
			Wait(delay)
			delay = delay * 1.6
		end
		return false, nil
	end

	local function getBadges()
		local all, cursor = {}, ""
		repeat
			local url = ("https://badges.roproxy.com/v1/universes/%d/badges?limit=100&sortOrder=Asc%s"):format(
				GameId,
				cursor ~= "" and "&cursor="..HttpService:UrlEncode(cursor) or ""
			)
			local res = opt.NAREQUEST({Url = url, Method = "GET"})
			if not res or res.StatusCode ~= 200 then break end
			local body = HttpService:JSONDecode(res.Body)
			for _, b in ipairs(body.data or {}) do
				Insert(all, {
					id = b.id,
					name = b.name,
					desc = b.displayDescription or b.description or "",
					icon = b.iconImageId,
					rarity = (b.statistics and b.statistics.winRatePercentage) or 0,
					awarded = (b.statistics and b.statistics.awardedCount) or 0,
					pastDay = (b.statistics and b.statistics.pastDayAwardedCount) or 0,
					universe = (b.awardingUniverse and b.awardingUniverse.name) or "Unknown",
				})
			end
			cursor = body.nextPageCursor or ""
		until cursor == ""
		return all
	end

	local function pill(parent, text, color)
		local p = InstanceNew("TextLabel", parent)
		p.BackgroundColor3 = color
		p.BackgroundTransparency = 0.15
		p.TextColor3 = Color3.new(1,1,1)
		p.Font = Enum.Font.GothamSemibold
		p.Text = text
		p.Size = UDim2.new(0, 0, 0, 0)
		p.AutomaticSize = Enum.AutomaticSize.XY
		p.AnchorPoint = Vector2.new(1,0)
		p.Position = UDim2.new(1, -10, 0, 10)
		p.TextScaled = true
		local pc = InstanceNew("UICorner", p); pc.CornerRadius = UDim.new(0, 999)
		local pad = InstanceNew("UIPadding", p)
		pad.PaddingLeft = UDim.new(0, 10)
		pad.PaddingRight = UDim.new(0, 10)
		pad.PaddingTop = UDim.new(0, 6)
		pad.PaddingBottom = UDim.new(0, 6)
		local ts = InstanceNew("UITextSizeConstraint", p); ts.MinTextSize = 10; ts.MaxTextSize = 16
		p.Visible = false
		return p
	end

	local function applyOwnedStyle(card, stroke, ownedTag)
		stroke.Color = COLORS.OWNED
		stroke.Transparency = 0
		stroke.Thickness = 2
		card.BackgroundTransparency = 0.1
		card.BackgroundColor3 = Color3.fromRGB(35, 44, 38)
		ownedTag.Visible = true
	end

	local function tweenTransparency(container, target, tinfo)
		for _, d in ipairs(container:GetDescendants()) do
			if d:IsA("TextLabel") or d:IsA("TextButton") or d:IsA("TextBox") then
				TweenService:Create(d, tinfo, {TextTransparency = target}):Play()
			elseif d:IsA("ImageLabel") or d:IsA("ImageButton") then
				TweenService:Create(d, tinfo, {ImageTransparency = target}):Play()
			elseif d:IsA("Frame") then
				TweenService:Create(d, tinfo, {BackgroundTransparency = math.clamp(target,0,1)}):Play()
			elseif d:IsA("UIStroke") then
				TweenService:Create(d, tinfo, {Transparency = target}):Play()
			end
		end
	end

	local function copyToClipboard(str, msg)
		local s = tostring(str)
		local ok
		if setclipboard then
			setclipboard(s)
			ok = true
		end
		if ok then
			DoNotif(msg or "Copied to clipboard",2)
		end
	end

	local function createBadgeUI(data)
		local sgui = InstanceNew("ScreenGui")
		NaProtectUI(sgui)
		sgui.Name = "BadgeViewer"

		local headerH = 70
		local expandedMainSize = IsOnMobile and UDim2.new(0.96,0,0.86,0) or UDim2.new(0.75,0,0.78,0)

		local main = InstanceNew("Frame", sgui)
		main.Size = expandedMainSize
		main.Position = UDim2.new(0.5,0,0.5,0)
		main.AnchorPoint = Vector2.new(0.5,0.5)
		main.BackgroundColor3 = COLORS.PANEL
		main.BackgroundTransparency = 0.08
		main.BorderSizePixel = 0
		main.ClipsDescendants = true
		main.Active = true
		main.Name = "Main"
		local uicorner = InstanceNew("UICorner", main); uicorner.CornerRadius = UDim.new(0, 14)
		local stroke = InstanceNew("UIStroke", main); stroke.Color = COLORS.STROKE; stroke.Thickness = 1; stroke.Transparency = 0.2

		local grad = InstanceNew("UIGradient", main)
		grad.Rotation = 90
		grad.Color = ColorSequence.new({
			ColorSequenceKeypoint.new(0, Color3.fromRGB(40,40,46)),
			ColorSequenceKeypoint.new(1, Color3.fromRGB(20,20,24))
		})
		grad.Transparency = NumberSequence.new({
			NumberSequenceKeypoint.new(0, 0),
			NumberSequenceKeypoint.new(1, 0.25)
		})

		local header = InstanceNew("Frame", main)
		header.Size = UDim2.new(1, 0, 0, headerH)
		header.BackgroundColor3 = COLORS.TOP
		header.BackgroundTransparency = 0.12

		local headerC = InstanceNew("UICorner", header); headerC.CornerRadius = UDim.new(0, 14)

		local title = InstanceNew("TextLabel", header)
		title.Position = UDim2.new(0, 12, 0, 6)
		title.Size = UDim2.new(0.5, -24, 0, 24)
		title.Text = "Badge Viewer"
		title.Font = Enum.Font.GothamBold
		title.TextColor3 = COLORS.TEXT
		title.BackgroundTransparency = 1
		title.TextXAlignment = Enum.TextXAlignment.Left
		title.TextScaled = true
		local tsTitle = InstanceNew("UITextSizeConstraint", title); tsTitle.MinTextSize = 14; tsTitle.MaxTextSize = 20

		local statLabel = InstanceNew("TextLabel", header)
		statLabel.Position = UDim2.new(1, -160, 0, 6)
		statLabel.Size = UDim2.new(0, 140, 0, 24)
		statLabel.Text = ""
		statLabel.Font = Enum.Font.Gotham
		statLabel.TextColor3 = COLORS.MUTED
		statLabel.BackgroundTransparency = 1
		statLabel.TextXAlignment = Enum.TextXAlignment.Right
		statLabel.TextScaled = true
		statLabel.ZIndex = 6
		local tsStat = InstanceNew("UITextSizeConstraint", statLabel); tsStat.MinTextSize = 11; tsStat.MaxTextSize = 16

		local fixedBar = InstanceNew("Frame", header)
		fixedBar.AnchorPoint = Vector2.new(1,0)
		fixedBar.Position = UDim2.new(1, -8, 0, headerH-28)
		fixedBar.Size = UDim2.new(0, 72, 0, 22)
		fixedBar.BackgroundTransparency = 1
		fixedBar.ZIndex = 5
		local fixedLayout = InstanceNew("UIListLayout", fixedBar)
		fixedLayout.FillDirection = Enum.FillDirection.Horizontal
		fixedLayout.VerticalAlignment = Enum.VerticalAlignment.Center
		fixedLayout.HorizontalAlignment = Enum.HorizontalAlignment.Right
		fixedLayout.Padding = UDim.new(0, 4)

		local minBtn = InstanceNew("TextButton", fixedBar)
		minBtn.Size = UDim2.new(0, 32, 1, 0)
		minBtn.Text = "-"
		minBtn.Font = Enum.Font.Gotham
		minBtn.BackgroundTransparency = 1
		minBtn.TextColor3 = COLORS.MUTED
		minBtn.TextScaled = true
		minBtn.ZIndex = 6
		local tsMin = InstanceNew("UITextSizeConstraint", minBtn); tsMin.MinTextSize = 14; tsMin.MaxTextSize = 22

		local closeBtn = InstanceNew("TextButton", fixedBar)
		closeBtn.Size = UDim2.new(0, 32, 1, 0)
		closeBtn.Text = "X"
		closeBtn.Font = Enum.Font.Gotham
		closeBtn.BackgroundTransparency = 1
		closeBtn.TextColor3 = COLORS.BAD
		closeBtn.TextScaled = true
		closeBtn.ZIndex = 6
		local tsClose = InstanceNew("UITextSizeConstraint", closeBtn); tsClose.MinTextSize = 14; tsClose.MaxTextSize = 22

		local tabsScroll = InstanceNew("ScrollingFrame", header)
		tabsScroll.Name = "TabsScroll"
		tabsScroll.Position = UDim2.new(0, 8, 0, headerH-30)
		tabsScroll.Size = UDim2.new(1, -16, 0, 24)
		tabsScroll.BackgroundTransparency = 1
		tabsScroll.ScrollBarThickness = 4
		tabsScroll.ScrollingDirection = Enum.ScrollingDirection.X
		tabsScroll.AutomaticCanvasSize = Enum.AutomaticSize.X
		tabsScroll.CanvasSize = UDim2.new(0,0,0,0)

		local tabsRow = InstanceNew("Frame", tabsScroll)
		tabsRow.BackgroundTransparency = 1
		tabsRow.AutomaticSize = Enum.AutomaticSize.XY
		tabsRow.Size = UDim2.new(0,0,1,0)
		local tabsLayout = InstanceNew("UIListLayout", tabsRow)
		tabsLayout.FillDirection = Enum.FillDirection.Horizontal
		tabsLayout.VerticalAlignment = Enum.VerticalAlignment.Center
		tabsLayout.Padding = UDim.new(0, 8)

		local function mkBtn(parent, text, w)
			local b = InstanceNew("TextButton", parent)
			b.AutoButtonColor = false
			b.Text = text
			b.Font = Enum.Font.GothamSemibold
			b.TextColor3 = COLORS.TEXT
			b.Size = UDim2.new(0, w, 0, 24)
			b.BackgroundColor3 = COLORS.BUTTON
			b.BackgroundTransparency = 0.2
			b.TextScaled = true
			b.ZIndex = 5
			local c = InstanceNew("UICorner", b); c.CornerRadius = UDim.new(0, 8)
			local s = InstanceNew("UIStroke", b); s.Color = COLORS.STROKE; s.Thickness = 1; s.Transparency = 0.5
			local ts = InstanceNew("UITextSizeConstraint", b); ts.MinTextSize = 10; ts.MaxTextSize = 18

			local function hover(v)
				local target = v and 0.12 or 0.2
				local st = v and 0.35 or 0.5
				TweenService:Create(b, TweenInfo.new(0.14, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {BackgroundTransparency = target}):Play()
				TweenService:Create(s, TweenInfo.new(0.14, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {Transparency = st}):Play()
			end

			if IsOnPC then
				NAlib.connect("BadgeViewer", b.MouseEnter:Connect(function() hover(true) end))
				NAlib.connect("BadgeViewer", b.MouseLeave:Connect(function() hover(false) end))
			end

			return b
		end

		local searchWrap = InstanceNew("Frame", tabsRow)
		searchWrap.BackgroundColor3 = COLORS.BUTTON
		searchWrap.BackgroundTransparency = 0.18
		searchWrap.Size = UDim2.new(0, 260, 0, 24)
		local swC = InstanceNew("UICorner", searchWrap); swC.CornerRadius = UDim.new(0, 8)
		local swS = InstanceNew("UIStroke", searchWrap); swS.Color = COLORS.STROKE; swS.Thickness = 1; swS.Transparency = 0.6

		local swPad = InstanceNew("UIPadding", searchWrap)
		swPad.PaddingLeft = UDim.new(0, 8)
		swPad.PaddingRight = UDim.new(0, 8)

		local swLayout = InstanceNew("UIListLayout", searchWrap)
		swLayout.FillDirection = Enum.FillDirection.Horizontal
		swLayout.VerticalAlignment = Enum.VerticalAlignment.Center
		swLayout.Padding = UDim.new(0, 6)

		local searchIcon = InstanceNew("TextLabel", searchWrap)
		searchIcon.BackgroundTransparency = 1
		searchIcon.Text = "🔎"
		searchIcon.Font = Enum.Font.Gotham
		searchIcon.TextColor3 = COLORS.MUTED
		searchIcon.TextScaled = true
		searchIcon.Size = UDim2.new(0, 18, 1, 0)
		local tsSI = InstanceNew("UITextSizeConstraint", searchIcon); tsSI.MinTextSize = 12; tsSI.MaxTextSize = 18

		local search = InstanceNew("TextBox", searchWrap)
		search.Size = UDim2.new(1, -70, 1, 0)
		search.PlaceholderText = "Search badges..."
		search.ClearTextOnFocus = false
		search.Text = ""
		search.BackgroundTransparency = 1
		search.TextColor3 = COLORS.TEXT
		search.PlaceholderColor3 = COLORS.MUTED
		search.TextXAlignment = Enum.TextXAlignment.Left
		search.Font = Enum.Font.Gotham
		search.TextScaled = true
		local tsSearch = InstanceNew("UITextSizeConstraint", search); tsSearch.MinTextSize = 10; tsSearch.MaxTextSize = 18

		local clearSearch = InstanceNew("TextButton", searchWrap)
		clearSearch.BackgroundTransparency = 1
		clearSearch.Text = "Clear"
		clearSearch.Font = Enum.Font.GothamSemibold
		clearSearch.TextColor3 = COLORS.MUTED
		clearSearch.TextScaled = true
		clearSearch.Size = UDim2.new(0, 40, 1, 0)
		clearSearch.Visible = false
		local tsClr = InstanceNew("UITextSizeConstraint", clearSearch); tsClr.MinTextSize = 10; tsClr.MaxTextSize = 16

		local ownedOnlyBtn = mkBtn(tabsRow, "Owned: OFF", 110)
		local unownedOnlyBtn = mkBtn(tabsRow, "Unowned: OFF", 130)
		local layoutToggle = mkBtn(tabsRow, "List", 80)
		local sortBtn = mkBtn(tabsRow, "Sort: Default", 130)
		local refreshBtn = mkBtn(tabsRow, "Refresh", 100)

		local content = InstanceNew("Frame", main)
		content.Name = "Content"
		content.Size = UDim2.new(1, 0, 1, -headerH)
		content.Position = UDim2.new(0, 0, 0, headerH)
		content.BackgroundTransparency = 1
		content.ClipsDescendants = true

		local scroll = InstanceNew("ScrollingFrame", content)
		scroll.Size = UDim2.new(1, 0, 1, 0)
		scroll.BackgroundTransparency = 1
		scroll.ScrollBarThickness = 6
		scroll.AutomaticCanvasSize = Enum.AutomaticSize.Y
		scroll.CanvasSize = UDim2.new(0,0,0,0)

		local pad = InstanceNew("UIPadding", scroll)
		pad.PaddingLeft = UDim.new(0, 10)
		pad.PaddingRight = UDim.new(0, 10)
		pad.PaddingTop = UDim.new(0, 10)
		pad.PaddingBottom = UDim.new(0, 10)

		local listLayout = InstanceNew("UIListLayout")
		listLayout.Padding = UDim.new(0, 10)
		listLayout.SortOrder = Enum.SortOrder.LayoutOrder

		local gridLayout = InstanceNew("UIGridLayout")
		gridLayout.FillDirection = Enum.FillDirection.Horizontal
		gridLayout.HorizontalAlignment = Enum.HorizontalAlignment.Left
		gridLayout.VerticalAlignment = Enum.VerticalAlignment.Top
		gridLayout.SortOrder = Enum.SortOrder.LayoutOrder
		gridLayout.CellPadding = UDim2.new(0.02, 0, 0, 8)
		gridLayout.CellSize = UDim2.new(0.48, 0, 0, 200)

		local loadingOverlay = InstanceNew("Frame", content)
		loadingOverlay.Size = UDim2.new(1,0,1,0)
		loadingOverlay.BackgroundColor3 = Color3.new(0,0,0)
		loadingOverlay.BackgroundTransparency = 0.6
		loadingOverlay.Visible = true
		loadingOverlay.ZIndex = 50
		local loadingBox = InstanceNew("Frame", loadingOverlay)
		loadingBox.AnchorPoint = Vector2.new(0.5,0.5)
		loadingBox.Position = UDim2.new(0.5,0,0.5,0)
		loadingBox.Size = UDim2.new(0,220,0,60)
		loadingBox.BackgroundColor3 = COLORS.PANEL
		loadingBox.BackgroundTransparency = 0.08
		loadingBox.ZIndex = 51
		local lbC = InstanceNew("UICorner", loadingBox); lbC.CornerRadius = UDim.new(0, 14)
		local lbS = InstanceNew("UIStroke", loadingBox); lbS.Color = COLORS.STROKE; lbS.Thickness = 1; lbS.Transparency = 0.3
		local loadingText = InstanceNew("TextLabel", loadingBox)
		loadingText.AnchorPoint = Vector2.new(0.5,0.5)
		loadingText.Position = UDim2.new(0.5,0,0.5,0)
		loadingText.Size = UDim2.new(1,0,1,0)
		loadingText.BackgroundTransparency = 1
		loadingText.Text = "Loading..."
		loadingText.Font = Enum.Font.GothamSemibold
		loadingText.TextColor3 = COLORS.TEXT
		loadingText.TextScaled = true
		loadingText.ZIndex = 52
		local ltSz = InstanceNew("UITextSizeConstraint", loadingText); ltSz.MinTextSize = 12; ltSz.MaxTextSize = 24

		local function updateGridColumns()
			local w = scroll.AbsoluteSize.X
			if w <= 0 then return end
			local cols
			if w < 480 then
				cols = 1
			elseif w < 900 then
				cols = 2
			else
				cols = 3
			end
			local padScale = 0.02
			local widthScale = (1 - padScale * (cols - 1)) / cols
			gridLayout.CellPadding = UDim2.new(padScale,0,0,8)
			gridLayout.CellSize = UDim2.new(widthScale,0,0,200)
		end
		scroll:GetPropertyChangedSignal("AbsoluteSize"):Connect(updateGridColumns)
		Defer(updateGridColumns)

		local ownedOnly = false
		local unownedOnly = false
		local useGrid = false
		local ownedMap = {}
		local listCards, gridCards = {}, {}
		local idToCards = {}
		local badgesData = data
		local gridBuilt = false

		local function mkToolBtn(parent, label, cb)
			local b = InstanceNew("TextButton", parent)
			b.BackgroundColor3 = COLORS.BUTTON_DARK
			b.BackgroundTransparency = 0.18
			b.AutoButtonColor = true
			b.Text = label
			b.Font = Enum.Font.GothamSemibold
			b.TextColor3 = COLORS.TEXT
			b.TextScaled = true
			b.Size = UDim2.new(0, 54, 1, 0)
			local c = InstanceNew("UICorner", b); c.CornerRadius = UDim.new(0, 6)
			local s = InstanceNew("UIStroke", b); s.Color = COLORS.STROKE; s.Thickness = 1; s.Transparency = 0.4
			local ts = InstanceNew("UITextSizeConstraint", b); ts.MinTextSize = 9; ts.MaxTextSize = 13
			NAlib.connect("BadgeViewer", MouseButtonFix(b, cb))
			return b
		end

		local function makeListCard(b)
			local f = InstanceNew("Frame")
			f.Size = UDim2.new(1, 0, 0, 138)
			f.BackgroundColor3 = Color3.fromRGB(36, 36, 40)
			f.BackgroundTransparency = 0.12
			f.ClipsDescendants = true
			local fc = InstanceNew("UICorner", f); fc.CornerRadius = UDim.new(0, 12)
			local fs = InstanceNew("UIStroke", f); fs.Color = COLORS.STROKE; fs.Thickness = 1; fs.Transparency = 0.2

			local img = InstanceNew("ImageLabel", f)
			img.Size = UDim2.new(0, 96, 0, 96)
			img.Position = UDim2.new(0, 14, 0, 16)
			img.BackgroundTransparency = 1
			img.Image = "rbxthumb://type=Asset&id="..tostring(b.icon or 0).."&w=420&h=420"

			local titleL = InstanceNew("TextLabel", f)
			titleL.Position = UDim2.new(0, 120, 0, 14)
			titleL.Size = UDim2.new(1, -140, 0, 24)
			titleL.Text = b.name or ("Badge "..tostring(b.id))
			titleL.TextColor3 = COLORS.TEXT
			titleL.BackgroundTransparency = 1
			titleL.Font = Enum.Font.GothamSemibold
			titleL.TextXAlignment = Enum.TextXAlignment.Left
			titleL.TextTruncate = Enum.TextTruncate.AtEnd
			titleL.TextScaled = true
			local tsLT = InstanceNew("UITextSizeConstraint", titleL); tsLT.MinTextSize = 10; tsLT.MaxTextSize = 18

			local desc = InstanceNew("TextLabel", f)
			desc.Position = UDim2.new(0, 120, 0, 42)
			desc.Size = UDim2.new(1, -140, 0, 34)
			desc.Text = b.desc
			desc.TextWrapped = true
			desc.TextColor3 = COLORS.MUTED
			desc.BackgroundTransparency = 1
			desc.Font = Enum.Font.Gotham
			desc.TextXAlignment = Enum.TextXAlignment.Left
			desc.TextYAlignment = Enum.TextYAlignment.Top
			desc.TextScaled = true
			local tsLD = InstanceNew("UITextSizeConstraint", desc); tsLD.MinTextSize = 9; tsLD.MaxTextSize = 14

			local stat = InstanceNew("TextLabel", f)
			stat.Position = UDim2.new(0, 120, 0, 80)
			stat.Size = UDim2.new(1, -200, 0, 26)
			stat.Text = Format("🎯 %.2f%%   📈 %d   ⏱️ %d   🧭 %s", b.rarity, b.awarded, b.pastDay, b.universe)
			stat.TextColor3 = Color3.fromRGB(160, 160, 165)
			stat.BackgroundTransparency = 1
			stat.Font = Enum.Font.Gotham
			stat.TextXAlignment = Enum.TextXAlignment.Left
			stat.TextScaled = true
			local tsLS = InstanceNew("UITextSizeConstraint", stat); tsLS.MinTextSize = 9; tsLS.MaxTextSize = 13

			local tools = InstanceNew("Frame", f)
			tools.AnchorPoint = Vector2.new(1,1)
			tools.Position = UDim2.new(1, -10, 1, -8)
			tools.Size = UDim2.new(0, 190, 0, 22)
			tools.BackgroundColor3 = COLORS.BUTTON
			tools.BackgroundTransparency = 0.35
			tools.BorderSizePixel = 0
			local tC = InstanceNew("UICorner", tools); tC.CornerRadius = UDim.new(0, 999)
			local tS = InstanceNew("UIStroke", tools); tS.Color = COLORS.STROKE; tS.Thickness = 1; tS.Transparency = 0.7
			local tl = InstanceNew("UIListLayout", tools)
			tl.FillDirection = Enum.FillDirection.Horizontal
			tl.VerticalAlignment = Enum.VerticalAlignment.Center
			tl.HorizontalAlignment = Enum.HorizontalAlignment.Center
			tl.Padding = UDim.new(0, 6)

			mkToolBtn(tools, "Name", function()
				copyToClipboard(b.name or ("Badge "..tostring(b.id)), "Copied badge name")
			end)
			mkToolBtn(tools, "ID", function()
				copyToClipboard(b.id, "Copied badge ID")
			end)
			mkToolBtn(tools, "URL", function()
				copyToClipboard("https://www.roblox.com/badges/"..tostring(b.id), "Copied badge URL")
			end)

			local ownedTag = pill(f, "OWNED", COLORS.OWNED)

			f.Parent = scroll
			local card = {frame=f, data=b, stroke=fs, ownedTag=ownedTag}
			idToCards[b.id] = idToCards[b.id] or {}
			idToCards[b.id].list = card
			Insert(listCards, card)
			return card
		end

		local function makeGridCard(b)
			local f = InstanceNew("Frame")
			f.Size = UDim2.new(1, 0, 0, 200)
			f.BackgroundColor3 = Color3.fromRGB(36, 36, 40)
			f.BackgroundTransparency = 0.12
			f.ClipsDescendants = true
			local fc = InstanceNew("UICorner", f); fc.CornerRadius = UDim.new(0, 12)
			local fs = InstanceNew("UIStroke", f); fs.Color = COLORS.STROKE; fs.Thickness = 1; fs.Transparency = 0.2

			local img = InstanceNew("ImageLabel", f)
			img.AnchorPoint = Vector2.new(0.5,0)
			img.Position = UDim2.new(0.5, 0, 0, 12)
			img.Size = UDim2.new(0, 72, 0, 72)
			img.BackgroundTransparency = 1
			img.Image = "rbxthumb://type=Asset&id="..tostring(b.icon or 0).."&w=420&h=420"

			local titleL = InstanceNew("TextLabel", f)
			titleL.AnchorPoint = Vector2.new(0.5,0)
			titleL.Position = UDim2.new(0.5, 0, 0, 90)
			titleL.Size = UDim2.new(0.9, 0, 0, 20)
			titleL.Text = b.name or ("Badge "..tostring(b.id))
			titleL.TextColor3 = COLORS.TEXT
			titleL.BackgroundTransparency = 1
			titleL.Font = Enum.Font.GothamSemibold
			titleL.TextXAlignment = Enum.TextXAlignment.Center
			titleL.TextTruncate = Enum.TextTruncate.AtEnd
			titleL.TextScaled = true
			local tsGT = InstanceNew("UITextSizeConstraint", titleL); tsGT.MinTextSize = 10; tsGT.MaxTextSize = 16

			local desc = InstanceNew("TextLabel", f)
			desc.AnchorPoint = Vector2.new(0.5,0)
			desc.Position = UDim2.new(0.5, 0, 0, 112)
			desc.Size = UDim2.new(0.9, 0, 0, 30)
			desc.Text = b.desc
			desc.TextWrapped = true
			desc.TextColor3 = COLORS.MUTED
			desc.BackgroundTransparency = 1
			desc.Font = Enum.Font.Gotham
			desc.TextXAlignment = Enum.TextXAlignment.Center
			desc.TextYAlignment = Enum.TextYAlignment.Top
			desc.TextScaled = true
			local tsGD = InstanceNew("UITextSizeConstraint", desc); tsGD.MinTextSize = 9; tsGD.MaxTextSize = 13

			local stat = InstanceNew("TextLabel", f)
			stat.AnchorPoint = Vector2.new(0.5,0)
			stat.Position = UDim2.new(0.5, 0, 0, 144)
			stat.Size = UDim2.new(0.9, 0, 0, 20)
			stat.Text = Format("🎯 %.1f%%  📈 %d  ⏱️ %d", b.rarity, b.awarded, b.pastDay)
			stat.TextColor3 = Color3.fromRGB(160, 160, 165)
			stat.BackgroundTransparency = 1
			stat.Font = Enum.Font.Gotham
			stat.TextXAlignment = Enum.TextXAlignment.Center
			stat.TextScaled = true
			local tsGS = InstanceNew("UITextSizeConstraint", stat); tsGS.MinTextSize = 9; tsGS.MaxTextSize = 13

			local tools = InstanceNew("Frame", f)
			tools.AnchorPoint = Vector2.new(0.5,1)
			tools.Position = UDim2.new(0.5, 0, 1, -10)
			tools.Size = UDim2.new(0.9, 0, 0, 22)
			tools.BackgroundColor3 = COLORS.BUTTON
			tools.BackgroundTransparency = 0.35
			tools.BorderSizePixel = 0
			local tC = InstanceNew("UICorner", tools); tC.CornerRadius = UDim.new(0, 999)
			local tS = InstanceNew("UIStroke", tools); tS.Color = COLORS.STROKE; tS.Thickness = 1; tS.Transparency = 0.7
			local tl = InstanceNew("UIListLayout", tools)
			tl.FillDirection = Enum.FillDirection.Horizontal
			tl.VerticalAlignment = Enum.VerticalAlignment.Center
			tl.HorizontalAlignment = Enum.HorizontalAlignment.Center
			tl.Padding = UDim.new(0, 6)

			mkToolBtn(tools, "Name", function()
				copyToClipboard(b.name or ("Badge "..tostring(b.id)), "Copied badge name")
			end)
			mkToolBtn(tools, "ID", function()
				copyToClipboard(b.id, "Copied badge ID")
			end)
			mkToolBtn(tools, "URL", function()
				copyToClipboard("https://www.roblox.com/badges/"..tostring(b.id), "Copied badge URL")
			end)

			local ownedTag = pill(f, "OWNED", COLORS.OWNED)

			local card = {frame=f, data=b, stroke=fs, ownedTag=ownedTag}
			idToCards[b.id] = idToCards[b.id] or {}
			idToCards[b.id].grid = card
			Insert(gridCards, card)
			return card
		end

		for _, b in ipairs(badgesData) do
			makeListCard(b)
		end

		local function buildGridIfNeeded()
			if gridBuilt then return end
			for _, b in ipairs(badgesData) do
				local c = makeGridCard(b)
				c.frame.Parent = nil
			end
			gridBuilt = true
		end

		local function textContains(h, n)
			if n == "" then return true end
			h = Lower(h or ""); n = Lower(n or "")
			return Find(h, n, 1, true) ~= nil
		end

		local function setStatLabel()
			local q = search.Text
			local src = useGrid and gridCards or listCards
			local visible = 0
			for _, c in ipairs(src) do
				if c.frame.Parent == scroll and c.frame.Visible then
					visible += 1
				end
			end
			local total = #badgesData
			local extra = ""
			if ownedOnly then extra = extra.." • owned" end
			if unownedOnly then extra = extra.." • unowned" end
			if q ~= "" then extra = extra.." • search" end
			statLabel.Text = ("%d/%d%s"):format(visible, total, extra)
		end

		local function applyOwnedVisualsFor(id)
			local pair = idToCards[id]
			if not pair then return end
			if pair.list then applyOwnedStyle(pair.list.frame, pair.list.stroke, pair.list.ownedTag) end
			if pair.grid then applyOwnedStyle(pair.grid.frame, pair.grid.stroke, pair.grid.ownedTag) end
		end

		local function refreshOwnedStylesForAll()
			for id, v in pairs(ownedMap) do
				if v == true then applyOwnedVisualsFor(id) end
			end
		end

		local sortModeIndex = 1
		local sortMode = "default"
		local sortModes = {
			{id="default", label="Sort: Default"},
			{id="rarityDesc", label="Sort: Rarity ↓"},
			{id="rarityAsc", label="Sort: Rarity ↑"},
			{id="nameAsc", label="Sort: Name A-Z"},
			{id="nameDesc", label="Sort: Name Z-A"},
		}

		local function applySort()
			local arr = {}
			for _, b in ipairs(badgesData) do
				Insert(arr, b)
			end
			table.sort(arr, function(a, b)
				if sortMode == "rarityDesc" then
					return (a.rarity or 0) > (b.rarity or 0)
				elseif sortMode == "rarityAsc" then
					return (a.rarity or 0) < (b.rarity or 0)
				elseif sortMode == "nameAsc" then
					return Lower(a.name or "") < Lower(b.name or "")
				elseif sortMode == "nameDesc" then
					return Lower(a.name or "") > Lower(b.name or "")
				else
					return (a.id or 0) < (b.id or 0)
				end
			end)
			for i, b in ipairs(arr) do
				local pair = idToCards[b.id]
				if pair then
					if pair.list and pair.list.frame then pair.list.frame.LayoutOrder = i end
					if pair.grid and pair.grid.frame then pair.grid.frame.LayoutOrder = i end
				end
			end
		end

		local function applyFilters()
			local q = search.Text
			for _, card in ipairs(listCards) do
				if card.frame.Parent == scroll then
					local id = card.data.id
					local show = textContains(card.data.name.." "..card.data.desc, q)
					if ownedOnly then
						show = show and (ownedMap[id] == true)
					elseif unownedOnly then
						show = show and (ownedMap[id] == false)
					end
					card.frame.Visible = show
				end
			end
			for _, card in ipairs(gridCards) do
				if card.frame.Parent == scroll then
					local id = card.data.id
					local show = textContains(card.data.name.." "..card.data.desc, q)
					if ownedOnly then
						show = show and (ownedMap[id] == true)
					elseif unownedOnly then
						show = show and (ownedMap[id] == false)
					end
					card.frame.Visible = show
				end
			end
			clearSearch.Visible = (search.Text ~= "")
			setStatLabel()
		end

		local function attachLayout()
			listLayout.Parent = nil
			gridLayout.Parent = nil
			for _, c in ipairs(listCards) do c.frame.Parent = nil end
			for _, c in ipairs(gridCards) do c.frame.Parent = nil end
			if useGrid then
				buildGridIfNeeded()
				gridLayout.Parent = scroll
				pad.PaddingLeft = UDim.new(0, 10)
				pad.PaddingRight = UDim.new(0, 10)
				pad.PaddingTop = UDim.new(0, 10)
				pad.PaddingBottom = UDim.new(0, 10)
				for _, c in ipairs(gridCards) do c.frame.Parent = scroll end
				layoutToggle.Text = "Grid"
			else
				listLayout.Parent = scroll
				pad.PaddingLeft = UDim.new(0, 10)
				pad.PaddingRight = UDim.new(0, 10)
				pad.PaddingTop = UDim.new(0, 10)
				pad.PaddingBottom = UDim.new(0, 10)
				for _, c in ipairs(listCards) do c.frame.Parent = scroll end
				layoutToggle.Text = "List"
			end
			updateGridColumns()
			refreshOwnedStylesForAll()
			applySort()
			applyFilters()
		end

		local function setOwnedOnly(v)
			ownedOnly = v and true or false
			if ownedOnly then unownedOnly = false end
			ownedOnlyBtn.Text = ownedOnly and "Owned: ON" or "Owned: OFF"
			unownedOnlyBtn.Text = "Unowned: OFF"
			applyFilters()
		end

		local function setUnownedOnly(v)
			unownedOnly = v and true or false
			if unownedOnly then ownedOnly = false end
			unownedOnlyBtn.Text = unownedOnly and "Unowned: ON" or "Unowned: OFF"
			ownedOnlyBtn.Text = "Owned: OFF"
			applyFilters()
		end

		search:GetPropertyChangedSignal("Text"):Connect(applyFilters)
		MouseButtonFix(clearSearch, function()
			search.Text = ""
		end)
		MouseButtonFix(ownedOnlyBtn, function() setOwnedOnly(not ownedOnly) end)
		MouseButtonFix(unownedOnlyBtn, function() setUnownedOnly(not unownedOnly) end)

		MouseButtonFix(layoutToggle, function()
			useGrid = not useGrid
			attachLayout()
		end)

		MouseButtonFix(sortBtn, function()
			sortModeIndex += 1
			if sortModeIndex > #sortModes then sortModeIndex = 1 end
			sortMode = sortModes[sortModeIndex].id
			sortBtn.Text = sortModes[sortModeIndex].label
			applySort()
			applyFilters()
		end)

		local minimized = false
		local function minimize()
			if minimized then return end
			tweenTransparency(content, 1, TweenInfo.new(0.18, Enum.EasingStyle.Quad, Enum.EasingDirection.Out))
			local tA = TweenService:Create(content, TweenInfo.new(0.18, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {Size = UDim2.new(1,0,0,0)})
			local tB = TweenService:Create(main, TweenInfo.new(0.26, Enum.EasingStyle.Back, Enum.EasingDirection.Out), {Size = UDim2.new(expandedMainSize.X.Scale, expandedMainSize.X.Offset, 0, headerH)})
			tA:Play(); tB:Play()
			Delay(0.18, function() content.Visible = false end)
			minimized = true
		end
		local function restore()
			if not minimized then return end
			content.Visible = true
			local tB = TweenService:Create(main, TweenInfo.new(0.3, Enum.EasingStyle.Quint, Enum.EasingDirection.Out), {Size = expandedMainSize})
			local tA = TweenService:Create(content, TweenInfo.new(0.22, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {Size = UDim2.new(1,0,1, -headerH)})
			tB:Play(); tA:Play()
			Delay(0.1, function() tweenTransparency(content, 0, TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)) end)
			minimized = false
		end
		MouseButtonFix(minBtn, function() if minimized then restore() else minimize() end end)

		MouseButtonFix(closeBtn, function()
			local t1 = TweenService:Create(main, TweenInfo.new(0.28, Enum.EasingStyle.Quint, Enum.EasingDirection.InOut), {
				Size = UDim2.new(0.02,0,0.02,0),
				Position = UDim2.new(0.99,0,0.02,0)
			})
			t1:Play(); t1.Completed:Wait()
			sgui:Destroy()
		end)

		NAgui.dragger(main, header)

		local function runOwnershipChecks(dataset)
			loadingOverlay.Visible = true
			local pending = #dataset
			if pending == 0 then
				loadingOverlay.Visible = false
				refreshBtn.AutoButtonColor = true
				refreshBtn.Text = "Refresh"
				refreshBtn.Active = true
				return
			end
			local active = 0
			local maxActive = 12
			local idx = 1
			local function step()
				while active < maxActive and idx <= #dataset do
					local b = dataset[idx]
					idx += 1
					active += 1
					Spawn(function()
						local ok, has = hasBadgeWithRetry(Player.UserId, b.id)
						if ok then
							ownedMap[b.id] = has
							if has then applyOwnedVisualsFor(b.id) end
						else
							ownedMap[b.id] = nil
						end
						active -= 1
						pending -= 1
						if ownedOnly or unownedOnly then applyFilters() end
						if pending <= 0 then
							loadingOverlay.Visible = false
							refreshBtn.AutoButtonColor = true
							refreshBtn.Text = "Refresh"
							refreshBtn.Active = true
							setStatLabel()
						else
							step()
						end
					end)
				end
			end
			step()
		end

		MouseButtonFix(refreshBtn, function()
			if refreshBtn.Active == false then return end
			refreshBtn.Active = false
			refreshBtn.AutoButtonColor = false
			refreshBtn.Text = "Refreshing..."
			loadingOverlay.Visible = true
			for _, c in ipairs(listCards) do if c.frame and c.frame.Parent then c.frame:Destroy() end end
			for _, c in ipairs(gridCards) do if c.frame and c.frame.Parent then c.frame:Destroy() end end
			listCards, gridCards, idToCards, ownedMap = {}, {}, {}, {}
			gridBuilt = false
			ownedOnly = false
			unownedOnly = false
			useGrid = false
			sortModeIndex = 1
			sortMode = "default"
			search.Text = ""
			clearSearch.Visible = false
			ownedOnlyBtn.Text = "Owned: OFF"
			unownedOnlyBtn.Text = "Unowned: OFF"
			layoutToggle.Text = "List"
			sortBtn.Text = "Sort: Default"
			local ok2, res2 = NACaller(getBadges)
			if ok2 then
				badgesData = res2
				for _, b in ipairs(badgesData) do
					makeListCard(b)
				end
				attachLayout()
				runOwnershipChecks(badgesData)
			else
				loadingOverlay.Visible = false
				refreshBtn.AutoButtonColor = true
				refreshBtn.Text = "Refresh"
				refreshBtn.Active = true
				DoNotif("Failed to refresh badge data")
			end
		end)

		tweenTransparency(content, 0, TweenInfo.new(0.22, Enum.EasingStyle.Quad, Enum.EasingDirection.Out))
		attachLayout()
		runOwnershipChecks(badgesData)
	end

	local ok, result = NACaller(getBadges)
	if ok then
		local root = NAmanage.guiCHECKINGAHHHHH()
		for _, g in ipairs(root:GetChildren()) do
			if g:IsA("ScreenGui") and g.Name == "BadgeViewer" then g:Destroy() end
		end
		createBadgeUI(result)
	else
		DoNotif("Failed to fetch badge data")
	end
end)

cmd.add({"bodytransparency","btransparency","bodyt"}, {"bodytransparency <number> [part1] [part2] ... (btransparency,bodyt)", "Sets LocalTransparencyModifier on selected body parts (no Head) to a value (0-1). UI supports multi-select."}, function(...)
	local a = {...}
	local vv = nil
	local q = {}
	for i = 1, #a do
		local s = a[i]
		local n = tonumber(s)
		if n ~= nil and vv == nil then
			vv = n
		elseif s ~= nil and tostring(s) ~= "" then
			q[#q+1] = tostring(s)
		end
	end
	if vv == nil then vv = 0.5 end
	if vv < 0 then vv = 0 elseif vv > 1 then vv = 1 end

	local function okp(p)
		if not p or not p.Parent then return false end
		if not p:IsA("BasePart") then return false end
		if Lower(p.Name) == "head" then return false end
		if p:FindFirstAncestorOfClass("Accessory") then return false end
		if p:FindFirstAncestorOfClass("Tool") then return false end
		return true
	end

	local st = getgenv().__na_btr_st
	if type(st) ~= "table" then
		st = {
			ch = nil, d = true, a = nil, r = nil, mp = nil,
			vv = 0, all = false, sel = {}, dirty = true,
			pend = {}, pendF = false,
		}
		getgenv().__na_btr_st = st
	end

	local function setch(ch)
		if st.a then st.a:Disconnect() st.a = nil end
		if st.r then st.r:Disconnect() st.r = nil end
		st.ch = ch
		st.d = true
		st.mp = {}
		if ch then
			st.a = ch.DescendantAdded:Connect(function() st.d = true end)
			st.r = ch.DescendantRemoving:Connect(function() st.d = true end)
		end
	end

	local function scan()
		local ch = st.ch
		if not ch then return end
		local mp = {}
		for _,p in ipairs(ch:GetDescendants()) do
			if okp(p) then
				local n = Lower(p.Name)
				mp[n] = mp[n] or {}
				mp[n][#mp[n]+1] = p
			end
		end
		st.mp = mp
		st.d = false
	end

	local function clr()
		local ch = st.ch
		if not ch then return end
		for _,p in ipairs(ch:GetDescendants()) do
			if okp(p) then
				p.LocalTransparencyModifier = 0
			end
		end
	end

	local function apply()
		local ch = getChar() or (Players.LocalPlayer and Players.LocalPlayer.Character)
		if ch ~= st.ch then
			setch(ch)
			if st.ch then
				st.dirty = true
			end
		end
		if st.ch and st.d then
			scan()
		end
		if not st.ch then return end

		if st.dirty then
			clr()
			st.dirty = false
		end

		if st.all then
			for _,t in next, (st.mp or {}) do
				for i = 1, #t do
					local p = t[i]
					if p and p.Parent then
						p.LocalTransparencyModifier = st.vv
					end
				end
			end
			return
		end

		for n, on in next, (st.sel or {}) do
			if on then
				local t = st.mp and st.mp[n]
				if t then
					for i = 1, #t do
						local p = t[i]
						if p and p.Parent then
							p.LocalTransparencyModifier = st.vv
						end
					end
				end
			end
		end
	end

	local function start()
		st.vv = vv
		NAlib.disconnect("body_transparency")

		apply()

		NAlib.connect("body_transparency", RunService.RenderStepped:Connect(function()
			Defer(apply)
		end))
	end

	local function setSel(list, all)
		st.all = all and true or false
		st.sel = {}
		if not st.all then
			for i = 1, #list do
				local n = Lower(tostring(list[i] or ""))
				if n ~= "" and n ~= "head" then
					st.sel[n] = true
				end
			end
		end
		st.dirty = true
		start()
	end

	local function queuePick(name)
		name = tostring(name or "")
		local n = Lower(name)
		if n == "" then return end
		st.pend[n] = true
		if st.pendF then return end
		st.pendF = true
		Defer(function()
			st.pendF = false
			local all = false
			local list = {}
			for k in next, st.pend do
				if k == "__all" or k == "all" or k == "body" then
					all = true
				elseif k ~= "head" then
					list[#list+1] = k
				end
			end
			st.pend = {}
			setSel(list, all)
			DebugNotif("Body transparency "..Format("%.2f", vv).." applied", 1.5)
		end)
	end

	if #q > 0 then
		local all = false
		local list = {}
		for i = 1, #q do
			local n = Lower(q[i])
			if n == "all" or n == "body" then
				all = true
			elseif n ~= "head" then
				list[#list+1] = q[i]
			end
		end
		setSel(list, all)
		DebugNotif("Body transparency "..Format("%.2f", vv).." set", 1.5)
		return
	end

	local ch = getChar() or (Players.LocalPlayer and Players.LocalPlayer.Character)
	local btns = {}

	Insert(btns, { Text = "All", Callback = function() queuePick("__all") end })

	if ch then
		local seen = {}
		for _,p in ipairs(ch:GetDescendants()) do
			if okp(p) then
				local n = p.Name
				if not seen[n] then
					seen[n] = true
					Insert(btns, { Text = n, Callback = function() queuePick(n) end })
				end
			end
		end
	else
		Insert(btns, { Text = "No character", Callback = function() DebugNotif("No character found", 2) end })
	end

	Window({
		Title = "Body Transparency",
		Description = "Pick body parts to apply: "..Format("%.2f", vv),
		Buttons = btns
	})
end, true)

cmd.add({"unbodytransparency","unbtransparency","unbodyt"}, {"unbodytransparency (unbtransparency,unbodyt)", "Stops transparency loop"}, function()
	if not NAlib.isConnected("body_transparency") then
		DebugNotif("No loop running", 2)
		return
	end

	NAlib.disconnect("body_transparency")

	local ch = getChar() or (Players.LocalPlayer and Players.LocalPlayer.Character)
	if ch then
		for _,p in ipairs(ch:GetDescendants()) do
			if p:IsA("BasePart") and Lower(p.Name) ~= "head" and not p:FindFirstAncestorOfClass("Accessory") and not p:FindFirstAncestorOfClass("Tool") then
				p.LocalTransparencyModifier = 0
			end
		end
	end

	local st = getgenv().__na_btr_st
	if type(st) == "table" then
		st.all = false
		st.sel = {}
		st.pend = {}
		st.pendF = false
		st.dirty = true
	end
end)

cmd.add({"animationspeed", "animspeed", "aspeed"}, {"animationspeed <speed> (animspeed,aspeed)", "Adjusts the speed of currently playing animations"}, function(speed)
	local targetSpeed = tonumber(speed) or 1

	NAlib.disconnect("animation_speed")

	NAlib.connect("animation_speed", RunService.Stepped:Connect(function()
		local character = getChar()
		local humanoid = getHum()
		if humanoid then
			for _, track in ipairs(humanoid:GetPlayingAnimationTracks()) do
				if track and track:IsA("AnimationTrack") then
					track:AdjustSpeed(targetSpeed)
				end
			end
		end
	end))

	DebugNotif("Animation speed set to "..targetSpeed)
end, true)

cmd.add({"unanimationspeed", "unanimspeed", "unaspeed"}, {"unanimationspeed (unanimspeed,unaspeed)", "Stops the animation speed adjustment loop"}, function()
	if NAlib.isConnected("animation_speed") then
		NAlib.disconnect("animation_speed")
		DebugNotif("Animation speed disabled")
	else
		DebugNotif("No active animation speed to disable")
	end
end)

cmd.add({"placeid","pid"},{"placeid (pid)","Copies the PlaceId of the game you're in"},function()
	setclipboard(tostring(PlaceId))

	Wait();

	DebugNotif("Copied the game's PlaceId: "..PlaceId)
end)

cmd.add({"gameid","universeid","gid"},{"gameid (universeid,gid)","Copies the GameId/Universe Id of the game you're in"},function()
	setclipboard(tostring(GameId))

	Wait();

	DebugNotif("Copied the game's GameId: "..GameId)
end)

cmd.add({"firework"}, {"firework", "pop"}, function()
	local character = LocalPlayer.Character
	if not character then return end

	local root = getRoot(character)
	local humanoid = getHum()
	if not root or not humanoid then return end

	local part = InstanceNew("Part")
	part.Size = Vector3.new(0.1, 0.1, 0.1)
	part.Transparency = 1
	part.Anchored = false
	part.CanCollide = false
	part.Parent = workspace

	local weld = InstanceNew("Weld")
	weld.Part0 = part
	weld.Part1 = root
	weld.C0 = CFrame.new()
	weld.Parent = part

	local bv = InstanceNew("BodyVelocity")
	bv.Velocity = Vector3.new(0, 50, 0)
	bv.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
	bv.Parent = part

	local bg = InstanceNew("BodyGyro")
	bg.MaxTorque = Vector3.new(math.huge, math.huge, math.huge)
	bg.P = 10000
	bg.D = 0
	bg.Parent = part

	local spinTime = 3
	local spinSpeed = 720
	local startTime = tick()
	local angle = 0

	NAlib.connect("firework_spin", RunService.Heartbeat:Connect(function(dt)
		if tick() - startTime > spinTime then
			NAlib.disconnect("firework_spin")
			bv:Destroy()
			bg:Destroy()
			part:Destroy()

			local explosion = InstanceNew("Explosion")
			explosion.Position = root.Position
			explosion.BlastRadius = 6
			explosion.BlastPressure = 500000
			explosion.Parent = workspace

			humanoid.Health = 0
			return
		end

		angle = angle + math.rad(spinSpeed * dt)
		bg.CFrame = CFrame.new(root.Position) * CFrame.Angles(0, angle, 0)
	end))
end)

cmd.add({"placename","pname"},{"placename (pname)","Copies the game's place name to your clipboard"},function()
	placeNaem = placeName()
	setclipboard(placeNaem)

	Wait();

	DebugNotif("Copied the game's place name: "..placeNaem)
end)

cmd.add({"gameinfo","ginfo"},{"gameinfo (ginfo)","shows info about the game you're playing"},function()
	loadstring(game:HttpGet("https://raw.githubusercontent.com/ltseverydayyou/uuuuuuu/refs/heads/main/GameInfo.lua"))()
end)

cmd.add({"userpreview","userp","upreview"},{"userpreview","show info about a user you name"},function()
	loadstring(game:HttpGet("https://raw.githubusercontent.com/ltseverydayyou/uuuuuuu/refs/heads/main/UserInfo.luau"))()
end)

cmd.add({"copyname", "cname"}, {"copyname <player> (cname)", "Copies the username of the target"}, function(...)
	local usr = ...
	local tgt = getPlr(usr)

	for _, plr in next, tgt do
		setclipboard(tostring(plr.Name))
		Wait()
		DebugNotif("Copied the username of "..nameChecker(plr))
	end
end, true)

cmd.add({"copydisplay", "cdisplay"}, {"copydisplay <player> (cdisplay)", "Copies the display name of the target"}, function(...)
	local usr = ...
	local tgt = getPlr(usr)

	for _, plr in next, tgt do
		setclipboard(tostring(plr.DisplayName))
		Wait()
		DebugNotif("Copied the display name of "..nameChecker(plr))
	end
end, true)

cmd.add({"copyid", "id"}, {"copyid <player> (id)", "Copies the UserId of the target"}, function(...)
	local usr = ...
	local tgt = getPlr(usr)

	for _, plr in next, tgt do
		setclipboard(tostring(plr.UserId))
		Wait()
		DebugNotif("Copied the UserId of "..nameChecker(plr))
	end
end, true)

--[ PLAYER ]--
cmd.add({"antikillbrick","antikb"},{"antikillbrick (antikb)","Prevents kill bricks from killing you"},function()
	NAlib.disconnect("antikb")
	NAlib.disconnect("antikb_char")
	NAStuff._kbTracked = NAStuff._kbTracked or setmetatable({}, {__mode="k"})
	NAStuff._kbOrig = NAStuff._kbOrig or setmetatable({}, {__mode="k"})
	NAStuff._kbSignals = NAStuff._kbSignals or setmetatable({}, {__mode="k"})
	local tracked, orig, signals = NAStuff._kbTracked, NAStuff._kbOrig, NAStuff._kbSignals
	local lp = Players.LocalPlayer
	local apply = function(p)
		if not (p and p:IsA("BasePart")) then return end
		if orig[p] == nil then orig[p] = NAlib.isProperty(p,"CanTouch") end
		if NAlib.isProperty(p,"CanTouch") ~= false then NAlib.setProperty(p,"CanTouch", false) end
		tracked[p] = true
		if not signals[p] then
			local c = p:GetPropertyChangedSignal("CanTouch"):Connect(function()
				if NAlib.isProperty(p,"CanTouch") ~= false then NAlib.setProperty(p,"CanTouch", false) end
			end)
			signals[p] = {c}
			NAlib.connect("antikb", c)
		end
	end
	local seed = function(char)
		if not char then return end
		for _,d in ipairs(char:GetDescendants()) do
			if d:IsA("BasePart") then apply(d) end
		end
		NAlib.connect("antikb", char.DescendantAdded:Connect(function(inst)
			if inst:IsA("BasePart") then apply(inst) end
		end))
		NAlib.connect("antikb", char.DescendantRemoving:Connect(function(inst)
			if signals[inst] then for _,c in ipairs(signals[inst]) do if c then c:Disconnect() end end signals[inst]=nil end
			tracked[inst] = nil
			orig[inst] = nil
		end))
	end
	if lp.Character then seed(lp.Character) end
	NAlib.connect("antikb_char", lp.CharacterAdded:Connect(function(char)
		for _,arr in pairs(signals) do if arr then for _,c in ipairs(arr) do if c then c:Disconnect() end end end end
		for k in pairs(signals) do signals[k]=nil end
		for k in pairs(tracked) do tracked[k]=nil end
		for k in pairs(orig) do orig[k]=nil end
		Wait(); seed(char)
	end))
	NAlib.connect("antikb_char", lp.CharacterRemoving:Connect(function()
		for _,arr in pairs(signals) do if arr then for _,c in ipairs(arr) do if c then c:Disconnect() end end end end
		for k in pairs(signals) do signals[k]=nil end
		for k in pairs(tracked) do tracked[k]=nil end
		for k in pairs(orig) do orig[k]=nil end
	end))
	NAlib.connect("antikb", RunService.Stepped:Connect(function()
		local char = lp.Character
		if not char then return end
		for p in pairs(tracked) do
			if typeof(p)=="Instance" and p:IsA("BasePart") and p:IsDescendantOf(char) then
				if p.CanTouch ~= false then NAlib.setProperty(p,"CanTouch", false) end
			end
		end
	end))
end)

cmd.add({"unantikillbrick","unantikb"},{"unantikillbrick (unantikb)","Allows kill bricks to kill you"},function()
	local tracked = NAStuff._kbTracked or {}
	local orig = NAStuff._kbOrig or {}
	local signals = NAStuff._kbSignals or {}
	NAlib.disconnect("antikb")
	NAlib.disconnect("antikb_char")
	for _,arr in pairs(signals) do if arr then for _,c in ipairs(arr) do if c then c:Disconnect() end end end end
	for p in pairs(tracked) do
		if typeof(p)=="Instance" and p:IsA("BasePart") then
			local v = orig[p]; if v == nil then v = true end
			NAlib.setProperty(p,"CanTouch", v)
		end
	end
	for k in pairs(signals) do signals[k] = nil end
	for k in pairs(tracked) do tracked[k] = nil end
	for k in pairs(orig) do orig[k] = nil end
end)

cmd.add({"height","hipheight","hh"},{"height <number> (hipheight,hh)","Changes your hipheight"},function(...)
	getHum().HipHeight=(...)
end,true)

cmd.add({"netbypass", "netb"}, {"netbypass (netb)", "Net bypass"}, function()
	Wait()
	DebugNotif("Netbypass enabled")
	local fenv = getfenv()
	local shp = fenv.sethiddenproperty or fenv.set_hidden_property or fenv.sethiddenprop or fenv.set_hidden_prop
	local ssr = fenv.setsimulationradius or fenv.setsimradius or fenv.set_simulation_radius
	net = shp and function(r) shp(lp, "SimulationRadius", r) end or ssr
end)

cmd.add({"day"},{"day","Makes it day"},function()
	Lighting.ClockTime=14
end)

cmd.add({"night"},{"night","Makes it night"},function()
	Lighting.ClockTime=0
end)

cmd.add({"time"}, {"time <number>", "Sets the time"}, function(...)
	local time = {...}
	if time then Lighting.ClockTime = time[1] end
end, true)

cmd.add({"chat", "message"}, {"chat <text> (message)", "Chats for you, useful if you're muted"}, function(...)
	local chatMessage = Concat({...}, " ")
	local chatTarget = "All"
	NAlib.LocalPlayerChat(chatMessage, chatTarget)
end, true)

cmd.add({"privatemessage", "pm"}, {"privatemessage <player> <text> (pm)", "Sends a private message to a player"}, function(...)
	local args = {...}
	local Player = getPlr(args[1])

	for _, plr in next, Player do
		local chatMessage = Concat(args, " ", 2)
		local chatTarget = plr.Name
		local result = NAlib.LocalPlayerChat(chatMessage, chatTarget)
		if result == "Hooking" then
			Wait(.5)
			NAlib.LocalPlayerChat(chatMessage, chatTarget)
		end
	end
end,true)

cmd.add({"mimicchat", "mimic"}, {"mimicchat <player> (mimic)", "Mimics the chat of a player"}, function(name)
	NAlib.disconnect("mimicchat")

	local targets = getPlr(name)
	if #targets == 0 then
		DoNotif("Player not found",2)
		return
	end

	for _, plr in pairs(targets) do
		DebugNotif("Now mimicking "..plr.Name.."'s chat", 2)

		NAlib.connect("mimicchat", plr.Chatted:Connect(function(msg)
			NAlib.LocalPlayerChat(msg, "All")
		end))
	end
end, true)

cmd.add({"stopmimicchat", "unmimicchat"}, {"stopmimicchat (unmimicchat)", "Stops mimicking a player"}, function()
	NAlib.disconnect("mimicchat")
	DebugNotif("Stopped mimicking", 2)
end, true)

cmd.add({"fixcam", "fix"}, {"fixcam", "Fix your camera"}, function()
	local ws = workspace
	local plr = Players.LocalPlayer
	local cam = ws.CurrentCamera
	if not cam then return end
	local al = cam:FindFirstChildOfClass("AudioListener")
	if al then
		al.Parent = nil
	end
	cam:Remove()
	Wait(0.1)
	repeat Wait() until plr.Character and ws.CurrentCamera
	cam = ws.CurrentCamera
	if al then
		al.Parent = cam
	end
	cam.CameraSubject = getHum()
	cam.CameraType = "Custom"
	plr.CameraMinZoomDistance = 0.5
	plr.CameraMaxZoomDistance = math.huge
	plr.CameraMode = "Classic"
	getHead(plr.Character).Anchored = false
end)

cmd.add({"saw"}, {"saw <challenge>", "shush"}, function(...)
	local challenge = Concat({...}, " ")
	getgenv().SawFinish = false

	local function playSound(id, vol)
		local sfx = InstanceNew("Sound")
		sfx.Parent = PlrGui
		sfx.SoundId = "rbxassetid://"..id
		sfx.Volume = vol or 1
		sfx:Play()
		sfx.Ended:Connect(function()
			sfx:Destroy()
		end)
	end

	local function createUIElement(class, properties, parent)
		local element = InstanceNew(class)
		for prop, value in pairs(properties) do
			element[prop] = value
		end
		if parent then element.Parent = parent end
		return element
	end

	local ScreenGui = createUIElement("ScreenGui", { Name = '\0' })
	NaProtectUI(ScreenGui)

	local background = createUIElement("Frame", {
		BackgroundColor3 = Color3.fromRGB(0, 0, 0),
		BackgroundTransparency = 1,
		Size = UDim2.new(1, 0, 1, 0),
		ZIndex = 0
	}, ScreenGui)

	local staticOverlay = createUIElement("ImageLabel", {
		BackgroundTransparency = 1,
		Size = UDim2.new(1, 0, 1, 0),
		Image = "rbxassetid://259236205",
		ImageTransparency = 0.8,
		ZIndex = 1
	}, background)

	coroutine.wrap(function()
		while not getgenv().SawFinish do
			local tween = TweenService:Create(
				staticOverlay,
				TweenInfo.new(0.1, Enum.EasingStyle.Quad, Enum.EasingDirection.InOut),
				{ ImageTransparency = math.random(0.7, 0.9), Position = UDim2.new(math.random(-0.01, 0.01), 0, math.random(-0.01, 0.01), 0) }
			)
			tween:Play()
			Wait(math.random(0.05, 0.2))
		end
	end)()

	local bgTween = TweenService:Create(
		background,
		TweenInfo.new(1, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),
		{ BackgroundTransparency = 0.5 }
	)
	bgTween:Play()

	local progressBar = createUIElement("Frame", {
		BackgroundColor3 = Color3.fromRGB(50, 50, 50),
		Position = UDim2.new(0.25, 0, 0.05, 0),
		Size = UDim2.new(0.5, 0, 0.03, 0),
		BorderSizePixel = 0,
		ZIndex = 2
	}, ScreenGui)

	local progressFill = createUIElement("Frame", {
		BackgroundColor3 = Color3.fromRGB(255, 0, 0),
		Size = UDim2.new(1, 0, 1, 0),
		BorderSizePixel = 0,
		ZIndex = 3
	}, progressBar)

	local imgLabel = createUIElement("ImageLabel", {
		AnchorPoint = Vector2.new(0.5, 0),
		BackgroundTransparency = 1,
		Position = UDim2.new(0.5, 0, 0.1, 0),
		Size = UDim2.new(0, 150, 0, 150),
		Image = "rbxassetid://8747893766",
		ImageColor3 = Color3.fromRGB(255, 0, 0),
		ZIndex = 2
	}, ScreenGui)

	coroutine.wrap(function()
		while not getgenv().SawFinish do
			local newSize = math.random(140, 160)
			local newRotation = math.random(-10, 10)
			local tween = TweenService:Create(
				imgLabel,
				TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.InOut),
				{ Size = UDim2.new(0, newSize, 0, newSize), Rotation = newRotation, ImageColor3 = Color3.fromRGB(math.random(200, 255), 0, 0) }
			)
			tween:Play()
			tween.Completed:Wait()
			if math.random() < 0.2 then
				local glitchTween = TweenService:Create(
					imgLabel,
					TweenInfo.new(0.05, Enum.EasingStyle.Quad, Enum.EasingDirection.InOut),
					{ ImageTransparency = math.random(0.3, 0.7), Position = UDim2.new(0.5 + math.random(-0.05, 0.05), 0, 0.1 + math.random(-0.05, 0.05), 0) }
				)
				glitchTween:Play()
				glitchTween.Completed:Wait()
				local resetTween = TweenService:Create(
					imgLabel,
					TweenInfo.new(0.05, Enum.EasingStyle.Quad, Enum.EasingDirection.InOut),
					{ ImageTransparency = 0, Position = UDim2.new(0.5, 0, 0.1, 0) }
				)
				resetTween:Play()
			end
		end
	end)()

	local ttLabelLeft = createUIElement("TextLabel", {
		BackgroundColor3 = Color3.fromRGB(0, 0, 0),
		BackgroundTransparency = 0.3,
		AnchorPoint = Vector2.new(0, 0.5),
		Position = UDim2.new(0.05, 0, 0.5, 0),
		Size = UDim2.new(0.4, 0, 0.1, 0),
		Font = Enum.Font.SciFi,
		Text = "Challenge: "..challenge,
		TextColor3 = Color3.fromRGB(255, 0, 0),
		TextSize = 24,
		TextStrokeColor3 = Color3.fromRGB(100, 0, 0),
		TextStrokeTransparency = 0.5,
		TextWrapped = true,
		ZIndex = 3
	}, ScreenGui)

	local ttLabelRight = createUIElement("TextLabel", {
		BackgroundColor3 = Color3.fromRGB(0, 0, 0),
		BackgroundTransparency = 0.3,
		AnchorPoint = Vector2.new(1, 0.5),
		Position = UDim2.new(0.95, 0, 0.5, 0),
		Size = UDim2.new(0.4, 0, 0.1, 0),
		Font = Enum.Font.SciFi,
		Text = "Time Remaining: 180 seconds",
		TextColor3 = Color3.fromRGB(255, 0, 0),
		TextSize = 24,
		TextStrokeColor3 = Color3.fromRGB(100, 0, 0),
		TextStrokeTransparency = 0.5,
		TextWrapped = true,
		ZIndex = 3
	}, ScreenGui)

	local dramaticLabel = createUIElement("TextLabel", {
		BackgroundTransparency = 1,
		AnchorPoint = Vector2.new(0.5, 0.5),
		Position = UDim2.new(0.5, 0, 0.7, 0),
		Size = UDim2.new(0.5, 0, 0.2, 0),
		Font = Enum.Font.SciFi,
		Text = "",
		TextColor3 = Color3.fromRGB(255, 0, 0),
		TextSize = 50,
		TextStrokeTransparency = 0.5,
		TextWrapped = true,
		ZIndex = 4
	}, ScreenGui)

	local function flickerText()
		while not getgenv().SawFinish do
			local newColor = Color3.fromRGB(math.random(200, 255), 0, 0)
			ttLabelLeft.TextColor3 = newColor
			ttLabelRight.TextColor3 = newColor
			ttLabelLeft.TextStrokeTransparency = math.random(0.4, 0.7)
			ttLabelRight.TextStrokeTransparency = math.random(0.4, 0.7)
			ttLabelLeft.Text = "Challenge: "..challenge:sub(1, math.random(1, #challenge))
			Wait(math.random(0.05, 0.15))
		end
	end

	local function dramaticCountdown(num)
		dramaticLabel.Text = tostring(num)
		playSound(138081500, 2)
		for i = 1, 5 do
			local shakeTween = TweenService:Create(
				dramaticLabel,
				TweenInfo.new(0.05, Enum.EasingStyle.Quad, Enum.EasingDirection.InOut),
				{ Position = UDim2.new(0.5 + math.random(-0.02, 0.02), 0, 0.7 + math.random(-0.02, 0.02), 0) }
			)
			shakeTween:Play()
			shakeTween.Completed:Wait()
		end
		local resetTween = TweenService:Create(
			dramaticLabel,
			TweenInfo.new(0.1, Enum.EasingStyle.Quad, Enum.EasingDirection.InOut),
			{ Position = UDim2.new(0.5, 0, 0.7, 0) }
		)
		resetTween:Play()
		Wait(1)
		dramaticLabel.Text = ""
	end

	local ambientSound = InstanceNew("Sound")
	ambientSound.Parent = PlrGui
	ambientSound.SoundId = "rbxassetid://1846090198"
	ambientSound.Volume = 0.2
	ambientSound.Looped = true
	ambientSound:Play()

	local function count()
		local num = 180
		while Wait(1) do
			if not getgenv().SawFinish then
				if num > 0 then
					num = num - 1
					playSound(138081500, num <= 10 and 2 or 1)
					ttLabelRight.Text = "Time Remaining: "..num.." seconds"

					local progress = num / 180
					local jitter = math.random(-0.02, 0.02)
					local tween = TweenService:Create(
						progressFill,
						TweenInfo.new(1, Enum.EasingStyle.Linear),
						{ Size = UDim2.new(progress + jitter, 0, 1, 0), BackgroundColor3 = num <= 30 and Color3.fromRGB(math.random(200, 255), math.random(0, 50), 0) or Color3.fromRGB(255, 0, 0) }
					)
					tween:Play()

					if num == 30 or num == 20 or num == 10 then
						dramaticCountdown(num)
					elseif num <= 10 then
						dramaticLabel.Text = tostring(num)
						playSound(138081500, 2)
					end
				else
					local flash = createUIElement("Frame", {
						BackgroundColor3 = Color3.fromRGB(255, 0, 0),
						BackgroundTransparency = 0,
						Size = UDim2.new(1, 0, 1, 0),
						ZIndex = 10
					}, ScreenGui)
					playSound(9125915751, 5)
					Wait(0.2)
					flash:Destroy()
					Players.LocalPlayer:Kick("You Failed The Challenge")
				end
			else
				ttLabelLeft.Text = "You Survived... For Now"
				ttLabelRight.Text = ""
				dramaticLabel.Text = "I'll be watching..."
				local distortion = createUIElement("Frame", {
					BackgroundColor3 = Color3.fromRGB(100, 0, 0),
					BackgroundTransparency = 0.7,
					Size = UDim2.new(1, 0, 1, 0),
					ZIndex = 5
				}, ScreenGui)
				local glitchOverlay = createUIElement("ImageLabel", {
					BackgroundTransparency = 1,
					Size = UDim2.new(1, 0, 1, 0),
					Image = "rbxassetid://259236205",
					ImageTransparency = 0.5,
					ZIndex = 6
				}, distortion)
				playSound(9125915751, 5)
				for i = 1, 3 do
					local glitchTween = TweenService:Create(
						glitchOverlay,
						TweenInfo.new(0.1, Enum.EasingStyle.Quad, Enum.EasingDirection.InOut),
						{ Position = UDim2.new(math.random(-0.05, 0.05), 0, math.random(-0.05, 0.05), 0), ImageTransparency = math.random(0.3, 0.7) }
					)
					glitchTween:Play()
					Wait(0.15)
				end
				local fadeTween = TweenService:Create(
					dramaticLabel,
					TweenInfo.new(3, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),
					{ TextTransparency = 1 }
				)
				local distortionFade = TweenService:Create(
					distortion,
					TweenInfo.new(3, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),
					{ BackgroundTransparency = 1 }
				)
				local glitchFade = TweenService:Create(
					glitchOverlay,
					TweenInfo.new(3, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),
					{ ImageTransparency = 1 }
				)
				fadeTween:Play()
				distortionFade:Play()
				glitchFade:Play()
				Wait(3)
				ScreenGui:Destroy()
				ambientSound:Destroy()
				break
			end
		end
	end

	coroutine.wrap(count)()
	coroutine.wrap(flickerText)()
end, true)

cmd.add({"jend"}, {"jend", "nil"}, function()
	getgenv().SawFinish = true
end)

cmd.add({"fling"}, {"fling <player>", "Fling the given player"}, function(plr)
	local Players = game.GetService(game,"Players")
	local LocalPlayer    = Players.LocalPlayer
	local Character      = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
	local Humanoid       = getPlrHum(Character)
	local RootPart       = Humanoid and Humanoid.RootPart
	if not RootPart then return end

	local AllBool = false
	local function GetPlayer(Name)
		Name = Lower(Name)
		if Name == "all" or Name == "others" then
			AllBool = true
			return
		elseif Name == "random" then
			local list = Players:GetPlayers()
			if Discover(list, LocalPlayer) then
				table.remove(list, Discover(list, LocalPlayer))
			end
			return list[math.random(#list)]
		end
		for _, x in next, Players:GetPlayers() do
			if x ~= LocalPlayer then
				if Sub(Lower(x.Name), 1, #Name) == Name or Sub(Lower(x.DisplayName), 1, #Name) == Name then
					return x
				end
			end
		end
	end

	local flingManager       = flingManager
	local OrgDestroyHeight   = workspace.FallenPartsDestroyHeight

	local function SkidFling(TargetPlayer)
		local Character = LocalPlayer.Character
		local Humanoid  = getPlrHum(Character)
		local RootPart  = Humanoid and Humanoid.RootPart
		local TChar     = TargetPlayer.Character
		local THumanoid = getPlrHum(TChar)
		local TRootPart = THumanoid and THumanoid.RootPart
		local THead     = getHead(TChar)
		local Acc       = TChar:FindFirstChildOfClass("Accessory")
		local Handle    = Acc and Acc:FindFirstChild("Handle")

		if Character and Humanoid and RootPart then
			if not flingManager.cFlingOldPos or RootPart.Velocity.Magnitude < 50 then
				flingManager.cFlingOldPos = RootPart.CFrame
			end

			if THead then
				workspace.CurrentCamera.CameraSubject = THead
			elseif Handle then
				workspace.CurrentCamera.CameraSubject = Handle
			elseif THumanoid and TRootPart then
				workspace.CurrentCamera.CameraSubject = THumanoid
			end

			if not TChar:FindFirstChildWhichIsA("BasePart") then return end

			local function FPos(BasePart, Pos, Ang)
				RootPart.CFrame = CFrame.new(BasePart.Position) * Pos * Ang
				Character:SetPrimaryPartCFrame(CFrame.new(BasePart.Position) * Pos * Ang)
				RootPart.Velocity    = Vector3.new(9e7, 9e7*10, 9e7)
				RootPart.RotVelocity = Vector3.new(9e8, 9e8, 9e8)
			end

			local function SFBasePart(BasePart)
				local TimeToWait = 2
				local Time       = tick()
				local Angle      = 0
				repeat
					if RootPart and THumanoid then
						if BasePart.Velocity.Magnitude < 50 then
							Angle = Angle + 100
							FPos(BasePart, CFrame.new(0,1.5,0) + THumanoid.MoveDirection * BasePart.Velocity.Magnitude/1.25, CFrame.Angles(math.rad(Angle),0,0)) Wait()
							FPos(BasePart, CFrame.new(0,-1.5,0) + THumanoid.MoveDirection * BasePart.Velocity.Magnitude/1.25, CFrame.Angles(math.rad(Angle),0,0)) Wait()
							FPos(BasePart, CFrame.new(2.25,1.5,-2.25) + THumanoid.MoveDirection * BasePart.Velocity.Magnitude/1.25, CFrame.Angles(math.rad(Angle),0,0)) Wait()
							FPos(BasePart, CFrame.new(-2.25,-1.5,2.25) + THumanoid.MoveDirection * BasePart.Velocity.Magnitude/1.25, CFrame.Angles(math.rad(Angle),0,0)) Wait()
							FPos(BasePart, CFrame.new(0,1.5,0) + THumanoid.MoveDirection, CFrame.Angles(math.rad(Angle),0,0)) Wait()
							FPos(BasePart, CFrame.new(0,-1.5,0) + THumanoid.MoveDirection, CFrame.Angles(math.rad(Angle),0,0)) Wait()
						else
							FPos(BasePart, CFrame.new(0,1.5,THumanoid.WalkSpeed), CFrame.Angles(math.rad(90),0,0)) Wait()
							FPos(BasePart, CFrame.new(0,-1.5,-THumanoid.WalkSpeed), CFrame.Angles(0,0,0)) Wait()
							FPos(BasePart, CFrame.new(0,1.5,THumanoid.WalkSpeed), CFrame.Angles(math.rad(90),0,0)) Wait()
							FPos(BasePart, CFrame.new(0,1.5,TRootPart.Velocity.Magnitude/1.25), CFrame.Angles(math.rad(90),0,0)) Wait()
							FPos(BasePart, CFrame.new(0,-1.5,-TRootPart.Velocity.Magnitude/1.25), CFrame.Angles(0,0,0)) Wait()
							FPos(BasePart, CFrame.new(0,1.5,TRootPart.Velocity.Magnitude/1.25), CFrame.Angles(math.rad(90),0,0)) Wait()
							FPos(BasePart, CFrame.new(0,-1.5,0), CFrame.Angles(math.rad(90),0,0)) Wait()
							FPos(BasePart, CFrame.new(0,-1.5,0), CFrame.Angles(0,0,0)) Wait()
							FPos(BasePart, CFrame.new(0,-1.5,0), CFrame.Angles(math.rad(-90),0,0)) Wait()
							FPos(BasePart, CFrame.new(0,-1.5,0), CFrame.Angles(0,0,0)) Wait()
						end
					else
						break
					end
				until BasePart.Velocity.Magnitude > 500
					or BasePart.Parent ~= TargetPlayer.Character
					or TargetPlayer.Parent ~= Players
					or TargetPlayer.Character ~= TChar
					or THumanoid.Sit
					or Humanoid.Health <= 0
					or tick() > Time + TimeToWait
			end

			workspace.FallenPartsDestroyHeight = 0/0

			local BV = InstanceNew("BodyVelocity")
			BV.Parent    = RootPart
			BV.Velocity  = Vector3.new(9e8,9e8,9e8)
			BV.MaxForce  = Vector3.new(1/0,1/0,1/0)

			Humanoid:SetStateEnabled(Enum.HumanoidStateType.Seated, false)

			if TRootPart and THead then
				if (TRootPart.CFrame.p - THead.CFrame.p).Magnitude > 5 then
					SFBasePart(THead)
				else
					SFBasePart(TRootPart)
				end
			elseif TRootPart then
				SFBasePart(TRootPart)
			elseif THead then
				SFBasePart(THead)
			elseif Handle then
				SFBasePart(Handle)
			end

			BV:Destroy()
			Humanoid:SetStateEnabled(Enum.HumanoidStateType.Seated, true)
			workspace.CurrentCamera.CameraSubject = Humanoid

			repeat
				RootPart.CFrame                  = flingManager.cFlingOldPos * CFrame.new(0, .5, 0)
				Character:SetPrimaryPartCFrame( flingManager.cFlingOldPos * CFrame.new(0, .5, 0) )
				Humanoid:ChangeState("GettingUp")
				for _, x in next, Character:GetChildren() do
					if x:IsA("BasePart") then
						x.Velocity, x.RotVelocity = Vector3.new(), Vector3.new()
					end
				end
				Wait()
			until (RootPart.Position - flingManager.cFlingOldPos.p).Magnitude < 25

			workspace.FallenPartsDestroyHeight = OrgDestroyHeight
		end
	end

	local targets = {}
	for _, name in next, {plr} do
		local p = GetPlayer(name)
		if p then Insert(targets, p) end
	end

	if AllBool then
		for _, p in next, Players:GetPlayers() do
			if p ~= LocalPlayer then SkidFling(p) end
		end
	else
		for _, p in next, targets do
			SkidFling(p)
		end
	end
end)

cmd.add({"commitoof", "suicide", "kys"}, {"commitoof (suicide, kys)", "Triggers a dramatic oof sequence for the player"}, function()
	local p = Players.LocalPlayer
	if not p then
		return
	end

	local c = p.Character
	if not c then
		c = p.CharacterAdded:Wait()
	end

	local h = getPlrHum(c)
	if not h then
		return
	end

	local r = getRoot(c)
	if not r then
		return
	end

	NAlib.LocalPlayerChat("Okay... I will do it.", "All")
	Wait(1.5)
	NAlib.LocalPlayerChat("I will oof now...", "All")
	Wait(1.5)
	NAlib.LocalPlayerChat("Goodbye, cruel world.", "All")
	Wait(2)

	h:MoveTo(r.Position + r.CFrame.LookVector * 10)
	h:ChangeState(Enum.HumanoidStateType.Jumping)
	Wait(0.45)

	cmd.run({'die'})
end)

cmd.add({"volume","vol"},{"volume <0-10> (vol)","Changes your volume"},function(vol)
	local numberValue = tonumber(vol)
	if not numberValue then
		return DoNotif("please provide a number between 0-10",2)
	end
	numberValue = numberValue / 10
	local amount = math.clamp(numberValue, 0, 1)
	UserSettings():GetService("UserGameSettings").MasterVolume = amount
end,true)

cmd.add({"perfstats"},{"perfstats <on/off>","Shows or hides performance stats"},function(t)
	local s=UserSettings():GetService("UserGameSettings")
	local a=tostring(t or ""):lower()
	pcall(function() s.PerformanceStatsVisible=(a=="on" or a=="true" or a=="1") end)
end,true)

cmd.add({"preftransparency","prefalpha"},{"preftransparency <0-15>","Preferred UI transparency"},function(v)
	local s=UserSettings():GetService("UserGameSettings")
	local n=math.clamp(tonumber(v) or 0,0,15)
	pcall(function() s.PreferredTransparency=n end)
end,true)

cmd.add({"sensitivity","sens"},{"sensitivity <1-10> (sens)","Changes your sensitivity"},function(ss)
	UserInputService.MouseDeltaSensitivity=ss
end,true)

cmd.add({"torandom","tr"},{"torandom (tr)","Teleports to a random player"},function()
	target=getPlr("random")
	for _, plr in next, target do
		SpawnCall(function() getRoot(getChar()).CFrame=getPlrHum(plr).RootPart.CFrame end)
	end
end)

cmd.add({"timestop", "tstop"}, {"timestop (tstop)", "freezes all players (ZA WARUDO)"}, function()
	local target = getPlr("others")
	if #target == 0 then return end

	for _, plr in pairs(Players:GetPlayers()) do
		NAlib.disconnect("timestop_char_"..plr.UserId)
	end
	NAlib.disconnect("timestop_playeradd")

	for _, plr in pairs(target) do
		local char = plr.Character or getPlrChar(plr)
		if char then
			for _, v in pairs(char:GetDescendants()) do
				if v:IsA("BasePart") then
					v.Anchored = true
				end
			end
		end

		NAlib.connect("timestop_char_"..plr.UserId, plr.CharacterAdded:Connect(function(char)
			while not getRoot(char) do Wait(.1) end
			for _, v in pairs(char:GetDescendants()) do
				if v:IsA("BasePart") then
					v.Anchored = true
				end
			end
		end))
	end

	NAlib.connect("timestop_playeradd", Players.PlayerAdded:Connect(function(plr)
		NAlib.connect("timestop_char_"..plr.UserId, plr.CharacterAdded:Connect(function(char)
			while not getRoot(char) do Wait(.1) end
			for _, v in pairs(char:GetDescendants()) do
				if v:IsA("BasePart") then
					v.Anchored = true
				end
			end
		end))
	end))
end)

cmd.add({"untimestop", "untstop"}, {"untimestop (untstop)", "unfreeze all players"}, function()
	local target = getPlr("all")
	if #target == 0 then return end

	for _, plr in pairs(Players:GetPlayers()) do
		NAlib.disconnect("timestop_char_"..plr.UserId)
	end
	NAlib.disconnect("timestop_playeradd")

	for _, plr in pairs(target) do
		local char = plr.Character or getPlrChar(plr)
		if char then
			for _, v in pairs(char:GetDescendants()) do
				if v:IsA("BasePart") then
					v.Anchored = false
				end
			end
		end
	end
end)

NAStuff._outfitCache=NAStuff._outfitCache or{};NAStuff._httpBackoff=NAStuff._httpBackoff or{};NAStuff._httpCooldown=NAStuff._httpCooldown or{}
NAmanage._waitCharReady=function(timeout)
	local t=timeout or 5
	local plr=Players.LocalPlayer
	local t0=time()
	while time()-t0<t do
		local char=getChar()
		if char and char.Parent==workspace then
			local hum=getHum() or char:FindFirstChildOfClass("Humanoid")
			local root=getRoot(char) or char:FindFirstChild("HumanoidRootPart") or char:FindFirstChildWhichIsA("BasePart")
			local head=getHead(char) or char:FindFirstChild("Head")
			if hum and root and head then
				if plr and plr.CanLoadCharacterAppearance then
					if not plr:HasAppearanceLoaded() then
						plr.CharacterAppearanceLoaded:Wait()
					end
					Wait(0.15)
				end
				return char,hum,root,head
			end
		end
		Wait(0.1)
	end
	local c=getChar();return c,(c and (getHum() or c:FindFirstChildOfClass("Humanoid"))),(c and (getRoot(c) or c:FindFirstChild("HumanoidRootPart") or c:FindFirstChildWhichIsA("BasePart"))),(c and (getHead(c) or c:FindFirstChild("Head")))
end
NAmanage._applyFixedDescription=function(desc,uidFallback,opts)
	if not desc then return end
	opts = opts or {}
	local plr=Players.LocalPlayer
	local char,hum=NAmanage._waitCharReady(5)
	if not char or not hum then return end
	if not NAStuff.originalDesc then
		local okA,ap=pcall(function()return hum:GetAppliedDescription() end)
		if okA and ap then
			NAStuff.originalDesc=ap:Clone()
		end
	end

	local function clearAppearance()
		for _,inst in ipairs(char:GetChildren()) do
			if inst:IsA("Accessory") or inst:IsA("Shirt") or inst:IsA("Pants") or inst:IsA("ShirtGraphic") or inst:IsA("CharacterMesh") or inst:IsA("BodyColors") then
				inst:Destroy()
			end
		end
		local hd=getHead(char)
		if hd then
			for _,d in ipairs(hd:GetChildren()) do
				if d:IsA("Decal") and Lower(d.Name)=="face" then
					d:Destroy()
				end
			end
		end
	end

	local function ensureFace()
		local headNow=getHead(char)
		if not headNow then return end
		local hasFace=false
		for _,d in ipairs(headNow:GetChildren()) do
			if d:IsA("Decal") and Lower(d.Name)=="face" then
				hasFace=true
				break
			end
		end
		if hasFace then return end
		local faceId=0
		pcall(function() faceId=desc.Face or 0 end)
		if faceId and faceId>0 then
			local dec=InstanceNew("Decal")
			dec.Name="face"
			dec.Texture="rbxassetid://"..tostring(faceId)
			dec.Face=Enum.NormalId.Front
			dec.Parent=headNow
		elseif uidFallback then
			local okA2,ap=pcall(Players.GetCharacterAppearanceAsync,Players,uidFallback)
			if okA2 and ap then
				for _,v in ipairs(ap:GetDescendants()) do
					if v:IsA("Decal") and Lower(v.Name)=="face" then
						v:Clone().Parent=headNow
						break
					end
				end
			end
		end
	end

	local function ensureClothes()
		local sid=desc.Shirt
		local pid=desc.Pants
		local gid=desc.GraphicTShirt or desc.TShirt
		if not char:FindFirstChildOfClass("Shirt") and sid and sid>0 then
			local s=InstanceNew("Shirt")
			s.ShirtTemplate="rbxassetid://"..sid
			s.Parent=char
		end
		if not char:FindFirstChildOfClass("Pants") and pid and pid>0 then
			local p=InstanceNew("Pants")
			p.PantsTemplate="rbxassetid://"..pid
			p.Parent=char
		end
		if not char:FindFirstChildOfClass("ShirtGraphic") and gid and gid>0 then
			local g=InstanceNew("ShirtGraphic")
			g.Graphic="rbxassetid://"..gid
			g.Parent=char
		end
	end

	if opts.forceRefresh then
		NAStuff._blankCharDesc = NAStuff._blankCharDesc or InstanceNew("HumanoidDescription")
		pcall(function() hum:ApplyDescriptionClientServer(NAStuff._blankCharDesc) end)
		Wait(0.15)
	end

	clearAppearance()
	hum:ApplyDescriptionClientServer(desc)
	Wait(0.25)
	ensureFace()
	ensureClothes()
	if hum.RigType==Enum.HumanoidRigType.R6 and uidFallback then
		local okA3,ap=pcall(Players.GetCharacterAppearanceAsync,Players,uidFallback)
		if okA3 and ap then
			for _,v in ipairs(ap:GetDescendants()) do
				if v:IsA("CharacterMesh") then
					v:Clone().Parent=char
				end
			end
		end
	end

	local targetKey = opts.targetKey or (uidFallback and ("uid:"..tostring(uidFallback))) or nil
	NAStuff._lastDescriptionKey = targetKey
end

NAmanage._resolveHumanoidDescription=function(target)
	if not target or target=="" then
		return nil
	end
	local userId=tonumber(target)
	if not userId then
		local ok,id=pcall(Players.GetUserIdFromNameAsync,Players,target)
		if not ok or not id then
			return nil
		end
		userId=id
	end
	local okDesc,desc=pcall(Players.GetHumanoidDescriptionFromUserId,Players,userId)
	if not okDesc or not desc then
		return nil
	end
	return desc,userId
end

cmd.add({"team"},{"team <team name>","Changes your team (for the client)"},function(...)
	local args={...}
	local teamName=Concat(args," ")
	teamName=teamName and teamName:gsub("^%s+",""):gsub("%s+$","") or""
	if teamName=="" then DoNotif("team <team name>",3,"Team") return end
	local teamsService=SafeGetService("Teams")
	if not teamsService then return end
	local lookup=Lower(teamName)
	local targetTeam=nil
	for _,team in ipairs(teamsService:GetChildren()) do
		if Lower(team.Name):find(lookup,1,true) then targetTeam=team break end
	end
	if not targetTeam then DoNotif(Format("Invalid team \"%s\"",teamName),3,"Team") return end
	local localPlayer=Players.LocalPlayer
	if not localPlayer then return end
	local character=getChar()
	local root=character and getRoot(character)
	local function assignTeam()
		pcall(function()
			localPlayer.Neutral=false
			localPlayer.Team=targetTeam
		end)
	end
	if typeof(firetouchinterest)=="function" and root then
		for _,spawnLocation in ipairs(workspace:GetDescendants()) do
			if spawnLocation:IsA("SpawnLocation") and spawnLocation.BrickColor==targetTeam.TeamColor and spawnLocation.AllowTeamChangeOnTouch then
				pcall(firetouchinterest,spawnLocation,root,0)
				Wait()
				pcall(firetouchinterest,spawnLocation,root,1)
				assignTeam()
				return
			end
		end
	end
	assignTeam()
end,true)

cmd.add({"nilchar"},{"nilchar","Temporarily parent your character to nil"},function()
	local char=getChar()
	if not char then
		DoNotif("Character unavailable",2)
		return
	end
	char.Parent=nil
end)

cmd.add({"unnilchar","nonilchar"},{"unnilchar (nonilchar)","Move your character back to workspace"},function()
	local char=getChar()
	if not char then
		DoNotif("Character unavailable",2)
		return
	end
	char.Parent=workspace
end)

cmd.add({"char","character","morph"},{"char <username/userid>","change your character's appearance to someone else's"},function(arg)
	local desc,userId=NAmanage._resolveHumanoidDescription(arg)
	if not desc or not userId then
		DoNotif("Unable to load that avatar.",3,"Char")
		return
	end
	local targetKey="char:"..tostring(userId)
	local opts={targetKey=targetKey}
	if NAStuff._lastDescriptionKey==targetKey then
		opts.forceRefresh=true
	end
	SpawnCall(function()
		NAmanage._applyFixedDescription(desc:Clone(),userId,opts)
	end)
end,true)

cmd.add({"unchar"},{"unchar","revert to your character"},function()
	local plr=Players.LocalPlayer
	if not plr then return end
	local desc=NAmanage._resolveHumanoidDescription(tostring(plr.UserId))
	if not desc then return end
	local targetKey="char:"..tostring(plr.UserId)
	local opts={targetKey=targetKey}
	if NAStuff._lastDescriptionKey==targetKey then
		opts.forceRefresh=true
	end
	SpawnCall(function()
		NAmanage._applyFixedDescription(desc:Clone(),plr.UserId,opts)
	end)
end)

cmd.add({"autochar","achar"},{"autochar","auto-change your character on respawn"},function(target)
	local desc,userId=NAmanage._resolveHumanoidDescription(target)
	if not desc or not userId then
		DoNotif("Unable to load that avatar.",3,"Autochar")
		return
	end
	local targetKey="char:"..tostring(userId)
	NAStuff.AutoChar={UserId=userId,Description=desc}
	NAlib.disconnect("autochar")
	NAlib.connect("autochar",Players.LocalPlayer.CharacterAdded:Connect(function()
		SpawnCall(function()
			Wait(0.3)
			if NAStuff.AutoChar and NAStuff.AutoChar.Description and NAStuff.AutoChar.UserId then
				local evKey="char:"..tostring(NAStuff.AutoChar.UserId)
				local opts={targetKey=evKey}
				if NAStuff._lastDescriptionKey==evKey then
					opts.forceRefresh=true
				end
				NAmanage._applyFixedDescription(NAStuff.AutoChar.Description:Clone(),NAStuff.AutoChar.UserId,opts)
			end
		end)
	end))
	SpawnCall(function()
		local opts={targetKey=targetKey}
		if NAStuff._lastDescriptionKey==targetKey then
			opts.forceRefresh=true
		end
		NAmanage._applyFixedDescription(desc:Clone(),userId,opts)
	end)
end,true)

cmd.add({"unautochar","unachar"},{"unautochar","stop auto-change on respawn"},function()
	NAlib.disconnect("autochar")
	NAStuff.AutoChar=nil
end)

cmd.add({"autooutfit","aoutfit"},{"autooutfit {username/userid}","Auto-apply a selected outfit on respawn"},function(arg)
	if not arg or arg=="" then return end
	local req=opt and opt.NAREQUEST;if not req then DoNotif("HTTP not available",3,"AutoOutfit") return end
	local uid=tonumber(arg);if not uid then local ok,id=pcall(Players.GetUserIdFromNameAsync,Players,arg);if ok and id then uid=id else DoNotif("Couldn't resolve user",3,"AutoOutfit") return end end
	local function lowerKeys(t)local r={};for k,v in pairs(t or{})do r[Lower(k)]=v end;return r end
	local function hostOf(url)return Match(url,"^https?://([^/]+)") or"" end
	local function httpJSON(url)
		local host=hostOf(url)
		local cd=NAStuff._httpCooldown[host];if cd and time()<cd then local left=math.max(0,cd-time());DoNotif(Format("Loading outfits… retrying in %.1fs",left),math.max(1.2,left),"AutoOutfit");return false,"cooldown" end
		local okR,resp=pcall(req,{Url=url,Method="GET"})
		local status=okR and (resp.StatusCode or resp.Status) or 0
		local text=okR and (resp.Body or resp.body) or""
		if status==200 and type(text)=="string" then local okJ,data=pcall(HttpService.JSONDecode,HttpService,text);if okJ then NAStuff._httpBackoff[host]=0 return true,data end return false,"bad json" end
		if status==429 then
			local hdrs=lowerKeys(resp and (resp.Headers or resp.headers) or{})
			local ra=tonumber(hdrs["retry-after"]) or tonumber(hdrs["x-ratelimit-retryafter"]) or nil
			local waitSec=math.clamp((ra or (NAStuff._httpBackoff[host] and NAStuff._httpBackoff[host]*2 or 1.5))+math.random()*0.25,1,10)
			NAStuff._httpBackoff[host]=waitSec;NAStuff._httpCooldown[host]=time()+waitSec
			DoNotif(Format("Loading outfits… retrying in %.1fs",waitSec),math.max(1.5,waitSec),"AutoOutfit")
			return false,"retry"
		end
		if status>=500 and status<600 then
			local waitSec=math.clamp((NAStuff._httpBackoff[host] and NAStuff._httpBackoff[host]*1.5 or 1.0)+math.random()*0.2,0.8,8)
			NAStuff._httpBackoff[host]=waitSec;NAStuff._httpCooldown[host]=time()+waitSec
			DoNotif(Format("Loading outfits… retrying in %.1fs",waitSec),math.max(1.5,waitSec),"AutoOutfit")
			return false,"retry"
		end
		return false,"bad response "..tostring(status)
	end
	local outfits={}
	local cache=NAStuff._outfitCache[uid]
	if cache and (time()-cache.t)<120 and cache.list and #cache.list>0 then
		outfits=cache.list
	else
		local cursor=nil
		repeat
			local url=Format("https://avatar.roblox.com/v1/users/%d/outfits?itemsPerPage=50%s",uid,cursor and("&cursor="..HttpService:UrlEncode(cursor)) or"")
			local okD,data=httpJSON(url);if not okD then return end
			for _,it in ipairs(data.data or{})do if it and it.id and it.name and it.isEditable==true then Insert(outfits,{id=it.id,name=it.name}) end end
			cursor=data.nextPageCursor
			if cursor then Wait(0.4) end
		until not cursor
		if #outfits==0 then DoNotif("No user-created outfits for that user",2,"AutoOutfit") return end
		NAStuff._outfitCache[uid]={t=time(),list=outfits}
	end
	local buttons={}
	for _,o in ipairs(outfits)do
		Insert(buttons,{Text=Format("%s  (#%d)",o.name,o.id),Callback=function()
			NAlib.disconnect("autooutfit")
			NAStuff.autoOutfitState={id=o.id,name=o.name,owner=uid}
			local outfitKey="autooutfit:"..tostring(o.id)
			local function applyAutoOutfit(desc)
				local opts={targetKey=outfitKey}
				if NAStuff._lastDescriptionKey==outfitKey then
					opts.forceRefresh=true
				end
				NAmanage._applyFixedDescription(desc:Clone(),Players.LocalPlayer.UserId,opts)
			end
			NAlib.connect("autooutfit",Players.LocalPlayer.CharacterAdded:Connect(function()
				SpawnCall(function()
					local okD,desc=pcall(Players.GetHumanoidDescriptionFromOutfitId,Players,o.id)
					if okD and desc then applyAutoOutfit(desc) end
				end)
			end))
			SpawnCall(function()
				local okD,desc=pcall(Players.GetHumanoidDescriptionFromOutfitId,Players,o.id)
				if okD and desc then applyAutoOutfit(desc) end
			end)
			DoNotif("Auto outfit set: "..o.name,2,"AutoOutfit")
		end})
	end
	Window({Title=Format("AutoOutfit • %s (%d)",tostring(arg),uid),Buttons=buttons})
end,true)

cmd.add({"unautooutfit","unaoutfit"},{"unautooutfit","stop outfit auto-apply"},function()
	NAlib.disconnect("autooutfit");NAStuff.autoOutfitState=nil;DoNotif("Auto outfit disabled",2,"AutoOutfit")
end)

cmd.add({"outfit"},{"outfit {username/userid}","Open a list of a user's saved outfits"},function(arg)
	if not arg or arg=="" then return end
	NAStuff=NAStuff or{};NAStuff._outfitCache=NAStuff._outfitCache or{};NAStuff._httpBackoff=NAStuff._httpBackoff or{};NAStuff._httpCooldown=NAStuff._httpCooldown or{}
	local req=opt and opt.NAREQUEST;if not req then DoNotif("HTTP not available",3,"Outfits") return end
	local uid=tonumber(arg)
	if not uid then
		local ok,id=pcall(Players.GetUserIdFromNameAsync,Players,arg)
		if ok and id then uid=id else
			local body=HttpService:JSONEncode({usernames={arg},excludeBannedUsers=true})
			local okR,resp=pcall(req,{Url="https://users.roblox.com/v1/usernames/users",Method="POST",Headers={["Content-Type"]="application/json"},Body=body})
			local status=okR and (resp.StatusCode or resp.Status) or 0
			local text=okR and (resp.Body or resp.body) or""
			if status==200 and type(text)=="string" then
				local okJ,data=pcall(HttpService.JSONDecode,HttpService,text)
				if okJ and data and data.data and data.data[1] and data.data[1].id then uid=data.data[1].id end
			end
			if not uid then DoNotif("Couldn't resolve user",3,"Outfits") return end
		end
	end
	local cache=NAStuff._outfitCache[uid]
	if cache and (time()-cache.t)<120 and cache.list and #cache.list>0 then
		local buttons={}
		for _,o in ipairs(cache.list) do
			Insert(buttons,{Text=Format("%s  (#%d)",o.name,o.id),Callback=function()
				local okD,desc=pcall(Players.GetHumanoidDescriptionFromOutfitId,Players,o.id)
				if not okD or not desc then DoNotif("Failed to fetch outfit",3,"Outfits") return end
				NAStuff.lastSelectedOutfitId=o.id
				if NAmanage._applyFixedDescription then
					local outfitKey="outfit:"..tostring(o.id)
					local opts={targetKey=outfitKey}
					if NAStuff._lastDescriptionKey==outfitKey then
						opts.forceRefresh=true
					end
					NAmanage._applyFixedDescription(desc:Clone(),Players.LocalPlayer.UserId,opts)
				else
					local char=getChar() or Players.LocalPlayer.CharacterAdded:Wait()
					local hum=getHum() or char:WaitForChild("Humanoid",3)
					if not hum then return end
					local blank=InstanceNew("HumanoidDescription");hum:ApplyDescriptionClientServer(blank);Wait();hum:ApplyDescriptionClientServer(desc)
				end
				DoNotif("Outfit applied: "..o.name,2,"Outfits")
			end})
		end
		Window({Title=Format("Outfits • %s (%d) [cache]",tostring(arg),uid),Buttons=buttons})
		return
	end
	local function lowerKeys(t)local r={};for k,v in pairs(t or{})do r[Lower(k)]=v end;return r end
	local function hostOf(url)return Match(url,"^https?://([^/]+)") or"" end
	local function httpJSON(url)
		local host=hostOf(url)
		local cd=NAStuff._httpCooldown[host];if cd and time()<cd then local left=math.max(0,cd-time());DoNotif(Format("Loading outfits… retrying in %.1fs",left),math.max(1.2,left),"Outfits");return false,"cooldown" end
		local okR,resp=pcall(req,{Url=url,Method="GET"})
		local status=okR and (resp.StatusCode or resp.Status) or 0
		local text=okR and (resp.Body or resp.body) or""
		if status==200 and type(text)=="string" then local okJ,data=pcall(HttpService.JSONDecode,HttpService,text);if okJ then NAStuff._httpBackoff[host]=0 return true,data end return false,"bad json" end
		if status==429 then
			local hdrs=lowerKeys(resp and (resp.Headers or resp.headers) or{})
			local ra=tonumber(hdrs["retry-after"]) or tonumber(hdrs["x-ratelimit-retryafter"]) or nil
			local waitSec=math.clamp((ra or (NAStuff._httpBackoff[host] and NAStuff._httpBackoff[host]*2 or 1.5))+math.random()*0.25,1,10)
			NAStuff._httpBackoff[host]=waitSec;NAStuff._httpCooldown[host]=time()+waitSec
			DoNotif(Format("Loading outfits… retrying in %.1fs",waitSec),math.max(1.5,waitSec),"Outfits")
			return false,"429"
		end
		if status>=500 and status<600 then
			local waitSec=math.clamp((NAStuff._httpBackoff[host] and NAStuff._httpBackoff[host]*1.5 or 1.0)+math.random()*0.2,0.8,8)
			NAStuff._httpBackoff[host]=waitSec;NAStuff._httpCooldown[host]=time()+waitSec
			DoNotif(Format("Loading outfits… retrying in %.1fs",waitSec),math.max(1.5,waitSec),"Outfits")
			return false,"5xx"
		end
		return false,"bad response "..tostring(status)
	end
	local outfits,cursor={},nil
	repeat
		local url=Format("https://avatar.roblox.com/v1/users/%d/outfits?itemsPerPage=50%s",uid,cursor and("&cursor="..HttpService:UrlEncode(cursor)) or"")
		local okD,data=httpJSON(url)
		if not okD then if data=="429" or data=="5xx" or data=="cooldown" then return else DoNotif(data,3,"Outfits") return end end
		for _,it in ipairs(data.data or{})do if it and it.id and it.name and it.isEditable==true then Insert(outfits,{id=it.id,name=it.name}) end end
		cursor=data.nextPageCursor
		if cursor then Wait(0.4) end
	until not cursor
	if #outfits==0 then DoNotif("No user-created outfits for that user",2,"Outfits") return end
	NAStuff._outfitCache[uid]={t=time(),list=outfits}
	local buttons={}
	for _,o in ipairs(outfits)do
		Insert(buttons,{Text=Format("%s  (#%d)",o.name,o.id),Callback=function()
			local okD,desc=pcall(Players.GetHumanoidDescriptionFromOutfitId,Players,o.id)
			if not okD or not desc then DoNotif("Failed to fetch outfit",3,"Outfits") return end
			NAStuff.lastSelectedOutfitId=o.id
			if NAmanage._applyFixedDescription then
				local outfitKey="outfit:"..tostring(o.id)
				local opts={targetKey=outfitKey}
				if NAStuff._lastDescriptionKey==outfitKey then
					opts.forceRefresh=true
				end
				NAmanage._applyFixedDescription(desc:Clone(),Players.LocalPlayer.UserId,opts)
			else
				local char=getChar() or Players.LocalPlayer.CharacterAdded:Wait()
				local hum=getHum() or char:WaitForChild("Humanoid",3)
				if not hum then return end
				local blank=InstanceNew("HumanoidDescription");hum:ApplyDescriptionClientServer(blank);Wait();hum:ApplyDescriptionClientServer(desc)
			end
			DoNotif("Outfit applied: "..o.name,2,"Outfits")
		end})
	end
	Window({Title=Format("Outfits • %s (%d)",tostring(arg),uid),Buttons=buttons})
end,true)

cmd.add({"goto","to","tp","teleport"},{"goto <player|X,Y,Z>","Teleport to the given player or X,Y,Z coordinates"},function(...)
	local input   = Concat({...}," ")
	local targets = getPlr(input)
	local char    = getChar()
	if #targets > 0 then
		for _,plr in ipairs(targets) do
			char:PivotTo(plr.Character:GetPivot())
		end
	else
		local x,y,z = input:match("^(%-?%d+%.?%d*)[,%s]+(%-?%d+%.?%d*)[,%s]+(%-?%d+%.?%d*)$")
		if x and y and z then
			char:PivotTo(CFrame.new(tonumber(x),tonumber(y),tonumber(z)))
		else
			DebugNotif("Invalid input: not a valid player or X,Y,Z coordinates",3)
		end
	end
end,true)

function stareFIXER(char, facePos)
	local root = getRoot(char)
	if not root then return end
	local pos = root.Position
	local flatTarget = Vector3.new(facePos.X, pos.Y, facePos.Z)
	if (flatTarget - pos).Magnitude < 0.1 then return end
	root.CFrame = CFrame.new(pos, flatTarget)
end

cmd.add({"lookat", "stare"}, {"lookat <player>", "Stare at a player"}, function(...)
	local Username = (...)
	local Target = getPlr(Username)

	for _, plr in next, Target do
		NAlib.disconnect("stare_direct")

		local lp = Players.LocalPlayer
		if not (lp.Character and getRoot(lp.Character)) then return end
		if not (plr and plr.Character and getRoot(plr.Character)) then return end

		getHum().AutoRotate = false

		local function Stare()
			if lp.Character and plr.Character and getRoot(plr.Character) then
				stareFIXER(lp.Character, getRoot(plr.Character).Position)
			elseif not Players:FindFirstChild(plr.Name) then
				NAlib.disconnect("stare_direct")
			end
		end

		NAlib.connect("stare_direct", RunService.RenderStepped:Connect(Stare))
	end
end, true)

cmd.add({"unlookat", "unstare"}, {"unlookat", "Stops staring"}, function()
	NAlib.disconnect("stare_direct")
	if getHum() then
		getHum().AutoRotate = true
	end
end)

cmd.add({"starenear", "stareclosest"}, {"starenear (stareclosest)", "Stare at the closest player"}, function()
	NAlib.disconnect("stare_nearest")

	local function getClosest()
		local lp = Players.LocalPlayer
		local char = lp.Character
		if not (char and getRoot(char)) then return nil end

		local closest, dist = nil, math.huge
		local pos = getRoot(char).Position
		for _, p in ipairs(Players:GetPlayers()) do
			if p ~= lp and p.Character and getRoot(p.Character) then
				local pPos = getRoot(p.Character).Position
				local d = (pPos - pos).Magnitude
				if d < dist then
					dist = d
					closest = p
				end
			end
		end
		return closest
	end

	local lp = Players.LocalPlayer
	if getHum() then
		getHum().AutoRotate = false
	end

	local function stare()
		local lp = Players.LocalPlayer
		local char = lp.Character
		if not (char and getRoot(char)) then return end
		local target = getClosest()
		if target and target.Character and getRoot(target.Character) then
			stareFIXER(char, getRoot(target.Character).Position)
		end
	end

	NAlib.connect("stare_nearest", RunService.RenderStepped:Connect(stare))
end)

cmd.add({"unstarenear", "unstareclosest"}, {"unstarenear (unstareclosest)", "Stop staring at closest player"}, function()
	NAlib.disconnect("stare_nearest")
	if getHum() then
		getHum().AutoRotate = true
	end
end)

specUI = nil
connStep, connAdd, connRemove = nil, nil, nil

local spectateTarget, spectateSubject = nil, nil
local spectateConns = {
	char = nil,
	leave = nil,
	loop = nil,
	cam = nil,
	camW = nil
}

originalIO.disconnectSpectateConns=function()
	for k, c in pairs(spectateConns) do
		if c then
			c:Disconnect()
			spectateConns[k] = nil
		end
	end
	NAlib.disconnect("spectate_char")
	NAlib.disconnect("spectate_loop")
	NAlib.disconnect("spectate_leave")
	NAlib.disconnect("spectate_cam")
	NAlib.disconnect("spectate_camW")
end

originalIO.ensureCam=function()
	if not spectateTarget or not spectateSubject then return end
	if not workspace then return end
	local cam = workspace.CurrentCamera
	if not cam then return end
	if NAlib.isProperty(cam, "CameraSubject") == nil then return end
	if cam.CameraSubject ~= spectateSubject then
		NAlib.setProperty(cam, "CameraSubject", spectateSubject)
	end
end

originalIO.hookCameraGuard=function()
	if not workspace then return end
	local cam = workspace.CurrentCamera
	if not cam then return end

	if spectateConns.cam then
		spectateConns.cam:Disconnect()
		spectateConns.cam = nil
	end

	if NAlib.isProperty(cam, "CameraSubject") ~= nil then
		spectateConns.cam = NAlib.connect("spectate_cam", cam:GetPropertyChangedSignal("CameraSubject"):Connect(function()
			if not spectateTarget or not spectateSubject then return end
			originalIO.ensureCam()
		end))
	end

	if not spectateConns.camW and NAlib.isProperty(workspace, "CurrentCamera") ~= nil then
		spectateConns.camW = NAlib.connect("spectate_camW", workspace:GetPropertyChangedSignal("CurrentCamera"):Connect(function()
			if not spectateTarget or not spectateSubject then return end
			originalIO.hookCameraGuard()
			originalIO.ensureCam()
		end))
	end
end

function cleanup(preserveSpecUI)
	spectateTarget = nil
	spectateSubject = nil

	originalIO.disconnectSpectateConns()

	if connStep then connStep:Disconnect() connStep = nil end
	if connAdd then connAdd:Disconnect() connAdd = nil end
	if connRemove then connRemove:Disconnect() connRemove = nil end

	if specUI and not preserveSpecUI then
		specUI:Destroy()
		specUI = nil
	end

	local hum = getHum()
	if workspace then
		local cam = workspace.CurrentCamera
		if hum and cam and NAlib.isProperty(cam, "CameraSubject") ~= nil then
			NAlib.setProperty(cam, "CameraSubject", hum)
		end
	end
end

function spectatePlayer(targetPlayer)
	if not targetPlayer then return end

	spectateTarget = targetPlayer
	spectateSubject = nil
	originalIO.disconnectSpectateConns()

	local function setCamToCharacter(character)
		if spectateTarget ~= targetPlayer or not character then return end

		local hum = getPlrHum(character)
		local subj = hum or getRoot(character)
		if not subj then return end

		spectateSubject = subj
		originalIO.ensureCam()
		originalIO.hookCameraGuard()
	end

	setCamToCharacter(targetPlayer.Character)

	spectateConns.char = NAlib.connect("spectate_char", targetPlayer.CharacterAdded:Connect(function(character)
		if spectateTarget ~= targetPlayer then return end
		setCamToCharacter(character)
	end))

	spectateConns.leave = NAlib.connect("spectate_leave", Players.PlayerRemoving:Connect(function(player)
		if player == targetPlayer and spectateTarget == targetPlayer then
			cleanup(true)
			DebugNotif("Player left - camera reset")
		end
	end))

	spectateConns.loop = NAlib.connect("spectate_loop", RunService.RenderStepped:Connect(function()
		if spectateTarget ~= targetPlayer then return end

		local char = targetPlayer.Character
		if not char or not char.Parent then return end

		if not spectateSubject or spectateSubject.Parent ~= char then
			setCamToCharacter(char)
		else
			originalIO.ensureCam()
		end
	end))
end

cmd.add({"watch", "view", "spectate"}, {"watch <Player> (view, spectate)", "Spectate player"}, function(...)
	cleanup()
	local targetPlayer = getPlr((...))
	for _, plr in next, targetPlayer do
		if not plr then return end
		spectatePlayer(plr)
	end
end, true)

cmd.add({"unwatch", "unview"}, {"unwatch (unview)", "Stop spectating"}, function()
	cleanup()
end)

cmd.add({"watch2","view2","spectate2"},{"watch2",""},function()
	NAlib.disconnect("spectate_char")
	NAlib.disconnect("spectate_loop")
	NAlib.disconnect("spectate_leave")

	local LocalPlayer = Players.LocalPlayer
	local PAD = 8
	local CARD_W = IsOnMobile and 0.6 or 0.4
	local CARD_H = IsOnMobile and 62 or 68
	local BTN_H = IsOnMobile and 34 or 32
	local BTN_W_SIDE = IsOnMobile and 58 or 60
	local BTN_W_V = IsOnMobile and 34 or 32
	local BTN_W_X = IsOnMobile and 34 or 32
	local AV_SZ = IsOnMobile and 40 or 42
	local ROW_H = IsOnMobile and 40 or 34
	local HEADER_H = IsOnMobile and 36 or 32

	local ui, card, avatar, nameMain, nameSub, toggleBtn, btnPrev, btnNext, btnClose
	local drop, searchBox, list, listLayout, dropMaxH
	local listOpen, dropdownBusy = false, false
	local dropdownSeq = 0

	local playerList, currentIndex, spectatedPlayer = {}, 1, nil
	local rows = {}
	local searchTerm = ""
	local thumbCache = {}
	local fallbackThumbFmt = "rbxthumb://type=AvatarHeadShot&id=%d&w=420&h=420"

	local function getHeadshot(plr)
		-- Roblox occasionally throws from GetUserThumbnailAsync, cache and fall back so the UI never breaks.
		if not plr then
			return Format(fallbackThumbFmt, 0)
		end
		local userId = tonumber(plr.UserId) or 0
		if thumbCache[userId] then
			return thumbCache[userId]
		end
		local ok, image = pcall(function()
			return Players:GetUserThumbnailAsync(userId, Enum.ThumbnailType.HeadShot, Enum.ThumbnailSize.Size420x420)
		end)
		local resolved = (ok and image and image ~= "") and image or Format(fallbackThumbFmt, userId)
		thumbCache[userId] = resolved
		return resolved
	end

	local function insertSorted(plr)
		local n = #playerList
		if n == 0 then Insert(playerList, plr) return 1 end
		local key = Lower(plr.Name)
		local lo, hi, pos = 1, n, n + 1
		while lo <= hi do
			local mid = (lo + hi) // 2
			if Lower(playerList[mid].Name) > key then
				pos = mid
				hi = mid - 1
			else
				lo = mid + 1
			end
		end
		Insert(playerList, pos, plr)
		return pos
	end

	local function removeFromList(plr)
		local i = Discover(playerList, plr)
		if i then table.remove(playerList, i) return i end
	end

	local function matchesFilter(plr)
		if searchTerm == "" then return true end
		return Find(Lower(nameChecker(plr)), searchTerm, 1, true) ~= nil
	end

	local function setHeader(plr)
		if not plr then
			nameSub.Text = "Spectating"
			nameMain.Text = "None"
			return
		end
		nameSub.Text = "Spectating"
		nameMain.Text = nameChecker(plr)
		nameMain.TextColor3 = (plr == LocalPlayer) and Color3.fromRGB(255,255,0) or Color3.fromRGB(255,255,255)
		avatar.Image = getHeadshot(plr)
	end

	local function recolor()
		for _, btn in pairs(rows) do
			local lbl = btn:FindFirstChild("NameLabel")
			if lbl then
				local uid = btn:GetAttribute("uid")
				local plr = Players:GetPlayerByUserId(uid)
				if plr == LocalPlayer then
					lbl.TextColor3 = Color3.fromRGB(255,255,0)
				elseif spectatedPlayer and plr == spectatedPlayer then
					lbl.TextColor3 = Color3.fromRGB(0,162,255)
				else
					lbl.TextColor3 = Color3.fromRGB(255,255,255)
				end
			end
		end
	end

	local function gotoPlayer(plr)
		if not plr then return end
		spectatedPlayer = plr
		currentIndex = Discover(playerList, plr) or currentIndex
		setHeader(plr)
		spectatePlayer(plr)
		recolor()
	end

	local function gotoIndex(idx)
		if #playerList == 0 then return end
		if idx < 1 then idx = #playerList end
		if idx > #playerList then idx = 1 end
		currentIndex = idx
		gotoPlayer(playerList[currentIndex])
	end

	local function mkRow(plr)
		if not list or rows[plr.UserId] then return end
		local pb = InstanceNew("TextButton")
		pb.Parent = list
		pb.Name = Lower(plr.Name).."|"..tostring(plr.UserId)
		pb.Size = UDim2.new(1, 0, 0, ROW_H)
		pb.BackgroundColor3 = Color3.fromRGB(40,40,40)
		pb.AutoButtonColor = true
		pb.Text = ""
		pb:SetAttribute("uid", plr.UserId)
		local corner = InstanceNew("UICorner", pb) corner.CornerRadius = UDim.new(0, 10)
		local stroke = InstanceNew("UIStroke", pb) stroke.Thickness = 1 stroke.Transparency = 0.6 stroke.Color = Color3.fromRGB(70,70,70)
		local img = InstanceNew("ImageLabel", pb)
		img.Size = UDim2.new(0, ROW_H, 0, ROW_H)
		img.BackgroundTransparency = 1
		img.Image = getHeadshot(plr)
		local nameLbl = InstanceNew("TextLabel", pb)
		nameLbl.Name = "NameLabel"
		nameLbl.BackgroundTransparency = 1
		nameLbl.Size = UDim2.new(1, -ROW_H-12, 1, 0)
		nameLbl.Position = UDim2.new(0, ROW_H+12, 0, 0)
		nameLbl.Font = Enum.Font.SourceSansSemibold
		nameLbl.TextScaled = true
		nameLbl.TextXAlignment = Enum.TextXAlignment.Left
		nameLbl.TextColor3 = Color3.fromRGB(255,255,255)
		nameLbl.Text = nameChecker(plr)
		pb.Visible = matchesFilter(plr)
		MouseButtonFix(pb, function()
			gotoPlayer(plr)
		end)
		rows[plr.UserId] = pb
	end

	local function destroyRow(plr)
		local b = rows[plr.UserId]
		if b then b:Destroy() rows[plr.UserId] = nil end
	end

	local function filterRows()
		for uid, btn in pairs(rows) do
			local plr = Players:GetPlayerByUserId(uid)
			if plr then
				btn.Visible = matchesFilter(plr)
			else
				btn.Visible = false
			end
		end
		if drop and list then
			local headerH = HEADER_H + PAD*2
			local contentY = list.AbsoluteCanvasSize.Y
			local target = math.min(headerH + contentY + PAD, dropMaxH)
			drop.Size = UDim2.new(1, 0, 0, target)
		end
	end

	local function safeConnectProp(inst, prop, mySeq, cb)
		if not inst then return end
		local ok, sig = pcall(function() return inst:GetPropertyChangedSignal(prop) end)
		if not ok or not sig then return end
		sig:Connect(function()
			if dropdownSeq ~= mySeq or not drop or not list or inst.Parent == nil then return end
			cb()
		end)
	end

	local function openDropdown()
		if dropdownBusy or listOpen then return end
		dropdownBusy = true
		toggleBtn.Active = false
		toggleBtn.AutoButtonColor = false
		dropdownSeq += 1
		local mySeq = dropdownSeq

		drop = InstanceNew("Frame", card)
		drop.BackgroundColor3 = Color3.fromRGB(34,34,34)
		drop.BorderSizePixel = 0
		drop.Position = UDim2.new(0, 0, 1, PAD)
		drop.Size = UDim2.new(1, 0, 0, 0)
		local dCorner = InstanceNew("UICorner", drop) dCorner.CornerRadius = UDim.new(0, 12)
		local dStroke = InstanceNew("UIStroke", drop) dStroke.Thickness = 1 dStroke.Transparency = 0.6 dStroke.Color = Color3.fromRGB(64,64,64)

		local header = InstanceNew("Frame", drop)
		header.BackgroundTransparency = 1
		header.Size = UDim2.new(1, -PAD*2, 0, HEADER_H)
		header.Position = UDim2.new(0, PAD, 0, PAD)

		searchBox = InstanceNew("TextBox", header)
		searchBox.Size = UDim2.new(1, 0, 1, 0)
		searchBox.BackgroundColor3 = Color3.fromRGB(45,45,45)
		searchBox.TextXAlignment = Enum.TextXAlignment.Left
		searchBox.Font = Enum.Font.SourceSans
		searchBox.TextSize = IsOnMobile and 18 or 16
		searchBox.PlaceholderText = "Type to filter players"
		searchBox.PlaceholderColor3 = Color3.fromRGB(185,185,185)
		searchBox.ClearTextOnFocus = false
		searchBox.Text = searchTerm
		searchBox.TextColor3 = Color3.fromRGB(255,255,255)
		local sCorner = InstanceNew("UICorner", searchBox) sCorner.CornerRadius = UDim.new(0, 8)
		local sStroke = InstanceNew("UIStroke", searchBox) sStroke.Thickness = 1 sStroke.Transparency = 0.6 sStroke.Color = Color3.fromRGB(70,70,70)

		list = InstanceNew("ScrollingFrame", drop)
		list.BackgroundTransparency = 1
		list.BorderSizePixel = 0
		list.Position = UDim2.new(0, PAD, 0, HEADER_H + PAD*2)
		list.Size = UDim2.new(1, -PAD*2, 1, -(HEADER_H + PAD*3))
		list.AutomaticCanvasSize = Enum.AutomaticSize.Y
		list.CanvasSize = UDim2.new(0,0,0,0)
		list.ScrollBarThickness = 8
		list.ClipsDescendants = true
		listLayout = InstanceNew("UIListLayout", list)
		listLayout.SortOrder = Enum.SortOrder.Name
		listLayout.Padding = UDim.new(0, 6)
		local padIn = InstanceNew("UIPadding", list)
		padIn.PaddingLeft = UDim.new(0, 6)
		padIn.PaddingRight = UDim.new(0, 6)
		padIn.PaddingTop = UDim.new(0, 6)
		padIn.PaddingBottom = UDim.new(0, 6)

		local vpY = workspace.CurrentCamera and workspace.CurrentCamera.ViewportSize.Y or 720
		dropMaxH = math.floor(vpY * (IsOnMobile and 0.7 or 0.55))
		local openStart = TweenService:Create(drop, TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {Size = UDim2.new(1, 0, 0, math.min(dropMaxH, (IsOnMobile and 280 or 240)))})
		openStart:Play()

		for _, plr in ipairs(playerList) do
			mkRow(plr)
		end

		filterRows()

		safeConnectProp(searchBox, "Text", mySeq, function()
			searchTerm = Lower(searchBox.Text or "")
			filterRows()
		end)

		safeConnectProp(listLayout, "AbsoluteContentSize", mySeq, function()
			filterRows()
		end)

		toggleBtn.Text = "V"
		toggleBtn.Rotation = 180
		listOpen = true
		dropdownBusy = false
		toggleBtn.Active = true
		toggleBtn.AutoButtonColor = true
	end

	local function closeDropdown()
		if not listOpen and not dropdownBusy then return end
		dropdownSeq += 1
		dropdownBusy = false
		toggleBtn.Active = true
		toggleBtn.AutoButtonColor = true
		toggleBtn.Text = "V"
		toggleBtn.Rotation = 0
		if drop then
			local tClose = TweenService:Create(drop, TweenInfo.new(0.18, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {Size = UDim2.new(1, 0, 0, 0)})
			tClose:Play()
			tClose.Completed:Wait()
			if drop then drop:Destroy() end
		end
		drop, list, listLayout, searchBox = nil, nil, nil, nil
		listOpen = false
		rows = {}
	end

	local function buildCard()
		card = InstanceNew("Frame", ui)
		card.AnchorPoint = Vector2.new(0.5, 1)
		card.Size = UDim2.new(CARD_W, 0, 0, CARD_H)
		card.Position = UDim2.new(0.5, 0, 0.14, 0)
		card.BackgroundColor3 = Color3.fromRGB(24,24,24)
		card.BorderSizePixel = 0
		local cardCorner = InstanceNew("UICorner", card) cardCorner.CornerRadius = UDim.new(0, 12)
		local cardStroke = InstanceNew("UIStroke", card) cardStroke.Thickness = 1 cardStroke.Transparency = 0.5 cardStroke.Color = Color3.fromRGB(60,60,60)
		local grad = InstanceNew("UIGradient", card) grad.Color = ColorSequence.new(Color3.fromRGB(30,30,30), Color3.fromRGB(18,18,18))
		NAgui.draggerV2(card)

		local content = InstanceNew("Frame", card)
		content.BackgroundTransparency = 1
		content.Size = UDim2.new(1, -PAD*2, 1, -PAD*2)
		content.Position = UDim2.new(0, PAD, 0, PAD)

		avatar = InstanceNew("ImageLabel", content)
		avatar.Size = UDim2.new(0, AV_SZ, 0, AV_SZ)
		avatar.Position = UDim2.new(0, 0, 0.5, -AV_SZ/2)
		avatar.BackgroundTransparency = 1
		local avCorner = InstanceNew("UICorner", avatar) avCorner.CornerRadius = UDim.new(1, 0)

		nameSub = InstanceNew("TextLabel", content)
		nameSub.BackgroundTransparency = 1
		nameSub.Position = UDim2.new(0, AV_SZ + PAD, 0, 0)
		nameSub.Size = UDim2.new(1, -(AV_SZ + PAD), 0.45, 0)
		nameSub.Font = Enum.Font.SourceSans
		nameSub.TextScaled = true
		nameSub.TextXAlignment = Enum.TextXAlignment.Left
		nameSub.TextColor3 = Color3.fromRGB(185,185,185)
		nameSub.Text = "Spectating"

		nameMain = InstanceNew("TextLabel", content)
		nameMain.BackgroundTransparency = 1
		nameMain.Position = UDim2.new(0, AV_SZ + PAD, 0.48, 0)
		nameMain.Size = UDim2.new(1, -(AV_SZ + PAD), 0.5, 0)
		nameMain.Font = Enum.Font.SourceSansBold
		nameMain.TextScaled = true
		nameMain.TextXAlignment = Enum.TextXAlignment.Left
		nameMain.TextColor3 = Color3.fromRGB(255,255,255)
		nameMain.Text = ""

		btnPrev = InstanceNew("TextButton", card)
		btnPrev.Size = UDim2.new(0, BTN_W_SIDE, 0, BTN_H)
		btnPrev.AnchorPoint = Vector2.new(1, 0.5)
		btnPrev.Position = UDim2.new(0, -PAD, 0.5, 0)
		btnPrev.BackgroundColor3 = Color3.fromRGB(45,45,45)
		btnPrev.Text = "Prev"
		btnPrev.TextColor3 = Color3.fromRGB(255,255,255)
		btnPrev.Font = Enum.Font.SourceSansBold
		btnPrev.TextSize = IsOnMobile and 16 or 16
		local pc = InstanceNew("UICorner", btnPrev) pc.CornerRadius = UDim.new(0, 10)
		local ps = InstanceNew("UIStroke", btnPrev) ps.Thickness = 1 ps.Transparency = 0.5 ps.Color = Color3.fromRGB(70,70,70)
		MouseButtonFix(btnPrev, function() gotoIndex(currentIndex - 1) end)

		btnNext = InstanceNew("TextButton", card)
		btnNext.Size = UDim2.new(0, BTN_W_SIDE, 0, BTN_H)
		btnNext.AnchorPoint = Vector2.new(0, 0.5)
		btnNext.Position = UDim2.new(1, PAD, 0.5, 0)
		btnNext.BackgroundColor3 = Color3.fromRGB(45,45,45)
		btnNext.Text = "Next"
		btnNext.TextColor3 = Color3.fromRGB(255,255,255)
		btnNext.Font = Enum.Font.SourceSansBold
		btnNext.TextSize = IsOnMobile and 16 or 16
		local nc = InstanceNew("UICorner", btnNext) nc.CornerRadius = UDim.new(0, 10)
		local ns = InstanceNew("UIStroke", btnNext) ns.Thickness = 1 ns.Transparency = 0.5 ns.Color = Color3.fromRGB(70,70,70)
		MouseButtonFix(btnNext, function() gotoIndex(currentIndex + 1) end)

		toggleBtn = InstanceNew("TextButton", card)
		toggleBtn.Size = UDim2.new(0, BTN_W_V, 0, BTN_H)
		toggleBtn.AnchorPoint = Vector2.new(1, 1)
		toggleBtn.Position = UDim2.new(1, PAD, 1, PAD)
		toggleBtn.BackgroundColor3 = Color3.fromRGB(45,45,45)
		toggleBtn.Text = "V"
		toggleBtn.TextColor3 = Color3.fromRGB(255,255,255)
		toggleBtn.Font = Enum.Font.SourceSansBold
		toggleBtn.TextSize = IsOnMobile and 14 or 14
		local vc = InstanceNew("UICorner", toggleBtn) vc.CornerRadius = UDim.new(0, 10)
		local vs = InstanceNew("UIStroke", toggleBtn) vs.Thickness = 1 vs.Transparency = 0.5 vs.Color = Color3.fromRGB(70,70,70)
		MouseButtonFix(toggleBtn, function()
			if listOpen then closeDropdown() else openDropdown() end
		end)

		btnClose = InstanceNew("TextButton", card)
		btnClose.Size = UDim2.new(0, BTN_W_X, 0, BTN_H)
		btnClose.AnchorPoint = Vector2.new(1, 0)
		btnClose.Position = UDim2.new(1, PAD, 0, -PAD)
		btnClose.BackgroundColor3 = Color3.fromRGB(255,60,60)
		btnClose.Text = "X"
		btnClose.TextColor3 = Color3.fromRGB(255,255,255)
		btnClose.Font = Enum.Font.SourceSansBold
		btnClose.TextSize = IsOnMobile and 14 or 14
		local xc = InstanceNew("UICorner", btnClose) xc.CornerRadius = UDim.new(0, 10)
		local xs = InstanceNew("UIStroke", btnClose) xs.Thickness = 1 xs.Transparency = 0.5 xs.Color = Color3.fromRGB(120,30,30)
		MouseButtonFix(btnClose, function()
			NAlib.disconnect("spectate2_step")
			NAlib.disconnect("spectate2_add")
			NAlib.disconnect("spectate2_remove")
			if drop then drop:Destroy() drop=nil end
			listOpen, dropdownBusy = false, false
			cleanup()
		end)
	end

	local function initialRoster()
		table.clear(playerList)
		for _, p in ipairs(Players:GetPlayers()) do
			insertSorted(p)
		end
	end

	initialRoster()
	if #playerList == 0 then return DebugNotif("No players to spectate", 2) end

	ui = InstanceNew("ScreenGui")
	NaProtectUI(ui)
	ui.ResetOnSpawn = false
	ui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
	ui.DisplayOrder = 10

	buildCard()
	specUI = ui
	gotoIndex(1)

	NAlib.connect("spectate2_add", Players.PlayerAdded:Connect(function(plr)
		local wasOpen = listOpen
		local keep = searchTerm
		local prevSel = spectatedPlayer
		insertSorted(plr)
		if wasOpen and list then mkRow(plr) filterRows() end
		if prevSel then
			currentIndex = Discover(playerList, prevSel) or currentIndex
		elseif #playerList > 0 and not prevSel then
			gotoIndex(1)
		end
		searchTerm = keep
	end))

	NAlib.connect("spectate2_remove", Players.PlayerRemoving:Connect(function(plr)
		local wasOpen = listOpen
		local keep = searchTerm
		local prevSel = spectatedPlayer
		local removedIndex = removeFromList(plr)
		if wasOpen and list then destroyRow(plr) filterRows() end
		if prevSel == plr then
			spectatedPlayer = nil
			nameMain.Text = "None"
			local hum = getHum()
			if hum then workspace.CurrentCamera.CameraSubject = hum end
		else
			if prevSel then currentIndex = Discover(playerList, prevSel) or currentIndex end
		end
		searchTerm = keep
	end))
end, true)

cmd.add({"unwatch2","unview2"},{"unwatch2",""},function()
	NAlib.disconnect("spectate2_step")
	NAlib.disconnect("spectate2_add")
	NAlib.disconnect("spectate2_remove")
	cleanup()
	DebugNotif("Spectate stopped", 1.2)
end, true)

cmd.add({"stealaudio","getaudio","steal","logaudio"},{"stealaudio <player>","Save all sounds a player is playing to a file -Cyrus"},function(p)
	Wait(.1)
	local players=getPlr(p)
	if not next(players) then DoNotif("Player not found") return end
	local ids={}
	for _,plr in pairs(players)do
		local char=plr and plr.Character
		if char then
			for _,snd in pairs(char:GetDescendants())do
				if snd:IsA("Sound") and snd.Playing then
					ids[#ids+1]=snd.SoundId
				end
			end
		end
	end
	if #ids>0 then
		setclipboard(Concat(ids,"\n"))
		DebugNotif("Audio links copied.")
	else
		DebugNotif("No audio found.")
	end
end,true)

cmd.add({"follow", "stalk", "walk"}, {"follow <player>", "Follow a player wherever they go"}, function(p)
	NAlib.disconnect("follow")
	local targetPlayers = getPlr(p)
	for _, plr in next, targetPlayers do
		if not plr then
			DoNotif("Player not found or invalid.")
			return
		end
		NAlib.connect("follow", RunService.RenderStepped:Connect(function()
			local target = plr.Character
			if target then
				local hum = getHum()
				local targetPart = getHead(target)
				if hum and targetPart then
					local targetPos = targetPart.Position
					hum:MoveTo(targetPos)
				else
					NAlib.disconnect("follow")
				end
			else
				NAlib.disconnect("follow")
			end
		end))
	end
end, true)

cmd.add({"unfollow", "unstalk", "unwalk", "unpathfind"}, {"unfollow", "Stop all attempts to follow a player"}, function()
	NAlib.disconnect("follow")
end)

PROXIMITY_RADIUS = 15
lastDistances = {}
ISfollowing = false
followTarget = nil
followConnection = nil
flwCharAdd = nil

cmd.add({"autofollow", "autostalk", "proxfollow"}, {"autofollow (autostalk,proxfollow)", "Automatically follow any player who comes close"}, function()
	NAlib.disconnect("autofollow")
	if followConnection then followConnection:Disconnect() followConnection = nil end
	if flwCharAdd then flwCharAdd:Disconnect() flwCharAdd = nil end
	lastDistances = {}
	ISfollowing = false
	followTarget = nil

	NAlib.connect("autofollow", RunService.Stepped:Connect(function()
		if ISfollowing then return end

		local myChar = getChar()
		local myRoot = getRoot(myChar)
		local myHum = getHum()
		if not (myChar and myRoot and myHum) then return end

		for _, plr in ipairs(Players:GetPlayers()) do
			if plr ~= LocalPlayer then
				local char = plr.Character
				local root = getRoot(char)
				if char and root then
					local currentDist = (myRoot.Position - root.Position).Magnitude
					local lastDist = lastDistances[plr]

					if lastDist and lastDist > PROXIMITY_RADIUS and currentDist < PROXIMITY_RADIUS and currentDist < lastDist then
						ISfollowing = true
						followTarget = plr

						local function setupFollow(char)
							local targetRoot = getRoot(char)
							while not targetRoot do Wait(.1) targetRoot=getRoot(char) end

							if followConnection then followConnection:Disconnect() end
							followConnection = RunService.Stepped:Connect(function()
								if myChar and myHum and targetRoot and char and char.Parent then
									myHum:MoveTo(targetRoot.Position)
								else
									if followConnection then followConnection:Disconnect() followConnection = nil end
									if flwCharAdd then flwCharAdd:Disconnect() flwCharAdd = nil end
									ISfollowing = false
									followTarget = nil
								end
							end)

							local hum = getPlrHum(plr)
							if hum then
								hum.Died:Connect(function()
									if followConnection then followConnection:Disconnect() followConnection = nil end
									ISfollowing = false
									followTarget = nil
								end)
							end
						end

						if plr.Character then
							setupFollow(plr.Character)
						end

						if flwCharAdd then flwCharAdd:Disconnect() end
						flwCharAdd = plr.CharacterAdded:Connect(function(newChar)
							Wait(0.1)
							setupFollow(newChar)
						end)

						break
					end

					lastDistances[plr] = currentDist
				end
			end
		end
	end))
end)

cmd.add({"unautofollow", "stopautofollow", "unproxfollow"}, {"unautofollow (stopautofollow,unproxfollow)", "Stop automatically following nearby players"}, function()
	NAlib.disconnect("autofollow")
	if followConnection then followConnection:Disconnect() followConnection = nil end
	if flwCharAdd then flwCharAdd:Disconnect() flwCharAdd = nil end
	lastDistances = {}
	ISfollowing = false
	followTarget = nil
end)

cmd.add({"pathfind"},{"pathfind <player>","Follow a player using the pathfinder API wherever they go"},function(p)
	Wait(.1)
	local players=getPlr(p)
	for _,plr in ipairs(players)do
		if plr then
			NAlib.disconnect("follow")
			local ps=SafeGetService("PathfindingService")
			local lastSrc, lastDst = Vector3.new(), Vector3.new()
			NAlib.connect("follow",RunService.Heartbeat:Connect(function()
				local hum=getHum() local char=getChar() local tgt=plr.Character
				if not(hum and char and tgt and hum.RootPart) then return end
				local src=hum.RootPart.Position
				local dst=(getRoot(tgt) or getHead(tgt)).Position+Vector3.new(0,0,-2)
				if (src-lastSrc).Magnitude>1 or (dst-lastDst).Magnitude>1 then
					lastSrc, lastDst = src, dst
					local path=ps:CreatePath{AgentRadius=2,AgentHeight=5,AgentCanJump=true}
					path:ComputeAsync(src,dst)
					if path.Status~=Enum.PathStatus.NoPath then
						for _,wp in ipairs(path:GetWaypoints())do
							if wp.Action==Enum.PathWaypointAction.Jump then
								if hum:GetState()~=Enum.HumanoidStateType.Freefall and hum.FloorMaterial~=Enum.Material.Air then
									hum:ChangeState(Enum.HumanoidStateType.Jumping)
								end
							end
							hum:MoveTo(wp.Position)
							hum.MoveToFinished:Wait(1)
						end
					end
				end
			end))
		end
	end
end,true)

freezeBTNTOGGLE = nil
isFrozennn = false

cmd.add({"freeze","thaw","anchor","fr"},{"freeze (thaw,anchor,fr)","Freezes your character"}, function(bool)
	local char = getChar()
	if not char then return end

	for _, part in ipairs(char:GetChildren()) do
		if part:IsA("BasePart") then
			part.Anchored = true
		end
	end
	isFrozennn = true

	if IsOnMobile and not bool then
		if freezeBTNTOGGLE then freezeBTNTOGGLE:Destroy() freezeBTNTOGGLE = nil end

		freezeBTNTOGGLE = InstanceNew("ScreenGui")
		local btn = InstanceNew("TextButton")
		local corner = InstanceNew("UICorner")
		local aspect = InstanceNew("UIAspectRatioConstraint")

		NaProtectUI(freezeBTNTOGGLE)
		freezeBTNTOGGLE.ResetOnSpawn = false

		btn.Parent = freezeBTNTOGGLE
		btn.BackgroundColor3 = Color3.fromRGB(0, 170, 0)
		btn.BackgroundTransparency = 0.1
		btn.Position = UDim2.new(0.9, 0, 0.6, 0)
		btn.Size = UDim2.new(0.08, 0, 0.1, 0)
		btn.Font = Enum.Font.GothamBold
		btn.Text = "UNFRZ"
		btn.TextColor3 = Color3.fromRGB(255, 255, 255)
		btn.TextSize = 18
		btn.TextWrapped = true
		btn.Active = true
		btn.TextScaled = true

		corner.CornerRadius = UDim.new(0.2, 0)
		corner.Parent = btn

		aspect.Parent = btn
		aspect.AspectRatio = 1.0

		NAgui.draggerV2(btn)

		MouseButtonFix(btn, function()
			local char = getChar()
			if not char then return end

			for _, part in ipairs(char:GetChildren()) do
				if part:IsA("BasePart") then
					part.Anchored = not isFrozennn
				end
			end

			isFrozennn = not isFrozennn
			btn.Text = isFrozennn and "UNFRZ" or "FRZ"
			btn.BackgroundColor3 = isFrozennn and Color3.fromRGB(0, 170, 0) or Color3.fromRGB(170, 0, 0)
		end)
	end
end)

cmd.add({"unfreeze","unthaw","unanchor","unfr"},{"unfreeze (unthaw,unanchor,unfr)","Unfreezes your character"}, function()
	local char = getChar()
	if not char then return end

	for _, part in ipairs(char:GetChildren()) do
		if part:IsA("BasePart") then
			part.Anchored = false
		end
	end

	isFrozennn = false

	if freezeBTNTOGGLE then
		freezeBTNTOGGLE:Destroy()
		freezeBTNTOGGLE = nil
	end
end)

cmd.add({"blackhole","bhole","bholepull"},{"blackhole","Makes unanchored parts teleport to the black hole"},function()
	if NAlib.isConnected("blackhole_force") then return DebugNotif("Blackhole already exists.") end

	local UIS=SafeGetService("UserInputService")
	local Mouse=LocalPlayer:GetMouse()
	local Folder=InstanceNew("Folder",workspace)
	local Part=InstanceNew("Part",Folder)
	local Attachment1=InstanceNew("Attachment",Part)
	Part.Anchored=true Part.CanCollide=false Part.Transparency=1

	local Updated=Mouse.Hit+Vector3.new(0,5,0)
	_G.BlackholeAttachment=Attachment1
	_G.BlackholeTarget=Updated
	_G.BlackholeActive=false

	NAlib.connect("blackhole_sim",RunService.RenderStepped:Connect(function()
		settings().Physics.AllowSleep=false
		for _,plr in next,Players:GetPlayers() do
			if plr~=LocalPlayer then NACaller(function()
					plr.MaximumSimulationRadius=0
					opt.hiddenprop(plr,"SimulationRadius",0)
				end) end
		end
		NACaller(function()
			LocalPlayer.MaximumSimulationRadius=1e9
			opt.hiddenprop(LocalPlayer,"SimulationRadius",1e9)
		end)
	end))

	NAlib.connect("blackhole_pos",RunService.RenderStepped:Connect(function()
		if _G.BlackholeAttachment then
			_G.BlackholeAttachment.WorldCFrame=_G.BlackholeTarget
		end
	end))

	local function ForcePart(v)
		if not _G.BlackholeActive then return end
		if v:IsA("Part") and not v.Anchored and not v.Parent:FindFirstChildWhichIsA("Humanoid") and not v.Parent:FindFirstChild("Head") and v.Name~="Handle" then
			for _,x in next,v:GetChildren() do
				if x:IsA("BodyMover") or x:IsA("RocketPropulsion") then x:Destroy() end
			end
			for _,n in next,{"Attachment","AlignPosition","Torque"} do local i=v:FindFirstChild(n) if i then i:Destroy() end end
			v.CanCollide=false
			local a2=InstanceNew("Attachment",v)
			local align=InstanceNew("AlignPosition",v)
			local torque=InstanceNew("Torque",v)
			align.Attachment0=a2 align.Attachment1=_G.BlackholeAttachment
			align.MaxForce=1e9 align.MaxVelocity=math.huge align.Responsiveness=200
			torque.Attachment0=a2 torque.Torque=Vector3.new(100000,100000,100000)
		end
	end

	for _,v in next,workspace:GetDescendants() do ForcePart(v) end
	NAlib.connect("blackhole_force",workspace.DescendantAdded:Connect(ForcePart))

	UIS.InputBegan:Connect(function(k,chat)
		if k.KeyCode==Enum.KeyCode.E and not chat then
			_G.BlackholeTarget=Mouse.Hit+Vector3.new(0,5,0)
		end
	end)

	local sGUI=InstanceNew("ScreenGui")
	NaProtectUI(sGUI)

	local toggleBtn=InstanceNew("TextButton",sGUI)
	local toggleCorner=InstanceNew("UICorner",toggleBtn)
	toggleBtn.Text="Enable Blackhole"
	toggleBtn.AnchorPoint=Vector2.new(0.5,0)
	toggleBtn.Size=UDim2.new(0,160,0,40)
	toggleBtn.Position=UDim2.new(0.5,0,0.88,0)
	toggleBtn.BackgroundColor3=Color3.new(0.15,0.15,0.15)
	toggleBtn.TextColor3=Color3.new(1,1,1)
	toggleBtn.Font=Enum.Font.SourceSansBold
	toggleBtn.TextSize=18
	toggleCorner.CornerRadius=UDim.new(0.25,0)

	MouseButtonFix(toggleBtn,function()
		_G.BlackholeActive=not _G.BlackholeActive
		toggleBtn.Text=_G.BlackholeActive and "Disable Blackhole" or "Enable Blackhole"
		if not _G.BlackholeActive then
			for _,p in ipairs(workspace:GetDescendants()) do
				if p:IsA("BasePart") and not p.Anchored then
					for _,o in ipairs(p:GetChildren()) do
						if o:IsA("AlignPosition") or o:IsA("Torque") or o:IsA("Attachment") then o:Destroy() end
					end
				end
			end
			DebugNotif("Blackhole force disabled",2)
		else
			for _,v in next,workspace:GetDescendants() do ForcePart(v) end
			DebugNotif("Blackhole force enabled",2)
		end
	end)

	local moveBtn=InstanceNew("TextButton",sGUI)
	local moveCorner=InstanceNew("UICorner",moveBtn)
	moveBtn.Text="Move Blackhole"
	moveBtn.AnchorPoint=Vector2.new(0.5,0)
	moveBtn.Size=UDim2.new(0,160,0,40)
	moveBtn.Position=UDim2.new(0.5,0,0.94,0)
	moveBtn.BackgroundColor3=Color3.new(0.2,0.2,0.2)
	moveBtn.TextColor3=Color3.new(1,1,1)
	moveBtn.Font=Enum.Font.SourceSansBold
	moveBtn.TextSize=18
	moveCorner.CornerRadius=UDim.new(0.25,0)

	MouseButtonFix(moveBtn,function()
		_G.BlackholeTarget=Mouse.Hit+Vector3.new(0,5,0)
	end)

	NAgui.draggerV2(toggleBtn)
	NAgui.draggerV2(moveBtn)

	DebugNotif("Blackhole created. Tap button or press E to move",3)
end,true)

cmd.add({"disableanimations","disableanims"},{"disableanimations (disableanims)","Freezes your animations"},function()
	getChar().Animate.Disabled=true
end)

cmd.add({"undisableanimations","undisableanims"},{"undisableanimations (undisableanims)","Unfreezes your animations"},function()
	getChar().Animate.Disabled=false
end)

cmd.add({"hatresize"},{"hatresize","Makes your hats very big r15 only"},function()
	Wait();

	DebugNotif("Hat resize loaded, rthro needed")

	loadstring(game:HttpGet('https://raw.githubusercontent.com/DigitalityScripts/roblox-scripts/refs/heads/main/Patched/hat%20resize'))()
end)

cmd.add({"exit"},{"exit","Close down pedoblox"},function()
	game:Shutdown()
end)

cmd.add({"firekey","fkey"},{"firekey <key> (fkey)","makes you fire a keybind using VirtualInputManager"},function(...)
	local args = {...}
	local target = args[1]
	local vim=SafeGetService("VirtualInputManager");
	local keyMap = {
		["leftcontrol"] = Enum.KeyCode.LeftControl,
		["lcontrol"] = Enum.KeyCode.LeftControl,
		["ctrl"] = Enum.KeyCode.LeftControl,
		["control"] = Enum.KeyCode.LeftControl,
		["rightcontrol"] = Enum.KeyCode.RightControl,
		["rcontrol"] = Enum.KeyCode.RightControl,
		["rightctrl"] = Enum.KeyCode.RightControl,
		["leftshift"] = Enum.KeyCode.LeftShift,
		["lshift"] = Enum.KeyCode.LeftShift,
		["shift"] = Enum.KeyCode.LeftShift,
		["rightshift"] = Enum.KeyCode.RightShift,
		["rshift"] = Enum.KeyCode.RightShift,
		["leftalt"] = Enum.KeyCode.LeftAlt,
		["lalt"] = Enum.KeyCode.LeftAlt,
		["alt"] = Enum.KeyCode.LeftAlt,
		["rightalt"] = Enum.KeyCode.RightAlt,
		["ralt"] = Enum.KeyCode.RightAlt,
		["space"] = Enum.KeyCode.Space,
		["spacebar"] = Enum.KeyCode.Space,
		["tab"] = Enum.KeyCode.Tab,
		["escape"] = Enum.KeyCode.Escape,
		["esc"] = Enum.KeyCode.Escape,
		["enter"] = Enum.KeyCode.Return,
		["return"] = Enum.KeyCode.Return,
		["backspace"] = Enum.KeyCode.Backspace,
		["0"] = Enum.KeyCode.Zero,
		["1"] = Enum.KeyCode.One,
		["2"] = Enum.KeyCode.Two,
		["3"] = Enum.KeyCode.Three,
		["4"] = Enum.KeyCode.Four,
		["5"] = Enum.KeyCode.Five,
		["6"] = Enum.KeyCode.Six,
		["7"] = Enum.KeyCode.Seven,
		["8"] = Enum.KeyCode.Eight,
		["9"] = Enum.KeyCode.Nine,
		["kp0"] = Enum.KeyCode.KeypadZero,
		["kp1"] = Enum.KeyCode.KeypadOne,
		["kp2"] = Enum.KeyCode.KeypadTwo,
		["kp3"] = Enum.KeyCode.KeypadThree,
		["kp4"] = Enum.KeyCode.KeypadFour,
		["kp5"] = Enum.KeyCode.KeypadFive,
		["kp6"] = Enum.KeyCode.KeypadSix,
		["kp7"] = Enum.KeyCode.KeypadSeven,
		["kp8"] = Enum.KeyCode.KeypadEight,
		["kp9"] = Enum.KeyCode.KeypadNine
	}

	local function normalizeKeyName(name)
		return Lower(tostring(name)):gsub("%s+", ""):gsub("_", "")
	end

	local function findKeyCode(input)
		if not input or input == "" then
			return nil
		end

		local cleaned = normalizeKeyName(input)

		if keyMap[cleaned] then
			return keyMap[cleaned]
		end

		for _, keyCode in ipairs(Enum.KeyCode:GetEnumItems()) do
			local keyName = normalizeKeyName(keyCode.Name)
			if keyName == cleaned or Match(keyName, cleaned) or Match(cleaned, keyName) then
				return keyCode
			end
		end

		return nil
	end

	local keyCode = findKeyCode(target)

	if keyCode then
		vim:SendKeyEvent(true, keyCode, 0, game)
		vim:SendKeyEvent(false, keyCode, 0, game)
	elseif not target or target == "" then
		DebugNotif("firekey needs a key name (ex: firekey space)", 3)
	else
		DebugNotif("No matching keycode for: "..tostring(target), 3)
	end
end,true)

LOOPPROTECT = nil

cmd.add({"loopfling"}, {"loopfling <player>", "Loop voids a player"}, function(plr)
	local Targets = {plr}
	Loopvoid = false
	Loopvoid = true
	repeat Wait()
		local mouse = LocalPlayer:GetMouse()
		local Players = game.GetService(game,"Players")
		local Player = Players.LocalPlayer
		local AllBool = false
		local GetPlayer = function(Name)
			Name = Name:lower()
			if Name == "all" or Name == "others" then
				AllBool = true
				return
			elseif Name == "random" then
				local GetPlayers = Players:GetPlayers()
				if Discover(GetPlayers, Player) then table.remove(GetPlayers, Discover(GetPlayers, Player)) end
				return GetPlayers[math.random(#GetPlayers)]
			elseif Name ~= "random" and Name ~= "all" and Name ~= "others" then
				for _, x in next, Players:GetPlayers() do
					if x ~= Player then
						if x.Name:lower():match("^"..Name) then
							return x
						elseif x.DisplayName:lower():match("^"..Name) then
							return x
						end
					end
				end
			else
				return
			end
		end
		local SkidFling = function(TargetPlayer)
			if LOOPPROTECT then LOOPPROTECT:Destroy() LOOPPROTECT = nil end
			local Character = Player.Character
			local Humanoid = getPlrHum(Character)
			local HRP = Humanoid and Humanoid.RootPart
			local camera = workspace.CurrentCamera
			LOOPPROTECT = InstanceNew("Part")
			LOOPPROTECT.Size = Vector3.new(1, 1, 1)
			LOOPPROTECT.Transparency = 1
			LOOPPROTECT.CanCollide = false
			LOOPPROTECT.Anchored = false
			LOOPPROTECT.Parent = camera
			local weld = InstanceNew("WeldConstraint")
			weld.Part0 = HRP
			weld.Part1 = LOOPPROTECT
			weld.Parent = LOOPPROTECT
			local bodyGyro = InstanceNew("BodyGyro")
			bodyGyro.MaxTorque = Vector3.new(400000, 400000, 400000)
			bodyGyro.D = 1000
			bodyGyro.P = 2000
			bodyGyro.Parent = LOOPPROTECT
			local RootPart = HRP
			local TCharacter = TargetPlayer.Character
			local THumanoid, TRootPart, THead, Accessory, Handle
			if not TCharacter then if LOOPPROTECT then LOOPPROTECT:Destroy() LOOPPROTECT = nil end return end
			if getPlrHum(TCharacter) then
				THumanoid = getPlrHum(TCharacter)
			end
			if THumanoid and THumanoid.RootPart then
				TRootPart = THumanoid.RootPart
			end
			if getHead(TCharacter) then
				THead = getHead(TCharacter)
			end
			if TCharacter:FindFirstChildOfClass("Accessory") then
				Accessory = TCharacter:FindFirstChildOfClass("Accessory")
			end
			if Accessory and Accessory:FindFirstChild("Handle") then
				Handle = Accessory.Handle
			end
			if Character and Humanoid and HRP then
				if not flingManager.lFlingOldPos or RootPart.Velocity.Magnitude < 50 then
					flingManager.lFlingOldPos = RootPart.CFrame
				end
				if THumanoid and THumanoid.Sit and not AllBool then
					return
				end
				if THead then
					workspace.CurrentCamera.CameraSubject = THead
				elseif not THead and Handle then
					workspace.CurrentCamera.CameraSubject = Handle
				elseif THumanoid and TRootPart then
					workspace.CurrentCamera.CameraSubject = THumanoid
				end
				if not TCharacter:FindFirstChildWhichIsA("BasePart") then
					return
				end
				local FPos = function(BasePart, Pos, Ang)
					RootPart.CFrame = CFrame.new(BasePart.Position) * Pos * Ang
					Character:SetPrimaryPartCFrame(CFrame.new(BasePart.Position) * Pos * Ang)
					RootPart.Velocity = Vector3.new(9e7, 9e7 * 10, 9e7)
					RootPart.RotVelocity = Vector3.new(9e8, 9e8, 9e8)
				end
				local SFBasePart = function(BasePart)
					local TimeToWait = 2
					local Time = tick()
					local Angle = 0
					repeat
						if RootPart and THumanoid then
							if BasePart.Velocity.Magnitude < 50 then
								Angle = Angle + 100
								FPos(BasePart, CFrame.new(0, 1.5, 0) + THumanoid.MoveDirection * BasePart.Velocity.Magnitude / 1.25, CFrame.Angles(math.rad(Angle), 0, 0))
								Wait()
								FPos(BasePart, CFrame.new(0, -1.5, 0) + THumanoid.MoveDirection * BasePart.Velocity.Magnitude / 1.25, CFrame.Angles(math.rad(Angle), 0, 0))
								Wait()
								FPos(BasePart, CFrame.new(2.25, 1.5, -2.25) + THumanoid.MoveDirection * BasePart.Velocity.Magnitude / 1.25, CFrame.Angles(math.rad(Angle), 0, 0))
								Wait()
								FPos(BasePart, CFrame.new(-2.25, -1.5, 2.25) + THumanoid.MoveDirection * BasePart.Velocity.Magnitude / 1.25, CFrame.Angles(math.rad(Angle), 0, 0))
								Wait()
								FPos(BasePart, CFrame.new(0, 1.5, 0) + THumanoid.MoveDirection, CFrame.Angles(math.rad(Angle), 0, 0))
								Wait()
								FPos(BasePart, CFrame.new(0, -1.5, 0) + THumanoid.MoveDirection, CFrame.Angles(math.rad(Angle), 0, 0))
								Wait()
							else
								FPos(BasePart, CFrame.new(0, 1.5, THumanoid.WalkSpeed), CFrame.Angles(math.rad(90), 0, 0))
								Wait()
								FPos(BasePart, CFrame.new(0, -1.5, -THumanoid.WalkSpeed), CFrame.Angles(0, 0, 0))
								Wait()
								FPos(BasePart, CFrame.new(0, 1.5, THumanoid.WalkSpeed), CFrame.Angles(math.rad(90), 0, 0))
								Wait()
								FPos(BasePart, CFrame.new(0, 1.5, TRootPart.Velocity.Magnitude / 1.25), CFrame.Angles(math.rad(90), 0, 0))
								Wait()
								FPos(BasePart, CFrame.new(0, -1.5, -TRootPart.Velocity.Magnitude / 1.25), CFrame.Angles(0, 0, 0))
								Wait()
								FPos(BasePart, CFrame.new(0, 1.5, TRootPart.Velocity.Magnitude / 1.25), CFrame.Angles(math.rad(90), 0, 0))
								Wait()
								FPos(BasePart, CFrame.new(0, -1.5, 0), CFrame.Angles(math.rad(90), 0, 0))
								Wait()
								FPos(BasePart, CFrame.new(0, -1.5, 0), CFrame.Angles(0, 0, 0))
								Wait()
								FPos(BasePart, CFrame.new(0, -1.5, 0), CFrame.Angles(math.rad(-90), 0, 0))
								Wait()
								FPos(BasePart, CFrame.new(0, -1.5, 0), CFrame.Angles(0, 0, 0))
								Wait()
							end
						else
							break
						end
					until BasePart.Velocity.Magnitude > 500 or BasePart.Parent ~= TargetPlayer.Character or TargetPlayer.Parent ~= Players or not TargetPlayer.Character == TCharacter or THumanoid.Sit or Humanoid.Health <= 0 or tick() > Time + TimeToWait
					if LOOPPROTECT then LOOPPROTECT:Destroy() LOOPPROTECT = nil end
				end
				workspace.FallenPartsDestroyHeight = 0/0
				local BV = InstanceNew("BodyVelocity")
				BV.Parent = RootPart
				BV.Velocity = Vector3.new(9e8, 9e8, 9e8)
				BV.MaxForce = Vector3.new(1/0, 1/0, 1/0)
				Humanoid:SetStateEnabled(Enum.HumanoidStateType.Seated, false)
				if TRootPart and THead then
					if (TRootPart.CFrame.p - THead.CFrame.p).Magnitude > 5 then
						SFBasePart(THead)
					else
						SFBasePart(TRootPart)
					end
				elseif TRootPart and not THead then
					SFBasePart(TRootPart)
				elseif not TRootPart and THead then
					SFBasePart(THead)
				elseif not TRootPart and not THead and Accessory and Handle then
					SFBasePart(Handle)
				else
					return
				end
				BV:Destroy()
				Humanoid:SetStateEnabled(Enum.HumanoidStateType.Seated, true)
				workspace.CurrentCamera.CameraSubject = Humanoid
				repeat
					RootPart.CFrame = flingManager.lFlingOldPos * CFrame.new(0, 0.5, 0)
					Character:SetPrimaryPartCFrame(flingManager.lFlingOldPos * CFrame.new(0, 0.5, 0))
					Humanoid:ChangeState("GettingUp")
					Foreach(Character:GetChildren(), function(_, x)
						if x:IsA("BasePart") then
							x.Velocity, x.RotVelocity = Vector3.new(), Vector3.new()
						end
					end)
					Wait()
				until (RootPart.Position - flingManager.lFlingOldPos.p).Magnitude < 25
				workspace.FallenPartsDestroyHeight = OrgDestroyHeight
				if LOOPPROTECT then LOOPPROTECT:Destroy() LOOPPROTECT = nil end
			else
				return
			end
		end
		if not getgenv().Welcome then DebugNotif("Enjoy!", 5, "Script by AnthonyIsntHere") end
		getgenv().Welcome = true
		if Targets[1] then for _, x in next, Targets do GetPlayer(x) end else return end
		if AllBool then
			for _, x in next, Players:GetPlayers() do
				SkidFling(x)
			end
		end
		for _, x in next, Targets do
			if GetPlayer(x) and GetPlayer(x) ~= Player then
				if GetPlayer(x).UserId ~= 1414978355 then
					local TPlayer = GetPlayer(x)
					if TPlayer then
						SkidFling(TPlayer)
					end
				end
			elseif not GetPlayer(x) and not AllBool then
			end
		end
	until Loopvoid == false
end, true)

cmd.add({"unloopfling"}, {"unloopfling", "Stops loop flinging a player"}, function()
	Loopvoid = false
	repeat Wait() if LOOPPROTECT then LOOPPROTECT:Destroy() LOOPPROTECT = nil end until LOOPPROTECT == nil
end)

cmd.add({"freegamepass", "freegp"},{"freegamepass (freegp)", "Pretends you own every gamepass and fires product purchase signals"},function()
	local market = SafeGetService("MarketplaceService")
	if not market then
		DoNotif("MarketplaceService is unavailable in this session", 3, "Free Gamepasses")
		return
	end

	if hookfunction and not NAStuff._freeGamepassHooked then
		local ok = pcall(function()
			return hookfunction(market.UserOwnsGamePassAsync, newcclosure(function(...)
				return true
			end))
		end)
		if ok then
			NAStuff._freeGamepassHooked = true
		end
	end

	local products = {}
	local okProducts, errProducts = pcall(function()
		products = market:GetDeveloperProductsAsync():GetCurrentPage()
	end)

	local gamepasses = (function()
		local result = {}

		pcall(function()
			local raw = game:HttpGet(Format("https://apis.roblox.com/game-passes/v1/universes/%s/game-passes?passView=Full&pageSize=100", tostring(GameId)))
			local decoded = HttpService:JSONDecode(raw)

			for _, gamepass in next, decoded.gamePasses do
				Insert(result, gamepass.id)
			end
		end)

		return result
	end)()

	local totalSignals = 0

	for _, product in next, (products or {}) do
		for key, id in next, product do
			if (key == "ProductId") or (key == "DeveloperProductId") then
				market:SignalPromptProductPurchaseFinished(LocalPlayer.UserId, id, true)
				totalSignals += 1
			end
		end
	end

	for _, gamepass in next, (gamepasses or {}) do
		pcall(function()
			market:SignalPromptGamePassPurchaseFinished(LocalPlayer, gamepass, true)
		end)
	end

	if okProducts then
		DoNotif(Format("Hooked gamepass ownership and fired %d purchase signals", totalSignals), 8, "Free Gamepasses")
	else
		DoNotif("Failed to spoof gamepasses: "..tostring(errProducts), 8, "Free Gamepasses")
	end
end)

NA_DEVPROD_GUI=nil

cmd.add({"devproducts","products"},{"devproducts (products)","Lists Developer Products"},function()
	if NA_DEVPROD_GUI and NA_DEVPROD_GUI.Parent then NA_DEVPROD_GUI:Destroy() end
	local MarketplaceService=SafeGetService("MarketplaceService")
	local GROUP="DevProductsGUI"
	NAlib.disconnect(GROUP)

	local gui=InstanceNew("ScreenGui")
	NAProtection(gui)
	NaProtectUI(gui)
	NA_DEVPROD_GUI=gui

	local shadow=InstanceNew("Frame",gui)
	shadow.BackgroundColor3=Color3.fromRGB(0,0,0)
	shadow.BackgroundTransparency=0.6
	shadow.BorderSizePixel=0
	shadow.Size=UDim2.fromOffset(680,600)
	shadow.ZIndex=0
	local shCorner=InstanceNew("UICorner",shadow); shCorner.CornerRadius=UDim.new(0,26)

	local win=InstanceNew("Frame",gui)
	win.BackgroundColor3=Color3.fromRGB(20,20,20)
	win.BorderSizePixel=0
	win.Size=UDim2.fromOffset(680,600)
	win.ZIndex=1
	NAProtection(win)
	NAmanage.centerFrame(win)
	shadow.Position=win.Position
	NAlib.connect(GROUP,win:GetPropertyChangedSignal("Position"):Connect(function() shadow.Position=win.Position end))

	local corner=InstanceNew("UICorner",win)
	corner.CornerRadius=UDim.new(0,26)
	local stroke=InstanceNew("UIStroke",win)
	stroke.Thickness=1
	stroke.Transparency=0.6
	stroke.Color=Color3.fromRGB(255,255,255)

	local top=InstanceNew("Frame",win)
	top.BackgroundColor3=Color3.fromRGB(26,26,26)
	top.Size=UDim2.new(1,0,0,60)
	top.BorderSizePixel=0
	local topCorner=InstanceNew("UICorner",top); topCorner.CornerRadius=UDim.new(0,26)
	local topMask=InstanceNew("Frame",top); topMask.BackgroundTransparency=1; topMask.Size=UDim2.new(1,-24,1,-16); topMask.Position=UDim2.fromOffset(12,8)
	NAgui.draggerV2(win,topMask)

	local title=InstanceNew("TextLabel",top)
	title.BackgroundTransparency=1
	title.Position=UDim2.fromOffset(20,0)
	title.Size=UDim2.new(1,-260,1,0)
	title.Font=Enum.Font.GothamBold
	title.TextXAlignment=Enum.TextXAlignment.Left
	title.TextColor3=Color3.fromRGB(240,240,240)
	title.Text="Developer Products"
	title.TextScaled=true

	local close=InstanceNew("TextButton",top)
	close.Size=UDim2.fromOffset(36,36)
	close.Position=UDim2.new(1,-44,0.5,-18)
	close.Text="X"
	close.Font=Enum.Font.GothamBold
	close.BackgroundColor3=Color3.fromRGB(50,50,50)
	close.TextColor3=Color3.fromRGB(255,255,255)
	close.TextScaled=true
	local closeCorner=InstanceNew("UICorner",close); closeCorner.CornerRadius=UDim.new(0,10)

	local minimize=InstanceNew("TextButton",top)
	minimize.Size=UDim2.fromOffset(36,36)
	minimize.Position=UDim2.new(1,-88,0.5,-18)
	minimize.Text="-"
	minimize.Font=Enum.Font.GothamBold
	minimize.BackgroundColor3=Color3.fromRGB(50,50,50)
	minimize.TextColor3=Color3.fromRGB(255,255,255)
	minimize.TextScaled=true
	local minCorner=InstanceNew("UICorner",minimize); minCorner.CornerRadius=UDim.new(0,10)

	local head=InstanceNew("Frame",win)
	head.BackgroundColor3=Color3.fromRGB(20,20,20)
	head.Position=UDim2.fromOffset(16,68)
	head.Size=UDim2.new(1,-32,0,48)
	head.BorderSizePixel=0
	local headCorner=InstanceNew("UICorner",head); headCorner.CornerRadius=UDim.new(0,16)
	local headStroke=InstanceNew("UIStroke",head); headStroke.Thickness=1; headStroke.Transparency=0.7

	local refresh=InstanceNew("TextButton",head)
	refresh.Size=UDim2.fromOffset(104,34)
	refresh.Position=UDim2.fromOffset(8,7)
	refresh.Text="Refresh"
	refresh.Font=Enum.Font.GothamMedium
	refresh.BackgroundColor3=Color3.fromRGB(56,56,56)
	refresh.TextColor3=Color3.fromRGB(255,255,255)
	refresh.TextScaled=true
	local rCorner=InstanceNew("UICorner",refresh); rCorner.CornerRadius=UDim.new(0,10)

	local search=InstanceNew("TextBox",head)
	search.Size=UDim2.new(1,-372,0,34)
	search.Position=UDim2.fromOffset(120,7)
	search.PlaceholderText="Search by name or ID"
	search.ClearTextOnFocus=false
	search.TextXAlignment=Enum.TextXAlignment.Left
	search.Text=""
	search.Font=Enum.Font.Gotham
	search.BackgroundColor3=Color3.fromRGB(34,34,34)
	search.TextColor3=Color3.fromRGB(230,230,230)
	search.TextScaled=true
	local sCorner=InstanceNew("UICorner",search); sCorner.CornerRadius=UDim.new(0,10)

	local buyAll=InstanceNew("TextButton",head)
	buyAll.Size=UDim2.fromOffset(108,34)
	buyAll.Position=UDim2.new(1,-244,0,7)
	buyAll.Text="Buy All"
	buyAll.Font=Enum.Font.GothamMedium
	buyAll.BackgroundColor3=Color3.fromRGB(70,70,110)
	buyAll.TextColor3=Color3.fromRGB(255,255,255)
	buyAll.TextScaled=true
	local bCorner=InstanceNew("UICorner",buyAll); bCorner.CornerRadius=UDim.new(0,10)

	local interval=InstanceNew("TextBox",head)
	interval.Size=UDim2.fromOffset(120,34)
	interval.Position=UDim2.new(1,-124,0,7)
	interval.PlaceholderText="Interval (s)"
	interval.Text="0.1"
	interval.ClearTextOnFocus=false
	interval.TextXAlignment=Enum.TextXAlignment.Center
	interval.Font=Enum.Font.GothamMedium
	interval.BackgroundColor3=Color3.fromRGB(34,34,34)
	interval.TextColor3=Color3.fromRGB(255,255,255)
	interval.TextScaled=true
	local iCorner=InstanceNew("UICorner",interval); iCorner.CornerRadius=UDim.new(0,10)

	local status=InstanceNew("TextLabel",win)
	status.BackgroundTransparency=1
	status.Size=UDim2.new(1,-32,0,20)
	status.Position=UDim2.fromOffset(16,116)
	status.Font=Enum.Font.Gotham
	status.TextXAlignment=Enum.TextXAlignment.Left
	status.TextColor3=Color3.fromRGB(190,190,190)
	status.Text="Ready."
	status.TextScaled=true

	local body=InstanceNew("Frame",win)
	body.BackgroundColor3=Color3.fromRGB(16,16,16)
	body.Position=UDim2.fromOffset(16,140)
	body.Size=UDim2.new(1,-32,1,-156)
	body.BorderSizePixel=0
	local bodyCorner=InstanceNew("UICorner",body); bodyCorner.CornerRadius=UDim.new(0,22)
	local bodyStroke=InstanceNew("UIStroke",body); bodyStroke.Thickness=1; bodyStroke.Transparency=0.75

	local list=InstanceNew("ScrollingFrame",body)
	list.BackgroundTransparency=1
	list.BorderSizePixel=0
	list.Position=UDim2.fromOffset(10,10)
	list.Size=UDim2.new(1,-20,1,-20)
	list.ScrollBarThickness=6
	list.CanvasSize=UDim2.new()

	local layout=InstanceNew("UIListLayout",list)
	layout.Padding=UDim.new(0,10)
	layout.SortOrder=Enum.SortOrder.LayoutOrder

	local padding=InstanceNew("UIPadding",list)
	padding.PaddingTop=UDim.new(0,2)
	padding.PaddingBottom=UDim.new(0,2)
	padding.PaddingLeft=UDim.new(0,2)
	padding.PaddingRight=UDim.new(0,2)

	local minimized=false
	local fullSize=win.Size
	local miniSize=UDim2.fromOffset(520,140)

	local function notify(m,t) if DoNotif then DoNotif(m,t or 4,"DevProducts") else warn("[DevProducts] "..m) end status.Text=m end
	local function setCanvas() list.CanvasSize=UDim2.fromOffset(0,layout.AbsoluteContentSize.Y+16) end
	NAlib.connect(GROUP,layout:GetPropertyChangedSignal("AbsoluteContentSize"):Connect(setCanvas))

	local loops={}
	local function stopAllLoops() for _,l in pairs(loops) do l.running=false end loops={} end

	NAlib.connect(GROUP, MouseButtonFix(close, function()
		stopAllLoops()
		NAlib.disconnect(GROUP)
		pcall(gui.Destroy,gui)
		NA_DEVPROD_GUI=nil
	end))

	NAlib.connect(GROUP, MouseButtonFix(minimize, function()
		if minimized then
			minimized=false
			body.Visible=true
			status.Visible=true
			TweenService:Create(win,TweenInfo.new(0.18,Enum.EasingStyle.Quad,Enum.EasingDirection.Out),{Size=fullSize}):Play()
			TweenService:Create(shadow,TweenInfo.new(0.18,Enum.EasingStyle.Quad,Enum.EasingDirection.Out),{Size=fullSize}):Play()
			minimize.Text="-"
		else
			minimized=true
			body.Visible=false
			status.Visible=false
			TweenService:Create(win,TweenInfo.new(0.18,Enum.EasingStyle.Quad,Enum.EasingDirection.Out),{Size=miniSize}):Play()
			TweenService:Create(shadow,TweenInfo.new(0.18,Enum.EasingStyle.Quad,Enum.EasingDirection.Out),{Size=miniSize}):Play()
			minimize.Text="+"
		end
	end))

	local cam=workspace.CurrentCamera
	if cam then
		NAlib.connect(GROUP,cam:GetPropertyChangedSignal("ViewportSize"):Connect(function()
			NAmanage.centerFrame(win)
			shadow.Position=win.Position
		end))
	end

	local rows={}
	local allItems={}

	local function clearList()
		for _,ch in ipairs(list:GetChildren()) do if ch:IsA("Frame") then ch:Destroy() end end
		table.clear(rows)
		setCanvas()
	end

	local function parseInterval()
		local v=tonumber(interval.Text) or tonumber(Match(interval.Text or "","%d*%.?%d+")) or 0.1
		if v<0 then v=0 end
		return v
	end

	local function makeRow(info)
		local id=info.ProductId
		local row=InstanceNew("Frame",list)
		row.BackgroundColor3=Color3.fromRGB(24,24,24)
		row.BorderSizePixel=0
		row.Size=UDim2.new(1,0,0,90)
		local rCorner=InstanceNew("UICorner",row); rCorner.CornerRadius=UDim.new(0,18)
		local rStroke=InstanceNew("UIStroke",row); rStroke.Thickness=1; rStroke.Transparency=0.75

		local nameL=InstanceNew("TextLabel",row)
		nameL.BackgroundTransparency=1
		nameL.Position=UDim2.fromOffset(14,10)
		nameL.Size=UDim2.new(1,-260,0,32)
		nameL.Font=Enum.Font.GothamMedium
		nameL.TextXAlignment=Enum.TextXAlignment.Left
		nameL.TextColor3=Color3.fromRGB(245,245,245)
		nameL.Text=info.Name or ("Product "..id)
		nameL.TextScaled=true
		nameL.TextWrapped=true

		local sub=InstanceNew("TextLabel",row)
		sub.BackgroundTransparency=1
		sub.Position=UDim2.fromOffset(14,46)
		sub.Size=UDim2.new(1,-260,0,24)
		sub.Font=Enum.Font.Gotham
		sub.TextXAlignment=Enum.TextXAlignment.Left
		sub.TextColor3=Color3.fromRGB(190,190,190)
		sub.Text=Format("ID: %d  •  Price: %s",id,info.PriceInRobux and (info.PriceInRobux.." R$") or "…")
		sub.TextScaled=true
		sub.TextWrapped=true

		local purchase=InstanceNew("TextButton",row)
		purchase.Size=UDim2.fromOffset(112,40)
		purchase.Position=UDim2.new(1,-240,0.5,-20)
		purchase.Font=Enum.Font.GothamBold
		purchase.AutoButtonColor=true
		purchase.TextColor3=Color3.fromRGB(255,255,255)
		purchase.BackgroundColor3=Color3.fromRGB(0,170,127)
		purchase.Text="Purchase"
		purchase.TextScaled=true
		local pCorner=InstanceNew("UICorner",purchase); pCorner.CornerRadius=UDim.new(0,12)

		local loopBtn=InstanceNew("TextButton",row)
		loopBtn.Size=UDim2.fromOffset(112,40)
		loopBtn.Position=UDim2.new(1,-120,0.5,-20)
		loopBtn.Font=Enum.Font.GothamBold
		loopBtn.AutoButtonColor=true
		loopBtn.TextColor3=Color3.fromRGB(255,255,255)
		loopBtn.BackgroundColor3=Color3.fromRGB(80,80,80)
		loopBtn.Text="Loop"
		loopBtn.TextScaled=true
		local lCorner=InstanceNew("UICorner",loopBtn); lCorner.CornerRadius=UDim.new(0,12)

		NAlib.connect(GROUP, MouseButtonFix(purchase, function()
			MarketplaceService:SignalPromptProductPurchaseFinished(LocalPlayer.UserId, id, true)
		end))
		NAlib.connect(GROUP, MouseButtonFix(loopBtn, function()
			local l=loops[id]
			if l and l.running then
				l.running=false
				loopBtn.Text="Loop"
				loopBtn.BackgroundColor3=Color3.fromRGB(80,80,80)
			else
				local state={running=true}
				loops[id]=state
				loopBtn.Text="Stop"
				loopBtn.BackgroundColor3=Color3.fromRGB(180,60,60)
				SpawnCall(function()
					while state.running do
						MarketplaceService:SignalPromptProductPurchaseFinished(LocalPlayer.UserId, id, true)
						Wait(parseInterval())
					end
					if loopBtn and loopBtn.Parent then
						loopBtn.Text="Loop"
						loopBtn.BackgroundColor3=Color3.fromRGB(80,80,80)
					end
					loops[id]=nil
				end)
			end
		end))

		rows[id]=row

		SpawnCall(function()
			local ok,pi=pcall(function() return MarketplaceService:GetProductInfo(id,Enum.InfoType.Product) end)
			if ok and type(pi)=="table" and rows[id] and rows[id].Parent then
				nameL.Text=pi.Name or nameL.Text
				sub.Text=Format("ID: %d  •  Price: %s",id,pi.PriceInRobux and (pi.PriceInRobux.." R$") or "—")
				info.Name=pi.Name or info.Name
				info.PriceInRobux=pi.PriceInRobux
				info.Description=pi.Description
			end
		end)

		return row
	end

	local fetching=false
	local function fetchAll()
		if fetching then return end
		fetching=true
		clearList()
		table.clear(allItems)
		notify("Loading developer products…")
		local ok,pagesOrErr=pcall(function() return MarketplaceService:GetDeveloperProductsAsync() end)
		if not ok then notify("Failed to get pages: "..tostring(pagesOrErr),8) fetching=false return end
		local pages=pagesOrErr
		local count=0
		while true do
			local pOk,pRes=pcall(function() return pages:GetCurrentPage() end)
			if not pOk then notify("Page error: "..tostring(pRes),8) break end
			for _,entry in ipairs(pRes) do
				local id=entry.ProductId or entry.DeveloperProductId
				if id then
					local info={ProductId=id,Name=entry.Name}
					Insert(allItems,info)
					makeRow(info)
					count+=1
					Wait()
				end
			end
			if pages.IsFinished then break end
			local aOk,aErr=pcall(function() pages:AdvanceToNextPageAsync() end)
			if not aOk then notify("Advance failed: "..tostring(aErr),8) break end
			Wait()
		end
		table.sort(allItems,function(a,b)
			local an=a.Name and Lower(a.Name) or ""
			local bn=b.Name and Lower(b.Name) or ""
			return an<bn
		end)
		notify(Format("Loaded %d developer product(s).",count))
		setCanvas()
		fetching=false
	end

	local function applyFilter(q)
		q=Lower(q or "")
		for _,info in ipairs(allItems) do
			local row=rows[info.ProductId]
			if row then
				local nameLabel=nil
				for _,c in ipairs(row:GetChildren()) do if c:IsA("TextLabel") then nameLabel=c break end end
				local nameText=nameLabel and nameLabel.Text or ""
				local idStr=tostring(info.ProductId)
				local vis=(q=="" or Find(Lower(nameText),q,1,true)~=nil or Find(idStr,q,1,true)~=nil)
				row.Visible=vis
			end
		end
		setCanvas()
	end

	NAlib.connect(GROUP,search:GetPropertyChangedSignal("Text"):Connect(function() applyFilter(search.Text) end))
	NAlib.connect(GROUP, MouseButtonFix(refresh, function() search.Text="" fetchAll() end))
	NAlib.connect(GROUP, MouseButtonFix(buyAll, function()
		if #allItems==0 then return end
		local delayS=parseInterval()
		SpawnCall(function()
			for _,info in ipairs(allItems) do
				MarketplaceService:SignalPromptProductPurchaseFinished(LocalPlayer.UserId, info.ProductId, true)
				Wait(delayS)
			end
		end)
	end))

	fetchAll()
end)

NA_GAMEPASS_GUI=nil

cmd.add({"gamepasses","passes"},{"gamepasses (passes)","Prompt & list Game Passes (manual IDs)"},function()
	if NA_GAMEPASS_GUI and NA_GAMEPASS_GUI.Parent then NA_GAMEPASS_GUI:Destroy() end
	local MarketplaceService=SafeGetService("MarketplaceService")
	local Players=SafeGetService("Players")
	local LocalPlayer=Players.LocalPlayer
	local GROUP="GamePassesGUI"
	NAlib.disconnect(GROUP)

	local gui=InstanceNew("ScreenGui")
	NAProtection(gui)
	NaProtectUI(gui)
	NA_GAMEPASS_GUI=gui

	local shadow=InstanceNew("Frame",gui)
	shadow.BackgroundColor3=Color3.fromRGB(0,0,0)
	shadow.BackgroundTransparency=0.6
	shadow.BorderSizePixel=0
	shadow.Size=UDim2.fromOffset(640,520)
	shadow.ZIndex=0
	local shCorner=InstanceNew("UICorner",shadow); shCorner.CornerRadius=UDim.new(0,22)

	local win=InstanceNew("Frame",gui)
	win.BackgroundColor3=Color3.fromRGB(20,20,20)
	win.BorderSizePixel=0
	win.Size=UDim2.fromOffset(640,520)
	win.ZIndex=1
	NAProtection(win)
	NAmanage.centerFrame(win)
	shadow.Position=win.Position
	NAlib.connect(GROUP,win:GetPropertyChangedSignal("Position"):Connect(function() shadow.Position=win.Position end))

	local corner=InstanceNew("UICorner",win); corner.CornerRadius=UDim.new(0,22)
	local stroke=InstanceNew("UIStroke",win); stroke.Thickness=1; stroke.Transparency=0.6; stroke.Color=Color3.fromRGB(255,255,255)

	local top=InstanceNew("Frame",win)
	top.BackgroundColor3=Color3.fromRGB(26,26,26)
	top.Size=UDim2.new(1,0,0,56)
	top.BorderSizePixel=0
	local topCorner=InstanceNew("UICorner",top); topCorner.CornerRadius=UDim.new(0,22)
	local topMask=InstanceNew("Frame",top); topMask.BackgroundTransparency=1; topMask.Size=UDim2.new(1,-24,1,-16); topMask.Position=UDim2.fromOffset(12,8)
	NAgui.draggerV2(win,topMask)

	local title=InstanceNew("TextLabel",top)
	title.BackgroundTransparency=1
	title.Position=UDim2.fromOffset(20,0)
	title.Size=UDim2.new(1,-200,1,0)
	title.Font=Enum.Font.GothamBold
	title.TextXAlignment=Enum.TextXAlignment.Left
	title.TextColor3=Color3.fromRGB(240,240,240)
	title.Text="Game Passes"
	title.TextScaled=true

	local close=InstanceNew("TextButton",top)
	close.Size=UDim2.fromOffset(36,36)
	close.Position=UDim2.new(1,-44,0.5,-18)
	close.Text="X"
	close.Font=Enum.Font.GothamBold
	close.BackgroundColor3=Color3.fromRGB(50,50,50)
	close.TextColor3=Color3.fromRGB(255,255,255)
	close.TextScaled=true
	local closeCorner=InstanceNew("UICorner",close); closeCorner.CornerRadius=UDim.new(0,10)

	local head=InstanceNew("Frame",win)
	head.BackgroundColor3=Color3.fromRGB(20,20,20)
	head.Position=UDim2.fromOffset(16,64)
	head.Size=UDim2.new(1,-32,0,72)
	head.BorderSizePixel=0
	local headCorner=InstanceNew("UICorner",head); headCorner.CornerRadius=UDim.new(0,14)
	local headStroke=InstanceNew("UIStroke",head); headStroke.Thickness=1; headStroke.Transparency=0.7

	local interval=InstanceNew("TextBox",head)
	interval.Size=UDim2.fromOffset(120,34)
	interval.Position=UDim2.new(1,-120,0,8)
	interval.PlaceholderText="Interval (s)"
	interval.Text="0.5"
	interval.ClearTextOnFocus=false
	interval.TextXAlignment=Enum.TextXAlignment.Center
	interval.Font=Enum.Font.GothamMedium
	interval.BackgroundColor3=Color3.fromRGB(34,34,34)
	interval.TextColor3=Color3.fromRGB(255,255,255)
	interval.TextScaled=true
	local iCorner=InstanceNew("UICorner",interval); iCorner.CornerRadius=UDim.new(0,10)

	local allBtn=InstanceNew("TextButton",head)
	allBtn.Size=UDim2.fromOffset(120,34)
	allBtn.Position=UDim2.new(1,-120-8-120,0,8)
	allBtn.Text="Buy All"
	allBtn.Font=Enum.Font.GothamMedium
	allBtn.BackgroundColor3=Color3.fromRGB(70,70,110)
	allBtn.TextColor3=Color3.fromRGB(255,255,255)
	allBtn.TextScaled=true
	local allCorner=InstanceNew("UICorner",allBtn); allCorner.CornerRadius=UDim.new(0,10)

	local search=InstanceNew("TextBox",head)
	search.Size=UDim2.new(1,-8-120-8-120-8,0,34)
	search.Position=UDim2.fromOffset(8,8)
	search.PlaceholderText="Search by name or ID"
	search.ClearTextOnFocus=false
	search.TextXAlignment=Enum.TextXAlignment.Left
	search.Text=""
	search.Font=Enum.Font.Gotham
	search.BackgroundColor3=Color3.fromRGB(34,34,34)
	search.TextColor3=Color3.fromRGB(230,230,230)
	search.TextScaled=true
	local sCorner=InstanceNew("UICorner",search); sCorner.CornerRadius=UDim.new(0,10)

	local status=InstanceNew("TextLabel",win)
	status.BackgroundTransparency=1
	status.Size=UDim2.new(1,-32,0,20)
	status.Position=UDim2.fromOffset(16,144)
	status.Font=Enum.Font.Gotham
	status.TextXAlignment=Enum.TextXAlignment.Left
	status.TextColor3=Color3.fromRGB(190,190,190)
	status.Text="Ready."
	status.TextScaled=true

	local body=InstanceNew("Frame",win)
	body.BackgroundColor3=Color3.fromRGB(16,16,16)
	body.Position=UDim2.fromOffset(16,172)
	body.Size=UDim2.new(1,-32,1,-188)
	body.BorderSizePixel=0
	local bodyCorner=InstanceNew("UICorner",body); bodyCorner.CornerRadius=UDim.new(0,18)
	local bodyStroke=InstanceNew("UIStroke",body); bodyStroke.Thickness=1; bodyStroke.Transparency=0.75

	local list=InstanceNew("ScrollingFrame",body)
	list.BackgroundTransparency=1
	list.BorderSizePixel=0
	list.Position=UDim2.fromOffset(10,10)
	list.Size=UDim2.new(1,-20,1,-20)
	list.ScrollBarThickness=6
	list.CanvasSize=UDim2.new()

	local layout=InstanceNew("UIListLayout",list)
	layout.Padding=UDim.new(0,10)
	layout.SortOrder=Enum.SortOrder.LayoutOrder

	local padding=InstanceNew("UIPadding",list)
	padding.PaddingTop=UDim.new(0,2)
	padding.PaddingBottom=UDim.new(0,2)
	padding.PaddingLeft=UDim.new(0,2)
	padding.PaddingRight=UDim.new(0,2)

	local function notify(m,t) if DoNotif then DoNotif(m,t or 4,"GamePasses") else warn("[GamePasses] "..m) end status.Text=m end
	local function setCanvas() list.CanvasSize=UDim2.fromOffset(0,layout.AbsoluteContentSize.Y+16) end
	NAlib.connect(GROUP,layout:GetPropertyChangedSignal("AbsoluteContentSize"):Connect(setCanvas))
	NAlib.connect(GROUP, MouseButtonFix(close, function() NAlib.disconnect(GROUP) pcall(gui.Destroy,gui) NA_GAMEPASS_GUI=nil end))

	local function parseInterval()
		local v=tonumber(interval.Text) or tonumber(Match(interval.Text or "","%d*%.?%d+")) or 0.5
		if v<0 then v=0 end
		return v
	end

	local rows={}
	local loops={}

	local function makeRow(id:number, nameText:string?, priceText:string?, isForSale:boolean?)
		if rows[id] then return end
		local row=InstanceNew("Frame",list)
		row.BackgroundColor3=Color3.fromRGB(24,24,24)
		row.BorderSizePixel=0
		row.Size=UDim2.new(1,0,0,84)
		local rCorner=InstanceNew("UICorner",row); rCorner.CornerRadius=UDim.new(0,16)
		local rStroke=InstanceNew("UIStroke",row); rStroke.Thickness=1; rStroke.Transparency=0.75

		local nameL=InstanceNew("TextLabel",row)
		nameL.BackgroundTransparency=1
		nameL.Position=UDim2.fromOffset(14,10)
		nameL.Size=UDim2.new(1,-240,0,30)
		nameL.Font=Enum.Font.GothamMedium
		nameL.TextXAlignment=Enum.TextXAlignment.Left
		nameL.TextColor3=Color3.fromRGB(245,245,245)
		nameL.Text=nameText or ("Pass "..id)
		nameL.TextScaled=true
		nameL.TextWrapped=true

		local sub=InstanceNew("TextLabel",row)
		sub.BackgroundTransparency=1
		sub.Position=UDim2.fromOffset(14,44)
		sub.Size=UDim2.new(1,-240,0,24)
		sub.Font=Enum.Font.Gotham
		sub.TextXAlignment=Enum.TextXAlignment.Left
		sub.TextColor3=Color3.fromRGB(190,190,190)
		sub.Text=Format("ID: %d | Price: %s%s",id, priceText or "Unknown", (isForSale == false) and " (Offsale)" or "")
		sub.TextScaled=true
		sub.TextWrapped=true

		local buy=InstanceNew("TextButton",row)
		buy.Size=UDim2.fromOffset(104,38)
		buy.Position=UDim2.new(1,-220,0.5,-19)
		buy.Font=Enum.Font.GothamBold
		buy.AutoButtonColor=true
		buy.TextColor3=Color3.fromRGB(255,255,255)
		buy.BackgroundColor3=Color3.fromRGB(0,170,127)
		buy.Text="Buy"
		buy.TextScaled=true
		local bCorner=InstanceNew("UICorner",buy); bCorner.CornerRadius=UDim.new(0,12)

		local spamBtn=InstanceNew("TextButton",row)
		spamBtn.Size=UDim2.fromOffset(104,38)
		spamBtn.Position=UDim2.new(1,-108,0.5,-19)
		spamBtn.Font=Enum.Font.GothamBold
		spamBtn.AutoButtonColor=true
		spamBtn.TextColor3=Color3.fromRGB(255,255,255)
		spamBtn.BackgroundColor3=Color3.fromRGB(80,80,80)
		spamBtn.Text="Spam"
		spamBtn.TextScaled=true
		local sCorner=InstanceNew("UICorner",spamBtn); sCorner.CornerRadius=UDim.new(0,12)

		NAlib.connect(GROUP, MouseButtonFix(buy, function()
			MarketplaceService:SignalPromptGamePassPurchaseFinished(LocalPlayer,id,true)
		end))
		NAlib.connect(GROUP, MouseButtonFix(spamBtn, function()
			local loop=loops[id]
			if loop and loop.running then
				loop.running=false
				loops[id]=nil
				spamBtn.Text="Spam"
				spamBtn.BackgroundColor3=Color3.fromRGB(80,80,80)
			else
				local state={running=true}
				loops[id]=state
				spamBtn.Text="Stop"
				spamBtn.BackgroundColor3=Color3.fromRGB(180,60,60)
				SpawnCall(function()
					while state.running do
						MarketplaceService:SignalPromptGamePassPurchaseFinished(LocalPlayer,id,true)
						Wait(parseInterval())
					end
					if spamBtn and spamBtn.Parent then
						spamBtn.Text="Spam"
						spamBtn.BackgroundColor3=Color3.fromRGB(80,80,80)
					end
					loops[id]=nil
				end)
			end
		end))

		rows[id]=row
		SpawnCall(function()
			local ok,info=pcall(function() return MarketplaceService:GetProductInfo(id,Enum.InfoType.GamePass) end)
			if ok and type(info)=="table" and rows[id] and rows[id].Parent then
				nameL.Text=info.Name or nameL.Text
				local price=info.PriceInRobux and (tostring(info.PriceInRobux).." R$") or "Unknown"
				sub.Text=Format("ID: %d | Price: %s",id,price)
			end
		end)
		setCanvas()
	end

	local function applyFilter(q)
		q=Lower(q or "")
		for id,row in pairs(rows) do
			local nameLabel
			for _,c in ipairs(row:GetChildren()) do if c:IsA("TextLabel") then nameLabel=c break end end
			local nameText=Lower(tostring(nameLabel and nameLabel.Text or ""))
			local idStr=tostring(id)
			row.Visible=(q=="" or (Find(nameText,q,1,true)~=nil) or (Find(idStr,q,1,true)~=nil))
		end
		setCanvas()
	end

	local function buyAllQueued()
		local ids={}
		for id in pairs(rows) do Insert(ids,id) end
		if #ids==0 then return end
		local delayS=parseInterval()
		SpawnCall(function()
			for _,id in ipairs(ids) do
				MarketplaceService:SignalPromptGamePassPurchaseFinished(LocalPlayer,id,true)
				Wait(delayS)
			end
		end)
	end

	local function clearRows()
		for _, loop in pairs(loops) do
			loop.running=false
		end
		loops={}
		for _, row in pairs(rows) do
			pcall(row.Destroy, row)
		end
		rows={}
	end

	local function fetchFromApi()
		clearRows()
		status.Text="Fetching gamepasses..."

		local function fetchPages()
			local fetched={}
			local base=Format("https://apis.roblox.com/game-passes/v1/universes/%s/game-passes?passView=Full&pageSize=100", tostring(GameId))
			local nextToken=nil

			repeat
				local url=base
				if nextToken and nextToken~="" then
					url=Format("%s&pageToken=%s",base,tostring(nextToken))
				end

				local ok, decoded=pcall(function()
					return HttpService:JSONDecode(game:HttpGet(url))
				end)

				if not ok or type(decoded)~="table" then
					return nil, "Failed to decode API response"
				end

				if decoded.gamePasses and type(decoded.gamePasses)=="table" then
					for _, gp in next, decoded.gamePasses do
						if gp and gp.id then
							Insert(fetched, gp)
						end
					end
				end

				nextToken=decoded.nextPageToken
				if nextToken=="" then
					nextToken=nil
				end
			until not nextToken

			return fetched
		end

		local passes, err=fetchPages()
		if not passes then
			status.Text="Failed to fetch gamepasses."
			notify("Failed to fetch gamepasses: "..tostring(err),6)
			return
		end

		for _, gp in ipairs(passes) do
			local priceText
			if gp.isForSale == false then
				priceText="Offsale"
			elseif gp.price then
				priceText=tostring(gp.price).." R$"
			elseif gp.displayPrice then
				priceText=tostring(gp.displayPrice)
			else
				priceText="Unknown"
			end

			local displayName=gp.displayName or gp.name or ("Pass "..tostring(gp.id))
			makeRow(gp.id, displayName, priceText, gp.isForSale)
			Wait()
		end

		applyFilter(search.Text)
		status.Text=Format("Loaded %d gamepasses.", #passes)
		notify(status.Text,4)
	end

	NAlib.connect(GROUP, MouseButtonFix(allBtn, function() buyAllQueued() end))
	NAlib.connect(GROUP,search:GetPropertyChangedSignal("Text"):Connect(function() applyFilter(search.Text) end))
	NAlib.connect(GROUP, MouseButtonFix(close, function() NAlib.disconnect(GROUP) pcall(gui.Destroy,gui) NA_GAMEPASS_GUI=nil end))
	fetchFromApi()
end)

cmd.add({"listen"}, {"listen <player>", "Listen to your target's voice chat"}, function(plr)
	local trg = getPlr(plr)

	for _, plr in next, trg do
		local Root = getRoot(plr.Character)
		if Root then
			SafeGetService("SoundService"):SetListener(Enum.ListenerType.ObjectPosition, Root)
		end
	end
end,true)

cmd.add({"vcworld","vcdefault"},{"vcworld <on/off>","Toggle default spatial voice routing"},function(mode)
	local vcs = SafeGetService("VoiceChatService")
	local m = Lower(tostring(mode or ""))
	if m ~= "on" and m ~= "off" then
		DoNotif("Usage: vcworld <on/off>",2)
		return
	end
	local target = (m == "on")
	NAlib.setProperty(vcs,"EnableDefaultVoice",target)
end,true)

cmd.add({"unlisten"}, {"unlisten", "Stops listening"}, function()
	SafeGetService("SoundService"):SetListener(Enum.ListenerType.Camera)
end)

cmd.add({"gear"}, {"gear [id]", "This is client sided and will probably not work"}, function(assetId)
	assetId = tostring(assetId or ""):match("%d+")
	if not assetId or assetId == "" then
		DoNotif("Please provide a gear asset ID.", 3)
		return
	end

	local ok, objects = pcall(game.GetObjects, "rbxassetid://"..assetId)
	if not ok or not objects or #objects == 0 then
		DoNotif("Failed to load gear "..assetId, 3)
		return
	end

	local gear = objects[1]
	local backpack = getBp()
	if not backpack then
		DoNotif("Unable to access your backpack.", 3)
		return
	end

	gear.Parent = backpack
end)

if IsOnPC then
	cmd.add({"lockmouse", "lockm"}, {"lockmouse (lockm)", "Default Mouse Behaviour (idk any description)"}, function()
		NAgui.doModal(false)
	end)
	cmd.add({"unlockmouse", "unlockm"}, {"unlockmouse (unlockm)", "Unlocks your mouse (fr this time)"}, function()
		NAgui.doModal(true)
	end)
	cmd.add({"lockmouse2", "lockm2"}, {"lockmouse2 (lockm2)", "Locks your mouse in the center"}, function()
		UserInputService.MouseBehavior = Enum.MouseBehavior.LockCenter
	end)

	cmd.add({"unlockmouse2", "unlockm2"}, {"unlockmouse2 (unlockm2)", "Unlocks your mouse"}, function()
		UserInputService.MouseBehavior = Enum.MouseBehavior.Default
	end)
end

platformParts = {}

cmd.add({"headsit"}, {"headsit <player>", "sit on someone's head"}, function(p)
	local ppp = getPlr(p)

	for _, plr in next, ppp do
		if not plr then return end

		local char = getChar()
		local hum = getHum()
		if not hum then return end

		NAlib.disconnect("headsit_follow")
		NAlib.disconnect("headsit_died")

		local charRoot = getRoot(char)
		local target = plr.Character
		if not charRoot or not target then return end

		hum.Sit = true

		NAlib.connect("headsit_died", hum.Died:Connect(function()
			NAlib.disconnect("headsit_follow")
			NAlib.disconnect("headsit_died")
			for _, part in pairs(platformParts) do
				part:Destroy()
			end
			platformParts = {}
		end))

		for _, part in pairs(platformParts) do
			part:Destroy()
		end
		platformParts = {}

		local thick = 1
		local halfWidth = 2
		local halfDepth = 2
		local halfHeight = 3

		local walls = {
			{offset = CFrame.new(0, 0, halfDepth + thick / 500), size = Vector3.new(4, 6, thick)},
			{offset = CFrame.new(0, 0, -(halfDepth + thick / 500)), size = Vector3.new(4, 6, thick)},
			{offset = CFrame.new(halfWidth + thick / 500, 0, 0), size = Vector3.new(thick, 6, 4)},
			{offset = CFrame.new(-(halfWidth + thick / 500), 0, 0), size = Vector3.new(thick, 6, 4)},
			{offset = CFrame.new(0, halfHeight + thick / 500, 0), size = Vector3.new(4, thick, 4)},
			{offset = CFrame.new(0, -(halfHeight + thick / 500), 0), size = Vector3.new(4, thick, 4)}
		}

		for _, wall in ipairs(walls) do
			local part = InstanceNew("Part")
			part.Size = wall.size
			part.Anchored = true
			part.CanCollide = true
			part.Transparency = 1
			part.Parent = workspace
			Insert(platformParts, part)
		end

		NAlib.connect("headsit_follow", RunService.Stepped:Connect(function()
			if not SafeGetService("Players"):FindFirstChild(plr.Name)
				or not plr.Character
				or not getHead(plr.Character)
				or hum.Sit == false then

				NAlib.disconnect("headsit_follow")
				NAlib.disconnect("headsit_died")

				for _, part in pairs(platformParts) do
					part:Destroy()
				end
				platformParts = {}
			else
				local targetHead = getHead(plr.Character)
				charRoot.CFrame = targetHead.CFrame * CFrame.new(0, 1.6, 0.4)

				for i, wall in ipairs(walls) do
					platformParts[i].CFrame = charRoot.CFrame * wall.offset
				end
			end
		end))
	end
end, true)

cmd.add({"unheadsit"}, {"unheadsit", "Stop the headsit command."}, function()
	NAlib.disconnect("headsit_follow")
	NAlib.disconnect("headsit_died")

	for _, part in pairs(platformParts) do
		part:Destroy()
	end
	platformParts = {}

	local char = getChar()
	local hum = getHum()
	if hum then
		hum:ChangeState(Enum.HumanoidStateType.Jumping)
	end
end)

cmd.add({"wallhop"},{"wallhop","wallhop helper"},function()
	local char = getChar()
	local root = getRoot(char)
	local hum = getHum()

	NAlib.disconnect("wallhop_loop")

	local canHop = true

	NAlib.connect("wallhop_loop", RunService.Stepped:Connect(function()
		if not char or not root or not hum or hum.Health <= 0 then
			NAlib.disconnect("wallhop_loop")
			return
		end

		local params = RaycastParams.new()
		params.FilterType = Enum.RaycastFilterType.Blacklist
		params.FilterDescendantsInstances = {char}

		local origin = root.Position + Vector3.new(0, -1, 0)
		local direction = root.CFrame.LookVector * 1.5
		local wallResult = workspace:Raycast(origin, direction, params)

		if wallResult and hum.FloorMaterial == Enum.Material.Air then
			local hitPart = wallResult.Instance
			local topPoint = wallResult.Position + Vector3.new(0, 0.1, 0)
			local upperCheck = workspace:Raycast(topPoint, Vector3.new(0, 2, 0), params)

			if upperCheck and upperCheck.Instance ~= hitPart then
				if root.Velocity.Y < -1 and canHop then
					canHop = false

					local originalYaw = root.Orientation.Y
					local flickAngle = 35 * (math.random(0,1) == 0 and -1 or 1)
					local newYaw = originalYaw + flickAngle

					root.CFrame = CFrame.new(root.Position) * CFrame.Angles(0, math.rad(newYaw), 0)
					hum:ChangeState(Enum.HumanoidStateType.Jumping)

					Delay(0.1, function()
						if root and root.Parent then
							root.CFrame = CFrame.new(root.Position) * CFrame.Angles(0, math.rad(originalYaw), 0)
						end
					end)
				end
			end
		end

		if root.Velocity.Y > 0 then
			canHop = true
		end
	end))
end)

cmd.add({"unwallhop"},{"unwallhop","disable wallhop helper"},function()
	NAlib.disconnect("wallhop_loop")
end)

cmd.add({"joinvoice", "joinvc"},{"joinvoice","let's you use vc if you were suspended"},function()
	SafeGetService("VoiceChatService"):joinVoice()
end)

cmd.add({"jump"},{"jump","jump."},function()
	getHum():ChangeState(Enum.HumanoidStateType.Jumping)
end)

cmd.add({"loopjump","bhop"},{"loopjump (bhop)","Continuously jump."},function()
	NAlib.disconnect("loopjump")
	NAlib.connect("loopjump",RunService.RenderStepped:Connect(function()
		local h=getHum()
		if h and h:GetState()~=Enum.HumanoidStateType.Freefall and h.FloorMaterial~=Enum.Material.Air then
			h:ChangeState(Enum.HumanoidStateType.Jumping)
		end
	end))
end)

cmd.add({"unloopjump","unbhop"},{"unloopjump (unbhop)","Stop continuous jumping."},function()
	NAlib.disconnect("loopjump")
end)

cmd.add({"trussjump","tj","tjump","trussj"},{"trussjump","Boost off trusses when you jump"},function() -- totally didn't stole this idea from FE2 lmao
	NAlib.disconnect("trussjump_spawn") NAlib.disconnect("trussjump_jump")
	local function hook()
		local hm=getHum()
		if not hm then return false end
		NAlib.disconnect("trussjump_jump")
		NAlib.connect("trussjump_jump",hm.Jumping:Connect(function(isJump)
			NACaller(function()
				local char=getChar()
				local rt=char and getRoot(char)
				local h=getHum()
				if isJump and h and rt and h:GetState()==Enum.HumanoidStateType.Jumping then
					h:SetStateEnabled(Enum.HumanoidStateType.Climbing,false)
					local hor=Vector3.new(rt.Velocity.X,0,rt.Velocity.Z)
					rt.Velocity=hor+Vector3.new(0,h.JumpPower*1.1,0)
					Delay(0.2,function() h:SetStateEnabled(Enum.HumanoidStateType.Climbing,true) end)
				end
			end)
		end))
		return true
	end
	local attempts=5
	while attempts>0 and not hook() do
		attempts-=1
		Wait(1)
	end
	if not getHum() then DoNotif("failed to hook to Humanoid",2) end
	NAlib.connect("trussjump_spawn",LocalPlayer.CharacterAdded:Connect(function()
		local attempts2=5
		while attempts2>0 and not hook() do
			attempts2-=1
			Wait(1)
		end
		if not getHum() then DoNotif("failed to hook to Humanoid",2) end
	end))
	DebugNotif("Trussjump enabled",2)
end,true)

cmd.add({"untrussjump","untj","untjump","untrussj"},{"untrussjump","Disable trussjump"},function()
	NAlib.disconnect("trussjump_spawn") NAlib.disconnect("trussjump_jump")
end)

cmd.add({"chattranslate","ctranslate","chatt"},{"chattranslate","the very old chat translator came back after years"},function()
	loadstring(game:HttpGet("https://raw.githubusercontent.com/ltseverydayyou/uuuuuuu/refs/heads/main/translatoooor"))();
end)

standParts = {}

cmd.add({"headstand"}, {"headstand <player>", "Stand on someone's head."}, function(p)
	NAlib.disconnect("headstand_follow")
	NAlib.disconnect("headstand_died")

	local targets = getPlr(p)
	if #targets == 0 then return end

	local plr = targets[1]
	local char = getChar()
	if not char then return end
	local hum = getHum()
	if not hum then return end

	NAlib.connect("headstand_died", hum.Died:Connect(function()
		NAlib.disconnect("headstand_follow")
		NAlib.disconnect("headstand_died")
		for _, part in pairs(standParts) do
			part:Destroy()
		end
		standParts = {}
	end))

	for _, part in pairs(standParts) do
		part:Destroy()
	end
	standParts = {}

	local thick = 1
	local halfWidth = 2
	local halfDepth = 2
	local halfHeight = 3

	local walls = {
		{offset = CFrame.new(0, 0, halfDepth + thick/500), size = Vector3.new(4, 6, thick)},
		{offset = CFrame.new(0, 0, -(halfDepth + thick/500)), size = Vector3.new(4, 6, thick)},
		{offset = CFrame.new(halfWidth + thick/500, 0, 0), size = Vector3.new(thick, 6, 4)},
		{offset = CFrame.new(-(halfWidth + thick/500), 0, 0), size = Vector3.new(thick, 6, 4)},
		{offset = CFrame.new(0, halfHeight + thick/500, 0), size = Vector3.new(4, thick, 4)},
		{offset = CFrame.new(0, -(halfHeight + thick/500), 0), size = Vector3.new(4, thick, 4)}
	}

	for _, wall in ipairs(walls) do
		local part = InstanceNew("Part")
		part.Size = wall.size
		part.Anchored = true
		part.CanCollide = true
		part.Transparency = 1
		part.Parent = workspace
		Insert(standParts, part)
	end

	NAlib.connect("headstand_follow", RunService.Stepped:Connect(function()
		local plrCharacter = plr.Character
		if Players:FindFirstChild(plr.Name) and plrCharacter and getRoot(plrCharacter) and getRoot(char) then
			local charRoot = getRoot(char)
			charRoot.CFrame = getRoot(plrCharacter).CFrame * CFrame.new(0, 4.6, 0.4)
			for i, wall in ipairs(walls) do
				standParts[i].CFrame = charRoot.CFrame * wall.offset
			end
		else
			NAlib.disconnect("headstand_follow")
			NAlib.disconnect("headstand_died")
			for _, part in pairs(standParts) do
				part:Destroy()
			end
			standParts = {}
		end
	end))
end, true)

cmd.add({"unheadstand"}, {"unheadstand", "Stop the headstand command."}, function()
	NAlib.disconnect("headstand_follow")
	NAlib.disconnect("headstand_died")

	for _, part in pairs(standParts) do
		part:Destroy()
	end
	standParts = {}
end)

getgenv().NamelessWs = nil
NAStuff.loopws = false

cmd.add({"loopwalkspeed", "loopws", "lws"}, {"loopwalkspeed <number> (loopws,lws)", "Loop walkspeed"}, function(...)
	local val = tonumber(...) or 16
	getgenv().NamelessWs = val
	NAStuff.loopws = true

	NAlib.disconnect("loopws_apply")
	NAlib.disconnect("loopws_char")

	local function applyWS()
		local hum = getHum()
		if hum then
			hum.WalkSpeed = val
			NAlib.connect("loopws_apply", hum:GetPropertyChangedSignal("WalkSpeed"):Connect(function()
				if NAStuff.loopws and hum.WalkSpeed ~= val then
					hum.WalkSpeed = val
				end
			end))
		end
	end

	applyWS()

	NAlib.connect("loopws_char", LocalPlayer.CharacterAdded:Connect(function()
		while not getHum() do Wait(.1) end
		if NAStuff.loopws then applyWS() end
	end))
end, true)

cmd.add({"unloopwalkspeed", "unloopws", "unlws"}, {"unloopwalkspeed (unloopws,unlws)", "Disable loop walkspeed"}, function()
	NAStuff.loopws = false
	NAlib.disconnect("loopws_apply")
	NAlib.disconnect("loopws_char")
end)

getgenv().NamelessJP = nil
NAStuff.loopjp = false

cmd.add({"loopjumppower", "loopjp", "ljp"}, {"loopjumppower <number> (loopjp,ljp)", "Loop JumpPower"}, function(...)
	local val = tonumber(...) or 50
	getgenv().NamelessJP = val
	NAStuff.loopjp = true

	NAlib.disconnect("loopjp_apply")
	NAlib.disconnect("loopjp_char")

	local function applyJP()
		local hum = getHum()
		if not hum then return end

		if hum.UseJumpPower then
			hum.JumpPower = val
			NAlib.connect("loopjp_apply", hum:GetPropertyChangedSignal("JumpPower"):Connect(function()
				if NAStuff.loopjp and hum.JumpPower ~= val then
					hum.JumpPower = val
				end
			end))
		else
			hum.JumpHeight = val
			NAlib.connect("loopjp_apply", hum:GetPropertyChangedSignal("JumpHeight"):Connect(function()
				if NAStuff.loopjp and hum.JumpHeight ~= val then
					hum.JumpHeight = val
				end
			end))
		end
	end

	applyJP()

	NAlib.connect("loopjp_char", LocalPlayer.CharacterAdded:Connect(function()
		while not getHum() do Wait(.1) end
		if NAStuff.loopjp then applyJP() end
	end))
end, true)

cmd.add({"unloopjumppower", "unloopjp", "unljp"}, {"unloopjumppower (unloopjp,unljp)", "Disable loop jump power"}, function()
	NAStuff.loopjp = false
	NAlib.disconnect("loopjp_apply")
	NAlib.disconnect("loopjp_char")
end)

cmd.add({"stopanimations", "stopanims", "stopanim", "noanim"}, {"stopanimations (stopanims,stopanim,noanim)", "Stops running animations"}, function()
	local char = Players.LocalPlayer and Players.LocalPlayer.Character
	local hum = getHum()
	if not hum then return end

	for _, track in ipairs(hum:GetPlayingAnimationTracks()) do
		track:Stop()
	end
end)

cmd.add({"refreshanimations", "refreshanimation", "refreshanims", "refreshanim"}, {"refreshanimations (refreshanimation,refreshanims,refreshanim)", "Reload character animations"}, function()
	local char=getChar()
	if not char then
		DoNotif("Character unavailable",2)
		return
	end
	local humanoid=getPlrHum(char)
	local animate=char:FindFirstChild("Animate")
	if not humanoid or not animate then
		DoNotif("Failed to locate Animate or Humanoid",3)
		return
	end
	animate.Disabled=true
	pcall(function()
		for _,track in ipairs(humanoid:GetPlayingAnimationTracks()) do
			track:Stop()
		end
	end)
	animate.Disabled=false
	DoNotif("Animations refreshed",2)
end)

loopwave = false

cmd.add({"loopwaveat", "loopwat"}, {"loopwaveat <player> (loopwat)", "Wave to a player in a loop"}, function(...)
	loopwave = true
	local playerName = (...)
	local targets = getPlr(playerName)
	for _, plr in next, targets do
		local char = getChar()
		local oldCFrame = getRoot(char).CFrame
		repeat
			Wait(0.2)
			local targetCFrame = getRoot(plr.Character).CFrame
			local waveAnim = InstanceNew("Animation")
			if getHum().RigType == Enum.HumanoidRigType.R15 then
				waveAnim.AnimationId = "rbxassetid://507770239"
			else
				waveAnim.AnimationId = "rbxassetid://128777973"
			end
			getRoot(char).CFrame = targetCFrame * CFrame.new(0, 0, -3)
			local charPos = char.PrimaryPart.Position
			local tpos = getRoot(plr.Character).Position
			local newCFrame = CFrame.new(charPos, Vector3.new(tpos.X, charPos.Y, tpos.Z))
			Players.LocalPlayer.Character:SetPrimaryPartCFrame(newCFrame)
			local wave = getHum():LoadAnimation(waveAnim)
			wave:Play(-1, 5, -1)
			Wait(1.6)
			wave:Stop()
		until not loopwave
		getRoot(char).CFrame = oldCFrame
	end
end, true)

cmd.add({"unloopwaveat", "unloopwat"}, {"unloopwaveat <player> (unloopwat)", "Stops the loopwaveat command"}, function()
	loopwave = false
end)

cmd.add({"tools", "gears"}, {"tools (gears)", "Copies tools from ReplicatedStorage and Lighting"}, function()
	function copyTools(source)
		for _, item in pairs(source:GetDescendants()) do
			if item:IsA('Tool') or item:IsA('HopperBin') then
				item:Clone().Parent = getBp()
			end
		end
	end

	copyTools(Lighting)
	copyTools(ReplicatedStorage)

	Wait()
	DebugNotif("Copied tools from ReplicatedStorage and Lighting", 3)
end)

tviewBillboards = {}
tviewAddConn, tviewRemoveConn = nil, nil
tviewGlobalMode = nil

if toolConnections then
	for _, conn in pairs(toolConnections) do
		pcall(function() if conn and conn.Disconnect then conn:Disconnect() end end)
	end
else
	toolConnections = {}
end

idkwhyididntmakethisbruh = nil

NAmanage.tvCleanupVisual=function(data)
	if data.renderConn then data.renderConn:Disconnect() data.renderConn = nil end
	if data.headConn then data.headConn:Disconnect() data.headConn = nil end
	if data.bb then data.bb:Destroy() data.bb = nil end
	data.container = nil
	data.char = nil
	data.head = nil
	data.lastToolNames = nil
end

NAmanage.tvDetach=function(plr)
	local data = tviewBillboards[plr]
	if not data then return end
	NAmanage.tvCleanupVisual(data)
	if data.charAddedConn then data.charAddedConn:Disconnect() data.charAddedConn = nil end
	if data.charRemovingConn then data.charRemovingConn:Disconnect() data.charRemovingConn = nil end
	if data.ancestryConn then data.ancestryConn:Disconnect() data.ancestryConn = nil end
	tviewBillboards[plr] = nil
end

NAmanage.tvAttach=function(plr, data, char)
	NAmanage.tvCleanupVisual(data)
	if not char or not plr.Parent then return end

	local head = getHead(char)
	if not head then
		if data.headConn then data.headConn:Disconnect() end
		data.headConn = char.ChildAdded:Connect(function(child)
			if child:IsA("BasePart") and child.Name == "Head" then
				if data.headConn then data.headConn:Disconnect() data.headConn = nil end
				NAmanage.tvAttach(plr, data, char)
			end
		end)
		return
	end

	local bb = InstanceNew("BillboardGui")
	bb.Name = "ToolViewDisplay"
	bb.Size = UDim2.new(0, 0, 0, 0)
	bb.StudsOffset = Vector3.new(0, 2.5, 0)
	bb.Adornee = head
	bb.AlwaysOnTop = true
	bb.LightInfluence = 0
	bb.ResetOnSpawn = false
	bb.Parent = head

	local container = InstanceNew("Frame")
	container.BackgroundTransparency = 1
	container.Size = UDim2.new(0, 0, 0, 50)
	container.AutomaticSize = Enum.AutomaticSize.X
	container.ClipsDescendants = false
	container.Parent = bb

	local layout = InstanceNew("UIListLayout")
	layout.FillDirection = Enum.FillDirection.Horizontal
	layout.SortOrder = Enum.SortOrder.LayoutOrder
	layout.Padding = UDim.new(0, 6)
	layout.Parent = container

	local function makeToolBtn(tool)
		local hasImg = tool.TextureId and tool.TextureId ~= ""
		local btn = hasImg and InstanceNew("ImageButton") or InstanceNew("TextButton")
		btn.Size = UDim2.new(0, 50, 0, 50)
		btn.Name = tool.Name
		btn.BackgroundColor3 = Color3.fromRGB(80, 80, 80)
		btn.AutoButtonColor = false
		btn.ZIndex = 5
		InstanceNew("UICorner", btn).CornerRadius = UDim.new(0.2, 0)
		if hasImg then
			btn.Image = tool.TextureId
		else
			btn.Text = tool.Name
			btn.TextScaled = true
			btn.TextColor3 = Color3.new(1, 1, 1)
			btn.Font = Enum.Font.SourceSans
		end
		return btn
	end

	local function refresh()
		for _, child in ipairs(container:GetChildren()) do
			if child:IsA("GuiButton") then child:Destroy() end
		end

		local bp = plr:FindFirstChildOfClass("Backpack") or plr:FindFirstChild("Backpack")
		if bp then
			for _, t in ipairs(bp:GetChildren()) do
				if t:IsA("Tool") then makeToolBtn(t).Parent = container end
			end
		end

		local activeChar = getPlrChar(plr) or plr.Character
		if activeChar then
			for _, t in ipairs(activeChar:GetChildren()) do
				if t:IsA("Tool") then makeToolBtn(t).Parent = container end
			end
		end
	end

	local function getToolNames()
		local names = {}
		local function add(t)
			if t:IsA("Tool") then Insert(names, t.Name) end
		end
		local bp = plr:FindFirstChildOfClass("Backpack") or plr:FindFirstChild("Backpack")
		if bp then
			for _, t in ipairs(bp:GetChildren()) do add(t) end
		end
		local activeChar = getPlrChar(plr) or plr.Character
		if activeChar then
			for _, t in ipairs(activeChar:GetChildren()) do add(t) end
		end
		table.sort(names)
		return names
	end

	refresh()
	data.lastToolNames = getToolNames()

	data.renderConn = RunService.RenderStepped:Connect(function()
		if not plr.Parent then NAmanage.tvCleanupVisual(data) return end
		local activeChar = plr.Character or getPlrChar(plr)
		if activeChar ~= char then NAmanage.tvCleanupVisual(data) return end
		local currentHead = getHead(activeChar)
		if not currentHead then NAmanage.tvCleanupVisual(data) return end
		if currentHead ~= head then
			head = currentHead
			bb.Adornee = head
			bb.Parent = head
		end
		if not head:IsDescendantOf(workspace) then NAmanage.tvCleanupVisual(data) return end

		local currentNames = getToolNames()
		local previous = data.lastToolNames or {}
		local changed = false
		if #currentNames ~= #previous then
			changed = true
		else
			for i = 1, #currentNames do
				if currentNames[i] ~= previous[i] then changed = true break end
			end
		end
		if changed then
			data.lastToolNames = currentNames
			refresh()
		end
		local width = container.AbsoluteSize.X
		local height = container.AbsoluteSize.Y
		bb.Size = UDim2.new(0, width, 0, height)
	end)

	data.bb = bb
	data.container = container
	data.char = char
	data.head = head
end

NAmanage.tvEnsure=function(plr)
	NAmanage.tvDetach(plr)
	if not plr then return end

	local data = {}
	tviewBillboards[plr] = data

	local function onCharAdded(char)
		NAmanage.tvAttach(plr, data, char)
	end

	data.charAddedConn = plr.CharacterAdded:Connect(onCharAdded)
	data.charRemovingConn = plr.CharacterRemoving:Connect(function()
		NAmanage.tvCleanupVisual(data)
	end)
	data.ancestryConn = plr.AncestryChanged:Connect(function(_, parent)
		if not parent then
			NAmanage.tvDetach(plr)
		end
	end)

	onCharAdded(getPlrChar(plr) or plr.Character)
end

cmd.add({"toolview", "tview"}, {"toolview <player> (tview)", "3D tool viewer above a player's head"}, function(...)
	local args = {...}
	local firstArg = args[1]
	local lowerFirst = type(firstArg) == "string" and Lower(firstArg)
	local isGlobal = lowerFirst == "all" or lowerFirst == "others"
	local targets = getPlr(Unpack(args))
	if #targets == 0 and not isGlobal then
		DoNotif("No players found", 2)
		return
	end

	for _, plr in ipairs(targets) do
		if plr and plr.Parent then
			NAmanage.tvEnsure(plr)
		end
	end

	if isGlobal then
		if tviewAddConn then tviewAddConn:Disconnect() end
		if tviewRemoveConn then tviewRemoveConn:Disconnect() end
		tviewGlobalMode = lowerFirst
		tviewAddConn = Players.PlayerAdded:Connect(function(plr)
			if tviewGlobalMode == "others" and plr == Players.LocalPlayer then return end
			NAmanage.tvEnsure(plr)
		end)
		tviewRemoveConn = Players.PlayerRemoving:Connect(function(plr)
			NAmanage.tvDetach(plr)
		end)
	end
end, true)

cmd.add({"untoolview", "untview"}, {"untview <player> (untview)", "Removes the tool viewer above a player's head"}, function(...)
	local args = {...}
	local firstArg = args[1]
	local lowerFirst = type(firstArg) == "string" and Lower(firstArg)
	local targets = getPlr(Unpack(args))
	if #targets == 0 and not (lowerFirst == "all" or lowerFirst == "others") then
		DoNotif("No players found", 2)
		return
	end

	for _, plr in ipairs(targets) do
		NAmanage.tvDetach(plr)
	end

	if lowerFirst == "all" or lowerFirst == "others" or lowerFirst == tviewGlobalMode then
		if tviewAddConn then tviewAddConn:Disconnect() tviewAddConn = nil end
		if tviewRemoveConn then tviewRemoveConn:Disconnect() tviewRemoveConn = nil end
		tviewGlobalMode = nil
	end
end, true)

cmd.add({"toolview2", "tview2"}, {"toolview2 (tview2)", "Live-updating tool viewer"}, function()
	if renderConn then renderConn:Disconnect() end
	if playerAddConn then playerAddConn:Disconnect() end
	if playerRemoveConn then playerRemoveConn:Disconnect() end
	for _, c in pairs(toolConnections) do NACaller(function() if c and c.Disconnect then c:Disconnect() end end) end
	toolConnections = {}

	if idkwhyididntmakethisbruh then idkwhyididntmakethisbruh:Destroy() idkwhyididntmakethisbruh = nil end

	idkwhyididntmakethisbruh = InstanceNew("ScreenGui")
	NaProtectUI(idkwhyididntmakethisbruh)
	idkwhyididntmakethisbruh.Name = "ToolViewGui"
	idkwhyididntmakethisbruh.ZIndexBehavior = Enum.ZIndexBehavior.Sibling

	local main = InstanceNew("Frame")
	main.Name = "Main"
	main.Size = UDim2.new(0.4, 0, 0.5, 0)
	main.Position = UDim2.new(0.5, 0, 0.5, 0)
	main.AnchorPoint = Vector2.new(0.5, 0.5)
	main.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
	main.BorderSizePixel = 0
	main.ZIndex = 10
	main.Active = true
	main.Selectable = true
	main.Parent = idkwhyididntmakethisbruh
	InstanceNew("UICorner", main).CornerRadius = UDim.new(0, 20)

	local topbar = InstanceNew("Frame")
	topbar.Size = UDim2.new(1, 0, 0, 35)
	topbar.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
	topbar.BorderSizePixel = 0
	topbar.ZIndex = 11
	topbar.Active = true
	topbar.Selectable = true
	topbar.Parent = main
	InstanceNew("UICorner", topbar).CornerRadius = UDim.new(0, 8)

	local title = InstanceNew("TextLabel")
	title.Text = "Tool Viewer"
	title.Size = UDim2.new(1, -70, 1, 0)
	title.Position = UDim2.new(0, 10, 0, 0)
	title.BackgroundTransparency = 1
	title.TextColor3 = Color3.new(1, 1, 1)
	title.Font = Enum.Font.SourceSansBold
	title.TextSize = 18
	title.TextXAlignment = Enum.TextXAlignment.Left
	title.ZIndex = 11
	title.Parent = topbar

	local closeBtn = InstanceNew("TextButton")
	closeBtn.Size = UDim2.new(0, 30, 1, 0)
	closeBtn.Position = UDim2.new(1, -35, 0, 0)
	closeBtn.Text = "X"
	closeBtn.Font = Enum.Font.SourceSansBold
	closeBtn.TextSize = 16
	closeBtn.TextColor3 = Color3.new(1, 1, 1)
	closeBtn.BackgroundColor3 = Color3.fromRGB(180, 50, 50)
	closeBtn.ZIndex = 11
	closeBtn.Parent = topbar
	InstanceNew("UICorner", closeBtn).CornerRadius = UDim.new(0, 6)

	local minimizeBtn = InstanceNew("TextButton")
	minimizeBtn.Size = UDim2.new(0, 30, 1, 0)
	minimizeBtn.Position = UDim2.new(1, -70, 0, 0)
	minimizeBtn.Text = "-"
	minimizeBtn.Font = Enum.Font.SourceSansBold
	minimizeBtn.TextSize = 16
	minimizeBtn.TextColor3 = Color3.new(1, 1, 1)
	minimizeBtn.BackgroundColor3 = Color3.fromRGB(80, 80, 80)
	minimizeBtn.ZIndex = 11
	minimizeBtn.Parent = topbar
	InstanceNew("UICorner", minimizeBtn).CornerRadius = UDim.new(0, 6)

	local scroll = InstanceNew("ScrollingFrame")
	scroll.Name = "Content"
	scroll.Size = UDim2.new(1, 0, 1, -35)
	scroll.Position = UDim2.new(0, 0, 0, 35)
	scroll.CanvasSize = UDim2.new(0, 0, 0, 0)
	scroll.ScrollBarThickness = 6
	scroll.BackgroundTransparency = 1
	scroll.BorderSizePixel = 0
	scroll.ZIndex = 10
	scroll.AutomaticCanvasSize = Enum.AutomaticSize.Y
	scroll.Parent = main

	local list = InstanceNew("UIListLayout")
	list.Padding = UDim.new(0, 12)
	list.SortOrder = Enum.SortOrder.LayoutOrder
	list.Parent = scroll

	local sections = {}

	local function disconnectAll(list)
		for i = #list, 1, -1 do
			local conn = list[i]
			NACaller(function()
				if conn and conn.Disconnect then conn:Disconnect() end
			end)
			list[i] = nil
		end
	end

	local function registerConn(store, conn)
		if conn then
			Insert(store, conn)
			Insert(toolConnections, conn)
		end
	end

	local function makeToolBtn(tool)
		local hasImg = tool.TextureId and tool.TextureId ~= ""
		local btn = hasImg and InstanceNew("ImageButton") or InstanceNew("TextButton")
		btn.Size = UDim2.new(0, 50, 0, 50)
		btn.Name = tool.Name
		btn.BackgroundColor3 = Color3.fromRGB(80, 80, 80)
		btn.AutoButtonColor = false
		btn.ZIndex = 10
		InstanceNew("UICorner", btn).CornerRadius = UDim.new(0.2, 0)

		if hasImg then
			btn.Image = tool.TextureId
		else
			btn.Text = tool.Name
			btn.TextScaled = true
			btn.TextColor3 = Color3.new(1, 1, 1)
			btn.Font = Enum.Font.SourceSans
		end

		return btn
	end

	local function updateTools(plr)
		local sec = sections[plr]
		if not sec then return end

		for _, btn in ipairs(sec.Holder:GetChildren()) do
			if btn:IsA("GuiButton") then btn:Destroy() end
		end

		if not plr then return end

		local tools = {}

		local bp = plr:FindFirstChildOfClass("Backpack") or plr:FindFirstChild("Backpack")
		if bp then
			for _, t in ipairs(bp:GetChildren()) do
				if t:IsA("Tool") then Insert(tools, t) end
			end
		end

		local char = plr.Character or getPlrChar(plr)
		if char then
			for _, t in ipairs(char:GetChildren()) do
				if t:IsA("Tool") then Insert(tools, t) end
			end
		end

		table.sort(tools, function(a, b)
			return Lower((a and a.Name) or "") < Lower((b and b.Name) or "")
		end)

		for _, t in ipairs(tools) do
			if t then
				makeToolBtn(t).Parent = sec.Holder
			end
		end
	end

	local function createSection(plr)
		if not plr then return end
		if sections[plr] then
			updateTools(plr)
			return
		end

		local frame = InstanceNew("Frame")
		frame.Size = UDim2.new(1, -10, 0, 100)
		frame.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
		frame.BorderSizePixel = 0
		frame.ZIndex = 10
		frame.Parent = scroll
		InstanceNew("UICorner", frame).CornerRadius = UDim.new(0, 12)

		local name = InstanceNew("TextLabel")
		name.Size = UDim2.new(1, -10, 0, 30)
		name.Position = UDim2.new(0, 5, 0, 5)
		name.BackgroundTransparency = 1
		name.Text = nameChecker(plr)
		name.Font = Enum.Font.SourceSansSemibold
		name.TextSize = 18
		name.TextColor3 = Color3.new(1, 1, 1)
		name.TextXAlignment = Enum.TextXAlignment.Left
		name.ZIndex = 10
		name.Parent = frame

		local holder = InstanceNew("ScrollingFrame")
		holder.Name = "ToolHolder"
		holder.Position = UDim2.new(0, 5, 0, 35)
		holder.Size = UDim2.new(1, -10, 0, 55)
		holder.CanvasSize = UDim2.new(0, 0, 0, 0)
		holder.ScrollBarThickness = 4
		holder.ScrollingDirection = Enum.ScrollingDirection.X
		holder.AutomaticCanvasSize = Enum.AutomaticSize.X
		holder.BackgroundTransparency = 1
		holder.BorderSizePixel = 0
		holder.ZIndex = 10
		holder.Parent = frame

		local hList = InstanceNew("UIListLayout")
		hList.Padding = UDim.new(0, 6)
		hList.FillDirection = Enum.FillDirection.Horizontal
		hList.SortOrder = Enum.SortOrder.LayoutOrder
		hList.Parent = holder

		local sec = {
			Frame = frame,
			Holder = holder,
			charConns = {},
			backpackConns = {},
			playerConns = {}
		}
		sections[plr] = sec

		local function connectBackpack(bp)
			disconnectAll(sec.backpackConns)
			if typeof(bp) ~= "Instance" then return end
			registerConn(sec.backpackConns, bp.ChildAdded:Connect(function(item)
				if item:IsA("Tool") then updateTools(plr) end
			end))
			registerConn(sec.backpackConns, bp.ChildRemoved:Connect(function(item)
				if item:IsA("Tool") then updateTools(plr) end
			end))
		end

		local function connectCharacter(char)
			disconnectAll(sec.charConns)
			if typeof(char) ~= "Instance" then return end
			registerConn(sec.charConns, char.ChildAdded:Connect(function(item)
				if item:IsA("Tool") then updateTools(plr) end
			end))
			registerConn(sec.charConns, char.ChildRemoved:Connect(function(item)
				if item:IsA("Tool") then updateTools(plr) end
			end))
		end

		registerConn(sec.playerConns, plr.ChildAdded:Connect(function(child)
			if typeof(child) == "Instance" and child:IsA("Backpack") then
				connectBackpack(child)
				updateTools(plr)
			end
		end))
		registerConn(sec.playerConns, plr.ChildRemoved:Connect(function(child)
			if typeof(child) == "Instance" and child:IsA("Backpack") then
				disconnectAll(sec.backpackConns)
				updateTools(plr)
			end
		end))
		registerConn(sec.playerConns, plr.CharacterAdded:Connect(function(char)
			connectCharacter(char)
			updateTools(plr)
		end))
		registerConn(sec.playerConns, plr.CharacterRemoving:Connect(function()
			disconnectAll(sec.charConns)
			updateTools(plr)
		end))

		connectBackpack(plr:FindFirstChildOfClass("Backpack") or plr:FindFirstChild("Backpack"))
		connectCharacter(plr.Character or getPlrChar(plr))
		updateTools(plr)
	end

	local function removeSection(plr)
		local sec = sections[plr]
		if not sec then return end
		disconnectAll(sec.charConns)
		disconnectAll(sec.backpackConns)
		disconnectAll(sec.playerConns)
		if sec.Frame then sec.Frame:Destroy() end
		sections[plr] = nil
	end

	local function refreshAll()
		for plr in pairs(sections) do
			if plr and plr.Parent == Players then
				updateTools(plr)
			end
		end
	end

	for _, plr in ipairs(Players:GetPlayers()) do
		createSection(plr)
	end

	renderConn = RunService.RenderStepped:Connect(refreshAll)
	playerAddConn = Players.PlayerAdded:Connect(function(plr)
		createSection(plr)
	end)
	playerRemoveConn = Players.PlayerRemoving:Connect(function(plr)
		removeSection(plr)
	end)

	local minimized = false
	MouseButtonFix(minimizeBtn, function()
		minimized = not minimized
		scroll.Visible = not minimized
		main.Size = minimized and UDim2.new(0.4, 0, 0.05, 0) or UDim2.new(0.4, 0, 0.5, 0)
	end)

	MouseButtonFix(closeBtn, function()
		if renderConn then renderConn:Disconnect() end
		if playerAddConn then playerAddConn:Disconnect() end
		if playerRemoveConn then playerRemoveConn:Disconnect() end
		local toRemove = {}
		for plr in pairs(sections) do
			Insert(toRemove, plr)
		end
		for _, plr in ipairs(toRemove) do
			removeSection(plr)
		end
		for _, c in pairs(toolConnections) do NACaller(function() if c and c.Disconnect then c:Disconnect() end end) end
		toolConnections = {}
		if idkwhyididntmakethisbruh then idkwhyididntmakethisbruh:Destroy() idkwhyididntmakethisbruh = nil end
	end)

	NAgui.dragger(main,topbar)
end)


cmd.add({"waveat", "wat"}, {"waveat <player> (wat)", "Wave to a player"}, function(...)
	local playerName = (...)
	local targets = getPlr(playerName)
	if #targets == 0 then return end
	local plr = targets[1]
	local char = getChar()
	local humanoid = getHum()
	local localRoot = getRoot(char)
	local oldCFrame = localRoot.CFrame
	local targetRoot = getRoot(plr.Character)
	if targetRoot then
		localRoot.CFrame = targetRoot.CFrame * CFrame.new(0, 0, -3)
		local charPos = char.PrimaryPart.Position
		local targetHRP = getRoot(plr.Character)
		if targetHRP then
			local newCFrame = CFrame.new(charPos, Vector3.new(targetHRP.Position.X, charPos.Y, targetHRP.Position.Z))
			Players.LocalPlayer.Character:SetPrimaryPartCFrame(newCFrame)
		end
		local waveAnim = InstanceNew("Animation")
		if IsR15() then
			waveAnim.AnimationId = "rbxassetid://507770239"
		else
			waveAnim.AnimationId = "rbxassetid://128777973"
		end
		local wave = humanoid:LoadAnimation(waveAnim)
		wave:Play(-1, 5, -1)
		Wait(1.6)
		wave:Stop()
		localRoot.CFrame = oldCFrame
	end
end, true)

bang, bangAnim, bangLoop, bangDied, bangParts = nil, nil, nil, nil, {}

cmd.add({"headbang", "mouthbang", "headfuck", "mouthfuck", "facebang", "facefuck", "hb", "mb"}, {"headbang <player> (mouthbang,headfuck,mouthfuck,facebang,facefuck,hb,mb)", "Bang them in the mouth because you are gay"}, function(h, d)
	local speed = d or 10
	local username = h
	local hasQuery = username and username ~= ""
	local players = hasQuery and getPlr(username) or {}
	local plr = players[1]
	if hasQuery and not plr then
		DoNotif("No targets found", 2)
	end
	bangAnim = InstanceNew("Animation")
	if not IsR15(Players.LocalPlayer) then
		bangAnim.AnimationId = "rbxassetid://148840371"
	else
		bangAnim.AnimationId = "rbxassetid://5918726674"
	end
	local humanoid = getHum()
	if not humanoid then return end
	bang = humanoid:LoadAnimation(bangAnim)
	bang:Play(0.1, 1, 1)
	bang:AdjustSpeed(speed)
	local bangplr = plr and plr.Name or nil
	bangDied = humanoid.Died:Connect(function()
		if bangLoop then
			bangLoop:Disconnect()
		end
		bang:Stop()
		bangAnim:Destroy()
		bangDied:Disconnect()
		for _, part in pairs(bangParts) do
			part:Destroy()
		end
		bangParts = {}
	end)
	for _, part in pairs(bangParts) do
		part:Destroy()
	end
	bangParts = {}
	local bangOffset = CFrame.new(0, 1, -1.1)
	if bangplr then
		bangLoop = RunService.Stepped:Connect(function()
			NACaller(function()
				local targetPlayer = Players:FindFirstChild(bangplr)
				if not targetPlayer or not targetPlayer.Character then
					if bangLoop then bangLoop:Disconnect() bangLoop = nil end
					return
				end
				local targetCharacter = targetPlayer.Character
				local localCharacter = getChar()
				local localRoot = localCharacter and getRoot(localCharacter)
				if not (localCharacter and localRoot) then return end
				local otherHead = getHead(targetCharacter)
				if otherHead then
					localRoot.CFrame = otherHead.CFrame * bangOffset
				end
				local targetRoot = getRoot(targetCharacter)
				local localPrimary = localCharacter.PrimaryPart
				if targetRoot and localPrimary then
					local charPos = localPrimary.Position
					local newCFrame = CFrame.new(charPos, Vector3.new(targetRoot.Position.X, charPos.Y, targetRoot.Position.Z))
					localCharacter:SetPrimaryPartCFrame(newCFrame)
				end
				localRoot.AssemblyLinearVelocity = Vector3.new()
				localRoot.AssemblyAngularVelocity = Vector3.new()
			end)
		end)
	end
end, true)

cmd.add({"unheadbang", "unmouthbang", "unhb", "unmb"}, {"unheadbang (unmouthbang,unhb,unmb)", "Stops headbang"}, function()
	if bangLoop then
		bangLoop:Disconnect()
		bang:Stop()
		bangAnim:Destroy()
		bangDied:Disconnect()
	end
	for _, part in pairs(bangParts) do
		part:Destroy()
	end
	bangParts = {}
end)

jerkAnim, jerkTrack, jerkLoop, jerkDied, jerkParts = nil, nil, nil, nil, {}

cmd.add({"jerkuser", "jorkuser", "handjob", "hjob", "handj"}, {"jerkuser <player> (jorkuser, handjob, hjob, handj)", "Lay under them and vibe"}, function(h, d)
	if not IsR6() then DoNotif("command requires R6",3) return end
	local username = h
	local players = getPlr(username)
	if #players == 0 then return end
	local plr = players[1]

	local char = getChar()
	if not char then return end

	local humanoid = getHum()
	if not humanoid then return end

	jerkAnim = InstanceNew("Animation")
	jerkAnim.AnimationId = "rbxassetid://95383980"
	jerkTrack = humanoid:LoadAnimation(jerkAnim)
	jerkTrack.Looped = true
	jerkTrack:Play()

	humanoid.Sit = true
	Wait(0.1)

	local root = getRoot(char)
	if not root then return end

	root.CFrame = root.CFrame * CFrame.Angles(math.pi * 0.5, math.pi, 0)

	for _, part in pairs(jerkParts) do
		part:Destroy()
	end
	jerkParts = {}

	local thick = 0.2
	local halfWidth = 2
	local halfDepth = 2
	local halfHeight = 3
	local walls = {
		{offset = CFrame.new(0, 0, halfDepth + thick / 500), size = Vector3.new(4, 6, thick)},
		{offset = CFrame.new(0, 0, -(halfDepth + thick / 500)), size = Vector3.new(4, 6, thick)},
		{offset = CFrame.new(halfWidth + thick / 500, 0, 0), size = Vector3.new(thick, 6, 4)},
		{offset = CFrame.new(-(halfWidth + thick / 500), 0, 0), size = Vector3.new(thick, 6, 4)},
		{offset = CFrame.new(0, halfHeight + thick / 500, 0), size = Vector3.new(4, thick, 4)},
		{offset = CFrame.new(0, -(halfHeight + thick / 500), 0), size = Vector3.new(4, thick, 4)}
	}

	for i, wall in ipairs(walls) do
		local part = InstanceNew("Part")
		part.Size = wall.size
		part.Anchored = true
		part.CanCollide = true
		part.Transparency = 1
		part.Parent = workspace
		Insert(jerkParts, part)
	end

	local jerkOffset = CFrame.new(0, -2.5, -0.25) * CFrame.Angles(math.pi * 0.5, 0, math.pi)
	jerkLoop = RunService.Stepped:Connect(function()
		NACaller(function()
			for i, wall in ipairs(walls) do
				jerkParts[i].CFrame = root.CFrame * wall.offset
			end
			local targetChar = plr.Character
			local targetRoot = targetChar and getRoot(targetChar)
			if targetRoot then
				root.CFrame = targetRoot.CFrame * jerkOffset
			end
		end)
	end)

	jerkDied = humanoid.Died:Connect(function()
		if jerkLoop then jerkLoop:Disconnect() end
		if jerkTrack then jerkTrack:Stop() end
		if jerkAnim then jerkAnim:Destroy() end
		for _, part in pairs(jerkParts) do
			part:Destroy()
		end
		jerkParts = {}
	end)
end, true)

cmd.add({"unjerkuser", "unjorkuser", "unhandjob", "unhjob", "unhandj"}, {"unjerkuser (unjorkuser, unhandjob, unhjob, unhandj)", "Stop the jerk user action"}, function()
	if jerkLoop then jerkLoop:Disconnect() end
	if jerkTrack then jerkTrack:Stop() end
	if jerkAnim then jerkAnim:Destroy() end
	if jerkDied then jerkDied:Disconnect() end

	local char = getChar()
	local root = getRoot(char)
	if root then
		root.CFrame = root.CFrame * CFrame.Angles(0, math.pi, 0)
	end

	local humanoid = getHum()
	if humanoid then
		humanoid.Sit = false
	end

	for _, part in pairs(jerkParts) do
		part:Destroy()
	end
	jerkParts = {}
end)

suckLOOP = nil
suckANIM = nil
suckDIED = nil
doSUCKING = nil
SUCKYSUCKY = {}

cmd.add({"suck","dicksuck"},{"suck <player> <number>","suck it"},function(h,d)
	if suckLOOP then suckLOOP = nil end
	if doSUCKING then doSUCKING:Stop() end
	if suckANIM then suckANIM:Destroy() end
	if suckDIED then suckDIED:Disconnect() end
	for _,p in pairs(SUCKYSUCKY) do p:Destroy() end
	SUCKYSUCKY = {}

	local speed = d or 10
	local tweenDuration = 1/speed
	local tweenInfo = TweenInfo.new(tweenDuration,Enum.EasingStyle.Sine,Enum.EasingDirection.Out)
	local targets = getPlr(h)
	if #targets == 0 then return end
	local plr = targets[1]
	local targetName = plr.Name

	suckANIM = InstanceNew("Animation")
	if not IsR15(Players.LocalPlayer) then
		suckANIM.AnimationId = "rbxassetid://189854234"
	else
		suckANIM.AnimationId = "rbxassetid://5918726674"
	end
	local hum = getHum()
	doSUCKING = hum:LoadAnimation(suckANIM)
	doSUCKING:Play(0.1,1,1)
	doSUCKING:AdjustSpeed(speed)

	suckDIED = hum.Died:Connect(function()
		if suckLOOP then suckLOOP = nil end
		doSUCKING:Stop()
		suckANIM:Destroy()
		suckDIED:Disconnect()
		for _,part in pairs(SUCKYSUCKY) do part:Destroy() end
		SUCKYSUCKY = {}
	end)

	local thick,halfWidth,halfDepth,halfHeight = 0.2,2,2,3
	local walls = {
		{offset=CFrame.new(0,0,halfDepth+thick/500), size=Vector3.new(4,6,thick)},
		{offset=CFrame.new(0,0,-(halfDepth+thick/500)), size=Vector3.new(4,6,thick)},
		{offset=CFrame.new(halfWidth+thick/500,0,0), size=Vector3.new(thick,6,4)},
		{offset=CFrame.new(-(halfWidth+thick/500),0,0), size=Vector3.new(thick,6,4)},
		{offset=CFrame.new(0,halfHeight+thick/500,0), size=Vector3.new(4,thick,4)},
		{offset=CFrame.new(0,-(halfHeight+thick/500),0), size=Vector3.new(4,thick,4)},
	}
	for i,wall in ipairs(walls) do
		local part = InstanceNew("Part")
		part.Size=wall.size
		part.Anchored=true
		part.CanCollide=true
		part.Transparency=1
		part.Parent=workspace
		Insert(SUCKYSUCKY,part)
	end

	suckLOOP = coroutine.wrap(function()
		while true do
			local targetPlayer = Players:FindFirstChild(targetName)
			local targetCharacter = targetPlayer and targetPlayer.Character
			local localCharacter = getChar()
			if targetCharacter and getRoot(targetCharacter) and localCharacter and getRoot(localCharacter) then
				local targetHRP = getRoot(targetCharacter)
				local localHRP = getRoot(localCharacter)
				local forwardCFrame = targetHRP.CFrame * CFrame.new(0,-2.3,-2.5) * CFrame.Angles(0,math.pi,0)
				local backwardCFrame = targetHRP.CFrame * CFrame.new(0,-2.3,-1.3) * CFrame.Angles(0,math.pi,0)
				local tweenForward = TweenService:Create(localHRP,TweenInfo.new(0.15,Enum.EasingStyle.Linear,Enum.EasingDirection.Out),{CFrame=forwardCFrame})
				tweenForward:Play()
				tweenForward.Completed:Wait()
				local tweenBackward = TweenService:Create(localHRP,TweenInfo.new(0.15,Enum.EasingStyle.Linear,Enum.EasingDirection.Out),{CFrame=backwardCFrame})
				tweenBackward:Play()
				tweenBackward.Completed:Wait()
				for i,wall in ipairs(walls) do
					SUCKYSUCKY[i].CFrame = localHRP.CFrame * wall.offset
				end
			end
			Wait(0.1)
		end
	end)
	suckLOOP()
end,true)

cmd.add({"unsuck","undicksuck"},{"unsuck","no more fun"},function()
	suckLOOP = nil
	if doSUCKING then doSUCKING:Stop() end
	if suckANIM then suckANIM:Destroy() end
	if suckDIED then suckDIED:Disconnect() end
	for _,p in pairs(SUCKYSUCKY) do p:Destroy() end
	SUCKYSUCKY = {}
end)

cmd.add({"improvetextures"},{"improvetextures","Switches Textures"},function()
	opt.hiddenprop(SafeGetService("MaterialService"), "Use2022Materials", true)
end)

cmd.add({"undotextures"},{"undotextures","Switches Textures"},function()
	opt.hiddenprop(SafeGetService("MaterialService"), "Use2022Materials", false)
end)

cmd.add({"serverlist","serverlister","slist"},{"serverlist (serverlister,slist)","list of servers to join in"},function()
	loadstring(game:HttpGet("https://raw.githubusercontent.com/ltseverydayyou/uuuuuuu/refs/heads/main/ServerLister.lua"))();
end)

cmd.add({"keyboard"},{"keyboard","provides a keyboard gui for mobile users"},function()
	loadstring(game:HttpGet("https://raw.githubusercontent.com/ltseverydayyou/uuuuuuu/refs/heads/main/VirtualKeyboard.lua"))();
end)

cmd.add({"autoclicker"},{"autoclicker","provides a autoclicker gui"},function()
	loadstring(game:HttpGet("https://raw.githubusercontent.com/ltseverydayyou/uuuuuuu/refs/heads/main/AutoClicker.luau"))();
end)

cmd.add({"backpack"},{"backpack","provides a custom backpack gui"},function()
	loadstring(game:HttpGet("https://raw.githubusercontent.com/ltseverydayyou/uuuuuuu/refs/heads/main/mobileBACKPACK.lua"))();
end)

-- patched
cmd.addPatched({"reserveserver","privateserver","ps","rs"},{"reserveserver [code]","Teleports to a reserved server or creates one if code is missing"},function(code)
	local md5={}
	local hmac={}
	local base64={}
	do
		local T={
			0xd76aa478,0xe8c7b756,0x242070db,0xc1bdceee,0xf57c0faf,0x4787c62a,0xa8304613,0xfd469501,
			0x698098d8,0x8b44f7af,0xffff5bb1,0x895cd7be,0x6b901122,0xfd987193,0xa679438e,0x49b40821,
			0xf61e2562,0xc040b340,0x265e5a51,0xe9b6c7aa,0xd62f105d,0x02441453,0xd8a1e681,0xe7d3fbc8,
			0x21e1cde6,0xc33707d6,0xf4d50d87,0x455a14ed,0xa9e3e905,0xfcefa3f8,0x676f02d9,0x8d2a4c8a,
			0xfffa3942,0x8771f681,0x6d9d6122,0xfde5380c,0xa4beea44,0x4bdecfa9,0xf6bb4b60,0xbebfbc70,
			0x289b7ec6,0xeaa127fa,0xd4ef3085,0x04881d05,0xd9d4d039,0xe6db99e5,0x1fa27cf8,0xc4ac5665,
			0xf4292244,0x432aff97,0xab9423a7,0xfc93a039,0x655b59c3,0x8f0ccc92,0xffeff47d,0x85845dd1,
			0x6fa87e4f,0xfe2ce6e0,0xa3014314,0x4e0811a1,0xf7537e82,0xbd3af235,0x2ad7d2bb,0xeb86d391
		}
		local function add(a,b)
			local lsw=bit32.band(a,0xFFFF)+bit32.band(b,0xFFFF)
			local msw=bit32.rshift(a,16)+bit32.rshift(b,16)+bit32.rshift(lsw,16)
			return bit32.bor(bit32.lshift(msw,16),bit32.band(lsw,0xFFFF))
		end
		local function rol(x,n) return bit32.bor(bit32.lshift(x,n),bit32.rshift(x,32-n)) end
		local function F(x,y,z) return bit32.bor(bit32.band(x,y),bit32.band(bit32.bnot(x),z)) end
		local function G(x,y,z) return bit32.bor(bit32.band(x,z),bit32.band(y,bit32.bnot(z))) end
		local function H(x,y,z) return bit32.bxor(x,bit32.bxor(y,z)) end
		local function I(x,y,z) return bit32.bxor(y,bit32.bor(x,bit32.bnot(z))) end
		function md5.sum(message)
			local a,b,c,d=0x67452301,0xefcdab89,0x98badcfe,0x10325476
			local message_len=#message
			local padded_message=message.."\128"
			while #padded_message%64~=56 do
				padded_message=padded_message.."\0"
			end
			local len_bytes=""
			local len_bits=message_len*8
			for i=0,7 do
				len_bytes=len_bytes..string.char(bit32.band(bit32.rshift(len_bits,i*8),0xFF))
			end
			padded_message=padded_message..len_bytes
			for i=1,#padded_message,64 do
				local chunk=padded_message:sub(i,i+63)
				local X={}
				for j=0,15 do
					local b1,b2,b3,b4=chunk:byte(j*4+1,j*4+4)
					X[j]=bit32.bor(b1,bit32.lshift(b2,8),bit32.lshift(b3,16),bit32.lshift(b4,24))
				end
				local aa,bb,cc,dd=a,b,c,d
				local s={7,12,17,22,5,9,14,20,4,11,16,23,6,10,15,21}
				for j=0,63 do
					local f,k,si
					if j<16 then f=F(b,c,d) k=j si=j%4
					elseif j<32 then f=G(b,c,d) k=(1+5*j)%16 si=4+(j%4)
					elseif j<48 then f=H(b,c,d) k=(5+3*j)%16 si=8+(j%4)
					else f=I(b,c,d) k=(7*j)%16 si=12+(j%4) end
					local t=add(a,f)
					t=add(t,X[k])
					t=add(t,T[j+1])
					t=rol(t,s[si+1])
					local nb=add(b,t)
					a,b,c,d=d,nb,b,c
				end
				a=add(a,aa) b=add(b,bb) c=add(c,cc) d=add(d,dd)
			end
			local function to_le(n)
				local s=""
				for i=0,3 do s=s..string.char(bit32.band(bit32.rshift(n,i*8),0xFF)) end
				return s
			end
			return to_le(a)..to_le(b)..to_le(c)..to_le(d)
		end
	end
	function hmac.new(key,msg,hash_func)
		if #key>64 then key=hash_func(key) end
		local o="" local i=""
		for n=1,64 do
			local by=(n<=#key and string.byte(key,n)) or 0
			o=o..string.char(bit32.bxor(by,0x5C))
			i=i..string.char(bit32.bxor(by,0x36))
		end
		return hash_func(o..hash_func(i..msg))
	end
	do
		local b="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
		function base64.encode(data)
			return ((data:gsub(".",function(x)
				local r,bv="",x:byte()
				for i=8,1,-1 do r=r..(bv%2^i-bv%2^(i-1)>0 and "1" or "0") end
				return r
			end).."0000"):gsub("%d%d%d?%d?%d?%d?",function(x)
				if #x<6 then return "" end
				local c=0
				for i=1,6 do c=c+((x:sub(i,i)=="1") and 2^(6-i) or 0) end
				return b:sub(c+1,c+1)
			end)..({"","==","="})[#data%3+1])
		end
	end
	local function isLikelyAccessCode(s)
		if not s then return false end
		if #s<20 then return false end
		if not s:match("%d$") then return false end
		if s:find("[_%-]") then return true end
		return s:find("[A-Za-z]")~=nil
	end
	local function GenerateAccessCode(placeId,seed)
		local firstBytes
		if seed and seed~="" then
			local dig=md5.sum(tostring(seed)..":"..tostring(placeId))
			local t={}
			for i=1,16 do t[i]=string.byte(dig,i) end
			t[7]=bit32.bor(bit32.band(t[7],0x0F),0x40)
			t[9]=bit32.bor(bit32.band(t[9],0x3F),0x80)
			firstBytes=string.char(Unpack(t))
		else
			local uuid={}
			for i=1,16 do uuid[i]=math.random(0,255) end
			uuid[7]=bit32.bor(bit32.band(uuid[7],0x0F),0x40)
			uuid[9]=bit32.bor(bit32.band(uuid[9],0x3F),0x80)
			firstBytes=""
			for i=1,16 do firstBytes=firstBytes..string.char(uuid[i]) end
		end
		local pid=placeId
		local placeIdBytes=""
		for _=1,8 do placeIdBytes=placeIdBytes..string.char(pid%256) pid=math.floor(pid/256) end
		local content=firstBytes..placeIdBytes
		local key="e4Yn8ckbCJtw2sv7qmbg"
		local sig=hmac.new(key,content,md5.sum)
		local final=base64.encode(sig..content)
		final=final:gsub("%+","-"):gsub("/","_")
		local pad=0
		final=final:gsub("=",function() pad=pad+1 return "" end)
		return final..tostring(pad)
	end
	local function getTeleportRemote()
		local RRS=SafeGetService("RobloxReplicatedStorage") or game:GetService("ReplicatedStorage"):FindFirstChild("RobloxReplicatedStorage")
		if not RRS then DoNotif("Missing RRS") return nil end
		local remote=RRS:FindFirstChild("ContactListIrisInviteTeleport")
		if not remote then DoNotif("Missing Teleport Remote") return nil end
		return remote
	end
	local function attemptTeleport(placeInfo,accessCode)
		local remote=getTeleportRemote()
		if not remote then return end
		local ok,err=pcall(function()
			remote:FireServer(placeInfo.PlaceId,"",accessCode)
		end)
		if ok then
			DoNotif(Format("Joining reserved server using code: %s",accessCode))
		else
			DoNotif("Teleport failed: "..tostring(err))
		end
	end
	local function copyCode(accessCode)
		if setclipboard then setclipboard(accessCode) DoNotif("Reserved server code copied to clipboard") return true end
		DoNotif("Clipboard unavailable")
		return false
	end
	local providedRaw=code and tostring(code) or nil
	if providedRaw and #providedRaw<1 then providedRaw=nil end
	local assetService=SafeGetService("AssetService")
	local places={}
	local fetchErr
	if assetService then
		local ok,pages=pcall(function() return assetService:GetGamePlacesAsync() end)
		if ok and pages then
			while true do
				for _,place in pages:GetCurrentPage() do
					places[#places+1]={Name=place.Name or "",PlaceId=place.PlaceId}
				end
				if pages.IsFinished then break end
				local advOk,advErr=pcall(function() pages:AdvanceToNextPageAsync() end)
				if not advOk then fetchErr=advErr break end
			end
		else
			fetchErr=pages
		end
	else
		fetchErr="AssetService unavailable"
	end
	local marketplace=SafeGetService("MarketplaceService")
	local currentPlaceName=Format("Place %d",game.PlaceId)
	if marketplace then
		local ok,info=pcall(function() return marketplace:GetProductInfo(game.PlaceId) end)
		if ok and info and info.Name and info.Name~="" then currentPlaceName=info.Name end
	end
	local seen,processed={},{}
	for _,info in ipairs(places) do
		if info.PlaceId and not seen[info.PlaceId] then
			seen[info.PlaceId]=true
			if not info.Name or info.Name=="" then info.Name=Format("Place %d",info.PlaceId) end
			processed[#processed+1]=info
		end
	end
	places=processed
	if not seen[game.PlaceId] then
		Insert(places,1,{Name=currentPlaceName,PlaceId=game.PlaceId})
	else
		for _,info in ipairs(places) do if info.PlaceId==game.PlaceId then info.Name=currentPlaceName break end end
	end
	if fetchErr then DoNotif("Some places may be missing: "..tostring(fetchErr)) end
	local function resolveName(info) return (info and info.Name and info.Name~="") and info.Name or Format("Place %d",info and info.PlaceId or game.PlaceId) end
	local function showOptions(selectedInfo)
		if not selectedInfo then DoNotif("Invalid place selection") return end
		local codeToUse
		if providedRaw then
			if isLikelyAccessCode(providedRaw) then
				codeToUse=providedRaw
			else
				codeToUse=GenerateAccessCode(selectedInfo.PlaceId,providedRaw)
			end
		else
			codeToUse=GenerateAccessCode(selectedInfo.PlaceId,nil)
		end
		local placeLabel=resolveName(selectedInfo)
		local description=Format("Place: %s\nPlaceId: %d\nCode: %s",placeLabel,selectedInfo.PlaceId,codeToUse)
		local buttons={}
		buttons[#buttons+1]={Text="Copy & Join",Callback=function() copyCode(codeToUse) attemptTeleport(selectedInfo,codeToUse) end}
		buttons[#buttons+1]={Text="Join (no copy)",Callback=function() attemptTeleport(selectedInfo,codeToUse) end}
		buttons[#buttons+1]={Text="Cancel",Callback=function() DoNotif("Cancelled reserved server request") end}
		Popup({Title="Reserved Server Ready",Description=description,Buttons=buttons})
	end
	local buttons={}
	for _,info in ipairs(places) do
		local label=Format("%s (%d)",resolveName(info),info.PlaceId)
		buttons[#buttons+1]={Text=label,Callback=function() showOptions(info) end}
	end
	buttons[#buttons+1]={Text="Cancel",Callback=function() DoNotif("Cancelled reserved server request") end}
	Popup({Title="Select Place",Description=providedRaw and "Choose the place for the reserved server code." or "Choose a place to create a reserved server.",Buttons=buttons})
end)

HumanModCons = {}

ToolLoopCons = {}

originalIO.stopEquipToolLoop=function(silent)
	if ToolLoopCons.loop then
		ToolLoopCons.loop:Disconnect()
		ToolLoopCons.loop = nil
	end

	if not silent then
		if ToolLoopCons.display then
			DoNotif(Format("Loop equip disabled for \"%s\".", ToolLoopCons.display), 2)
		else
			DoNotif("Loop equip disabled.", 2)
		end
	end

	ToolLoopCons.filter = nil
	ToolLoopCons.display = nil
	ToolLoopCons.warned = nil
end

originalIO.gatherPlayerTools=function()
	local char = getChar()
	local backpack = getBp()
	local tools = {}

	if not char and not backpack then
		return char, backpack, tools
	end

	local seen = {}
	local function considerTool(tool)
		if typeof(tool) == "Instance" and tool:IsA("Tool") and not seen[tool] then
			seen[tool] = true
			Insert(tools, tool)
		end
	end

	if backpack then
		for _, item in ipairs(backpack:GetChildren()) do
			considerTool(item)
		end
	end

	if char then
		for _, item in ipairs(char:GetChildren()) do
			considerTool(item)
		end
	end

	table.sort(tools, function(a, b)
		return Lower(a.Name) < Lower(b.Name)
	end)

	return char, backpack, tools
end

originalIO.safeToolImage=function(inst, props)
	for _, propName in ipairs(props) do
		local ok, value = pcall(function()
			return inst[propName]
		end)
		if ok then
			if typeof(value) == "number" then
				value = "rbxassetid://"..value
			end
			if typeof(value) == "string" and value ~= "" then
				return value
			end
		end
	end
end

originalIO.findToolImage=function(tool)
	if not tool then
		return nil
	end

	local direct = originalIO.safeToolImage(tool, { "TextureId", "TextureID", "Texture", "Image" })
	if direct then
		return direct
	end

	for _, desc in ipairs(tool:GetDescendants()) do
		local image
		if desc:IsA("Decal") or desc:IsA("Texture") then
			image = originalIO.safeToolImage(desc, { "Texture" })
		elseif desc:IsA("SpecialMesh") or desc:IsA("Mesh") or desc:IsA("DataModelMesh") then
			image = originalIO.safeToolImage(desc, { "TextureId" })
		elseif desc:IsA("MeshPart") or desc:IsA("UnionOperation") or desc:IsA("BasePart") then
			image = originalIO.safeToolImage(desc, { "TextureID", "TextureId" })
		elseif desc:IsA("ImageLabel") or desc:IsA("ImageButton") then
			image = originalIO.safeToolImage(desc, { "Image" })
		else
			image = originalIO.safeToolImage(desc, { "Texture", "TextureId", "TextureID", "Image" })
		end
		if image then
			return image
		end
	end

	return nil
end

originalIO.findToolByName=function(tools, query)
	if type(query) ~= "string" or query == "" then
		return nil
	end

	local lowerQuery = Lower(query)
	local partial
	for _, tool in ipairs(tools) do
		local lowerName = Lower(tool.Name)
		if lowerName == lowerQuery then
			return tool
		end
		if not partial and lowerName:find(lowerQuery, 1, true) then
			partial = tool
		end
	end
	return partial
end

originalIO.equipToolInstance=function(toolRef)
	if typeof(toolRef) ~= "Instance" or not toolRef:IsA("Tool") then
		DoNotif("Tool is no longer available.", 2)
		return false
	end

	local charNow = getChar()
	if not charNow then
		DoNotif("Could not find your character.", 2)
		return false
	end

	local target = toolRef
	if not (target and target.Parent) then
		local currentBp = getBp()
		if currentBp then
			local found = currentBp:FindFirstChild(toolRef.Name)
			if found and found:IsA("Tool") then
				target = found
			end
		end
	end

	if not target or not target:IsA("Tool") then
		DoNotif("Tool is no longer available.", 2)
		return false
	end

	local targetRef = target
	Defer(function()
		local charLater = getChar()
		if not charLater then
			return
		end

		local toolToEquip = targetRef
		if not (toolToEquip and toolToEquip.Parent) then
			local laterBackpack = getBp()
			if laterBackpack then
				local foundLater = laterBackpack:FindFirstChild(toolRef.Name)
				if foundLater and foundLater:IsA("Tool") then
					toolToEquip = foundLater
				end
			end
		end

		if toolToEquip and toolToEquip:IsA("Tool") and toolToEquip.Parent ~= charLater then
			toolToEquip.Parent = charLater
		end
	end)

	return true
end

originalIO.buildToolButtons=function(tools, action)
	local buttons = {}
	for _, toolRef in ipairs(tools) do
		local imageId = originalIO.findToolImage(toolRef) or ""
		local toolName = toolRef.Name
		buttons[#buttons + 1] = {
			Text = toolName,
			Image = imageId,
			Callback = function()
				action(toolRef)
			end
		}
	end
	buttons[#buttons + 1] = { Text = "Cancel", Callback = function() end }
	return buttons
end

originalIO.startLoopForTool=function(toolRef)
	if typeof(toolRef) ~= "Instance" or not toolRef:IsA("Tool") then
		DoNotif("Select a valid tool to loop equip.", 2)
		return
	end

	local displayName = toolRef.Name
	local filterLower = Lower(displayName)

	originalIO.stopEquipToolLoop(true)

	ToolLoopCons.filter = filterLower
	ToolLoopCons.display = displayName
	ToolLoopCons.warned = false

	originalIO.equipToolInstance(toolRef)

	ToolLoopCons.loop = RunService.Stepped:Connect(function()
		if not ToolLoopCons.filter then
			return
		end

		local currentChar = getChar()
		if not currentChar then
			return
		end

		local currentBackpack = getBp()
		if not currentBackpack then
			return
		end

		local function findMatch(container)
			for _, tool in ipairs(container:GetChildren()) do
				if tool:IsA("Tool") and Lower(tool.Name):find(filterLower, 1, true) then
					return tool
				end
			end
		end

		if findMatch(currentChar) then
			ToolLoopCons.warned = false
			return
		end

		local match = findMatch(currentBackpack)
		if match then
			ToolLoopCons.warned = false
			originalIO.equipToolInstance(match)
		elseif not ToolLoopCons.warned then
			DoNotif(Format("Loop equip: \"%s\" not found.", ToolLoopCons.display), 2)
			ToolLoopCons.warned = true
		end
	end)

	DoNotif(Format("Loop equip enabled for \"%s\". Use unloopequiptool to stop.", displayName), 3)
end

cmd.add({"edgejump", "ejump"}, {"edgejump (ejump)", "Automatically jumps when you get to the edge of an object"}, function()
	local Char = speaker.Character
	local Human = getHum()
	local currentState
	local previousState
	local lastCFrame

	local function edgeJump()
		if Char and Human then
			previousState = currentState
			currentState = Human:GetState()
			if previousState ~= currentState and currentState == Enum.HumanoidStateType.Freefall and previousState ~= Enum.HumanoidStateType.Jumping then
				local rootPart = getRoot(Char)
				rootPart.CFrame = lastCFrame
				rootPart.Velocity = Vector3.new(rootPart.Velocity.X, Human.JumpPower or Human.JumpHeight, rootPart.Velocity.Z)
			end
			lastCFrame = getRoot(Char).CFrame
		end
	end

	edgeJump()
	HumanModCons.ejLoop = (HumanModCons.ejLoop and HumanModCons.ejLoop:Disconnect() and false) or RunService.Stepped:Connect(edgeJump)
	HumanModCons.ejCA = (HumanModCons.ejCA and HumanModCons.ejCA:Disconnect() and false) or speaker.CharacterAdded:Connect(function(newChar)
		Char = newChar
		Human = getPlrHum(newChar)
		edgeJump()
		HumanModCons.ejLoop = (HumanModCons.ejLoop and HumanModCons.ejLoop:Disconnect() and false) or RunService.Stepped:Connect(edgeJump)
	end)
end)

cmd.add({"unedgejump", "noedgejump", "noejump", "unejump"}, {"unedgejump (noedgejump, noejump, unejump)", "Disables edgejump"}, function()
	if HumanModCons.ejLoop then
		HumanModCons.ejLoop:Disconnect()
		HumanModCons.ejLoop = nil
	end

	if HumanModCons.ejCA then
		HumanModCons.ejCA:Disconnect()
		HumanModCons.ejCA = nil
	end
end)

cmd.add({"equiptools","etools","equipt"},{"equiptools (etools,equipt)","Equips every tool in your inventory"},function()
	for i,v in pairs(LocalPlayer:FindFirstChildOfClass("Backpack"):GetChildren()) do
		if v:IsA("Tool") then
			v.Parent = getChar()
		end
	end
end)
cmd.add({"unequiptools"},{"unequiptools","Unequips every tool you are currently holding"},function()
	if getChar() then
		getChar():FindFirstChildOfClass('Humanoid'):UnequipTools()
	end
end)

cmd.add({"equiptool","etool"},{"equiptool (etool)","Equip a specific tool by name or selection"},function(...)
	local char, backpack, tools = originalIO.gatherPlayerTools()
	if not char or not backpack then
		DoNotif("Could not find your character or backpack.", 2)
		return
	end

	if #tools == 0 then
		DoNotif("You do not have any tools to equip.", 2)
		return
	end

	local rawInput = Concat({...}, " ")
	rawInput = (type(rawInput) == "string") and rawInput:gsub("^%s+", ""):gsub("%s+$", "") or ""

	if rawInput ~= "" then
		local match = originalIO.findToolByName(tools, rawInput)
		if match then
			originalIO.equipToolInstance(match)
		else
			DoNotif(Format("No tools matching '%s' found.", rawInput), 2)
		end
		return
	end

	if type(Popup) ~= "function" then
		DoNotif("Popup UI is unavailable in this session. Provide a tool name instead.", 3)
		return
	end

	local buttons = originalIO.buildToolButtons(tools, function(toolRef)
		originalIO.equipToolInstance(toolRef)
	end)

	Popup({
		Title = "Equip Tool",
		Description = "Select a tool to equip.",
		Buttons = buttons
	})
end)

cmd.add({"loopequiptool","lequiptool","loopet"},{"loopequiptool <tool name>","Keeps a specific tool equipped until disabled"},function(...)
	local char, backpack, tools = originalIO.gatherPlayerTools()
	if not char or not backpack then
		DoNotif("Could not find your character or backpack.", 2)
		return
	end

	if #tools == 0 then
		DoNotif("You do not have any tools to loop equip.", 2)
		return
	end

	local rawInput = Concat({...}, " ")
	rawInput = (type(rawInput) == "string") and rawInput:gsub("^%s+", ""):gsub("%s+$", "") or ""

	if rawInput ~= "" then
		local match = originalIO.findToolByName(tools, rawInput)
		if match then
			originalIO.startLoopForTool(match)
		else
			DoNotif(Format("No tools matching '%s' found.", rawInput), 2)
		end
		return
	end

	if type(Popup) ~= "function" then
		DoNotif("Popup UI is unavailable in this session. Provide a tool name instead.", 3)
		return
	end

	local buttons = originalIO.buildToolButtons(tools, function(toolRef)
		originalIO.startLoopForTool(toolRef)
	end)

	Popup({
		Title = "Loop Equip Tool",
		Description = "Select a tool to keep equipped.",
		Buttons = buttons
	})
end)

cmd.add({"unloopequiptool","unloopet","unlequiptool"},{"unloopequiptool","Stops the loop equip behaviour"},function()
	originalIO.stopEquipToolLoop()
end)

bangLoop = nil
bangAnim = nil
bangDied = nil
doBang = nil
BANGPARTS = {}

cmd.add({"bang", "fuck"}, {"bang <player> <number> (fuck)", "fucks the player by attaching to them"}, function(h, d)
	if bangLoop then
		bangLoop:Disconnect()
	end
	if doBang then
		doBang:Stop()
	end
	if bangAnim then
		bangAnim:Destroy()
	end
	if bangDied then
		bangDied:Disconnect()
	end
	for _, p in pairs(BANGPARTS) do
		p:Destroy()
	end
	BANGPARTS = {}

	local speed = d or 10
	local username = h
	local hasQuery = username and username ~= ""
	local targets = hasQuery and getPlr(username) or {}
	local plr = targets[1]
	if hasQuery and not plr then
		DoNotif("No targets found", 2)
	end

	bangAnim = InstanceNew("Animation")
	if not IsR15(Players.LocalPlayer) then
		bangAnim.AnimationId = "rbxassetid://148840371"
	else
		bangAnim.AnimationId = "rbxassetid://5918726674"
	end
	local hum = getHum()
	doBang = hum:LoadAnimation(bangAnim)
	doBang:Play(0.1, 1, 1)
	doBang:AdjustSpeed(speed)

	local bangplr = plr and plr.Name or nil
	bangDied = hum.Died:Connect(function()
		if bangLoop then
			bangLoop:Disconnect()
		end
		doBang:Stop()
		bangAnim:Destroy()
		if bangDied then
			bangDied:Disconnect()
		end
		for _, part in pairs(BANGPARTS) do
			part:Destroy()
		end
		BANGPARTS = {}
	end)

	local bangOffset = CFrame.new(0, 0, 1.1)
	if bangplr then
		bangLoop = RunService.Stepped:Connect(function()
			NACaller(function()
				local targetPlayer = Players:FindFirstChild(bangplr)
				if not targetPlayer or not targetPlayer.Character then
					if bangLoop then bangLoop:Disconnect() bangLoop = nil end
					return
				end
				local targetRoot = getRoot(targetPlayer.Character)
				local localChar = getChar()
				local localRoot = localChar and getRoot(localChar)
				if not (targetRoot and localRoot) then return end
				localRoot.CFrame = targetRoot.CFrame * bangOffset
				localRoot.AssemblyLinearVelocity = Vector3.new()
				localRoot.AssemblyAngularVelocity = Vector3.new()
			end)
		end)
	end
end, true)

cmd.add({"unbang", "unfuck"}, {"unbang (unfuck)", "Unbangs the player"}, function()
	if bangLoop then
		bangLoop:Disconnect()
	end
	if doBang then
		doBang:Stop()
	end
	if bangAnim then
		bangAnim:Destroy()
	end
	if bangDied then
		bangDied:Disconnect()
	end
	for _, p in pairs(BANGPARTS) do
		p:Destroy()
	end
	BANGPARTS = {}
end)

carpetLoop = nil
carpetAnim = nil
carpetTrack = nil
carpetDied = nil
CARPETPARTS = {}
originalIO.stopCarpet=function()
	if carpetLoop then
		carpetLoop:Disconnect()
		carpetLoop = nil
	end
	if carpetDied then
		carpetDied:Disconnect()
		carpetDied = nil
	end
	if carpetTrack then
		carpetTrack:Stop()
		carpetTrack = nil
	end
	if carpetAnim then
		carpetAnim:Destroy()
		carpetAnim = nil
	end
	for _, part in pairs(CARPETPARTS) do
		part:Destroy()
	end
	CARPETPARTS = {}
	local char = getChar()
	local root = char and getRoot(char)
	if root then
		root.AssemblyLinearVelocity = Vector3.new()
		root.AssemblyAngularVelocity = Vector3.new()
	end
	local hum = getHum(char)
	if hum then
		hum.Sit = false
		hum.PlatformStand = false
	end
end

cmd.add({"carpet"}, {"carpet <player>", "Be someone's carpet"}, function(username)
	if not IsR6() then
		DoNotif("This command requires the R6 rig type", 3)
		return
	end

	originalIO.stopCarpet()

	local hasQuery = username and username ~= ""
	local targets = hasQuery and getPlr(username) or {}
	if hasQuery and #targets == 0 then
		DoNotif("No targets found", 2)
	end

	local character = getChar()
	local humanoid = getHum(character)
	local root = character and getRoot(character)
	if not (character and humanoid and root) then
		return DoNotif("Your character is unavailable.", 3)
	end

	local targetPlayer = targets[1]
	local targetRoot = targetPlayer and targetPlayer.Character and getRoot(targetPlayer.Character)
	if hasQuery and targetPlayer and not targetRoot then
		return DoNotif("Target has no character or root.", 3)
	end

	carpetAnim = InstanceNew("Animation")
	carpetAnim.AnimationId = "rbxassetid://282574440"
	carpetTrack = humanoid:LoadAnimation(carpetAnim)
	carpetTrack:Play(0.1, 1, 1)

	carpetDied = humanoid.Died:Connect(originalIO.stopCarpet)
	if targetPlayer and targetRoot then
		local targetName = targetPlayer.Name
		carpetLoop = RunService.Heartbeat:Connect(function()
			NACaller(function()
				local tgt = Players:FindFirstChild(targetName)
				local tgtChar = tgt and tgt.Character
				if not tgtChar then
					originalIO.stopCarpet()
					return
				end
				local tgtRoot = getRoot(tgtChar)
				local localChar = getChar()
				local localRoot = localChar and getRoot(localChar)
				if tgtRoot and localRoot then
					localRoot.CFrame = tgtRoot.CFrame
					localRoot.AssemblyLinearVelocity = Vector3.new()
					localRoot.AssemblyAngularVelocity = Vector3.new()
				end
			end)
		end)
	end
end, true)

cmd.add({"uncarpet", "nocarpet"}, {"uncarpet (nocarpet)", "Undoes carpet"}, function()
	originalIO.stopCarpet()
end)

climbPart = nil
climbLoop = nil
originalIO.stopClimb=function()
	if climbLoop then
		climbLoop:Disconnect()
		climbLoop = nil
	end
	if climbPart then
		climbPart:Destroy()
		climbPart = nil
	end
end

cmd.add({"climb"}, {"climb", "Allows you to climb while in air"}, function()
	originalIO.stopClimb()

	local char = getChar()
	local root = char and getRoot(char)
	if not (char and root) then
		return DoNotif and DoNotif("Your character is unavailable.", 3) or nil
	end

	climbPart = InstanceNew("TrussPart")
	climbPart.Size = Vector3.new(2, 10, 2)
	climbPart.Transparency = 1
	climbPart.CanCollide = true
	climbPart.Anchored = true
	climbPart.Name = "NA_ClimbPart"
	climbPart.Parent = workspace

	climbLoop = RunService.Heartbeat:Connect(function()
		NACaller(function()
			if not climbPart or not climbPart.Parent then
				return originalIO.stopClimb()
			end
			local c = getChar()
			local r = c and getRoot(c)
			if not r then
				return originalIO.stopClimb()
			end
			climbPart.CFrame = r.CFrame * CFrame.new(0, 0, -1.5)
		end)
	end)
end, true)

cmd.add({"unclimb"}, {"unclimb", "Disables climb"}, function()
	originalIO.stopClimb()
end)

inversebangLoop = nil
inversebangAnim = nil
inversebangAnim2 = nil
inversebangDied = nil
doInversebang = nil
doInversebang2 = nil
INVERSEBANGPARTS = {}

function stopInversebang()
	if inversebangLoop then
		inversebangLoop:Disconnect()
		inversebangLoop = nil
	end
	if inversebangDied then
		inversebangDied:Disconnect()
		inversebangDied = nil
	end
	if doInversebang then
		doInversebang:Stop()
		doInversebang = nil
	end
	if doInversebang2 then
		doInversebang2:Stop()
		doInversebang2 = nil
	end
	if inversebangAnim then
		inversebangAnim:Destroy()
		inversebangAnim = nil
	end
	if inversebangAnim2 then
		inversebangAnim2:Destroy()
		inversebangAnim2 = nil
	end
	for _,p in pairs(INVERSEBANGPARTS) do
		p:Destroy()
	end
	INVERSEBANGPARTS = {}
end

cmd.add({"inversebang","ibang","inverseb"},{"inversebang <player> <number>","you're the one getting fucked today ;)"},function(h,d)
	stopInversebang()

	local speed = d or 10
	local hasQuery = h and h ~= ""
	local targets = hasQuery and getPlr(h) or {}
	local plr = targets[1]
	if hasQuery and not plr then
		DoNotif("No targets found", 2)
	end
	local bangplr = plr and plr.Name or nil

	inversebangAnim = InstanceNew("Animation")
	local isR15 = IsR15(Players.LocalPlayer)
	if not isR15 then
		inversebangAnim.AnimationId = "rbxassetid://189854234"
		inversebangAnim2 = InstanceNew("Animation")
		inversebangAnim2.AnimationId = "rbxassetid://106772613"
	else
		inversebangAnim.AnimationId = "rbxassetid://10714360343"
		inversebangAnim2 = nil
	end

	local hum = getHum()
	doInversebang = hum:LoadAnimation(inversebangAnim)
	doInversebang:Play(0.1,1,1)
	doInversebang:AdjustSpeed(speed)
	if not isR15 and inversebangAnim2 then
		doInversebang2 = hum:LoadAnimation(inversebangAnim2)
		doInversebang2:Play(0.1,1,1)
		doInversebang2:AdjustSpeed(speed)
	end

	inversebangDied = hum.Died:Connect(stopInversebang)

	if bangplr then
		local lastStep = 0
		inversebangLoop = RunService.Heartbeat:Connect(function()
			if tick() - lastStep < 0.1 then return end
			lastStep = tick()
			NACaller(function()
				local targetPlayer = Players:FindFirstChild(bangplr)
				local targetCharacter = targetPlayer and targetPlayer.Character
				local localCharacter = getChar()
				if not targetCharacter or not localCharacter then
					stopInversebang()
					return
				end

				local targetHRP = getRoot(targetCharacter)
				local localHRP = getRoot(localCharacter)
				if not (targetHRP and localHRP) then return end

				local forwardCFrame = targetHRP.CFrame * CFrame.new(0,0,-2.5)
				local backwardCFrame = targetHRP.CFrame * CFrame.new(0,0,-1.3)
				local tweenForward = TweenService:Create(localHRP,TweenInfo.new(0.15,Enum.EasingStyle.Linear,Enum.EasingDirection.Out),{CFrame=forwardCFrame})
				tweenForward:Play()
				tweenForward.Completed:Wait()
				local tweenBackward = TweenService:Create(localHRP,TweenInfo.new(0.15,Enum.EasingStyle.Linear,Enum.EasingDirection.Out),{CFrame=backwardCFrame})
				tweenBackward:Play()
				tweenBackward.Completed:Wait()
				localHRP.AssemblyLinearVelocity = Vector3.new()
				localHRP.AssemblyAngularVelocity = Vector3.new()
			end)
		end)
	end
end,true)

cmd.add({"uninversebang","unibang","uninverseb"},{"uninversebang","no more fun"},function()
	stopInversebang()
end)

sussyID = "rbxassetid://106772613"
susTrack, susCONN = nil, nil

cmd.add({"suslay", "laysus"}, {"suslay (laysus)", "Lay down in a suspicious way"}, function()
	if not IsR6() then return DoNotif("R6 only") end

	if susTrack then
		susTrack:Stop()
		susTrack = nil
	end

	if susCONN then
		susCONN:Disconnect()
		susCONN = nil
	end

	local hum = getHum()
	local root = hum.RootPart

	hum.Sit = true
	Wait(0.1)
	root.CFrame=root.CFrame * CFrame.Angles(math.pi * 0.5, 0, 0)

	for _, a in ipairs(hum:GetPlayingAnimationTracks()) do
		a:Stop()
	end

	local anim = InstanceNew("Animation")
	anim.AnimationId = sussyID
	susTrack = hum:LoadAnimation(anim)
	susTrack:Play()

	susCONN = hum:GetPropertyChangedSignal("Jump"):Connect(function()
		if susTrack then
			susTrack:Stop()
			susTrack = nil
		end
		if susCONN then
			susCONN:Disconnect()
			susCONN = nil
		end
	end)
end)

cmd.add({"unsuslay"}, {"unsuslay", "Stand up from the sussy lay"}, function()
	getHum():ChangeState(Enum.HumanoidStateType.Jumping)

	if susTrack then
		susTrack:Stop()
		susTrack = nil
	end

	if susCONN then
		susCONN:Disconnect()
		susCONN = nil
	end
end)

cmd.add({"jerk", "jork"}, {"jerk (jork)", "jorking it"}, function()
	local humanoid = getHum()
	local backpack = getBp()
	if not humanoid or not backpack then return end

	local tool = InstanceNew("Tool")
	tool.Name = "Jerk"
	tool.ToolTip = "oh yes i am feeling it COMING OUT AHHHHHHHHHHHHHHHHHHHHH"
	tool.RequiresHandle = false
	tool.Parent = backpack

	local jorkin = false
	local track = nil

	local function stopTomfoolery()
		jorkin = false
		if track then
			track:Stop()
			track = nil
		end
	end

	tool.Equipped:Connect(function() jorkin = true end)
	tool.Unequipped:Connect(stopTomfoolery)
	humanoid.Died:Connect(stopTomfoolery)

	while Wait() do
		if not jorkin then continue end

		if not track then
			local anim = InstanceNew("Animation")
			anim.AnimationId = not IsR15() and "rbxassetid://72042024" or "rbxassetid://698251653"
			track = humanoid:LoadAnimation(anim)
		end

		track:Play()
		track:AdjustSpeed(IsR15() and 0.7 or 0.65)
		track.TimePosition = 0.6
		Wait(0.2)
		while track and track.TimePosition < (not IsR15() and 0.65 or 0.7) do Wait(0.2) end
		if track then
			track:Stop()
			track = nil
		end
	end
end)

huggiePARTS = {}
hugUI = nil
currentHugTracks = {}
currentHugTarget = nil
hugFromFront = false
hugModeEnabled = false

cmd.add({"hug", "clickhug"}, {"hug (clickhug)", "huggies time (click on a target to hug)"}, function()
	if IsR6() then
		local mouse = LocalPlayer:GetMouse()

		NAlib.disconnect("hug_toggle")
		NAlib.disconnect("hug_side")
		NAlib.disconnect("hug_click")
		NAlib.disconnect("hug_plat")

		for _, track in pairs(currentHugTracks) do NACaller(function() track:Stop() end) end
		currentHugTracks = {}

		if hugUI then hugUI:Destroy() end
		hugFromFront = false
		currentHugTarget = nil
		for _, part in pairs(huggiePARTS) do part:Destroy() end
		huggiePARTS = {}

		hugUI = InstanceNew("ScreenGui")
		hugUI.Name = "HugModeUI"
		NaProtectUI(hugUI)

		local toggleHugButton = InstanceNew("TextButton")
		toggleHugButton.AnchorPoint = Vector2.new(0.5, 0)
		toggleHugButton.Size = UDim2.new(0, 150, 0, 50)
		toggleHugButton.Position = UDim2.new(0.4, 0, 0.1, 0)
		toggleHugButton.Text = "Hug Mode: OFF"
		toggleHugButton.TextSize = 14
		toggleHugButton.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
		toggleHugButton.TextColor3 = Color3.fromRGB(255, 255, 255)
		toggleHugButton.Parent = hugUI

		local sideToggleButton = InstanceNew("TextButton")
		sideToggleButton.AnchorPoint = Vector2.new(0.5, 0)
		sideToggleButton.Size = UDim2.new(0, 150, 0, 50)
		sideToggleButton.Position = UDim2.new(0.6, 0, 0.1, 0)
		sideToggleButton.Text = "Hug Side: Back"
		sideToggleButton.TextSize = 14
		sideToggleButton.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
		sideToggleButton.TextColor3 = Color3.fromRGB(255, 255, 255)
		sideToggleButton.Parent = hugUI

		local uiCorner = InstanceNew("UICorner")
		uiCorner.CornerRadius = UDim.new(0, 8)
		uiCorner.Parent = toggleHugButton

		local sideUICorner = InstanceNew("UICorner")
		sideUICorner.CornerRadius = UDim.new(0, 8)
		sideUICorner.Parent = sideToggleButton

		NAgui.draggerV2(toggleHugButton)
		NAgui.draggerV2(sideToggleButton)

		hugModeEnabled = false

		local function performHug(targetCharacter)
			currentHugTarget = targetCharacter

			local offsetDistance = 1.5
			local targetHRP = getRoot(targetCharacter)
			local localCharacter = LocalPlayer.Character
			if not localCharacter then return end
			local localHRP = getRoot(localCharacter)
			if targetHRP and localHRP then
				local offset = (hugFromFront and (targetHRP.CFrame.LookVector * offsetDistance)) or (-(targetHRP.CFrame.LookVector * offsetDistance))
				local initialHugPos = targetHRP.Position + offset
				localHRP.CFrame = CFrame.new(initialHugPos, targetHRP.Position)
				local humanoid = getPlrHum(localCharacter)
				if humanoid then
					local anim1 = InstanceNew("Animation")
					anim1.AnimationId = "rbxassetid://283545583"
					local track1 = humanoid:LoadAnimation(anim1)
					local anim2 = InstanceNew("Animation")
					anim2.AnimationId = "rbxassetid://225975820"
					local track2 = humanoid:LoadAnimation(anim2)
					Insert(currentHugTracks, track1)
					Insert(currentHugTracks, track2)
					track1:Play()
					track2:Play()

					if #huggiePARTS == 0 then
						local thick = 0.2
						local halfWidth = 2
						local halfDepth = 2
						local halfHeight = 3
						local walls = {
							{offset = CFrame.new(0, 0, halfDepth + thick/500), size = Vector3.new(4, 6, thick)},
							{offset = CFrame.new(0, 0, -(halfDepth + thick/500)), size = Vector3.new(4, 6, thick)},
							{offset = CFrame.new(halfWidth + thick/500, 0, 0), size = Vector3.new(thick, 6, 4)},
							{offset = CFrame.new(-(halfWidth + thick/500), 0, 0), size = Vector3.new(thick, 6, 4)},
							{offset = CFrame.new(0, halfHeight + thick/500, 0), size = Vector3.new(4, thick, 4)},
							{offset = CFrame.new(0, -(halfHeight + thick/500), 0), size = Vector3.new(4, thick, 4)}
						}
						for i, wall in ipairs(walls) do
							local part = InstanceNew("Part")
							part.Size = wall.size
							part.Anchored = true
							part.CanCollide = true
							part.Transparency = 1
							part.Parent = workspace
							Insert(huggiePARTS, part)
						end
						NAlib.connect("hug_plat", RunService.Stepped:Connect(function()
							local charRoot = getRoot(LocalPlayer.Character)
							if charRoot then
								for i, wall in ipairs(walls) do
									huggiePARTS[i].CFrame = charRoot.CFrame * wall.offset
								end
							end
						end))
					end

					SpawnCall(function()
						while hugModeEnabled and targetCharacter and getRoot(targetCharacter) and (currentHugTarget == targetCharacter) do
							targetHRP = getRoot(targetCharacter)
							offset = (hugFromFront and (targetHRP.CFrame.LookVector * offsetDistance)) or (-(targetHRP.CFrame.LookVector * offsetDistance))
							local newHugPos = targetHRP.Position + offset
							if localHRP then
								localHRP.CFrame = CFrame.new(newHugPos, targetHRP.Position)
							end
							Wait()
						end
					end)
				end
			end
		end

		NAlib.connect("hug_toggle", MouseButtonFix(toggleHugButton, function()
			hugModeEnabled = not hugModeEnabled
			if hugModeEnabled then
				toggleHugButton.Text = "Hug Mode: ON"
			else
				toggleHugButton.Text = "Hug Mode: OFF"
				for _, track in pairs(currentHugTracks) do NACaller(function() track:Stop() end) end
				currentHugTracks = {}
				currentHugTarget = nil
				for _, part in pairs(huggiePARTS) do part:Destroy() end
				huggiePARTS = {}
				NAlib.disconnect("hug_plat")
			end
		end))

		NAlib.connect("hug_side", MouseButtonFix(sideToggleButton, function()
			hugFromFront = not hugFromFront
			sideToggleButton.Text = (hugFromFront and "Hug Side: Front") or "Hug Side: Back"
		end))

		NAlib.connect("hug_click", LocalPlayer:GetMouse().Button1Down:Connect(function()
			if not hugModeEnabled then return end
			local target = mouse.Target
			if target and target.Parent then
				local targetPlayer = Players:GetPlayerFromCharacter(target.Parent)
				if targetPlayer and targetPlayer ~= LocalPlayer and targetPlayer.Character then
					performHug(targetPlayer.Character)
				end
			end
		end))
	else
		DoNotif("command requires R6")
	end
end)

cmd.add({"unhug"}, {"unhug", "no huggies :("}, function()
	NAlib.disconnect("hug_toggle")
	NAlib.disconnect("hug_side")
	NAlib.disconnect("hug_click")
	NAlib.disconnect("hug_plat")

	for _, track in pairs(currentHugTracks) do NACaller(function() track:Stop() end) end
	currentHugTracks = {}
	currentHugTarget = nil
	hugFromFront = false
	hugModeEnabled = false
	for _, part in pairs(huggiePARTS) do part:Destroy() end
	huggiePARTS = {}
	if hugUI then hugUI:Destroy() hugUI = nil end
end)

glueloop = {}

cmd.add({"glue","loopgoto","lgoto"},{"glue <player>","Loop teleport to a player"},function(...)
	local input = (...)
	local players = getPlr(input)
	for _, p in next, players do
		local name = p.Name
		if glueloop[name] then glueloop[name]:Disconnect() end
		glueloop[name] = RunService.RenderStepped:Connect(function()
			local target = Players:FindFirstChild(name)
			if target and target.Character then
				getRoot(getChar()).CFrame=getRoot(target.Character).CFrame
			end
		end)
	end
end,true)

cmd.add({"unglue","unloopgoto","noloopgoto"},{"unglue","Stops teleporting you to a player"},function()
	for _, conn in pairs(glueloop) do conn:Disconnect() end
	glueloop = {}
end)

glueBACKER = {}

cmd.add({"glueback","loopbehind","lbehind"},{"glueback <player>","Loop teleport behind a player"},function(...)
	local input   = (...)
	local targets = getPlr(input)
	for _,target in next,targets do
		local name = target.Name
		if glueBACKER[name] then
			glueBACKER[name]:Disconnect()
			glueBACKER[name] = nil
		end
		glueBACKER[name] = RunService.RenderStepped:Connect(function()
			local tp = Players:FindFirstChild(name)
			if not tp or not tp.Character then return end
			getRoot(getChar()).CFrame=getRoot(tp.Character).CFrame*CFrame.new(0,0,3)
		end)
	end
end,true)

cmd.add({"unglueback","unloopbehind","unlbehind"},{"unglueback","Stops teleporting you to a player"},function()
	for _,conn in pairs(glueBACKER) do conn:Disconnect() end
	glueBACKER = {}
end)

cmd.add({"spook", "scare"}, {"spook <player> (scare)", "Teleports next to a player for a few seconds"}, function(...)
	local username = (...)
	local targets = getPlr(username)
	for _, plr in next, targets do
		local char = getChar()
		local root = getRoot(char)
		local oldCF = root.CFrame
		local distancepl = 2
		if getPlrHum(plr) then
			local targetRoot = getRoot(plr.Character)
			if targetRoot then
				root.CFrame = targetRoot.CFrame + targetRoot.CFrame.LookVector * distancepl
				root.CFrame = CFrame.new(root.Position, targetRoot.Position)
				Wait(0.5)
				root.CFrame = oldCF
			end
		end
	end
end, true)

loopspook = false

cmd.add({"loopspook","loopscare"},{"loopspook <player>","Teleports next to a player repeatedly"},function(...)
	local input = (...)
	local names = {}
	for _, p in ipairs(getPlr(input)) do
		names[#names+1] = p.Name
	end
	loopspook = true

	SpawnCall(function()
		while loopspook do
			for _, name in ipairs(names) do
				local target = Players:FindFirstChild(name)
				if target and getPlrHum(target) then
					local lc = getChar()
					local lr = getRoot(lc)
					local tr = getRoot(target.Character)
					if lr and tr then
						local old = lr.CFrame
						lr.CFrame = tr.CFrame + tr.CFrame.LookVector * 2
						lr.CFrame = CFrame.new(lr.Position, tr.Position)
						Wait(0.5)
						lr.CFrame = old
					end
				end
			end
			Wait(0.3)
		end
	end)
end,true)

cmd.add({"unloopspook","unloopscare"},{"unloopspook","Stops the loopspook command"},function()
	loopspook = false
end)

Airwalker, awPart = nil, nil
NAStuff.airwalk = {
	Vars = {
		keybinds = {
			Increase = Enum.KeyCode.E,
			Decrease = Enum.KeyCode.Q,
		},
		decrease = false,
		increase = false,
		offset = 0,
		isTyping = false,
	},
	connections = {},
	guis = {},
}

cmd.add({"airwalk", "float", "aw"}, {"airwalk (float, aw)", "Press space to go up, unairwalk to stop"}, function()
	DebugNotif(IsOnMobile and "Airwalk: ON" or "Airwalk: ON (Q And E)")
	if Airwalker then Airwalker:Disconnect() Airwalker = nil end
	if awPart then awPart:Destroy() awPart = nil end

	function createButton(parent, text, position, callbackDown, callbackUp)
		local button = InstanceNew("TextButton")
		button.Parent = parent
		button.BackgroundColor3 = Color3.fromRGB(45, 45, 45)
		button.BackgroundTransparency = 0
		button.Position = position
		button.Size = UDim2.new(0.05, 0, 0.1, 0)
		button.Font = Enum.Font.SourceSansBold
		button.Text = text
		button.TextColor3 = Color3.fromRGB(255, 255, 255)
		button.TextSize = 18
		button.TextScaled = true
		button.AutoButtonColor = false

		local corner = InstanceNew("UICorner", button)
		corner.CornerRadius = UDim.new(0.2, 0)

		local stroke = InstanceNew("UIStroke", button)
		stroke.Color = Color3.fromRGB(255, 255, 255)
		stroke.Thickness = 2

		local hoverEffect = function(isHovering)
			button.BackgroundColor3 = isHovering and Color3.fromRGB(70, 70, 70) or Color3.fromRGB(45, 45, 45)
		end

		button.MouseEnter:Connect(function() hoverEffect(true) end)
		button.MouseLeave:Connect(function() hoverEffect(false) end)
		button.MouseButton1Down:Connect(callbackDown)
		button.MouseButton1Up:Connect(callbackUp)
		NAgui.draggerV2(button)

		return button
	end

	if IsOnMobile then
		local guiDown = InstanceNew("ScreenGui")
		NaProtectUI(guiDown)
		guiDown.ResetOnSpawn = false
		NAStuff.airwalk.guis.down = guiDown
		createButton(guiDown, "DOWN", UDim2.new(0.9, 0, 0.7, 0), function() NAStuff.airwalk.Vars.decrease = true end, function() NAStuff.airwalk.Vars.decrease = false end)

		local guiUp = InstanceNew("ScreenGui")
		NaProtectUI(guiUp)
		guiUp.ResetOnSpawn = false
		NAStuff.airwalk.guis.up = guiUp
		createButton(guiUp, "UP", UDim2.new(0.9, 0, 0.5, 0), function() NAStuff.airwalk.Vars.increase = true end, function() NAStuff.airwalk.Vars.increase = false end)
	else
		NAStuff.airwalk.connections.focused = UserInputService.TextBoxFocused:Connect(function() NAStuff.airwalk.Vars.isTyping = true end)
		NAStuff.airwalk.connections.released = UserInputService.TextBoxFocusReleased:Connect(function() NAStuff.airwalk.Vars.isTyping = false end)

		NAStuff.airwalk.connections.inputBegan = uis.InputBegan:Connect(function(input, gpe)
			if gpe or NAStuff.airwalk.Vars.isTyping then return end
			if input.KeyCode == NAStuff.airwalk.Vars.keybinds.Increase then NAStuff.airwalk.Vars.increase = true end
			if input.KeyCode == NAStuff.airwalk.Vars.keybinds.Decrease then NAStuff.airwalk.Vars.decrease = true end
		end)
		NAStuff.airwalk.connections.inputEnded = uis.InputEnded:Connect(function(input, gpe)
			if gpe then return end
			if input.KeyCode == NAStuff.airwalk.Vars.keybinds.Increase then NAStuff.airwalk.Vars.increase = false end
			if input.KeyCode == NAStuff.airwalk.Vars.keybinds.Decrease then NAStuff.airwalk.Vars.decrease = false end
		end)
	end

	awPart = InstanceNew("Part", workspace)
	awPart.Size = Vector3.new(10, 2, 10)
	awPart.Transparency = 1
	awPart.Anchored = true
	awPart.CanCollide = true

	Airwalker = RunService.RenderStepped:Connect(function()
		if not awPart then Airwalker:Disconnect() return end

		local char = getChar()
		local root = getRoot(char)
		local hum = getHum(char)
		if not (char and root and hum) then return end

		local hrpY = root.Position.Y
		local hrpHalf = ((NAlib.isProperty(root, "Size") and root.Size.Y) or 2) * 0.5
		local partHalf = awPart.Size.Y * 0.5

		local feetFromRoot
		if IsR6() then
			feetFromRoot = hrpHalf + 2
			if hum.HipHeight and hum.HipHeight > 0 then
				feetFromRoot = hrpHalf + hum.HipHeight
			end
		else
			feetFromRoot = hrpHalf + (hum.HipHeight or 2)
		end

		local baseOffset = feetFromRoot + partHalf
		local delta = (NAStuff.airwalk.Vars.decrease and 1.5) or (NAStuff.airwalk.Vars.increase and -1.5) or 0
		NAStuff.airwalk.Vars.offset = math.max(0, baseOffset + delta)

		awPart.CFrame = CFrame.new(root.Position.X, hrpY - NAStuff.airwalk.Vars.offset, root.Position.Z)
	end)
end)

cmd.add({"unairwalk", "unfloat", "unaw"}, {"unairwalk (unfloat, unaw)", "Stops the airwalk command"}, function()
	if Airwalker then Airwalker:Disconnect() Airwalker = nil end
	if awPart then awPart:Destroy() awPart = nil end
	for _, conn in pairs(NAStuff.airwalk.connections) do
		if conn then conn:Disconnect() end
	end
	NAStuff.airwalk.connections = {}
	for _, gui in pairs(NAStuff.airwalk.guis) do
		if gui then gui:Destroy() end
	end
	NAStuff.airwalk.guis = {}
	DebugNotif("Airwalk: OFF")
end)

bringc = {}

cmd.add({"cbring", "clientbring", "clientb"}, {"cbring <player>", "Brings the player once on your client"}, function(...)
	local username = (...)
	local target = getPlr(username)
	if #target == 0 then return end
	local localChar = getChar()
	if not localChar then return end
	local localRoot = getRoot(localChar)
	if not localRoot then return end
	for _, plr in next, target do
		local targetChar = getPlrChar(plr)
		if targetChar then
			local targetRoot = getRoot(targetChar)
			if targetRoot then
				targetRoot.CFrame = localRoot.CFrame + localRoot.CFrame.LookVector * 3
			end
		end
	end
end, true)

cmd.add({"loopcbring", "loppclientb", "loopclientbring", "lcbring", "lclientb"}, {"loopcbring <player>", "Continuously brings the player on your client"}, function(...)
	local username = (...)
	local target = getPlr(username)
	if #target == 0 then return end
	for _, conn in ipairs(bringc) do
		conn:Disconnect()
	end
	bringc = {}
	if NAlib.isConnected("cbnoclip") then
		NAlib.disconnect("cbnoclip")
	end
	NAlib.connect("cbnoclip", RunService.RenderStepped:Connect(function()
		local char = getChar()
		if not char then return end
		for _, descendant in pairs(char:GetDescendants()) do
			if descendant:IsA("BasePart") then
				descendant.CanCollide = false
			end
		end
	end))
	for _, plr in next, target do
		if not plr then return end
		local conn = RunService.RenderStepped:Connect(function()
			local targetChar = getPlrChar(plr)
			local localChar = getChar()
			if targetChar and localChar then
				local targetRoot = getRoot(targetChar)
				local localRoot = getRoot(localChar)
				if targetRoot and localRoot then
					targetRoot.CFrame = localRoot.CFrame + localRoot.CFrame.LookVector * 3
				end
			end
		end)
		Insert(bringc, conn)
	end
end, true)

cmd.add({"unloopcbring", "unloopcientb", "unlcbring", "unlclientb", "uncbring", "unclientb"}, {"unloopcbring", "Disable looped client bring"}, function()
	for _, conn in ipairs(bringc) do
		conn:Disconnect()
	end
	bringc = {}
	if NAlib.isConnected("cbnoclip") then
		NAlib.disconnect("cbnoclip")
	end
end)

cmd.add({"mute", "muteboombox"}, {"mute <player> (muteboombox)", "Mutes the player's boombox"}, function(...)
	local uuuu = ...
	local pp = getPlr(uuuu)
	if #pp == 0 then return end

	local function NONOSOUND(container)
		for _, descendant in ipairs(container:GetDescendants()) do
			if descendant:IsA("Sound") and descendant.Playing then
				descendant.Playing = false
			end
		end
	end

	for _, plr in ipairs(pp) do
		if plr and plr.Character then
			NONOSOUND(plr.Character)
		end

		local BK = plr:FindFirstChildOfClass("Backpack")
		if BK then
			NONOSOUND(BK)
		end
	end
end, true)

TPWalk = false

cmd.add({"tpwalk", "tpwalk"}, {"tpwalk <number>", "More undetectable walkspeed script"}, function(...)
	if TPWalk then
		TPWalk = false
		NAlib.disconnect("TPWalkingConnection")
	end

	TPWalk = true
	local Speed = ...

	NAlib.connect("TPWalkingConnection", RunService.Stepped:Connect(function(_, deltaTime)
		if TPWalk then
			local humanoid = getHum()
			if humanoid and humanoid.MoveDirection.Magnitude > 0 then
				local moveDirection = humanoid.MoveDirection
				local translation = moveDirection * (Speed or 1) * deltaTime * 10
				getChar():TranslateBy(translation)
			end
		end
	end))
end, true)

cmd.add({"untpwalk"}, {"untpwalk", "Stops the tpwalk command"}, function()
	TPWalk = false
	NAlib.disconnect("TPWalkingConnection")
end)

muteLOOP = {}

cmd.add({"loopmute", "loopmuteboombox"}, {"loopmute <player> (loopmuteboombox)", "Loop mutes the player's boombox"}, function(...)
	local u = ...
	local pls = getPlr(u)
	if #pls == 0 then return end

	local function mute(p)
		if p and p.Character then
			for _, d in ipairs(p.Character:GetDescendants()) do
				if d:IsA("Sound") and d.Playing then
					d.Playing = false
				end
			end
		end
		local bp = p:FindFirstChildOfClass("Backpack")
		if bp then
			for _, d in ipairs(bp:GetDescendants()) do
				if d:IsA("Sound") and d.Playing then
					d.Playing = false
				end
			end
		end
	end

	for _, p in ipairs(pls) do
		local id = p.UserId
		if not muteLOOP[id] then
			muteLOOP[id] = Spawn(function()
				while p and p.Parent do
					mute(p)
					Wait(1)
				end
				muteLOOP[id] = nil
			end)
			DebugNotif("Loopmuted "..p.Name)
		else
			DebugNotif(p.Name.." already loopmuted")
		end
	end
end, true)

cmd.add({"unloopmute", "unloopmuteboombox"}, {"unloopmute <player> (unloopmuteboombox)", "Unloop mutes the player's boombox"}, function(...)
	local u = ...
	local pls = getPlr(u)
	if #pls == 0 then return end

	for _, p in ipairs(pls) do
		local id = p.UserId
		local t = muteLOOP[id]
		if t then
			coroutine.close(t)
			muteLOOP[id] = nil
			DebugNotif("Unloopmuted "..p.Name)
		else
			DebugNotif(p.Name.." not loopmuted")
		end
	end
end, true)

cmd.add({"getmass"}, {"getmass <player>", "Get your mass"}, function(...)
	local target = getPlr(...)
	for _, plr in next, target do
		local char = plr.Character or getPlrChar(plr)
		if char then
			local root = getRoot(char)
			if root then
				local mass = root.AssemblyMass
				DoNotif(nameChecker(plr).."'s mass is "..mass)
			end
		end
		Wait()
	end
end, true)

cmd.add({"copyposition", "copypos", "cpos"}, {"copyposition <player>", "Get the position of another player"}, function(...)
	local args = {...}
	local targetList

	if #args == 0 then
		targetList = {Players and Players.LocalPlayer}
	else
		targetList = getPlr(...)
	end

	local plr = targetList and targetList[1]
	if not plr then
		DebugNotif("No matching players found")
		return
	end

	local char = plr.Character or getPlrChar(plr)
	if not char then
		DebugNotif("Unable to find "..tostring(plr.Name).."'s character")
		return
	end

	local root = getRoot(char)
	if not root then
		DebugNotif("Unable to find "..tostring(plr.Name).."'s root part")
		return
	end

	local pos = root.Position
	local formatted = Format("%.3f, %.3f, %.3f", pos.X, pos.Y, pos.Z)
	DebugNotif(nameChecker(plr).."'s position is: "..formatted)
	if setclipboard then
		setclipboard(formatted)
	end
end, true)

cmd.add({"equiptools"},{"equiptools","Equips every tool in your inventory at once"},function()
	for i,v in pairs(Player:FindFirstChildOfClass("Backpack"):GetChildren()) do
		if v:IsA("Tool") or v:IsA("HopperBin") then
			v.Parent=Player.Character
		end
	end
end)

cmd.add({"unequiptools"},{"unequiptools","Unequips every tool you are currently holding at once"},function()
	Player.Character:FindFirstChildOfClass('Humanoid'):UnequipTools()
end)

cmd.add({"removeterrain", "rterrain", "noterrain"},{"removeterrain (rterrain, noterrain)","clears terrain"},function()
	workspace:FindFirstChildOfClass('Terrain'):Clear()
end)

cmd.add({"clearnilinstances", "nonilinstances", "cni"},{"clearnilinstances (nonilinstances, cni)","Removes nil instances"},function()
	if getnilinstances then
		for _,nill in pairs(getnilinstances()) do
			nill:Destroy()
		end
	else
		DoNotif("Your exploit does not support getnilinstances")
	end
end)

cmd.add({"inspect"}, {"inspect", "checks a user's items"}, function(args)
	local targetPlayers = getPlr(args)

	for _, plr in next, targetPlayers do
		GuiService:CloseInspectMenu()
		GuiService:InspectPlayerFromUserId(plr.UserId)
	end
end, true)

promptTBL = promptTBL or {tracked = {}, conns = {}, blocking = false, polling = false}

function NAmanage.isPromptGuiName(name)
	if type(name) ~= "string" then
		return false
	end
	local lowerName = name:lower()
	return lowerName:find("purchaseprompt") or lowerName:find("foundationoverlay")
end

function NAmanage.trackPromptGui(inst)
	if not inst then
		return nil
	end
	local gui = inst:IsA("ScreenGui") and inst or inst:FindFirstAncestorWhichIsA("ScreenGui")
	if gui and gui.Name and NAmanage.isPromptGuiName(gui.Name) then
		return gui
	end
	return nil
end

function NAmanage.nuhuhprompt(v)
	NACaller(function()
		if v == false then
			if promptTBL.blocking then return end
			promptTBL.blocking = true

			local visited = {}

			local function disableGui(gui)
				if not gui or typeof(gui) ~= "Instance" or not gui:IsA("ScreenGui") then
					return
				end
				if promptTBL.tracked[gui] == nil then
					promptTBL.tracked[gui] = gui.Enabled
				end
				pcall(function()
					gui.Enabled = false
				end)
				local c = gui:GetPropertyChangedSignal("Enabled"):Connect(function()
					if promptTBL.blocking then
						pcall(function()
							gui.Enabled = false
						end)
					end
				end)
				Insert(promptTBL.conns, c)
			end

			local function trackAndDisable(inst)
				local gui = NAmanage.trackPromptGui(inst)
				if not gui or visited[gui] then
					return
				end
				visited[gui] = true

				disableGui(gui)

				for _, x in ipairs(gui:GetDescendants()) do
					if x:IsA("ScreenGui") then
						disableGui(x)
					end
				end

				local inner = gui.DescendantAdded:Connect(function(inst2)
					if inst2:IsA("ScreenGui") then
						disableGui(inst2)
					end
				end)
				Insert(promptTBL.conns, inner)
			end

			for _, d in ipairs(COREGUI:GetDescendants()) do
				trackAndDisable(d)
			end

			local c = COREGUI.DescendantAdded:Connect(function(inst)
				trackAndDisable(inst)
			end)
			Insert(promptTBL.conns, c)

			if not promptTBL.polling then
				promptTBL.polling = true
				SpawnCall(function()
					Wait(1)
					if promptTBL.blocking then
						for _, d in ipairs(COREGUI:GetDescendants()) do
							trackAndDisable(d)
						end
					end
					promptTBL.polling = false
				end)
			end
		else
			if not promptTBL.blocking then return end
			promptTBL.blocking = false

			for i = #promptTBL.conns, 1, -1 do
				local c = promptTBL.conns[i]
				if c and c.Connected then
					c:Disconnect()
				end
				promptTBL.conns[i] = nil
			end

			for gui, prev in pairs(promptTBL.tracked) do
				if typeof(gui) == "Instance" and gui and gui.Parent ~= nil then
					pcall(function()
						gui.Enabled = prev
					end)
				end
				promptTBL.tracked[gui] = nil
			end
		end
	end)
end

if NAStuff and NAStuff.PurchasePromptsDisabled == true then
	NAmanage.nuhuhprompt(false)
end

networkPauseBlock = networkPauseBlock or {tracked = {}, conns = {}, blocking = false, polling = false}

function NAmanage.isNetworkPauseScript(inst)
	if typeof(inst) ~= "Instance" then
		return false
	end
	if not inst:IsA("BaseScript") then
		return false
	end
	local name = inst.Name or ""
	if not Lower(name):find("networkpause", 1, true) then
		return false
	end
	local robloxGui = inst:FindFirstAncestor("RobloxGui")
	if not robloxGui or not robloxGui:IsDescendantOf(COREGUI) then
		return false
	end
	if name == "CoreScripts/NetworkPause" then
		return true
	end
	local parent = inst.Parent
	return parent and parent.Name == "CoreScripts" and parent:IsDescendantOf(robloxGui)
end

function NAmanage.getNetworkPauseScript()
	local robloxGui = COREGUI:FindFirstChild("RobloxGui")
	if not robloxGui then
		return nil
	end

	local direct = robloxGui:FindFirstChild("CoreScripts/NetworkPause")
	if direct and NAmanage.isNetworkPauseScript(direct) then
		return direct
	end
	return nil
end

function NAmanage.setNetworkPauseBlocked(disable)
	NACaller(function()
		local tbl = networkPauseBlock
		local function destroyNetworkPauseGui(inst)
			if typeof(inst) ~= "Instance" or not inst:IsA("ScreenGui") then
				return
			end
			local name = inst.Name
			if name and name ~= "" and Lower(name):find("networkpause", 1, true) then
				pcall(function() inst:Destroy() end)
			end
		end
		local function trackAndDisable(inst)
			if inst then
				destroyNetworkPauseGui(inst)
			end
			local scriptInst
			if inst and NAmanage.isNetworkPauseScript(inst) then
				scriptInst = inst
			elseif inst == nil then
				scriptInst = NAmanage.getNetworkPauseScript()
			end
			if scriptInst then
				if tbl.tracked[scriptInst] == nil then tbl.tracked[scriptInst] = scriptInst.Disabled end
				pcall(function() scriptInst.Disabled = true end)
			end
		end
		local function startPolling()
			if tbl.polling then
				return
			end
			tbl.polling = true
			SpawnCall(function()
				while tbl.blocking do
					trackAndDisable(nil)
					Wait(0.5)
				end
				tbl.polling = false
			end)
		end
		if disable then
			if tbl.blocking then return end
			tbl.blocking = true
			trackAndDisable(nil)
			startPolling()
			for _, d in ipairs(COREGUI:GetDescendants()) do
				trackAndDisable(d)
			end
			local c = COREGUI.DescendantAdded:Connect(trackAndDisable)
			Insert(tbl.conns, c)
		else
			if not tbl.blocking then return end
			tbl.blocking = false
			for i = #tbl.conns, 1, -1 do
				local c = tbl.conns[i]
				if c and c.Connected then c:Disconnect() end
				tbl.conns[i] = nil
			end
			for scriptInst, prev in pairs(tbl.tracked) do
				if typeof(scriptInst) == "Instance" and scriptInst and scriptInst.Parent ~= nil then
					pcall(function() scriptInst.Disabled = prev end)
				end
				tbl.tracked[scriptInst] = nil
			end
		end
	end)
end

if NAStuff and NAStuff.NetworkPauseDisabled == true then
	NAmanage.setNetworkPauseBlocked(true)
end

cmd.add({"noprompt","nopurchaseprompts","noprompts","np"},{"noprompt (nopurchaseprompts,noprompts,np)","remove the stupid purchase prompt"},function()
	NAStuff.PurchasePromptsDisabled = true
	pcall(NAmanage.NASettingsSet, "purchasePromptsDisabled", true)
	NAmanage.nuhuhprompt(false)
	DebugNotif("Purchase prompts have been disabled")
end)

cmd.add({"prompt","purchaseprompts","showprompts","showpurchaseprompts","ppr"},{"prompt (purchaseprompts,showprompts,showpurchaseprompts,ppr)","allows the stupid purchase prompt"},function()
	NAStuff.PurchasePromptsDisabled = false
	pcall(NAmanage.NASettingsSet, "purchasePromptsDisabled", false)
	NAmanage.nuhuhprompt(true)
	DebugNotif("Purchase prompts have been enabled")
end)

cmd.add({"nonetworkpause","disableNetworkPause","nnw","nnpause"},{"nonetworkpause (disableNetworkPause,nnw,nnpause)","Disable Roblox network pause overlay"},function()
	NAStuff.NetworkPauseDisabled = true
	pcall(NAmanage.NASettingsSet, "networkPauseDisabled", true)
	NAmanage.setNetworkPauseBlocked(true)
	DoNotif("Network pause UI blocked", 3)
end)

cmd.add({"networkpause","enablenetworkpause","nw","npause"},{"networkpause (enablenetworkpause,nw,npause)","Re-enable Roblox network pause overlay"},function()
	NAStuff.NetworkPauseDisabled = false
	pcall(NAmanage.NASettingsSet, "networkPauseDisabled", false)
	NAmanage.setNetworkPauseBlocked(false)
	DoNotif("Network pause UI allowed", 3)
end)

cmd.add({"wallwalk"},{"wallwalk","Makes you walk on walls"},function()
	loadstring(game:HttpGet("https://raw.githubusercontent.com/ltseverydayyou/uuuuuuu/main/WallWalk.lua"))() -- backup cause i don't trust pastebin
end)

hiddenGUIS = hiddenGUIS or {}
showPrev = showPrev or {}

cmd.add({"hideguis"}, {"hideguis","Hides GUIs"}, function()
	for _, guiElement in pairs(PlrGui:GetDescendants()) do
		if guiElement:IsA("GuiObject") and guiElement.Visible then
			guiElement.Visible = false
			if not Discover(hiddenGUIS, guiElement) then
				Insert(hiddenGUIS, guiElement)
			end
		end
	end
end)

cmd.add({"unhideguis"}, {"unhideguis","Restores GUIs hidden by hideguis"}, function()
	for _, guiElement in pairs(hiddenGUIS) do
		if guiElement and guiElement.Parent then
			guiElement.Visible = true
		end
	end
	hiddenGUIS = {}
end)

cmd.add({"showguis"}, {"showguis","Enables every UI"}, function()
	for _, inst in pairs(PlrGui:GetDescendants()) do
		if inst:IsA("ScreenGui") then
			if not showPrev[inst] then showPrev[inst] = {enabled = inst.Enabled} end
			inst.Enabled = true
		elseif inst:IsA("GuiObject") then
			if not showPrev[inst] then showPrev[inst] = {visible = inst.Visible} else if showPrev[inst].visible == nil then showPrev[inst].visible = inst.Visible end end
			inst.Visible = true
		end
	end
end)

cmd.add({"unshowguis"}, {"unshowguis","Restores UI states set by showguis"}, function()
	for inst, prev in pairs(showPrev) do
		if inst and inst.Parent then
			if prev.enabled ~= nil and inst:IsA("ScreenGui") then inst.Enabled = prev.enabled end
			if prev.visible ~= nil and inst:IsA("GuiObject") then inst.Visible = prev.visible end
		end
		showPrev[inst] = nil
	end
end)

spinThingy = nil
spinPart = nil

cmd.add({"spin"}, {"spin {amount}", "Makes your character spin as fast as you want"}, function(...)
	Wait()

	local spinSpeed = (...)
	if not spinSpeed then spinSpeed = 20 end

	if spinThingy then
		spinThingy:Destroy()
		spinThingy = nil
	end

	if spinPart then
		spinPart:Destroy()
		spinPart = nil
	end

	spinPart = InstanceNew("Part")
	spinPart.Anchored = false
	spinPart.CanCollide = false
	spinPart.Transparency = 1
	spinPart.Size = Vector3.new(1, 1, 1)
	spinPart.Parent = workspace
	spinPart.CFrame = getRoot(LocalPlayer.Character).CFrame

	spinThingy = InstanceNew("BodyAngularVelocity")
	spinThingy.Parent = spinPart
	spinThingy.MaxTorque = Vector3.new(0, math.huge, 0)
	spinThingy.AngularVelocity = Vector3.new(0, spinSpeed, 0)

	local weld = InstanceNew("WeldConstraint")
	weld.Part0 = spinPart
	weld.Part1 = getRoot(LocalPlayer.Character)
	weld.Parent = spinPart

	DebugNotif("Spinning...")
end, true)

cmd.add({"unspin"}, {"unspin", "Makes your character unspin"}, function()
	Wait()

	if spinThingy then
		spinThingy:Destroy()
		spinThingy = nil
	end

	if spinPart then
		spinPart:Destroy()
		spinPart = nil
	end

	DebugNotif("Spin Disabled", 3)
end)

cmd.add({"notepad"},{"notepad","notepad for making scripts / etc"},function()
	loadstring(game:HttpGet("https://raw.githubusercontent.com/ltseverydayyou/Nameless-Admin/main/NAnotepad.lua"))()
end)

cmd.add({"rc7"},{"rc7","RC7 Internal UI"},function()
	loadstring(game:HttpGet("https://raw.githubusercontent.com/ltseverydayyou/Nameless-Admin/main/rc%20sexy%207"))()
end)

cmd.add({"scriptviewer","viewscripts"},{"scriptviewer (viewscripts)","Can view scripts made by 0866"},function()
	loadstring(game:HttpGet("https://raw.githubusercontent.com/ltseverydayyou/uuuuuuu/main/scriptviewer",true))()
end)

-- idk if this is either broken or patched but i'll keep it ig?
cmd.add({"hydroxide","hydro"},{"hydroxide (hydro)","executes hydroxide"},function()
	if IsOnMobile then
		local owner = "Hosvile"
		local branch = "revision"

		local function webImport(file)
			return loadstring(game:HttpGetAsync(("https://raw.githubusercontent.com/%s/MC-Hydroxide/%s/%s.lua"):format(owner, branch, file)), file..'.lua')()
		end

		webImport("init")
		webImport("ui/main")
	else
		local owner="Upbolt"
		local branch="revision"

		local function webImport(file)
			return loadstring(game:HttpGetAsync(("https://raw.githubusercontent.com/%s/Hydroxide/%s/%s.lua"):format(owner,branch,file)),file..'.lua')()
		end

		webImport("init")
		webImport("ui/main")
	end
end)

cmd.add({"remotespy","simplespy","rspy"},{"remotespy (simplespy,rspy)","executes simplespy that supports both pc and mobile"},function()
	loadstring(game:HttpGet("https://raw.githubusercontent.com/ltseverydayyou/uuuuuuu/refs/heads/main/SimpleSpyRework.luau"))()
end)

cmd.add({"cobaltspy","cobalt","cspy"},{"cobaltspy (cobalt,cspy)"},function()
	loadstring(game:HttpGet("https://github.com/notpoiu/cobalt/releases/latest/download/Cobalt.luau"))()
end)

cmd.add({"turtlespy","tspy"},{"turtlespy (tspy)","executes Turtle Spy that supports both pc and mobile"},function()
	loadstring(game:HttpGet("https://raw.githubusercontent.com/ltseverydayyou/uuuuuuu/main/Turtle%20Spy.lua"))()
end)

cmd.add({"gravity","grav"},{"gravity <amount> (grav)","sets game gravity to whatever u want"},function(...)
	workspace.Gravity=(...)
end,true)

cmd.add({"fireclickdetectors","fcd","firecd"},{"fireclickdetectors (fcd,firecd)","Fires every ClickDetector in Workspace"},function(...)
	local args={...}
	local targetText = args[1] and Concat(args," ")
	local target = targetText and Lower(targetText) or nil
	if typeof(fireclickdetector)~="function" then return DoNotif("fireclickdetector not available",3) end
	NAindex.init()
	local list,f={},0
	if NAindex.click then
		for inst,rec in pairs(NAindex.click) do
			if inst and inst.Parent and rec and rec.names and NAindex.matchAny(rec.names, target) then
				Insert(list,inst)
			end
		end
	end
	if #list==0 then
		if target then return DebugNotif("No ClickDetectors found matching \""..targetText.."\"",2) end
		return DebugNotif("No ClickDetectors found",2)
	end
	for _,d in ipairs(list) do
		if not pcall(function() fireclickdetector(d) end) then f += 1 end
	end
	Wait()
	if f>0 then
		DebugNotif(("Fired %d ClickDetectors, Failed: %d"):format(#list,f),2)
	else
		DebugNotif(("Fired %d ClickDetectors"):format(#list),2)
	end
end,true)

cmd.add({"fireclickdetectorsfind","fcdfind","firecdfind"},{"fireclickdetectorsfind <target> (fcdfind,firecdfind)","Fires ClickDetectors substring-matching [target] in Workspace"},function(...)
	local args={...}
	if not args[1] then return DebugNotif("Usage: fireclickdetectorsfind <target>",2) end
	local targetText = Concat(args," ")
	local target = Lower(targetText)
	if typeof(fireclickdetector)~="function" then return DoNotif("fireclickdetector not available",3) end
	NAindex.init()
	local list,f={},0
	if NAindex.click then
		for inst,rec in pairs(NAindex.click) do
			if inst and inst.Parent and rec and rec.names and NAindex.matchAnyFind(rec.names, target) then
				Insert(list,inst)
			end
		end
	end
	if #list==0 then
		return DebugNotif(("No ClickDetectors found matching \"%s\""):format(targetText),2)
	end
	for _,d in ipairs(list) do
		if not pcall(function() fireclickdetector(d) end) then f += 1 end
	end
	Wait()
	if f>0 then
		DebugNotif(("Fired %d ClickDetectors, Failed: %d"):format(#list,f),2)
	else
		DebugNotif(("Fired %d ClickDetectors"):format(#list),2)
	end
end,true)

cmd.add({"fireproximityprompts","fpp","firepp"},{"fireproximityprompts (fpp,firepp)","Fires every ProximityPrompt in Workspace"},function(...)
	local args={...}
	local targetText = args[1] and Concat(args," ")
	local target = targetText and Lower(targetText) or nil
	if typeof(fireproximityprompt)~="function" then return DoNotif("fireproximityprompt not available",3) end
	NAindex.init()
	local list,f={},0
	if NAindex.prompt then
		for inst,rec in pairs(NAindex.prompt) do
			if inst and inst.Parent and rec and rec.names and NAindex.matchAny(rec.names, target) then
				Insert(list,inst)
			end
		end
	end
	if #list==0 then
		if target then return DebugNotif("No ProximityPrompts found matching \""..targetText.."\"",2) end
		return DebugNotif("No ProximityPrompts found",2)
	end
	for _,p in ipairs(list) do
		if not pcall(function() fireproximityprompt(p,1) end) then f += 1 end
	end
	Wait()
	if f>0 then
		DebugNotif(("Fired %d ProximityPrompts, Failed: %d"):format(#list,f),2)
	else
		DebugNotif(("Fired %d ProximityPrompts"):format(#list),2)
	end
end,true)

cmd.add({"fireproximitypromptsfind","fppfind","fireppfind"},{"fireproximitypromptsfind <target> (fppfind,fireppfind)","Fires ProximityPrompts substring-matching [target] in Workspace"},function(...)
	local args={...}
	if not args[1] then return DebugNotif("Usage: fireproximitypromptsfind <target>",2) end
	local targetText = Concat(args," ")
	local target = Lower(targetText)
	if typeof(fireproximityprompt)~="function" then return DoNotif("fireproximityprompt not available",3) end
	NAindex.init()
	local list,f={},0
	if NAindex.prompt then
		for inst,rec in pairs(NAindex.prompt) do
			if inst and inst.Parent and rec and rec.names and NAindex.matchAnyFind(rec.names, target) then
				Insert(list,inst)
			end
		end
	end
	if #list==0 then
		return DebugNotif(("No ProximityPrompts found matching \"%s\""):format(targetText),2)
	end
	for _,p in ipairs(list) do
		if not pcall(function() fireproximityprompt(p,1) end) then f += 1 end
	end
	Wait()
	if f>0 then
		DebugNotif(("Fired %d ProximityPrompts, Failed: %d"):format(#list,f),2)
	else
		DebugNotif(("Fired %d ProximityPrompts"):format(#list),2)
	end
end,true)

cmd.add({"firetouchinterests","fti"},{"firetouchinterests (fti)","Fires every TouchInterest in Workspace"},function(...)
	local args = {...}
	local targetText = args[1] and Concat(args," ")
	local target = targetText and Lower(targetText) or nil
	if typeof(firetouchinterest) ~= "function" then return end
	local char = getChar()
	local root = char and (getRoot(char) or char:FindFirstChildWhichIsA("BasePart"))
	if not root then return end
	NAindex.init()
	local found = 0
	if NAindex.touch then
		for ti in pairs(NAindex.touch) do
			local container = ti.Parent
			if container and container.Parent then
				local part = NAindex.carPart(container)
				if part and part.Parent then
					local names = {}
					if ti.Name and ti.Name ~= "" then Insert(names, NAindex.lc(ti.Name)) end
					if container.Name and container.Name ~= "" then Insert(names, NAindex.lc(container.Name)) end
					if part.Name and part.Name ~= "" then Insert(names, NAindex.lc(part.Name)) end
					local model = part:FindFirstAncestorWhichIsA("Model")
					while model do
						if model.Name and model.Name ~= "" then Insert(names, NAindex.lc(model.Name)) end
						model = model:FindFirstAncestorWhichIsA("Model")
					end
					if NAindex.matchAny(names, target) then
						found += 1
						local targetPart = part
						SpawnCall(function()
							local orig = targetPart.CFrame
							targetPart.CFrame = root.CFrame
							firetouchinterest(targetPart,root,1)
							Wait()
							firetouchinterest(targetPart,root,0)
							Delay(0.1,function()
								if targetPart and targetPart.Parent then
									targetPart.CFrame = orig
								end
							end)
						end)
					end
				end
			end
		end
	end
	if found == 0 then
		if target then
			DebugNotif(("No TouchInterests found matching \"%s\""):format(targetText),2)
		else
			DebugNotif("No TouchInterests found",2)
		end
	else
		DebugNotif(("Fired %d TouchInterests"):format(found),2)
	end
end,true)

cmd.add({"firetouchinterestsfind","ftifind","firetifind"},{"firetouchinterestsfind <target> (ftifind,firetifind)","Fires TouchInterests substring-matching [target] in Workspace"},function(...)
	local args = {...}
	if not args[1] then return DebugNotif("Usage: firetouchinterestsfind <target>",2) end
	local targetText = Concat(args," ")
	local target = Lower(targetText)
	if typeof(firetouchinterest) ~= "function" then return end
	local char = getChar()
	local root = char and (getRoot(char) or char:FindFirstChildWhichIsA("BasePart"))
	if not root then return end
	NAindex.init()
	local found = 0
	if NAindex.touch then
		for ti in pairs(NAindex.touch) do
			local container = ti.Parent
			if container and container.Parent then
				local part = NAindex.carPart(container)
				if part and part.Parent then
					local names = {}
					if ti.Name and ti.Name ~= "" then Insert(names, NAindex.lc(ti.Name)) end
					if container.Name and container.Name ~= "" then Insert(names, NAindex.lc(container.Name)) end
					if part.Name and part.Name ~= "" then Insert(names, NAindex.lc(part.Name)) end
					local model = part:FindFirstAncestorWhichIsA("Model")
					while model do
						if model.Name and model.Name ~= "" then Insert(names, NAindex.lc(model.Name)) end
						model = model:FindFirstAncestorWhichIsA("Model")
					end
					if NAindex.matchAnyFind(names, target) then
						found += 1
						local targetPart = part
						SpawnCall(function()
							local orig = targetPart.CFrame
							targetPart.CFrame = root.CFrame
							firetouchinterest(targetPart,root,1)
							Wait()
							firetouchinterest(targetPart,root,0)
							Delay(0.1,function()
								if targetPart and targetPart.Parent then
									targetPart.CFrame = orig
								end
							end)
						end)
					end
				end
			end
		end
	end
	if found == 0 then
		DebugNotif(("No TouchInterests found matching \"%s\""):format(targetText),2)
	else
		DebugNotif(("Fired %d TouchInterests"):format(found),2)
	end
end,true)

NAutil.parseInterval = function(defaultInterval, ...)
	local args = { ... }
	local n1 = tonumber(args[1])
	if n1 then
		return n1, (args[2] and Lower(Concat(args, " ", 2)) or nil)
	else
		return defaultInterval, (args[1] and Lower(Concat(args, " ", 1)) or nil)
	end
end

NAindex.lc = function(s) return s and Lower(s) or "" end

NAindex.carPart = function(inst)
	if not inst then return nil end
	if inst:IsA("BasePart") then return inst end
	if inst:IsA("Attachment") then
		local p = inst.Parent
		if p and p:IsA("BasePart") then return p end
	end
	return inst:FindFirstAncestorWhichIsA("BasePart")
end

NAindex.getPromptPart = function(pp)
	local parent = pp and pp.Parent
	if not parent then return nil end
	if parent:IsA("Attachment") then
		local p = parent.Parent
		return p and p:IsA("BasePart") and p or nil
	elseif parent:IsA("BasePart") then
		return parent
	end
	local model = pp:FindFirstAncestorWhichIsA("Model")
	if model then
		if model.PrimaryPart then return model.PrimaryPart end
		local bp = model:FindFirstChildWhichIsA("BasePart", true)
		if bp then return bp end
	end
	return pp:FindFirstAncestorWhichIsA("BasePart")
end

NAindex.namesForPrompt = function(p)
	local names = {}
	if p.Name then Insert(names, p.Name) end
	if p.ObjectText then Insert(names, p.ObjectText) end
	if p.ActionText then Insert(names, p.ActionText) end
	if p.Parent and p.Parent.Name then Insert(names, p.Parent.Name) end
	local part = NAindex.getPromptPart(p)
	if part then
		Insert(names, part.Name)
		local m = part:FindFirstAncestorWhichIsA("Model")
		while m do
			Insert(names, m.Name)
			m = m:FindFirstAncestorWhichIsA("Model")
		end
	else
		local m = p:FindFirstAncestorWhichIsA("Model")
		while m do
			Insert(names, m.Name)
			m = m:FindFirstAncestorWhichIsA("Model")
		end
	end
	for i = 1, #names do names[i] = NAindex.lc(names[i]) end
	return names
end

NAindex.namesForClick = function(d)
	local names = {}
	if d.Name then Insert(names, d.Name) end
	if d.Parent and d.Parent.Name then Insert(names, d.Parent.Name) end
	local part = NAindex.carPart(d.Parent or d)
	if part then
		Insert(names, part.Name)
		local m = part:FindFirstAncestorWhichIsA("Model")
		while m do
			Insert(names, m.Name)
			m = m:FindFirstAncestorWhichIsA("Model")
		end
	end
	for i = 1, #names do names[i] = NAindex.lc(names[i]) end
	return names
end

NAindex.matchAny = function(names, target)
	target = NAindex.lc(target)
	if not target or target == "" then return true end
	for i = 1, #names do
		if names[i] == target then
			return true
		end
	end
	return false
end

NAindex.matchAnyFind = function(names, target)
	target = NAindex.lc(target)
	if not target or target == "" then return true end
	for i = 1, #names do
		local n = names[i]
		if n == target or Find(n, target, 1, true) then
			return true
		end
	end
	return false
end

NAindex.promptTarget = function(pp)
	local part = NAindex.getPromptPart(pp)
	return part, part and part.Position or nil
end

NAindex.clickTarget = function(cd)
	local part = NAindex.carPart(cd.Parent or cd)
	return part, part and part.Position or nil
end

NAindex.inRangePrompt = function(pp, rootPos, extra)
	local part, pos = NAindex.promptTarget(pp)
	if not pos then return false, math.huge, part end
	local dist = (pos - rootPos).Magnitude
	local maxd = (pp.MaxActivationDistance or 0) + (extra or 0)
	return dist <= maxd, dist, part
end

NAindex.inRangeClick = function(cd, rootPos, extra)
	local part, pos = NAindex.clickTarget(cd)
	if not pos then return false, math.huge, part end
	local dist = (pos - rootPos).Magnitude
	local maxd = (cd.MaxActivationDistance or 0) + (extra or 0)
	return dist <= maxd, dist, part
end

NAindex.add = function(inst)
	if inst:IsA("ProximityPrompt") then
		NAindex.prompt = NAindex.prompt or {}
		NAindex.prompt[inst] = { inst = inst, names = NAindex.namesForPrompt(inst) }
	elseif inst:IsA("ClickDetector") then
		NAindex.click = NAindex.click or {}
		NAindex.click[inst] = { inst = inst, names = NAindex.namesForClick(inst) }
	elseif inst:IsA("TouchTransmitter") or inst.Name == "TouchInterest" then
		NAindex.touch = NAindex.touch or {}
		NAindex.touch[inst] = { inst = inst }
	end
end

NAindex.remove = function(inst)
	if NAindex.prompt then NAindex.prompt[inst] = nil end
	if NAindex.click   then NAindex.click[inst]   = nil end
	if NAindex.touch   then NAindex.touch[inst]   = nil end
end

NAindex.init = function()
	if NAindex._init then return end
	NAindex.prompt = NAindex.prompt or {}
	NAindex.click = NAindex.click or {}
	NAindex.touch = NAindex.touch or {}
	NAindex._init = true
end

NAsuppress._acquire = function(pp)
	local r = NAsuppress.ref[pp] or 0
	if r == 0 then
		NAsuppress.snap[pp] = pp.Enabled
		pp.Enabled = false
	end
	NAsuppress.ref[pp] = r + 1
end

NAsuppress._release = function(pp)
	local r = NAsuppress.ref[pp]
	if not r then return end
	r -= 1
	if r <= 0 then
		local prev = NAsuppress.snap[pp]
		if prev ~= nil and pp and pp.Parent then
			pp.Enabled = prev
		end
		NAsuppress.ref[pp] = nil
		NAsuppress.snap[pp] = nil
	else
		NAsuppress.ref[pp] = r
	end
end

NAsuppress.collectAndAcquire = function(centerPos, radius, allowSet)
	local list = {}
	if interactTbl and type(interactTbl.proxy) == "table" then
		for _, p in ipairs(interactTbl.proxy) do
			if p and p.Parent and p.Enabled and not (allowSet and allowSet[p]) then
				local _, pos = NAindex.promptTarget(p)
				if pos and (pos - centerPos).Magnitude <= radius then
					NAsuppress._acquire(p)
					Insert(list, p)
				end
			end
		end
	end
	return list
end

NAsuppress.releaseList = function(list)
	for _, p in ipairs(list) do
		NAsuppress._release(p)
	end
end

NAjobs._claim = function(key)
	if not key then return true end
	if NAjobs._claimed[key] == NAjobs._frame then return false end
	NAjobs._claimed[key] = NAjobs._frame
	return true
end

NAjobs._restoreTouchDue = function()
	local now = time()
	for part, st in pairs(NAjobs._touchState) do
		if st.moved and st.restoreAt and now >= st.restoreAt then
			if part and part.Parent then
				part.CFrame = st.orig
			end
			st.moved = false
			st.orig = nil
			st.restoreAt = nil
			NAjobs._touchState[part] = nil
		end
	end
end

NAjobs._schedule = function()
	if NAjobs.hb then return end
	NAjobs.hb = NAlib.connect("NAjobs_stp", RunService.Heartbeat:Connect(function()
		NAjobs._frame += 1
		NAjobs._claimed = {}
		local now = time()
		for _, job in pairs(NAjobs.jobs) do
			if job.interval <= 0 then
				job.tick(job)
			else
				if now >= job.next then
					job.next = now + job.interval
					job.tick(job)
				end
			end
		end
		NAjobs._restoreTouchDue()
	end))
end

NAjobs._maybeStop = function()
	if not next(NAjobs.jobs) and NAjobs.hb then
		NAlib.disconnect("NAjobs_stp")
		NAjobs.hb = nil
	end
end

NAjobs._findExisting = function(kind, target, useFind)
	local findMode = useFind and true or false
	for id, job in pairs(NAjobs.jobs) do
		if job.kind == kind and (job.target or nil) == target and (job.useFind and true or false) == findMode then
			return id, job
		end
	end
	return nil
end

NAjobs._nextIdForKind = function(kind)
	local used = {}
	for id, job in pairs(NAjobs.jobs) do
		if job.kind == kind then
			local n = tonumber(tostring(id):match("^"..kind.."#(%d+)$"))
			if n then used[n] = true end
		end
	end
	local i = 1
	while used[i] do i += 1 end
	return kind.."#"..tostring(i)
end

NAjobs.start = function(kind, interval, target, useFind)
	NAindex.init();
	local tgt = target and Lower(target) or nil;
	local ivl = interval or 0.1;
	local ivlClamped = math.max(0, ivl);
	local stagger = ivlClamped > 0 and math.min(0.02, ivlClamped / 8) or 0;
	local matcher = useFind and NAindex.matchAnyFind or NAindex.matchAny;
	local existingId, existingJob = NAjobs._findExisting(kind, tgt, useFind);
	if existingJob then
		existingJob.interval = ivlClamped;
		existingJob.target = tgt;
		existingJob.m = matcher;
		existingJob.useFind = useFind and true or false;
		existingJob.stagger = stagger;
		existingJob.next = time();
		return existingId, true;
	end;
	local id = NAjobs._nextIdForKind(kind);
	local job = {
		id = id,
		kind = kind,
		interval = ivlClamped,
		target = tgt,
		next = time(),
		stagger = stagger,
		m = matcher,
		useFind = useFind and true or false
	};
	if kind == "prompt" then
		job.tick = function(self)
			if not interactTbl or type(interactTbl.proxy) ~= "table" then
				return;
			end;
			local char = getChar();
			local root = char and (getRoot(char) or char:FindFirstChildWhichIsA("BasePart"));
			if not root then
				return;
			end;
			local rootPos = root.Position;
			local list = {};
			for _, inst in ipairs(interactTbl.proxy) do
				if inst and inst.Parent and inst.Enabled then
					local rec = NAindex.prompt and NAindex.prompt[inst];
					if not rec then
						rec = {
							inst = inst,
							names = NAindex.namesForPrompt(inst)
						};
						NAindex.prompt[inst] = rec;
					end;
					if self.m(rec.names, self.target) then
						local ok, dist, part = NAindex.inRangePrompt(inst, rootPos, 5);
						if ok then
							Insert(list, {
								inst = inst,
								dist = dist,
								part = part
							});
						end;
					end;
				end;
			end;
			table.sort(list, function(a, b)
				return a.dist < b.dist;
			end);
			local step = self.interval > 0 and self.stagger or 0;
			local i = 0;
			for _, it in ipairs(list) do
				if NAjobs._claim(it.inst) then
					i += 1;
					Delay(step * (i - 1), function()
						local range = (it.inst.MaxActivationDistance or 0) + 5;
						local allow = {
							[it.inst] = true
						};
						local suppressed = NAsuppress.collectAndAcquire(it.part and it.part.Position or rootPos, 10, allow);
						pcall(fireproximityprompt, it.inst, {
							hold = 0.03,
							distance = range,
							stagger = 0
						});
						Delay(0.06, function()
							NAsuppress.releaseList(suppressed);
						end);
					end);
				end;
			end;
		end;
	elseif kind == "click" then
		job.tick = function(self)
			if not interactTbl or type(interactTbl.click) ~= "table" then
				return;
			end;
			local char = getChar();
			local root = char and (getRoot(char) or char:FindFirstChildWhichIsA("BasePart"));
			if not root then
				return;
			end;
			local rootPos = root.Position;
			local list = {};
			for _, inst in ipairs(interactTbl.click) do
				if inst and inst.Parent then
					local rec = NAindex.click and NAindex.click[inst];
					if not rec then
						rec = {
							inst = inst,
							names = NAindex.namesForClick(inst)
						};
						NAindex.click[inst] = rec;
					end;
					if self.m(rec.names, self.target) then
						local ok, dist, part = NAindex.inRangeClick(inst, rootPos, 5);
						if ok then
							Insert(list, {
								inst = inst,
								dist = dist,
								part = part
							});
						end;
					end;
				end;
			end;
			table.sort(list, function(a, b)
				return a.dist < b.dist;
			end);
			local step = self.interval > 0 and self.stagger or 0;
			local i = 0;
			for _, it in ipairs(list) do
				if NAjobs._claim(it.part) then
					i += 1;
					Delay(step * (i - 1), function()
						pcall(fireclickdetector, it.inst);
					end);
				end;
			end;
		end;
	elseif kind == "touch" then
		job.tick = function(self)
			if not interactTbl or type(interactTbl.touch) ~= "table" then
				return;
			end;
			local char = getChar();
			local root = char and (getRoot(char) or char:FindFirstChildWhichIsA("BasePart"));
			if not root or (not root:IsDescendantOf(workspace)) then
				return;
			end;
			local list = {};
			for _, ti in ipairs(interactTbl.touch) do
				if ti then
					local container = ti.Parent;
					if container and container.Parent then
						local part = NAindex.carPart(container);
						if part then
							local names = {
								NAindex.lc(part.Name)
							};
							local m = part:FindFirstAncestorWhichIsA("Model");
							while m do
								Insert(names, NAindex.lc(m.Name));
								m = m:FindFirstAncestorWhichIsA("Model");
							end;
							if self.m(names, self.target) then
								local asm = part.AssemblyRootPart or part;
								if asm then
									Insert(list, {
										part = asm
									});
								end;
							end;
						end;
					end;
				end;
			end;
			for _, it in ipairs(list) do
				if NAjobs._claim(it.part) then
					Spawn(function()
						local asm = it.part;
						if not asm or (not asm.Parent) or (not asm:IsDescendantOf(workspace)) then
							return;
						end;
						local st = NAjobs._touchState[asm];
						if not st or (not st.moved) then
							st = st or {};
							st.orig = asm.CFrame;
							st.moved = true;
							NAjobs._touchState[asm] = st;
						end;
						local char2 = getChar();
						local root2 = char2 and (getRoot(char2) or char2:FindFirstChildWhichIsA("BasePart"));
						if not root2 or (not root2:IsDescendantOf(workspace)) then
							return;
						end;
						asm:PivotTo(root2.CFrame);
						pcall(firetouchinterest, asm, root2, 1);
						Wait();
						pcall(firetouchinterest, asm, root2, 0);
						st.restoreAt = time() + 0.05;
					end);
				end;
			end;
		end;
	end;
	NAjobs.jobs[id] = job;
	NAjobs._schedule();
	return id;
end;

NAjobs._restoreAllTouch = function()
	for part, st in pairs(NAjobs._touchState) do
		if st.moved and st.orig and part and part.Parent then
			part.CFrame = st.orig
		end
		NAjobs._touchState[part] = nil
	end
end

NAjobs.stopByKind = function(kind)
	for id, job in pairs(NAjobs.jobs) do
		if job.kind == kind then NAjobs.jobs[id] = nil end
	end
	if kind == "touch" then NAjobs._restoreAllTouch() end
	NAjobs._maybeStop()
end

NAjobs.stopById = function(id)
	local job = NAjobs.jobs[id]
	if not job then return end
	NAjobs.jobs[id] = nil
	if job.kind == "touch" then NAjobs._restoreAllTouch() end
	NAjobs._maybeStop()
end

NAjobs.stopAll = function()
	for id in pairs(NAjobs.jobs) do NAjobs.jobs[id] = nil end
	NAjobs._restoreAllTouch()
	NAjobs._maybeStop()
end

NAmanage._sortedJobs = function(kind, useFind)
	local list = {}
	local findMode = useFind and true or false
	for _, job in pairs(NAjobs.jobs) do
		if job.kind == kind and (job.useFind and true or false) == findMode then
			Insert(list, job)
		end
	end
	table.sort(list, function(a, b)
		local ai = tonumber(tostring(a.id):match("#(%d+)$")) or math.huge
		local bi = tonumber(tostring(b.id):match("#(%d+)$")) or math.huge
		if ai == bi then
			return (a.target or "") < (b.target or "")
		end
		return ai < bi
	end)
	return list
end

local function buildStopWindow(kind, titleText, useFind)
	local buttons = {}
	for _, job in ipairs(NAmanage._sortedJobs(kind, useFind)) do
		local label = job.id..(job.target and (" • "..job.target) or "")
		Insert(buttons, {
			Text = label,
			Callback = function()
				NAjobs.stopById(job.id)
				DebugNotif("stopped "..label, 2)
			end
		})
	end
	Insert(buttons, {
		Text = "All",
		Callback = function()
			for jid, j in pairs(NAjobs.jobs) do
				if j.kind == kind and (j.useFind and true or false) == (useFind and true or false) then
					NAjobs.stopById(jid)
				end
			end
			local suffix = useFind and " (find)" or ""
			DebugNotif("all "..kind..suffix.." stopped", 2)
		end
	})
	Window({
		Title = titleText,
		Buttons = buttons
	})
end

NAmanage._windowStopKind=function(kind, titleText)
	buildStopWindow(kind, titleText, false)
end

NAmanage._windowStopKindFind=function(kind, titleText)
	buildStopWindow(kind, titleText, true)
end

cmd.add({"AutoFireProxi","afp"},{"AutoFireProxi <interval> [target] (afp)","Automatically fires ProximityPrompts matching [target] every <interval> seconds"}, function(...)
	local args = {...}
	local interval, target
	if args[1] and not tonumber(args[1]) then
		interval = 0
		target = Lower(Concat(args, " ", 1))
	else
		interval, target = NAutil.parseInterval(0.01, ...)
	end
	local id, reused = NAjobs.start("prompt", interval, target)
	local action = reused and "updated" or "started"
	DebugNotif(target and ("afp %s (%s) → %s"):format(action, target, id) or ("afp %s → %s"):format(action, id), 2)
end, true)

cmd.add({"AutoFireProxiFind","afpfind"},{"AutoFireProxiFind <interval> [target] (afpfind)","Automatically fires ProximityPrompts matching [target] using substring matching every <interval> seconds"}, function(...)
	local args = {...}
	local interval, target
	if args[1] and not tonumber(args[1]) then
		interval = 0
		target = Lower(Concat(args, " ", 1))
	else
		interval, target = NAutil.parseInterval(0.01, ...)
	end
	local id, reused = NAjobs.start("prompt", interval, target, true)
	local action = reused and "updated" or "started"
	DebugNotif(target and ("afpfind %s (%s) → %s"):format(action, target, id) or ("afpfind %s → %s"):format(action, id), 2)
end, true)

cmd.add({"AutoFireClick","afc"},{"AutoFireClick <interval> [target] (afc)","Automatically fires ClickDetectors matching [target] every <interval> seconds"}, function(...)
	local args = {...}
	local interval, target
	if args[1] and not tonumber(args[1]) then
		interval = 0
		target = Lower(Concat(args, " ", 1))
	else
		interval, target = NAutil.parseInterval(0.01, ...)
	end
	local id, reused = NAjobs.start("click", interval, target)
	local action = reused and "updated" or "started"
	DebugNotif(target and ("afc %s (%s) → %s"):format(action, target, id) or ("afc %s → %s"):format(action, id), 2)
end, true)

cmd.add({"AutoFireClickFind","afcfind"},{"AutoFireClickFind <interval> [target] (afcfind)","Automatically fires ClickDetectors matching [target] using substring matching every <interval> seconds"}, function(...)
	local args = {...}
	local interval, target
	if args[1] and not tonumber(args[1]) then
		interval = 0
		target = Lower(Concat(args, " ", 1))
	else
		interval, target = NAutil.parseInterval(0.01, ...)
	end
	local id, reused = NAjobs.start("click", interval, target, true)
	local action = reused and "updated" or "started"
	DebugNotif(target and ("afcfind %s (%s) → %s"):format(action, target, id) or ("afcfind %s → %s"):format(action, id), 2)
end, true)

cmd.add({"AutoTouch","at"},{"AutoTouch <interval> [target] (at)","Automatically fires TouchInterests on parts matching [target] every <interval> seconds"}, function(...)
	local interval, target = NAutil.parseInterval(0.5, ...)
	local id, reused = NAjobs.start("touch", interval, target)
	local action = reused and "updated" or "started"
	DebugNotif(target and ("at %s (%s) → %s"):format(action, target, id) or ("at %s → %s"):format(action, id), 2)
end, true)

cmd.add({"AutoTouchFind","atfind"},{"AutoTouchFind <interval> [target] (atfind)","Automatically fires TouchInterests on parts matching [target] using substring matching every <interval> seconds"}, function(...)
	local interval, target = NAutil.parseInterval(0.5, ...)
	local id, reused = NAjobs.start("touch", interval, target, true)
	local action = reused and "updated" or "started"
	DebugNotif(target and ("atfind %s (%s) → %s"):format(action, target, id) or ("atfind %s → %s"):format(action, id), 2)
end, true)

cmd.add({"unautofireproxi","uafp"},{"unautofireproxi (uafp)","Stops all AutoFireProxi loops"}, function()
	NAmanage._windowStopKind("prompt","AutoFireProxi Jobs")
end)

cmd.add({"unautofireclick","uafc"},{"unautofireclick (uafc)","Stops all AutoFireClick loops"}, function()
	NAmanage._windowStopKind("click","AutoFireClick Jobs")
end)

cmd.add({"unautotouch","uat"},{"unautotouch (uat)","Stops all AutoTouch loops"}, function()
	NAmanage._windowStopKind("touch","AutoTouch Jobs")
end)

cmd.add({"unautotouchfind","uatfind"},{"unautotouchfind (uatfind)","Stops substring-matching AutoTouch loops"}, function()
	NAmanage._windowStopKindFind("touch","AutoTouchFind Jobs")
end)

cmd.add({"unautofireproxifind","uafpfind"},{"unautofireproxifind (uafpfind)","Stops substring-matching AutoFireProxi loops"}, function()
	NAmanage._windowStopKindFind("prompt","AutoFireProxiFind Jobs")
end)

cmd.add({"unautofireclickfind","uafcfind"},{"unautofireclickfind (uafcfind)","Stops substring-matching AutoFireClick loops"}, function()
	NAmanage._windowStopKindFind("click","AutoFireClickFind Jobs")
end)

cmd.add({"noclickdetectorlimits","nocdlimits","removecdlimits"},{"noclickdetectorlimits <limit> (nocdlimits,removecdlimits)","Sets all click detectors MaxActivationDistance to math.huge"},function(...)
	local limit = (...) or math.huge
	for _,v in ipairs(interactTbl.click) do
		v.MaxActivationDistance = limit
	end
end,true)

cmd.add({"noproximitypromptlimits","nopplimits","removepplimits"},{"noproximitypromptlimits <limit> (nopplimits,removepplimits)","Sets all proximity prompts MaxActivationDistance to math.huge"},function(...)
	local limit = (...) or math.huge
	for _,v in ipairs(interactTbl.proxy) do
		v.MaxActivationDistance = limit
	end
end,true)

cmd.add({"instantproximityprompts","instantpp","ipp"},{"instantproximityprompts (instantpp,ipp)","Disable the cooldown for proximity prompts"},function()
	NAlib.disconnect("instantpp")
	NAlib.connect("instantpp", SafeGetService("ProximityPromptService").PromptButtonHoldBegan:Connect(function(pp)
		fireproximityprompt(pp, 1)
	end))
end)

cmd.add({"uninstantproximityprompts","uninstantpp","unipp"},{"uninstantproximityprompts (uninstantpp,unipp)","Undo the cooldown removal"},function()
	NAlib.disconnect("instantpp")
end)

cmd.add({"enableproximitypromptservice","enablepps","epps","ppson","ppon"},{"enableproximitypromptservice (enablepps,epps,ppson,ppon)","enable proximity prompt buttons"},function()
	SafeGetService("ProximityPromptService").Enabled = true
end,true)

cmd.add({"disableproximitypromptservice","disablepps","dpps","ppsoff","ppoff"},{"disableproximitypromptservice (disablepps,dpps,ppsoff,ppoff)","disable proximity prompt buttons"},function()
	SafeGetService("ProximityPromptService").Enabled = false
end,true)

cmd.add({"enableproximityprompts","enableprox","enprox","enprx","enpp"},{"enableproximityprompts [name]","Enable ProximityPrompts (all or matching)"},function(...)
	local term = Lower(Concat({...}," "))
	for _,obj in ipairs(interactTbl.proxy) do
		if obj and obj.Parent then
			if term=="" or Find(Lower(obj.Name), term) then
				obj.Enabled = true
			end
		end
	end
end,true)

cmd.add({"disableproximityprompts","disableprox","disprox","dprx","dpp"},{"disableproximityprompts [name]","Disable ProximityPrompts (all or matching)"},function(...)
	local term = Lower(Concat({...}," "))
	for _,obj in ipairs(interactTbl.proxy) do
		if obj and obj.Parent then
			if term=="" or Find(Lower(obj.Name), term) then
				obj.Enabled = false
			end
		end
	end
end,true)

proxyEnableLoopState = {active=false;}

cmd.add({"loopenableproximityprompts","loopenableprox","lenprox","lenpp"},{"loopenableproximityprompts [name]","Continuously enable ProximityPrompts (all or matching)"},function(...)
	local term = Lower(Concat({...}," "))
	if proxyEnableLoopState then proxyEnableLoopState.active=false end
	proxyEnableLoopState = {active=true}
	SpawnCall(function()
		while proxyEnableLoopState and proxyEnableLoopState.active do
			for _,obj in ipairs(interactTbl.proxy) do
				if obj and obj.Parent and obj:IsA("ProximityPrompt") then
					if term=="" or Find(Lower(obj.Name), term) then
						if obj.Enabled ~= true then obj.Enabled = true end
					end
				end
			end
			Wait(0.1)
		end
	end)
end,true)

cmd.add({"unloopenableproximityprompts","unloopenableprox","unlenprox","unlenpp"},{"unloopenableproximityprompts","Stop enabling loop"},function()
	if proxyEnableLoopState then
		proxyEnableLoopState.active=false
		proxyEnableLoopState=nil
	end
end)

cmd.add({"r6"},{"r6","Shows a prompt that will switch your character rig type into R6"},function()
	SafeGetService("AvatarEditorService"):PromptSaveAvatar(getPlrHum(LocalPlayer).HumanoidDescription,Enum.HumanoidRigType.R6)
	SafeGetService("AvatarEditorService").PromptSaveAvatarCompleted:Wait()
	getHum():ChangeState(Enum.HumanoidStateType.Dead)
	getHum().Health=0
end)

cmd.add({"r15"},{"r15","Shows a prompt that will switch your character rig type into R15"},function()
	SafeGetService("AvatarEditorService"):PromptSaveAvatar(getPlrHum(LocalPlayer).HumanoidDescription,Enum.HumanoidRigType.R15)
	SafeGetService("AvatarEditorService").PromptSaveAvatarCompleted:Wait()
	getHum():ChangeState(Enum.HumanoidStateType.Dead)
	getHum().Health=0
end)

cmd.add({"breakvelocity"},{"breakvelocity","Sets your character's velocity to zero momentarily"},function()
	local char=getChar()
	if not char then
		DoNotif("Character unavailable",2)
		return
	end
	local zero=Vector3.zero
	local stopAt=time()+1
	repeat
		for _,part in ipairs(char:GetDescendants()) do
			if part:IsA("BasePart") then
				NAlib.setProperty(part,"AssemblyLinearVelocity",zero)
				NAlib.setProperty(part,"AssemblyAngularVelocity",zero)
				NAlib.setProperty(part,"Velocity",zero)
				NAlib.setProperty(part,"RotVelocity",zero)
			end
		end
		Wait()
	until time()>=stopAt or not char.Parent
end)

cmd.add({"maxslopeangle", "msa"}, {"maxslopeangle (msa)", "Changes your character's MaxSlopeAngle"}, function(...)
	local args = {...}
	local amount = tonumber(args[1]) or 89

	local humanoid = getHum()
	if humanoid then
		humanoid.MaxSlopeAngle = amount
		DebugNotif(Format("Set MaxSlopeAngle to %s", tostring(amount)), 2)
	else
		DebugNotif("Humanoid not found or invalid.", 2)
	end
end,true)

-- garbage that needs to be changed to something else

NAStuff._godEnabled = NAStuff._godEnabled or false
NAStuff._godMethod  = NAStuff._godMethod  or "nohooks_strong"
NAStuff._godTarget  = NAStuff._godTarget  or 1e9
NAStuff._godOrig    = NAStuff._godOrig    or setmetatable({}, {__mode="k"})
NAStuff._godSignals = NAStuff._godSignals or setmetatable({}, {__mode="k"})
NAStuff._godHumRef  = NAStuff._godHumRef  or nil
NAStuff._godHooked  = NAStuff._godHooked  or false
NAStuff._godOldNC   = NAStuff._godOldNC   or nil
NAStuff._godOldNI   = NAStuff._godOldNI   or nil

NAmanage.God_ClearSignals = function()
	NAlib.disconnect("godmode")
	NAlib.disconnect("god_char")
	NAlib.disconnect("god_loops")
	for _,arr in pairs(NAStuff._godSignals) do
		for _,c in ipairs(arr) do if c then c:Disconnect() end end
	end
	for k in pairs(NAStuff._godSignals) do NAStuff._godSignals[k] = nil end
end

NAmanage.God_UnhookMeta = function()
	if NAStuff._godHooked and NAStuff._godOldNC and NAStuff._godOldNI and typeof(getrawmetatable)=="function" and typeof(setreadonly)=="function" then
		local mt = getrawmetatable(game)
		local ro = isreadonly and isreadonly(mt)
		if ro then setreadonly(mt,false) end
		mt.__namecall = NAStuff._godOldNC
		mt.__newindex = NAStuff._godOldNI
		if ro then setreadonly(mt,true) end
	end
	NAStuff._godHooked, NAStuff._godOldNC, NAStuff._godOldNI = false, nil, nil
end

NAmanage.God_CommonApply = function(h)
	if not h then return end
	NAStuff._godHumRef = h
	if NAStuff._godOrig[h] == nil then
		NAStuff._godOrig[h] = { max = h.MaxHealth, bjd = NAlib.isProperty(h,"BreakJointsOnDeath") }
	end
	if h.MaxHealth < NAStuff._godTarget then NAlib.setProperty(h,"MaxHealth", NAStuff._godTarget) end
	if h.Health < h.MaxHealth then NAlib.setProperty(h,"Health", h.MaxHealth) end
	if NAlib.isProperty(h,"BreakJointsOnDeath") ~= false then NAlib.setProperty(h,"BreakJointsOnDeath", false) end
end

NAmanage.God_WireNoHooks = function(h, strong)
	if not h then return end
	if NAStuff._godSignals[h] then for _,c in ipairs(NAStuff._godSignals[h]) do if c then c:Disconnect() end end end
	NAStuff._godSignals[h] = {}
	Insert(NAStuff._godSignals[h], NAlib.connect("godmode", h.HealthChanged:Connect(function()
		if h.Health < h.MaxHealth then NAlib.setProperty(h,"Health", h.MaxHealth) end
	end)))
	Insert(NAStuff._godSignals[h], NAlib.connect("godmode", h:GetPropertyChangedSignal("Health"):Connect(function()
		if h.Health < h.MaxHealth then NAlib.setProperty(h,"Health", h.MaxHealth) end
	end)))
	Insert(NAStuff._godSignals[h], NAlib.connect("godmode", h:GetPropertyChangedSignal("MaxHealth"):Connect(function()
		if h.MaxHealth < NAStuff._godTarget then NAlib.setProperty(h,"MaxHealth", NAStuff._godTarget) end
		if h.Health < h.MaxHealth then NAlib.setProperty(h,"Health", h.MaxHealth) end
	end)))
	if strong then
		Insert(NAStuff._godSignals[h], NAlib.connect("godmode", h:GetPropertyChangedSignal("BreakJointsOnDeath"):Connect(function()
			if NAlib.isProperty(h,"BreakJointsOnDeath") ~= false then NAlib.setProperty(h,"BreakJointsOnDeath", false) end
		end)))
		Insert(NAStuff._godSignals[h], NAlib.connect("godmode", h.StateChanged:Connect(function(_, s)
			if s == Enum.HumanoidStateType.Dead then
				if h.Health < h.MaxHealth then NAlib.setProperty(h,"Health", h.MaxHealth) end
				pcall(function() h:SetStateEnabled(Enum.HumanoidStateType.Dead, false) end)
				pcall(function() h:ChangeState(Enum.HumanoidStateType.Running) end)
			end
		end)))
		Insert(NAStuff._godSignals[h], NAlib.connect("godmode", h.Died:Connect(function()
			if h.Health < h.MaxHealth then NAlib.setProperty(h,"Health", h.MaxHealth) end
			pcall(function() h:SetStateEnabled(Enum.HumanoidStateType.Dead, false) end)
			pcall(function() h:ChangeState(Enum.HumanoidStateType.Running) end)
		end)))
		pcall(function() h:SetStateEnabled(Enum.HumanoidStateType.Dead, false) end)
		if h:GetState() == Enum.HumanoidStateType.Dead then pcall(function() h:ChangeState(Enum.HumanoidStateType.Running) end) end
	end
	NAlib.connect("god_loops", RunService.RenderStepped:Connect(function()
		local hh = getHum()
		if not hh then return end
		NAStuff._godHumRef = hh
		if hh.MaxHealth < NAStuff._godTarget then NAlib.setProperty(hh,"MaxHealth", NAStuff._godTarget) end
		if hh.Health < hh.MaxHealth then NAlib.setProperty(hh,"Health", hh.MaxHealth) end
		if strong then
			if NAlib.isProperty(hh,"BreakJointsOnDeath") ~= false then NAlib.setProperty(hh,"BreakJointsOnDeath", false) end
			pcall(function() hh:SetStateEnabled(Enum.HumanoidStateType.Dead, false) end)
			if hh:GetState() == Enum.HumanoidStateType.Dead then pcall(function() hh:ChangeState(Enum.HumanoidStateType.Running) end) end
		end
	end))
	NAlib.connect("god_loops", RunService.Stepped:Connect(function()
		local hh = getHum()
		if hh and hh.Health < hh.MaxHealth then NAlib.setProperty(hh,"Health", hh.MaxHealth) end
	end))
	NAlib.connect("god_loops", RunService.Heartbeat:Connect(function()
		local hh = getHum()
		if hh and hh.Health < hh.MaxHealth then NAlib.setProperty(hh,"Health", hh.MaxHealth) end
	end))
end

NAmanage.God_HookMeta = function()
	if NAStuff._godHooked or not (typeof(hookmetamethod)=="function" and typeof(getnamecallmethod)=="function" and typeof(newcclosure)=="function") then return false end
	NAStuff._godHooked = true
	NAStuff._godOldNC = NAStuff._godOldNC or hookmetamethod(game,"__namecall",newcclosure(function(self,...)
		local m = getnamecallmethod()
		local hum = NAStuff._godHumRef
		if hum and typeof(self)=="Instance" then
			if self==hum and m=="ChangeState" then local st = ...; if st==Enum.HumanoidStateType.Dead then return end end
			if self==hum and m=="SetStateEnabled" then local st,en = ...; if st==Enum.HumanoidStateType.Dead and en==true then return end end
			if self==hum and m=="Destroy" then return end
			local char = Players.LocalPlayer.Character
			if char and self==char and m=="BreakJoints" then return end
		end
		return NAStuff._godOldNC(self,...)
	end))
	NAStuff._godOldNI = NAStuff._godOldNI or hookmetamethod(game,"__newindex",newcclosure(function(self,k,v)
		local hum = NAStuff._godHumRef
		if hum and self==hum then
			if k=="Health" and type(v)=="number" and v<=0 then return end
			if k=="MaxHealth" and type(v)=="number" and v<NAStuff._godTarget then return end
			if k=="BreakJointsOnDeath" and v==true then return end
			if k=="Parent" and v==nil then return end
		end
		return NAStuff._godOldNI(self,k,v)
	end))
	return true
end

NAmanage.God_Enable = function(method)
	NAmanage.God_ClearSignals()
	NAmanage.God_UnhookMeta()
	NAStuff._godMethod = method or NAStuff._godMethod
	local lp = Players.LocalPlayer
	local h = getHum()
	if not h then
		NAlib.connect("god_char", lp.CharacterAdded:Connect(function(char)
			local c; c = char.DescendantAdded:Connect(function(inst) if inst:IsA("Humanoid") then c:Disconnect(); NAmanage.God_Enable(NAStuff._godMethod) end end)
		end))
		return
	end
	NAStuff._godEnabled = true
	NAmanage.God_CommonApply(h)
	if NAStuff._godMethod == "hook_meta" then
		NAmanage.God_WireNoHooks(h, true)
		NAmanage.God_HookMeta()
	else
		NAmanage.God_WireNoHooks(h, true)
	end
	NAlib.connect("god_char", lp.CharacterAdded:Connect(function(char)
		Wait()
		local nh = getHum()
		if nh then
			NAmanage.God_CommonApply(nh)
			if NAStuff._godMethod=="hook_meta" then
				NAmanage.God_WireNoHooks(nh, true)
				NAmanage.God_HookMeta()
			else
				NAmanage.God_WireNoHooks(nh, true)
			end
		end
	end))
end

NAmanage.God_Disable = function()
	NAStuff._godEnabled = false
	NAmanage.God_ClearSignals()
	NAmanage.God_UnhookMeta()
	local h = getHum()
	local o = h and NAStuff._godOrig[h]
	if h and o then
		NAlib.setProperty(h,"MaxHealth", o.max or 100)
		if o.bjd ~= nil then NAlib.setProperty(h,"BreakJointsOnDeath", o.bjd) end
		pcall(function() h:SetStateEnabled(Enum.HumanoidStateType.Dead, true) end)
	end
	for k in pairs(NAStuff._godOrig) do NAStuff._godOrig[k] = nil end
	NAStuff._godHumRef = nil
end

cmd.add({"godmode","god"},{"godmode (god)","Pick and enable an invincibility method"},function(...)
	local args = {...}
	local choice = args[1] and Lower(args[1]) or nil
	local useHooking = (typeof(hookmetamethod)=="function" and typeof(getnamecallmethod)=="function" and typeof(newcclosure)=="function")

	local function enableStrong()
		NAStuff._godMethod = "strong"
		if NAmanage and NAmanage.God_Enable then
			NAmanage.God_Enable("nohooks_strong")
		end
		DebugNotif("Godmode ON (strong)",2)
	end

	local function enableHooking()
		NAStuff._godMethod = "hooking"
		if not useHooking then
			DebugNotif("Hooking unavailable; falling back to strong",2)
			return enableStrong()
		end
		if NAmanage and NAmanage.God_Enable then
			NAmanage.God_Enable("hook_meta")
		end
		DebugNotif("Godmode ON (hooking)",2)
	end

	local function disableGod()
		if NAmanage and NAmanage.God_Disable then
			NAmanage.God_Disable()
			DebugNotif("Godmode OFF",2)
		else
			NAlib.disconnect("godmode")
			DebugNotif("Godmode OFF",2)
		end
	end

	if choice == "strong" then return enableStrong() end
	if choice == "hook" or choice == "hooking" then return enableHooking() end
	if choice == "off" or choice == "disable" then return disableGod() end

	local buttons = {}
	Insert(buttons, { Text = "Enable: Strong (no hooks)",   Callback = enableStrong })
	Insert(buttons, { Text = "Enable: Hooking (metamethod)", Callback = enableHooking })
	if NAStuff._godEnabled then
		Insert(buttons, { Text = "Disable Godmode", Callback = disableGod })
	end

	Window({
		Title = "Godmode Methods",
		Buttons = buttons
	})
end)

cmd.add({"ungodmode","ungod"},{"ungodmode (ungod)","Disable invincibility"},function()
	NAmanage.God_Disable()
end)

cmd.add({"controllock","ctrllock"},{"controllock (ctrllock)","Set Shiftlock keys to Control for this session"},function()
	if not IsOnPC then DebugNotif("PC-only feature") return end
	NAmanage.ControlLock_Apply("LeftControl,RightControl")
end)

cmd.add({"uncontrollock","unctrllock"},{"uncontrollock (unctrllock)","Restore Shiftlock keys to default (Shift)"},function()
	if not IsOnPC then DebugNotif("PC-only feature") return end
	NAmanage.ControlLock_Apply("LeftShift,RightShift")
end)

cmd.add({"resetlock"}, {"resetlock", "Resets your Shiftlock keybinds to default (LeftShift)"}, function()
	local player = LocalPlayer
	local mouseLockController = player:WaitForChild("PlayerScripts"):WaitForChild("PlayerModule"):WaitForChild("CameraModule"):WaitForChild("MouseLockController")
	local boundKeys = mouseLockController:WaitForChild("BoundKeys")

	boundKeys.Value = "LeftShift,RightShift"

	DebugNotif("Reset your Shiftlock keybinds to Shift")
end)

cmd.add({"autoreport"}, {"autoreport", "Automatically reports players to get them banned"}, function()
	local ReportKeywords = {
		kid = "Bullying",
		youtube = "Offsite Links",
		date = "Dating",
		hack = "Cheating/Exploiting",
		idiot = "Bullying",
		fat = "Bullying",
		exploit = "Cheating/Exploiting",
		cheat = "Cheating/Exploiting",
		noob = "Bullying",
		clown = "Bullying",
	}

	local function CheckIfReportable(message)
		message = message:lower()
		for keyword, reason in pairs(ReportKeywords) do
			if message:find(keyword) then
				return keyword, reason
			end
		end
		return nil, nil
	end

	local function MonitorPlayerChat(player)
		if player == LocalPlayer then return end

		player.Chatted:Connect(function(message)
			local keyword, reason = CheckIfReportable(message)
			if keyword and reason then
				DebugNotif(Format("Reported %s", nameChecker(player)).." | "..Format("Reason - %s", reason))

				if reportplayer then
					reportplayer(player, reason, Format("Saying %s", keyword))
				else
					SafeGetService("Players"):ReportAbuse(player, reason, Format("Saying %s", keyword))
				end
			end
		end)
	end

	for _, player in ipairs(SafeGetService("Players"):GetPlayers()) do
		MonitorPlayerChat(player)
	end

	SafeGetService("Players").PlayerAdded:Connect(function(player)
		MonitorPlayerChat(player)
	end)
end)

cmd.add({"light"},{"light <range> <brightness> <hexColor>","Gives your player dynamic light"},function(rangeStr,brightnessStr,colorHex)
	local range     = tonumber(rangeStr)   or settingsLight.range
	local brightness= tonumber(brightnessStr)or settingsLight.brightness
	local color     = settingsLight.color
	if colorHex and #colorHex>0 then
		local hex = colorHex:match("^#?(%x+)")
		if hex and (#hex==6 or #hex==3) then
			if #hex==3 then hex = hex:gsub(".", function(c) return c..c end) end
			local r = tonumber(hex:sub(1,2),16)/255
			local g = tonumber(hex:sub(3,4),16)/255
			local b = tonumber(hex:sub(5,6),16)/255
			color = Color3.new(r,g,b)
		end
	end

	local root = getRoot(Player.Character)
	if not root then return end

	local light = settingsLight.LIGHTER
	if not light or not light.Parent then
		light = InstanceNew("PointLight")
		settingsLight.LIGHTER = light
	end

	light.Parent     = root
	light.Range      = range
	light.Brightness = brightness
	light.Color      = color
end, true)

cmd.add({"unlight","nolight"},{"unlight (nolight)","Removes dynamic light from your player"},function()
	if settingsLight.LIGHTER then
		settingsLight.LIGHTER:Destroy()
		settingsLight.LIGHTER = nil
	end
end)

cmd.add({"lighting","lightingcontrol"},{"lighting (lightingcontrol)","Manage lighting technology settings"},function(...)
	local args = {...}
	local target = args[1]
	local buttons = {}
	local function applyLightingTechnology(tech)
		if not Lighting or not tech then
			return
		end
		Lighting.Technology = tech
		local style = tech == Enum.Technology.Future and Enum.LightingStyle.Realistic or Enum.LightingStyle.Soft
		NAlib.setProperty(Lighting, "LightingStyle", style)
	end
	for _, lt in ipairs(Enum.Technology:GetEnumItems()) do
		Insert(buttons, {
			Text = lt.Name,
			Callback = function()
				applyLightingTechnology(lt)
			end
		})
	end
	if target and target ~= "" then
		local found = false
		for _, btn in ipairs(buttons) do
			if Match(Lower(btn.Text), Lower(target)) then
				btn.Callback()
				DebugNotif("Lighting technology set to "..btn.Text, 3)
				found = true
				break
			end
		end
		if not found then
			DebugNotif("No matching lighting tech for: "..target, 3)
		end
	else
		Window({
			Title = "Lighting Technology Options",
			Buttons = buttons
		})
	end
end)

cmd.add({"friend"}, {"friend <player>", "Sends a friend request to your target"}, function(p)
	local tg = getPlr(p)

	local function dlg()
		local rg = COREGUI:FindFirstChild("RobloxGui")
		if not rg then return nil end
		return rg:FindFirstChild("PromptDialog", true) or rg:FindFirstChild("RobloxPromptGui", true)
	end

	local function waitPrompt()
		local t0 = os.clock()
		while os.clock() - t0 < 2.5 do
			if dlg() then break end
			Wait()
		end
		t0 = os.clock()
		while os.clock() - t0 < 60 do
			local d = dlg()
			if not d then break end
			if d:IsA("GuiObject") and not d.Visible then break end
			Wait()
		end
	end

	for _, t in ipairs(tg) do
		if t and t ~= LocalPlayer and not LocalPlayer:IsFriendsWith(t.UserId) then
			local ok = pcall(function()
				StarterGui:SetCore("PromptSendFriendRequest", t)
			end)
			if ok then
				waitPrompt()
			else
				pcall(function()
					LocalPlayer:RequestFriendship(t)
				end)
			end
		end
	end
end, true)

cmd.add({"unfriend"}, {"unfriend <player>", "Prompts to unfriend your target"}, function(p)
	local tg = getPlr(p)

	local function dlg()
		local rg = COREGUI:FindFirstChild("RobloxGui")
		if not rg then return nil end
		return rg:FindFirstChild("PromptDialog", true) or rg:FindFirstChild("RobloxPromptGui", true)
	end

	local function waitPrompt()
		local t0 = os.clock()
		while os.clock() - t0 < 2.5 do
			if dlg() then break end
			Wait()
		end
		t0 = os.clock()
		while os.clock() - t0 < 60 do
			local d = dlg()
			if not d then break end
			if d:IsA("GuiObject") and not d.Visible then break end
			Wait()
		end
	end

	for _, t in ipairs(tg) do
		if t and t ~= LocalPlayer and LocalPlayer:IsFriendsWith(t.UserId) then
			local ok = pcall(function()
				StarterGui:SetCore("PromptUnfriend", t)
			end)
			if ok then
				waitPrompt()
			else
				pcall(function()
					LocalPlayer:RevokeFriendship(t)
				end)
			end
		end
	end
end, true)

cmd.add({"block","blockuser"},{"block <player> (blockuser)","Open block / unblock prompt for target player"},function(p)
	local tg = getPlr(p)
	for _,t in ipairs(tg) do
		if t ~= LocalPlayer then
			StarterGui:SetCore("PromptBlockPlayer",t)
		end
	end
end,true)

NAmanage.NAgetFriendCircles=function()
	local players = Players:GetPlayers()
	local graph, seen, groups = {}, {}, {}
	local friendSets = {}

	for _, plr in ipairs(players) do
		graph[plr] = {}
	end

	local function getFriendSet(plr)
		if friendSets[plr] then
			return friendSets[plr]
		end
		local set = {}
		local ok, pages = pcall(Players.GetFriendsAsync, Players, plr.UserId)
		if ok and pages then
			local function addPage(page)
				for _, item in ipairs(page) do
					if item and item.Id then
						set[item.Id] = true
					end
				end
			end
			addPage(pages:GetCurrentPage())
			while pages.IsFinished ~= nil and pages.IsFinished == false do
				local okN, nextPage = pcall(pages.AdvanceToNextPageAsync, pages)
				if not okN or not nextPage then
					break
				end
				addPage(nextPage)
			end
		end
		friendSets[plr] = set
		return set
	end

	for i = 1, #players do
		local p1 = players[i]
		local set1 = getFriendSet(p1)
		for j = i + 1, #players do
			local p2 = players[j]
			if set1[p2.UserId] then
				Insert(graph[p1], p2)
				Insert(graph[p2], p1)
			end
		end
	end

	local function dfs(plr, group)
		seen[plr] = true
		Insert(group, plr)
		for _, other in ipairs(graph[plr]) do
			if not seen[other] then
				dfs(other, group)
			end
		end
	end

	for _, plr in ipairs(players) do
		if not seen[plr] then
			local group = {}
			dfs(plr, group)
			Insert(groups, group)
		end
	end

	table.sort(groups, function(a, b)
		return #a > #b
	end)

	return groups, graph
end

cmd.add({"friendweb","fweb"},{"friendweb (fweb)","Finds friend circles in the current server"},function()
	DoNotif("Looking for friend circles... I'll let you know what I find.", 4)

	local groups, graph = NAmanage.NAgetFriendCircles()
	local useDisplayNames = false
	local ok, enabled = pcall(function()
		return StarterGui and StarterGui:GetCoreGuiEnabled(Enum.CoreGuiType.PlayerList)
	end)
	if ok and enabled then
		useDisplayNames = true
	end

	local lines = {}
	local index = 1
	for _, group in ipairs(groups) do
		if #group > 1 then
			table.sort(group, function(a, b)
				return (useDisplayNames and a.DisplayName or a.Name) < (useDisplayNames and b.DisplayName or b.Name)
			end)
			local edgeCount = 0
			local parts = {}
			for _, plr in ipairs(group) do
				local deg = graph[plr] and #graph[plr] or 0
				edgeCount += deg
				parts[#parts + 1] = Format("%s [%d]", useDisplayNames and plr.DisplayName or plr.Name, deg)
			end
			edgeCount = math.floor(edgeCount / 2)
			Insert(lines, Format("%d) %s (links: %d)", index, Concat(parts, ", "), edgeCount))
			index = index + 1
		end
	end

	local groupsFound = #lines
	local body = (groupsFound == 0) and "No friend circles found in this server." or ("Here are the circles I found:\n"..Concat(lines, "\n"))
	DoNotif(Format("Friend scan finished: %d circle%s found.", groupsFound, groupsFound == 1 and "" or "s"), 4, "Friend Web")
	DoPopup({ Title = "Friend Circles", Description = body })
end)

cmd.add({"tweengotocampos","tweentocampos","tweentcp"}, {"tweengotocampos (tweentcp)","Another version of goto camera position but bypassing more anti-cheats"}, function()
	local player = Players.LocalPlayer;
	local TweenService = TweenService;
	function teleportPlayer()
		local character = player.Character or player.CharacterAdded:wait(1);
		local camera = workspace.CurrentCamera;
		local cameraPosition = camera.CFrame.Position;
		local tween = TweenService:Create(character.PrimaryPart, TweenInfo.new(NAmanage.resolveTweenDuration(2)), {
			CFrame = CFrame.new(cameraPosition)
		});
		tween:Play();
	end;
	local camera = workspace.CurrentCamera;
	repeat
		Wait();
	until camera.CFrame ~= CFrame.new();
	teleportPlayer();
end);

cmd.add({"delete","remove","del"}, {"delete {partname} (remove, del)","Removes any part with a certain name from the workspace"}, function(...)
	local deleteCount = 0;
	local args = {
		...
	};
	local targetName = Concat(args, " ");
	for _, d in pairs(workspace:GetDescendants()) do
		if d.Name:lower() == targetName:lower() then
			d:Destroy();
			deleteCount = deleteCount + 1;
		end;
	end;
	Wait();
	if deleteCount > 0 then
		DebugNotif("Deleted " .. deleteCount .. " instance(s) of '" .. targetName .. "'", 2.5);
	else
		DebugNotif("'" .. targetName .. "' not found to delete", 2.5);
	end;
end, true);

cmd.add({"deletefind", "removefind", "delfind"}, {"deletefind {partname} (removefind, delfind)", "Removes any part with a name containing the given text from the workspace"}, function(...)
	local deFind = 0
	local targetName = Concat({...}, " "):lower()

	for _, d in pairs(workspace:GetDescendants()) do
		if d.Name:lower():find(targetName) then
			d:Destroy()
			deFind = deFind + 1
		end
	end

	Wait()

	if deFind > 0 then
		DebugNotif("Deleted "..deFind.." instance(s) containing '"..targetName.."'", 2.5)
	else
		DebugNotif("No instances found containing '"..targetName.."'", 2.5)
	end
end, true)

cmd.add({"deletelighting", "removelighting", "removel", "ldel"},{"deletelighting (removelighting, removel, ldel)","Removes all descendants (objects) within Lighting."},function()
	for _, l in ipairs(Lighting:GetDescendants()) do
		l:Destroy()
	end
end)

cmd.add({"lightingdisable", "disablelighting", "ldisable"},{"lightingdisable (disablelighting, ldisable)", "Disables all post-processing effects in Lighting instead of deleting them."},function()
	for _, inst in ipairs(Lighting:GetDescendants()) do
		if inst:IsA("PostEffect") then
			inst.Enabled = false
		end
	end
end)

autoRemover = {}
autoRemoveConnection = nil

function handleDescendantAdd(part)
	if #autoRemover > 0 then
		if FindInTable(autoRemover, part.Name:lower()) then
			Defer(function()
				if part and part.Parent then
					part:Destroy()
				end
			end)
		end
	else
		if autoRemoveConnection then
			autoRemoveConnection:Disconnect()
			autoRemoveConnection = nil
		end
	end
end

cmd.add({"autodelete", "autoremove", "autodel"}, {"autodelete {partname} (autoremove, autodel)", "Removes any part with a certain name from the workspace on loop"}, function(...)
	local args = {...}
	local targetName = Concat(args, " "):lower()

	if not FindInTable(autoRemover, targetName) then
		Insert(autoRemover, targetName)
		for _, part in pairs(workspace:GetDescendants()) do
			if part.Name:lower() == targetName then
				part:Destroy()
			end
		end
	end

	if not autoRemoveConnection then
		autoRemoveConnection = workspace.DescendantAdded:Connect(handleDescendantAdd)
	end

	Wait()
	DebugNotif("Auto deleting instances with name: "..targetName, 2.5)
end, true)

cmd.add({"unautodelete", "unautoremove", "unautodel"}, {"unautodelete {partname} (unautoremove, unautodel)", "Disables autodelete"}, function(...)
	if type(autoRemover) ~= "table" then
		autoRemover = {}
	end

	if #autoRemover == 0 then
		DoNotif("No autodelete names are active.", 2)
		return
	end

	local filter = Lower(Concat({...}, " "))

	local function disconnectAutoRemove()
		if autoRemoveConnection then
			autoRemoveConnection:Disconnect()
			autoRemoveConnection = nil
		end
	end

	local function cleanupConnection()
		if #autoRemover == 0 then
			disconnectAutoRemove()
		end
	end

	local function removeAll()
		autoRemover = {}
		disconnectAutoRemove()
		DoNotif("Cleared all autodelete names.", 2)
	end

	local function removeByTerm(term)
		for i = #autoRemover, 1, -1 do
			if autoRemover[i] == term then
				table.remove(autoRemover, i)
			end
		end
		cleanupConnection()
		DoNotif("Stopped autodeleting '"..term.."'.", 2)
	end

	if filter ~= "" then
		if filter == "all" then
			removeAll()
			return
		end
		local picked = nil
		for _, t in ipairs(autoRemover) do
			if t == filter then
				picked = t
				break
			end
		end
		if not picked then
			for _, t in ipairs(autoRemover) do
				if Match(t, filter) then
					picked = t
					break
				end
			end
		end
		if picked then
			removeByTerm(picked)
		else
			DoNotif("No matching autodelete name for: "..filter, 3)
		end
		return
	end

	local buttons = {}
	Insert(buttons, { Text = "All", Callback = removeAll })
	for _, t in ipairs(autoRemover) do
		Insert(buttons, { Text = t, Callback = function() removeByTerm(t) end })
	end

	Window({
		Title = "AutoDelete Names",
		Description = "Choose a tracked name to stop deleting (future spawns included).",
		Buttons = buttons
	})
end)

autoFinder = {}
finderConn = nil

function onAdd(obj)
	if #autoFinder > 0 then
		for _, kw in pairs(autoFinder) do
			if obj.Name:lower():find(kw) then
				Defer(function()
					if obj and obj.Parent then
						obj:Destroy()
					end
				end)
				break
			end
		end
	else
		if finderConn then
			finderConn:Disconnect()
			finderConn = nil
		end
	end
end

cmd.add({"autodeletefind", "autoremovefind", "autodelfind"}, {"autodeletefind {name} (autoremovefind, autodelfind)", "Auto removes parts with names containing text"}, function(...)
	local args = {...}
	local kw = Concat(args, " "):lower()

	if not FindInTable(autoFinder, kw) then
		Insert(autoFinder, kw)
		for _, obj in pairs(workspace:GetDescendants()) do
			if obj.Name:lower():find(kw) then
				obj:Destroy()
			end
		end
	end

	if not finderConn then
		finderConn = workspace.DescendantAdded:Connect(onAdd)
	end

	Wait()
	DebugNotif("Auto deleting parts containing: "..kw, 2.5)
end, true)

cmd.add({"unautodeletefind", "unautoremovefind", "unautodelfind"}, {"unautodeletefind (unautoremovefind,unautodelfind)", "Stops autodeletefind"}, function(...)
	if type(autoFinder) ~= "table" then
		autoFinder = {}
	end

	if #autoFinder == 0 then
		DoNotif("No autodeletefind keywords are active.", 2)
		return
	end

	local filter = Lower(Concat({...}, " "))

	local function disconnectFinder()
		if finderConn then
			finderConn:Disconnect()
			finderConn = nil
		end
	end

	local function cleanupConnection()
		if #autoFinder == 0 then
			disconnectFinder()
		end
	end

	local function removeAll()
		autoFinder = {}
		disconnectFinder()
		DoNotif("Cleared all autodeletefind keywords.", 2)
	end

	local function removeByTerm(term)
		for i = #autoFinder, 1, -1 do
			if autoFinder[i] == term then
				table.remove(autoFinder, i)
			end
		end
		cleanupConnection()
		DoNotif("Stopped autodeleting parts containing '"..term.."'.", 2)
	end

	if filter ~= "" then
		if filter == "all" then
			removeAll()
			return
		end
		local picked = nil
		for _, t in ipairs(autoFinder) do
			if t == filter then
				picked = t
				break
			end
		end
		if not picked then
			for _, t in ipairs(autoFinder) do
				if Match(t, filter) then
					picked = t
					break
				end
			end
		end
		if picked then
			removeByTerm(picked)
		else
			DoNotif("No matching autodeletefind keyword for: "..filter, 3)
		end
		return
	end

	local buttons = {}
	Insert(buttons, { Text = "All", Callback = removeAll })
	for _, t in ipairs(autoFinder) do
		Insert(buttons, { Text = t, Callback = function() removeByTerm(t) end })
	end

	Window({
		Title = "AutoDeleteFind Keywords",
		Description = "Select a keyword to stop clearing matching descendants.",
		Buttons = buttons
	})
end)

cmd.add({"deleteclass", "removeclass", "dc"}, {"deleteclass {ClassName} (removeclass, dc)", "Removes any part with a certain classname from the workspace"}, function(...)
	local args = {...}
	local targetClass = args[1]:lower()
	local deleteCount = 0

	for _, part in pairs(workspace:GetDescendants()) do
		if part.ClassName:lower() == targetClass then
			part:Destroy()
			deleteCount = deleteCount + 1
		end
	end

	Wait()
	if deleteCount > 0 then
		DebugNotif("Deleted "..deleteCount.." instance(s) of class: "..targetClass, 2.5)
	else
		DebugNotif("No instances of class: "..targetClass.." found to delete", 2.5)
	end
end, true)

NAStuff.autoClassRemover = {}
NAStuff.autoClassConnection = nil

function handleClassDescendantAdd(part)
	if #NAStuff.autoClassRemover > 0 then
		if FindInTable(NAStuff.autoClassRemover, part.ClassName:lower()) then
			Defer(function()
				if part and part.Parent then
					part:Destroy()
				end
			end)
		end
	else
		if NAStuff.autoClassConnection then
			NAStuff.autoClassConnection:Disconnect()
			NAStuff.autoClassConnection = nil
		end
	end
end

cmd.add({"autodeleteclass", "autoremoveclass", "autodc"}, {"autodeleteclass {ClassName} (autoremoveclass, autodc)", "Removes any part with a certain classname from the workspace on loop"}, function(...)
	local args = {...}
	local targetClass = args[1]:lower()

	if not FindInTable(NAStuff.autoClassRemover, targetClass) then
		Insert(NAStuff.autoClassRemover, targetClass)
		for _, part in pairs(workspace:GetDescendants()) do
			if part.ClassName:lower() == targetClass then
				part:Destroy()
			end
		end
	end

	if not NAStuff.autoClassConnection then
		NAStuff.autoClassConnection = workspace.DescendantAdded:Connect(handleClassDescendantAdd)
	end

	Wait()
	DebugNotif("Auto deleting instances with class: "..targetClass, 2.5)
end, true)

cmd.add({"unautodeleteclass", "unautoremoveclass", "unautodc"}, {"unautodeleteclass {ClassName} (unautoremoveclass, unautodc)", "Disables autodeleteclass"}, function(...)
	if type(NAStuff.autoClassRemover) ~= "table" then
		NAStuff.autoClassRemover = {}
	end

	if #NAStuff.autoClassRemover == 0 then
		DoNotif("No autodeleteclass entries are active.", 2)
		return
	end

	local filter = Lower(Concat({...}, " "))

	local function disconnectClass()
		if NAStuff.autoClassConnection then
			NAStuff.autoClassConnection:Disconnect()
			NAStuff.autoClassConnection = nil
		end
	end

	local function cleanupConnection()
		if #NAStuff.autoClassRemover == 0 then
			disconnectClass()
		end
	end

	local function removeAll()
		NAStuff.autoClassRemover = {}
		disconnectClass()
		DoNotif("Cleared all autodeleteclass entries.", 2)
	end

	local function removeByTerm(term)
		for i = #NAStuff.autoClassRemover, 1, -1 do
			if NAStuff.autoClassRemover[i] == term then
				table.remove(NAStuff.autoClassRemover, i)
			end
		end
		cleanupConnection()
		DoNotif("Stopped autodeleting class '"..term.."'.", 2)
	end

	if filter ~= "" then
		if filter == "all" then
			removeAll()
			return
		end
		local picked = nil
		for _, t in ipairs(NAStuff.autoClassRemover) do
			if t == filter then
				picked = t
				break
			end
		end
		if not picked then
			for _, t in ipairs(NAStuff.autoClassRemover) do
				if Match(t, filter) then
					picked = t
					break
				end
			end
		end
		if picked then
			removeByTerm(picked)
		else
			DoNotif("No matching autodeleteclass term for: "..filter, 3)
		end
		return
	end

	local buttons = {}
	Insert(buttons, { Text = "All", Callback = removeAll })
	for _, t in ipairs(NAStuff.autoClassRemover) do
		Insert(buttons, { Text = t, Callback = function() removeByTerm(t) end })
	end

	Window({
		Title = "AutoDeleteClass",
		Description = "Pick a class name to stop auto deleting.",
		Buttons = buttons
	})
end)

cmd.add({"chardelete", "charremove", "chardel", "cdelete", "cremove", "cdel"}, {"chardelete {partname} (charremove, chardel, cdelete, cremove, cdel)", "Removes any part with a certain name from your character"}, function(...)
	local args = {...}
	local targetName = Concat(args, " "):lower()
	local deleteCount = 0

	for _, part in pairs(Player.Character:GetDescendants()) do
		if part.Name:lower() == targetName then
			part:Destroy()
			deleteCount = deleteCount + 1
		end
	end

	Wait()
	if deleteCount > 0 then
		DebugNotif("Deleted "..deleteCount.." instance(s) of '"..targetName.."' inside the character", 2.5)
	else
		DebugNotif("'"..targetName.."' not found in the character", 2.5)
	end
end, true)

cmd.add({"chardeletefind", "charremovefind", "chardelfind", "cdeletefind", "cremovefind", "cdelfind"}, {"chardeletefind {name} (charremovefind, chardelfind, cdeletefind, cremovefind, cdelfind)", "Removes parts in your character with names containing text"}, function(...)
	local args = {...}
	local kw = Concat(args, " "):lower()
	local count = 0

	for _, obj in pairs(Player.Character:GetDescendants()) do
		if obj.Name:lower():find(kw) then
			obj:Destroy()
			count = count + 1
		end
	end

	Wait()
	if count > 0 then
		DebugNotif("Deleted "..count.." instance(s) containing '"..kw.."' in character", 2.5)
	else
		DebugNotif("Nothing found containing '"..kw.."' in character", 2.5)
	end
end, true)

cmd.add({"chardeleteclass", "charremoveclass", "chardeleteclassname", "cdc"}, {"chardeleteclass {ClassName} (charremoveclass, chardeleteclassname, cdc)", "Removes any part with a certain classname from your character"}, function(...)
	local args = {...}
	local targetClass = args[1]:lower()
	local deleteCount = 0

	for _, part in pairs(Player.Character:GetDescendants()) do
		if part.ClassName:lower() == targetClass then
			part:Destroy()
			deleteCount = deleteCount + 1
		end
	end

	Wait()
	if deleteCount > 0 then
		DebugNotif("Deleted "..deleteCount.." instance(s) of class: "..targetClass.." inside the character", 2.5)
	else
		DebugNotif("No instances of class: "..targetClass.." found in the character", 2.5)
	end
end, true)

NAStuff.activeTeleports = {};
originalIO.gotoNext = originalIO.gotoNext or {};

do
	local gotoNext = originalIO.gotoNext;
	local state = gotoNext.state or {
		teleporting = false,
		totalDuplicates = 0,
		duplicatesSessionOrder = {},
		tracerPart = nil,
		tracerConnection = nil,
		tracerHue = 0
	};
	gotoNext.state = state;
	function gotoNext.trim(str)
		if type(str) ~= "string" then
			return str;
		end;
		local trimmed = str:match("^%s*(.-)%s*$");
		return trimmed or str;
	end;
	function gotoNext.tokenizeArgs(rawArgs)
		local tokens = {};
		if not rawArgs or #rawArgs == 0 then
			return tokens;
		end;
		local combined = Concat(rawArgs, " ");
		if combined == "" then
			return tokens;
		end;
		local length = #combined;
		local index = 1;
		while index <= length do
			while index <= length and (combined:sub(index, index)):match("%s") do
				index = index + 1;
			end;
			if index > length then
				break;
			end;
			local ch = combined:sub(index, index);
			if ch == "\"" or ch == "'" then
				local quote = ch;
				index = index + 1;
				local buffer = {};
				while index <= length do
					local current = combined:sub(index, index);
					if current == quote then
						index = index + 1;
						break;
					end;
					buffer[(#buffer) + 1] = current;
					index = index + 1;
				end;
				tokens[(#tokens) + 1] = Concat(buffer);
			else
				local start = index;
				while index <= length and (not (combined:sub(index, index)):match("%s")) do
					index = index + 1;
				end;
				tokens[(#tokens) + 1] = combined:sub(start, index - 1);
			end;
		end;
		if #tokens == 0 then
			for _, value in ipairs(rawArgs) do
				if type(value) == "string" and value ~= "" then
					tokens[(#tokens) + 1] = value;
				end;
			end;
		end;
		for i = 1, #tokens do
			tokens[i] = gotoNext.trim(tokens[i]);
		end;
		return tokens;
	end;
	function gotoNext.buildSearchNames(rawPrefix, normalizedPrefix, index)
		local variants = {};
		local seen = {};
		local function add(name)
			if not name or name == "" then
				return;
			end;
			local canonical = name:lower();
			if not seen[canonical] then
				variants[(#variants) + 1] = name;
				seen[canonical] = true;
			end;
		end;
		local idx = tostring(index);
		add(idx);
		local normalized = normalizedPrefix and gotoNext.trim(normalizedPrefix) or nil;
		if normalized and normalized ~= "" then
			add(normalized .. " " .. idx);
			add(normalized .. idx);
		end;
		if rawPrefix and rawPrefix ~= "" then
			if not rawPrefix:match("%s$") then
				add(rawPrefix .. " " .. idx);
			end;
			add(rawPrefix .. idx);
		end;
		return variants;
	end;
	function gotoNext.extractIndexedToken(token)
		if type(token) ~= "string" then
			return nil;
		end;
		if token == "" then
			return nil;
		end;
		local head, digits = token:match("^(.-)(%-?%d+)%s*$");
		if not digits then
			return nil;
		end;
		local rawPrefix = head;
		local normalized = gotoNext.trim(rawPrefix or "");
		if normalized == "" then
			normalized = nil;
			rawPrefix = nil;
		end;
		return {
			raw = rawPrefix,
			normalized = normalized,
			number = tonumber(digits)
		};
	end;
	function gotoNext.sessionKey(objectType, normalizedLower, index)
		local keyPrefix = gotoNext.trim(normalizedLower or "");
		if keyPrefix ~= "" then
			keyPrefix = keyPrefix:lower();
		end;
		return (objectType or "Part") .. "|" .. keyPrefix .. "|" .. tostring(index);
	end;
	function gotoNext.notify(message, duration)
		DoNotif(message, duration or 3, "GotoNext");
	end;
	function gotoNext.clearTracer()
		if state.tracerConnection then
			state.tracerConnection:Disconnect();
			state.tracerConnection = nil;
		end;
		if state.tracerPart and state.tracerPart.Parent then
			state.tracerPart:Destroy();
		end;
		state.tracerPart = nil;
	end;
	function gotoNext.setTracer(nextCFrame)
		gotoNext.clearTracer();
		if not nextCFrame then
			return;
		end;
		local tracer = InstanceNew("Part", workspace);
		tracer.Name = "NA_GotoNextTracer";
		tracer.Anchored = true;
		tracer.CanCollide = false;
		tracer.Material = Enum.Material.Neon;
		tracer.Size = Vector3.new(2, 2, 2);
		tracer.CFrame = nextCFrame + Vector3.new(0, 3, 0);
		tracer.TopSurface = Enum.SurfaceType.Smooth;
		tracer.BottomSurface = Enum.SurfaceType.Smooth;
		state.tracerPart = tracer;
		state.tracerHue = 0;
		state.tracerConnection = RunService.Heartbeat:Connect(function(dt)
			if not state.tracerPart or (not state.tracerPart.Parent) then
				gotoNext.clearTracer();
				return;
			end;
			state.tracerHue = (state.tracerHue + dt * 0.5) % 1;
			state.tracerPart.Color = Color3.fromHSV(state.tracerHue, 1, 1);
		end);
	end;
	function gotoNext.fullPath(inst)
		if not inst then
			return "Unknown";
		end;
		local segments = {
			inst.Name
		};
		local parent = inst.Parent;
		while parent do
			Insert(segments, 1, parent.Name);
			parent = parent.Parent;
		end;
		return Concat(segments, ".");
	end;
	function gotoNext.findMatches(objectType, targetName)
		local matches = {};
		if not targetName or targetName == "" then
			return matches;
		end;
		local targetLower = targetName:lower();
		local queue = {
			workspace
		};
		local index = 1;
		while queue[index] do
			local current = queue[index];
			index += 1;
			for _, child in ipairs(current:GetChildren()) do
				local isValid = false;
				if objectType == "Part" then
					isValid = child:IsA("BasePart");
				elseif objectType == "Model" then
					isValid = child:IsA("Model");
				elseif objectType == "Folder" then
					isValid = child:IsA("Folder");
				end;
				if isValid and child.Name and child.Name:lower() == targetLower then
					Insert(matches, {
						inst = child,
						parent = child.Parent
					});
				end;
				queue[(#queue) + 1] = child;
			end;
		end;
		return matches;
	end;
	function gotoNext.resolveCFrame(inst)
		if not inst then
			return nil;
		end;
		if inst:IsA("BasePart") then
			return inst.CFrame;
		elseif inst:IsA("Model") then
			local ok, pivot = pcall(function()
				return inst:GetPivot();
			end);
			if ok then
				return pivot;
			end;
			local primary = inst.PrimaryPart or inst:FindFirstChildWhichIsA("BasePart");
			if primary then
				return primary.CFrame;
			end;
		end;
		return nil;
	end;
	function gotoNext.teleportToInstance(inst)
		local char = getChar();
		if not char then
			return false;
		end;
		local targetCFrame = gotoNext.resolveCFrame(inst);
		if not targetCFrame then
			return false;
		end;
		local hum = getHum(char);
		if hum then
			hum.Sit = false;
		end;
		pcall(function()
			char:PivotTo(targetCFrame + Vector3.new(0, 4, 0));
		end);
		return true;
	end;
	function gotoNext.collectFolderParts(folder)
		local parts = {};
		for _, descendant in ipairs(folder:GetDescendants()) do
			if descendant:IsA("BasePart") then
				Insert(parts, descendant);
			end;
		end;
		table.sort(parts, function(a, b)
			return a:GetFullName() < b:GetFullName();
		end);
		return parts;
	end;
	function gotoNext.normalizeSelection(selection)
		local normalized = {};
		for _, inst in ipairs(selection or {}) do
			if inst and inst.Parent then
				Insert(normalized, {
					inst = inst,
					parent = inst.Parent
				});
			end;
		end;
		return normalized;
	end;
	function gotoNext.promptDuplicates(name, duplicates)
		local selectionEvent = InstanceNew("BindableEvent");
		local selected;
		local resolved = false;
		local window;
		local descriptionLines = {
			Format("Found %d duplicates for '%s'. Choose a starting instance or TP all.", #duplicates, name)
		};
		for idx, info in ipairs(duplicates) do
			Insert(descriptionLines, Format("%d) %s", idx, gotoNext.fullPath(info.inst)));
		end;
		local buttons = {};
		local function finalize(choice)
			if resolved then
				return;
			end;
			selected = choice;
			resolved = true;
			if window and window.Parent then
				window:Destroy();
			end;
			selectionEvent:Fire();
		end;
		for idx, info in ipairs(duplicates) do
			Insert(buttons, {
				Text = Format("Start #%d", idx),
				Callback = function()
					finalize({
						info.inst
					});
				end
			});
		end;
		Insert(buttons, {
			Text = Format("TP All (%d)", #duplicates),
			Callback = function()
				local all = {};
				for _, entry in ipairs(duplicates) do
					Insert(all, entry.inst);
				end;
				finalize(all);
			end
		});
		Insert(buttons, {
			Text = "Cancel",
			Callback = function()
				finalize(nil);
			end
		});
		window = Window({
			Title = "GotoNext",
			Description = Concat(descriptionLines, "\n"),
			Buttons = buttons
		});
		if window then
			window.AncestryChanged:Connect(function(_, parent)
				if not parent and (not resolved) then
					resolved = true;
					selected = nil;
					selectionEvent:Fire();
				end;
			end);
		end;
		selectionEvent.Event:Wait();
		selectionEvent:Destroy();
		return selected;
	end;
	function gotoNext.parseArgs(rawArgs)
		local tokens = gotoNext.tokenizeArgs(rawArgs);
		local args = {};
		for _, value in ipairs(tokens) do
			if type(value) == "string" and value ~= "" then
				Insert(args, value);
			end;
		end;
		local first = args[1];
		if not first then
			return nil, "Usage:\n- gotopartnext <start> [end] [delay]\n- gotopartnext <prefix> <start> [end] [delay]";
		end;
		local prefixRaw;
		local prefixNormalized;
		local startNum;
		local endNum;
		local delay;
		local function applyPrefix(rawCandidate, normalizedCandidate)
			if rawCandidate and rawCandidate ~= "" then
				if not prefixRaw then
					prefixRaw = rawCandidate;
				end;
			end;
			if normalizedCandidate and normalizedCandidate ~= "" then
				normalizedCandidate = gotoNext.trim(normalizedCandidate);
				if normalizedCandidate == "" then
					normalizedCandidate = nil;
				end;
			else
				normalizedCandidate = nil;
			end;
			if normalizedCandidate then
				if prefixNormalized and prefixNormalized ~= normalizedCandidate then
					return false;
				end;
				prefixNormalized = prefixNormalized or normalizedCandidate;
			end;
			if not prefixRaw and prefixNormalized then
				prefixRaw = prefixNormalized;
			end;
			return true;
		end;
		local second = args[2];
		local third = args[3];
		local fourth = args[4];
		local firstNumeric = tonumber(first);
		local firstInfo = gotoNext.extractIndexedToken(first);
		local secondNumeric = tonumber(second);
		local secondInfo = gotoNext.extractIndexedToken(second);
		local thirdNumeric = tonumber(third);
		local thirdInfo = gotoNext.extractIndexedToken(third);
		if firstNumeric then
			startNum = math.floor(firstNumeric);
			if secondNumeric then
				endNum = math.floor(secondNumeric);
				delay = tonumber(third);
			elseif secondInfo and secondInfo.number then
				if not applyPrefix(secondInfo.raw, secondInfo.normalized) then
					return nil, "Start/end names use different prefixes.";
				end;
				endNum = math.floor(secondInfo.number);
				delay = tonumber(third);
			else
				endNum = startNum;
				delay = tonumber(second);
			end;
		elseif firstInfo and firstInfo.number then
			if not applyPrefix(firstInfo.raw, firstInfo.normalized) then
				return nil, "Start/end names use different prefixes.";
			end;
			startNum = math.floor(firstInfo.number);
			if secondNumeric then
				endNum = math.floor(secondNumeric);
				delay = tonumber(third);
			elseif secondInfo and secondInfo.number then
				if not applyPrefix(secondInfo.raw, secondInfo.normalized) then
					return nil, "Start/end names use different prefixes.";
				end;
				endNum = math.floor(secondInfo.number);
				delay = tonumber(third);
			else
				endNum = startNum;
				delay = tonumber(second);
			end;
		else
			if not applyPrefix(first, first) then
				return nil, "Invalid prefix value.";
			end;
			if not second then
				return nil, "Start number missing. Example: gotopartnext checkpoint 1 5";
			end;
			if secondNumeric then
				startNum = math.floor(secondNumeric);
				if thirdNumeric then
					endNum = math.floor(thirdNumeric);
					delay = tonumber(fourth);
				elseif thirdInfo and thirdInfo.number then
					if not applyPrefix(thirdInfo.raw, thirdInfo.normalized) then
						return nil, "Start/end names use different prefixes.";
					end;
					endNum = math.floor(thirdInfo.number);
					delay = tonumber(fourth);
				else
					endNum = startNum;
					delay = tonumber(third);
				end;
			elseif secondInfo and secondInfo.number then
				if not applyPrefix(secondInfo.raw, secondInfo.normalized) then
					return nil, "Start/end names use different prefixes.";
				end;
				startNum = math.floor(secondInfo.number);
				if thirdNumeric then
					endNum = math.floor(thirdNumeric);
					delay = tonumber(fourth);
				elseif thirdInfo and thirdInfo.number then
					if not applyPrefix(thirdInfo.raw, thirdInfo.normalized) then
						return nil, "Start/end names use different prefixes.";
					end;
					endNum = math.floor(thirdInfo.number);
					delay = tonumber(fourth);
				else
					endNum = startNum;
					delay = tonumber(third);
				end;
			else
				return nil, "Start number missing. Example: gotopartnext checkpoint 1 10 0.5";
			end;
		end;
		if not startNum then
			return nil, "Start number missing. Example: gotopartnext checkpoint 1 10 0.5";
		end;
		endNum = endNum or startNum;
		delay = tonumber(delay) or 0.5;
		if delay < 0 then
			delay = 0;
		end;
		local prefixRawOriginal = prefixRaw;
		if prefixRawOriginal then
			local trimmedCandidate = gotoNext.trim(prefixRawOriginal);
			if trimmedCandidate == "" then
				prefixRawOriginal = nil;
			end;
		end;
		if prefixNormalized then
			prefixNormalized = gotoNext.trim(prefixNormalized);
			if prefixNormalized == "" then
				prefixNormalized = nil;
			end;
		end;
		if not prefixNormalized and prefixRawOriginal then
			local trimmedRaw = gotoNext.trim(prefixRawOriginal);
			if trimmedRaw ~= "" then
				prefixNormalized = trimmedRaw;
			end;
		end;
		local prefixDisplay = nil;
		if prefixRawOriginal then
			prefixDisplay = gotoNext.trim(prefixRawOriginal);
			if prefixDisplay == "" then
				prefixDisplay = nil;
			end;
		end;
		if not prefixDisplay then
			prefixDisplay = prefixNormalized;
		end;
		local prefixLower = prefixNormalized and prefixNormalized:lower() or nil;
		return {
			prefixRaw = prefixRawOriginal,
			prefixNormalized = prefixNormalized,
			prefixLower = prefixLower,
			prefixDisplay = prefixDisplay,
			startNum = startNum,
			endNum = endNum,
			delay = delay
		};
	end;
	function gotoNext.handleSequence(objectType, rawArgs)
		if state.teleporting then
			gotoNext.notify("Sequence already running.", 2);
			return;
		end;
		local parsed, err = gotoNext.parseArgs(rawArgs);
		if not parsed then
			gotoNext.notify(err or "Invalid arguments.", 4);
			return;
		end;
		state.teleporting = true;
		state.totalDuplicates = 0;
		local prefixLabel = parsed.prefixDisplay;
		local descriptor;
		if prefixLabel and prefixLabel ~= "" then
			descriptor = Format("Teleporting %s '%s' %d -> %d (delay %.2fs)", objectType, prefixLabel, parsed.startNum, parsed.endNum, parsed.delay);
		else
			descriptor = Format("Teleporting %s %d -> %d (delay %.2fs)", objectType, parsed.startNum, parsed.endNum, parsed.delay);
		end;
		gotoNext.notify(descriptor, 3);
		SpawnCall(function()
			local step = parsed.startNum <= parsed.endNum and 1 or (-1);
			for index = parsed.startNum, parsed.endNum, step do
				if not state.teleporting then
					break;
				end;
				local searchNames = gotoNext.buildSearchNames(parsed.prefixRaw, parsed.prefixNormalized, index);
				if #searchNames == 0 then
					searchNames = {
						tostring(index)
					};
				end;
				local indexString = tostring(index);
				local displayName = searchNames[1];
				for _, candidateName in ipairs(searchNames) do
					if candidateName:find(" " .. indexString, 1, true) then
						displayName = candidateName;
						break;
					end;
				end;
				if parsed.prefixDisplay and parsed.prefixDisplay ~= "" then
					local prefixLowerForDisplay = parsed.prefixDisplay:lower();
					for _, candidateName in ipairs(searchNames) do
						local candidateLower = candidateName:lower();
						if candidateLower:find(prefixLowerForDisplay, 1, true) then
							displayName = candidateName;
							if candidateName:find(" " .. indexString, 1, true) then
								break;
							end;
						end;
					end;
				end;
				local sessionKey = gotoNext.sessionKey(objectType, parsed.prefixLower, index);
				local candidates = {};
				local seen = {};
				for _, name in ipairs(searchNames) do
					local found = gotoNext.findMatches(objectType, name);
					for _, info in ipairs(found) do
						local inst = info.inst;
						if inst and (not seen[inst]) then
							seen[inst] = true;
							Insert(candidates, info);
						end;
					end;
				end;
				if #candidates == 0 then
					gotoNext.notify(Format("No %s named '%s'.", objectType, displayName), 2);
				else
					if #candidates > 1 then
						local sessionChoice = state.duplicatesSessionOrder[sessionKey];
						if sessionChoice then
							sessionChoice = gotoNext.normalizeSelection(sessionChoice);
							if #sessionChoice == 0 then
								state.duplicatesSessionOrder[sessionKey] = nil;
								sessionChoice = nil;
							end;
						end;
						if not sessionChoice then
							local selection = gotoNext.promptDuplicates(displayName, candidates);
							if not selection or #selection == 0 then
								gotoNext.notify("Sequence canceled.", 2);
								state.teleporting = false;
								gotoNext.clearTracer();
								return;
							end;
							state.duplicatesSessionOrder[sessionKey] = selection;
							sessionChoice = gotoNext.normalizeSelection(selection);
						end;
						state.totalDuplicates = state.totalDuplicates + math.max(0, ((#sessionChoice) - 1));
						candidates = sessionChoice;
					end;
					for idx, info in ipairs(candidates) do
						if not state.teleporting then
							break;
						end;
						local inst = info.inst;
						if objectType == "Folder" then
							local parts = gotoNext.collectFolderParts(inst);
							for partIndex, part in ipairs(parts) do
								if not state.teleporting then
									break;
								end;
								local nextPart = parts[partIndex + 1];
								gotoNext.setTracer(nextPart and nextPart.CFrame or nil);
								gotoNext.teleportToInstance(part);
								Wait(parsed.delay);
							end;
						else
							local nextInfo = candidates[idx + 1];
							local nextTarget = nextInfo and gotoNext.resolveCFrame(nextInfo.inst) or nil;
							gotoNext.setTracer(nextTarget);
							gotoNext.teleportToInstance(inst);
							Wait(parsed.delay);
						end;
					end;
				end;
			end;
			gotoNext.clearTracer();
			if state.teleporting then
				gotoNext.notify(Format("Finished teleporting! Duplicates: %d", state.totalDuplicates), 4);
			else
				gotoNext.notify("Sequence stopped.", 2);
			end;
			state.teleporting = false;
		end);
	end;
	function gotoNext.cancelSequence()
		state.totalDuplicates = 0;
		state.duplicatesSessionOrder = {};
		if state.teleporting then
			state.teleporting = false;
			gotoNext.clearTracer();
			gotoNext.notify("Teleport sequence stopped!", 3);
		else
			gotoNext.clearTracer();
			gotoNext.notify("No teleport in progress.", 2);
		end;
	end;
end;

cmd.add({"gotopartnext", "gpn"}, {"gotopartnext [prefix] <start> [end] [delay] (gpn)", "Teleport sequentially to parts with optional prefix and duplicate handling."}, function(...)
	originalIO.gotoNext.handleSequence("Part", {...})
end, true)

cmd.add({"gotomodelnext", "gmn"}, {"gotomodelnext [prefix] <start> [end] [delay] (gmn)", "Teleport sequentially to models with optional prefix and duplicate handling."}, function(...)
	originalIO.gotoNext.handleSequence("Model", {...})
end, true)

cmd.add({"gotofoldernext", "gfn"}, {"gotofoldernext [prefix] <start> [end] [delay] (gfn)", "Teleport sequentially through folder contents with optional prefix."}, function(...)
	originalIO.gotoNext.handleSequence("Folder", {...})
end, true)

cmd.add({"gotobreak", "gb"}, {"gotobreak (gb)", "Stop the active goto sequence and clear duplicate selections."}, function()
	originalIO.gotoNext.cancelSequence()
end)

cmd.add({"gotopart", "topart", "toprt"}, {"gotopart {partname}", "Teleports you to each matching part by name once"}, function(...)
	local partName = Concat({...}, " "):lower()
	local commandKey = "gotopart"

	if NAStuff.activeTeleports[commandKey] then
		NAStuff.activeTeleports[commandKey].active = false
	end

	local taskState = {active = true}
	NAStuff.activeTeleports[commandKey] = taskState

	SpawnCall(function()
		for _, part in pairs(workspace:GetDescendants()) do
			if not taskState.active then return end
			if part:IsA("BasePart") and part.Name:lower() == partName then
				if getHum() then getHum().Sit = false Wait(0.1) end
				if getChar() then getChar():PivotTo(part:GetPivot()) end
				Wait(.2)
			end
		end
	end)
end, true)

cmd.add({"tweengotopart","tgotopart","ttopart","ttoprt"},{"tweengotopart <partName>","Tween to each matching part by name once"},function(...)
	local partName = Concat({...}," "):lower()
	local key      = "tweengotopart"
	if NAStuff.activeTeleports[key] then NAStuff.activeTeleports[key].active = false end
	local state    = {active = true}
	NAStuff.activeTeleports[key] = state
	SpawnCall(function()
		local char = getChar()
		for _,obj in ipairs(workspace:GetDescendants()) do
			if not state.active then return end
			if obj:IsA("BasePart") and obj.Name:lower() == partName then
				local hum = getHum()
				if hum then hum.Sit = false end
				local cfVal = InstanceNew("CFrameValue")
				cfVal.Value = char:GetPivot()
				cfVal.Changed:Connect(function(newCF) char:PivotTo(newCF) end)
				local duration = NAmanage.resolveTweenDuration()
				local tw = TweenService:Create(cfVal, TweenInfo.new(duration, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),{Value = obj.CFrame})
				tw:Play()
				tw.Completed:Connect(function() cfVal:Destroy() end)
				Wait(duration + 0.1)
			end
		end
	end)
end,true)


cmd.add({"gotopartfind", "topartfind", "toprtfind"}, {"gotopartfind {name}", "Teleports to each part containing name once"}, function(...)
	local name = Concat({...}, " "):lower()
	local commandKey = "gotopartfind"

	if NAStuff.activeTeleports[commandKey] then
		NAStuff.activeTeleports[commandKey].active = false
	end

	local taskState = {active = true}
	NAStuff.activeTeleports[commandKey] = taskState

	SpawnCall(function()
		for _, part in pairs(workspace:GetDescendants()) do
			if not taskState.active then return end
			if part:IsA("BasePart") and part.Name:lower():find(name) then
				if getHum() then getHum().Sit = false Wait(0.1) end
				if getChar() then getChar():PivotTo(part:GetPivot()) end
				Wait(.2)
			end
		end
	end)
end, true)

cmd.add({"tweengotopartfind", "tgotopartfind", "ttopartfind", "ttoprtfind"}, {"tweengotopartfind {name}", "Tweens to each part containing name once"}, function(...)
	local name = Concat({...}, " "):lower()
	local commandKey = "tweengotopartfind"

	if NAStuff.activeTeleports[commandKey] then
		NAStuff.activeTeleports[commandKey].active = false
	end

	local taskState = {active = true}
	NAStuff.activeTeleports[commandKey] = taskState

	SpawnCall(function()
		for _, part in pairs(workspace:GetDescendants()) do
			if not taskState.active then return end
			if part:IsA("BasePart") and part.Name:lower():find(name) then
				local hum = getHum()
				if hum then
					hum.Sit = false
					Wait(0.1)
				end
				local char = getChar()
				local root = char and getRoot(char)
				if root then
					local duration = NAmanage.resolveTweenDuration()
					local tween = TweenService:Create(root, TweenInfo.new(duration, Enum.EasingStyle.Linear), {CFrame = part.CFrame})
					tween:Play()
					Wait(duration + 0.1)
				end
			end
		end
	end)
end, true)

cmd.add({"gotopartclass", "gpc", "gotopartc", "gotoprtc"}, {"gotopartclass {classname}", "Teleports to each part of class once"}, function(...)
	local className = ({...})[1]:lower()
	local commandKey = "gotopartclass"

	if NAStuff.activeTeleports[commandKey] then
		NAStuff.activeTeleports[commandKey].active = false
	end

	local taskState = {active = true}
	NAStuff.activeTeleports[commandKey] = taskState

	SpawnCall(function()
		for _, part in pairs(workspace:GetDescendants()) do
			if not taskState.active then return end
			if part:IsA("BasePart") and part.ClassName:lower() == className then
				if getHum() then getHum().Sit = false Wait(0.1) end
				if getChar() then getChar():PivotTo(part:GetPivot()) end
				Wait(.2)
			end
		end
	end)
end, true)

cmd.add({"bringpart", "bpart", "bprt"}, {"bringpart {partname} (bpart, bprt)", "Brings a part to your character by name"}, function(...)
	local partName = Concat({...}, " "):lower()

	for _, part in pairs(workspace:GetDescendants()) do
		if part:IsA("BasePart") and part.Name:lower() == partName then
			if getChar() then
				part:PivotTo(getChar():GetPivot())
			end
		end
	end
end, true)

cmd.add({"bringpartfind","bpartfind","bprtfind"},{"bringpartfind {name} (bpartfind, bprtfind)","Brings all parts containing name to your character"},function(...)
	local name = Concat({...}," "):lower()
	if name == "" then return end

	local char = getChar()
	if not char then return end
	local pivot = char:GetPivot()

	for _, part in ipairs(workspace:GetDescendants()) do
		if part:IsA("BasePart") then
			local n = part.Name:lower()
			if Find(n, name, 1, true) ~= nil then
				part:PivotTo(pivot)
			end
		end
	end
end,true)

cmd.add({"bringmodel", "bmodel"}, {"bringmodel {modelname} (bmodel)", "Brings a model to your character by name"}, function(...)
	local modelName = Concat({...}, " "):lower()

	for _, model in pairs(workspace:GetDescendants()) do
		if model:IsA("Model") and model.Name:lower() == modelName then
			if getChar() then
				model:PivotTo(getChar():GetPivot())
			end
		end
	end
end, true)

cmd.add({"bringmodelfind","bmodelfind"},{"bringmodelfind {name} (bmodelfind)","Brings all models whose name contains the given text to your character"},function(...)
	local name = Concat({...}," "):lower()
	if name == "" then return end

	local char = getChar()
	if not char then return end
	local pivot = char:GetPivot()

	for _, model in ipairs(workspace:GetDescendants()) do
		if model:IsA("Model") then
			local n = model.Name:lower()
			if Find(n, name, 1, true) ~= nil then
				model:PivotTo(pivot)
			end
		end
	end
end,true)

cmd.add({"bringfolder","bfldr"},{"bringfolder {folderName} [partName] (bfldr)","Brings all parts in a folder or a specified part"},function(...)
	local raw = {...}
	if #raw == 0 then return end
	local lower = {}
	for i=1,#raw do lower[i] = tostring(raw[i]):lower() end
	local folder, partFilter
	do
		local nameAll = Concat(lower," ")
		for _,obj in ipairs(workspace:GetDescendants()) do
			if obj:IsA("Folder") and obj.Name:lower() == nameAll then folder = obj break end
		end
		if not folder and #lower>=2 then
			local nameWithoutLast = Concat(lower," ",1,#lower-1)
			local last = lower[#lower]
			for _,obj in ipairs(workspace:GetDescendants()) do
				if obj:IsA("Folder") and obj.Name:lower() == nameWithoutLast then folder = obj partFilter = last break end
			end
		end
		if not folder then
			for _,obj in ipairs(workspace:GetDescendants()) do
				if obj:IsA("Folder") and obj.Name:lower() == lower[1] then folder = obj break end
			end
			if folder and #lower>1 then
				partFilter = Concat(lower," ",2,#lower)
			end
		end
	end
	if not folder then return end
	local char = getChar()
	if not char then return end
	local pivot = char:GetPivot()
	for _,desc in ipairs(folder:GetDescendants()) do
		if desc:IsA("BasePart") then
			local ok = true
			if partFilter and partFilter ~= "" then
				local n = desc.Name:lower()
				ok = (n == partFilter) or (Find(n, partFilter, 1, true) ~= nil)
			end
			if ok then
				desc:PivotTo(pivot)
			end
		end
	end
end,true)

cmd.add({"gotomodel", "tomodel"}, {"gotomodel {modelname}", "Teleports to each model with name once"}, function(...)
	local modelName = Concat({...}, " "):lower()
	local commandKey = "gotomodel"

	if NAStuff.activeTeleports[commandKey] then
		NAStuff.activeTeleports[commandKey].active = false
	end

	local taskState = {active = true}
	NAStuff.activeTeleports[commandKey] = taskState

	SpawnCall(function()
		for _, model in pairs(workspace:GetDescendants()) do
			if not taskState.active then return end
			if model:IsA("Model") and model.Name:lower() == modelName then
				if getHum() then getHum().Sit = false Wait(0.1) end
				if getChar() then getChar():PivotTo(model:GetPivot()) end
				Wait(.2)
			end
		end
	end)
end, true)

cmd.add({"gotomodelfind", "tomodelfind"}, {"gotomodelfind {name}", "Teleports to each model containing name once"}, function(...)
	local name = Concat({...}, " "):lower()
	local commandKey = "gotomodelfind"

	if NAStuff.activeTeleports[commandKey] then
		NAStuff.activeTeleports[commandKey].active = false
	end

	local taskState = {active = true}
	NAStuff.activeTeleports[commandKey] = taskState

	SpawnCall(function()
		for _, model in pairs(workspace:GetDescendants()) do
			if not taskState.active then return end
			if model:IsA("Model") and model.Name:lower():find(name) then
				if getHum() then getHum().Sit = false Wait(0.1) end
				if getChar() then getChar():PivotTo(model:GetPivot()) end
				Wait(.2)
			end
		end
	end)
end, true)

cmd.add({"gotomodelfind", "tomodelfind"}, {"gotomodelfind {name} (tomodelfind)", "Teleports you to a model whose name contains the given text"}, function(...)
	local name = Concat({...}, " "):lower()

	for _, model in pairs(workspace:GetDescendants()) do
		if model:IsA("Model") and model.Name:lower():find(name) then
			if getHum() then
				getHum().Sit = false
				Wait(0.1)
			end
			if getChar() then
				getChar():PivotTo(model:GetPivot())
			end
			Wait(0.2)
		end
	end
end, true)

cmd.add({"gotofolder","gofldr"},{"gotofolder {folderName}","Teleports you to all parts in a folder"},function(...)
	local lower = {}
	for i,v in ipairs({...}) do lower[i] = tostring(v):lower() end
	local folderName = Concat(lower," ")
	if folderName == "" then return end
	local key = "gotofolder"
	if NAStuff.activeTeleports[key] then NAStuff.activeTeleports[key].active = false end
	local state = {active = true}
	NAStuff.activeTeleports[key] = state
	SpawnCall(function()
		local folder
		for _,obj in ipairs(workspace:GetDescendants()) do
			if obj:IsA("Folder") and obj.Name:lower() == folderName then folder = obj break end
		end
		if not folder then return end
		for _,desc in ipairs(folder:GetDescendants()) do
			if not state.active then return end
			if desc:IsA("BasePart") then
				local hum = getHum()
				if hum then hum.Sit = false Wait(0.1) end
				local char = getChar()
				if char then char:PivotTo(desc:GetPivot()) end
				Wait(0.2)
			end
		end
	end)
end,true)

OGGRAVV = workspace.Gravity;
SWIMMERRRR = false;

NAStuff.SWIM_STATES = NAStuff.SWIM_STATES or {
	Enum.HumanoidStateType.FallingDown,
	Enum.HumanoidStateType.Freefall,
	Enum.HumanoidStateType.Landed,
	Enum.HumanoidStateType.PlatformStanding,
	Enum.HumanoidStateType.Ragdoll,
	Enum.HumanoidStateType.GettingUp,
	Enum.HumanoidStateType.Seated
};

function ZEhumSTATE(humanoid, enabled)
	for _, st in ipairs(NAStuff.SWIM_STATES) do
		humanoid:SetStateEnabled(st, enabled);
	end;
end;

cmd.add({"swim"}, {"swim {speed}","Swim in the air"}, function(speed)
	local humanoid = getHum();
	if not humanoid or (not humanoid.Parent) or SWIMMERRRR then
		return;
	end;
	local hrp = getRoot(humanoid.Parent);
	if not hrp then
		return;
	end;
	local spd = tonumber(speed) or 16;
	OGGRAVV = workspace.Gravity;
	workspace.Gravity = 0;
	ZEhumSTATE(humanoid, false);
	humanoid:ChangeState(Enum.HumanoidStateType.Swimming);
	humanoid.WalkSpeed = spd;
	NAlib.connect("swim_die", humanoid.Died:Connect(function()
		workspace.Gravity = OGGRAVV;
		SWIMMERRRR = false;
		NAlib.disconnect("swim_heartbeat");
		ZEhumSTATE(humanoid, true);
	end));
	NAlib.connect("swim_heartbeat", RunService.Stepped:Connect(function()
		NACaller(function()
			if not SWIMMERRRR then
				return;
			end;
			if not humanoid or (not humanoid.Parent) or (not hrp) then
				return;
			end;
			local move = humanoid.MoveDirection;
			local v = Vector3.zero;
			if move.Magnitude > 0 then
				v = move.Unit * spd;
			end;
			if UserInputService:IsKeyDown(Enum.KeyCode.Space) then
				v = v + Vector3.new(0, spd, 0);
			end;
			if humanoid:GetState() == Enum.HumanoidStateType.Jumping then
				v = v + Vector3.new(0, spd, 0);
				humanoid:ChangeState(Enum.HumanoidStateType.Swimming);
			end;
			hrp.Velocity = v;
		end);
	end));
	SWIMMERRRR = true;
end, true);

cmd.add({"unswim"}, {"unswim","Stops the swim script"}, function()
	local humanoid = getHum();
	if not humanoid then
		return;
	end;
	workspace.Gravity = OGGRAVV;
	SWIMMERRRR = false;
	NAlib.disconnect("swim_die");
	NAlib.disconnect("swim_heartbeat");
	ZEhumSTATE(humanoid, true);
	humanoid:ChangeState(Enum.HumanoidStateType.RunningNoPhysics);
	humanoid.WalkSpeed = 16;
	local hrp = getRoot(humanoid.Parent);
	if hrp then
		hrp.Velocity = Vector3.zero;
	end;
end);

cmd.add({"punch"},{"punch","punch tool that flings"},function()
	loadstring(game:HttpGet('https://raw.githubusercontent.com/ltseverydayyou/Nameless-Admin/refs/heads/main/puncher.luau'))()
end)

cmd.add({"tpua","bringua"},{"tpua <player>","Brings every unanchored part on the map to the player"},function(...)
	local targets=getPlr(...)
	local targetPlayer=targets[1]
	if not targetPlayer then targetPlayer=LocalPlayer end

	local root=getRoot(getPlrChar(targetPlayer))
	if not root then return end

	local targetCF=root.CFrame

	SpawnCall(function()
		while RunService.Heartbeat:Wait() do
			NACaller(function()
				opt.hiddenprop(LocalPlayer,"SimulationRadius",1e9)
				LocalPlayer.MaximumSimulationRadius=1e9
			end)
		end
	end)

	local function ForcePart(v)
		if not v:IsA("BasePart") then return end
		if v.Anchored or v:IsDescendantOf(targetPlayer.Character) then return end
		if v.Parent:FindFirstChildWhichIsA("Humanoid") or v.Parent:FindFirstChild("Head") or v.Name=="Handle" then return end

		for _,x in next,v:GetChildren() do
			if x:IsA("BodyMover") or x:IsA("RocketPropulsion") then x:Destroy() end
		end
		for _,n in next,{"Attachment","AlignPosition","Torque"} do
			local i=v:FindFirstChild(n)
			if i then i:Destroy() end
		end

		v.CanCollide=false
		v.CFrame=targetCF*CFrame.new(math.random(-10,10),0,math.random(-10,10))
	end

	for _,part in ipairs(workspace:GetDescendants()) do
		ForcePart(part)
	end
end,true)

cmd.add({"blackholefollow","bhf","bhpull","bhfollow"},{"blackholefollow","Pulls unanchored parts to you with spin"},function()
	if NAlib.isConnected("bhf") then return DoNotif("BHF already active") end

	local root=getRoot(getPlrChar(LocalPlayer));if not root then return end
	local att1=InstanceNew("Attachment",root);att1.Name="BHF_Attach"

	local function ForcePart(v)
		if not v:IsA("BasePart") then return end
		if v.Anchored or v:IsDescendantOf(LocalPlayer.Character) then return end
		if v.Parent:FindFirstChildWhichIsA("Humanoid") or v.Parent:FindFirstChild("Head") or v.Name=="Handle" then return end

		for _,x in next,v:GetChildren() do
			if x:IsA("BodyMover") or x:IsA("RocketPropulsion") then x:Destroy() end
		end
		for _,n in next,{"Attachment","AlignPosition","Torque"} do
			local i=v:FindFirstChild(n)
			if i then i:Destroy() end
		end

		v.CanCollide=false

		local att0=InstanceNew("Attachment",v)
		local align=InstanceNew("AlignPosition",v)
		align.Attachment0=att0
		align.Attachment1=att1
		align.MaxForce=1e9
		align.MaxVelocity=math.huge
		align.Responsiveness=200

		local torque=InstanceNew("Torque",v)
		torque.Attachment0=att0
		torque.Torque=Vector3.new(100000,100000,100000)
	end

	for _,part in ipairs(workspace:GetDescendants()) do Defer(function() ForcePart(part) end) end

	NAlib.connect("bhf",workspace.DescendantAdded:Connect(ForcePart))
	NAlib.connect("bhf_sim",RunService.Heartbeat:Connect(function()
		NACaller(function()
			opt.hiddenprop(LocalPlayer,"SimulationRadius",1e9)
			LocalPlayer.MaximumSimulationRadius=1e9
		end)
	end))

	DebugNotif("Blackhole follow enabled.")
end,true)

cmd.add({"noblackholefollow","nobhf","nobhpull","stopbhf"},{"noblackholefollow","Stops blackhole follow and clears constraints"},function()
	NAlib.disconnect("bhf")
	NAlib.disconnect("bhf_sim")

	local root=getRoot(getPlrChar(LocalPlayer))
	if root then local att=root:FindFirstChild("BHF_Attach") if att then att:Destroy() end end

	for _,part in ipairs(workspace:GetDescendants()) do
		if part:IsA("BasePart") and not part.Anchored then
			for _,obj in ipairs(part:GetChildren()) do
				if obj:IsA("AlignPosition") or obj:IsA("Torque") or obj:IsA("Attachment") then obj:Destroy() end
			end
		end
	end

	DebugNotif("Blackhole follow disabled.")
end,true)

cmd.add({"swordfighter", "sfighter", "swordf", "swordbot", "sf"},{"swordfighter (sfighter, swordf, swordbot, sf)", "Activates a sword fighting bot that engages in automated PvP combat"},function()
	loadstring(game:HttpGet("https://raw.githubusercontent.com/ltseverydayyou/uuuuuuu/refs/heads/main/Sword%20Fight%20Bot"))()
end)

NAmanage.CreateBox = function(part, color, transparency)
	if not part or not part.Parent then return end
	NAmanage.RemoveEspFromPart(part)
	local c = (typeof(color) == "Color3" and color) or Color3.new(1,1,1)
	local entryTransparency = NAgui.sanitizeTransparency(transparency or (NAStuff.ESP_Transparency or 0.45))
	local h, s, v = Color3.toHSV(c)
	local off = 0.35
	local darker = Color3.fromHSV(h, s, math.clamp(v - off, 0, 1))
	local lighter = Color3.fromHSV(h, s, math.clamp(v + off, 0, 1))
	local useHighlight = NAgui.espUsesHighlight()
	local adornName = Lower(part.Name).."_peepee"
	local visual
	if useHighlight then
		visual = InstanceNew("Highlight", part)
		visual.Name = adornName
		visual.Adornee = part
		visual.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
		visual.FillColor = lighter
		visual.OutlineColor = darker
		visual.FillTransparency = entryTransparency
		visual.OutlineTransparency = NAgui.sanitizeTransparency(NAStuff.ESP_OutlineTransparency or 0)
		visual.Enabled = false
		Defer(function()
			if visual and visual.Parent then
				visual.Enabled = true
			end
		end)
	else
		visual = InstanceNew("BoxHandleAdornment", part)
		visual.Name = adornName
		visual.Adornee = part
		visual.AlwaysOnTop = true
		visual.ZIndex = 0
		visual.Transparency = entryTransparency
		visual.Color3 = lighter
	end
	local bb = InstanceNew("BillboardGui", part)
	bb.Name = Lower(part.Name).."_label"
	bb.Adornee = part
	bb.Size = UDim2.new(0, 160, 0, 28)
	bb.StudsOffset = Vector3.new(0, 0.5, 0)
	bb.AlwaysOnTop = true
	bb.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
	local tl = InstanceNew("TextLabel", bb)
	tl.Size = UDim2.new(1, 0, 1, 0)
	tl.BackgroundTransparency = 1
	tl.Text = part.Name
	tl.TextColor3 = Color3.new(1,1,1)
	tl.Font = Enum.Font.SourceSansBold
	tl.TextStrokeTransparency = 0.5
	tl.ZIndex = 1
	NAgui.applyLabelStyle(tl)
	local gr = InstanceNew("UIGradient", tl)
	gr.Color = ColorSequence.new(darker, lighter)
	local function update()
		if not part or not part.Parent then return end
		if not bb.Parent then return end
		local sizeY = 2.5
		if part:IsA("Model") then
			local ok, _, ms = pcall(part.GetBoundingBox, part)
			if ok and ms then
				sizeY = ms.Y
				if not useHighlight and visual and visual:IsA("BoxHandleAdornment") then
					local newSize = ms + Vector3.new(0.1,0.1,0.1)
					if visual.Size ~= newSize then
						visual.Size = newSize
					end
				end
			end
		elseif part:IsA("BasePart") then
			sizeY = part.Size.Y
			if not useHighlight and visual and visual:IsA("BoxHandleAdornment") then
				local newSize = part.Size + Vector3.new(0.1,0.1,0.1)
				if visual.Size ~= newSize then
					visual.Size = newSize
				end
			end
		end
		bb.StudsOffset = Vector3.new(0, (sizeY / 2) + 0.2, 0)
	end
	update()
	Defer(update)
	local key = "esp_update_"..tostring(visual)
	if part:IsA("Model") then
		NAlib.connect(key, part.DescendantAdded:Connect(update))
		NAlib.connect(key, part.DescendantRemoving:Connect(update))
	elseif NAlib.isProperty(part, "Size") then
		NAlib.connect(key, part:GetPropertyChangedSignal("Size"):Connect(update))
	end
	NAlib.connect(key, part.AncestryChanged:Connect(function(_, parentNow)
		if not parentNow then
			NAlib.disconnect(key)
		end
	end))
	local entry = {
		part = part,
		billboard = bb,
		label = tl,
		visual = visual,
		baseColor = c,
		lightColor = lighter,
		darkColor = darker,
		transparency = entryTransparency,
		gradient = gr,
		useHighlight = useHighlight,
		updateKey = key,
	}
	NAmanage.PartESP_RegisterEntry(entry)
	return visual
end

NAmanage.RemoveEspFromPart = function(part)
	if not part then return end
	for _, child in ipairs(part:GetChildren()) do
		if (child:IsA("BoxHandleAdornment") or child:IsA("Highlight")) and Sub(child.Name,-7) == "_peepee" then
			NAlib.disconnect("esp_update_"..tostring(child))
			local entry = NAStuff.partESPVisualMap and NAStuff.partESPVisualMap[child]
			if entry then
				NAmanage.PartESP_UnregisterEntry(entry)
			end
			child:Destroy()
		end
	end
	for _, child in ipairs(part:GetChildren()) do
		if child:IsA("BillboardGui") and Sub(Lower(child.Name),-6) == "_label" then
			local entry = NAStuff.partESPEntries and NAStuff.partESPEntries[child]
			if entry then
				NAmanage.PartESP_UnregisterEntry(entry)
			end
			child:Destroy()
		end
	end
end

NAmanage.EnableEsp = function(objType, color, list)
	for _,obj in ipairs(workspace:GetDescendants()) do
		if obj:IsA(objType) then
			local parent = obj:FindFirstAncestorWhichIsA("BasePart") or obj:FindFirstAncestorWhichIsA("Model")
			if parent and not Discover(list, parent) then
				Insert(list, parent)
				NAmanage.CreateBox(parent, color, 0.45)
			end
		end
	end
	if not NAStuff.espTriggers[objType] then
		NAStuff.espTriggers[objType] = workspace.DescendantAdded:Connect(function(obj)
			if obj:IsA(objType) then
				local parent = obj:FindFirstAncestorWhichIsA("BasePart") or obj:FindFirstAncestorWhichIsA("Model")
				if parent and not Discover(list, parent) then
					Insert(list, parent)
					NAmanage.CreateBox(parent, color, 0.45)
				end
			end
		end)
	end
end

NAmanage.DisableEsp = function(objType, list)
	if NAStuff.espTriggers[objType] then
		NAStuff.espTriggers[objType]:Disconnect()
		NAStuff.espTriggers[objType] = nil
	end
	for _,part in ipairs(list) do
		NAmanage.RemoveEspFromPart(part)
	end
	table.clear(list)
end

NAmanage.EnableNameEsp = function(mode, color, ...)
	NAStuff.nameESPExclusions = NAStuff.nameESPExclusions or { exact = {}, partial = {} }
	local terms = {...}
	local list = NAStuff.espNameLists[mode]
	local parts = NAStuff.nameESPPartLists[mode]
	for _,term in ipairs(terms) do
		local t = Lower(term)
		if mode == "exact" then
			NAStuff.nameESPExclusions.exact[t] = nil
		else
			for nm,_ in pairs(NAStuff.nameESPExclusions.partial) do
				if Find(nm, t) then
					NAStuff.nameESPExclusions.partial[nm] = nil
				end
			end
		end
		if not Discover(list, t) then
			Insert(list, t)
		end
	end
	local function matchFn(obj)
		if not (obj:IsA("BasePart") or obj:IsA("Model")) then return false end
		local nm = Lower(obj.Name)
		local ex = NAStuff.nameESPExclusions and NAStuff.nameESPExclusions[mode]
		if ex and ex[nm] then
			return false
		end
		for _,term in ipairs(list) do
			if (mode=="exact" and nm==term) or (mode=="partial" and Find(nm,term)) then
				return true
			end
		end
		return false
	end
	local function handleNameChange(obj)
		local matches = matchFn(obj)
		local idx = Discover(parts,obj)
		if matches and not idx then
			Insert(parts,obj)
			NAmanage.CreateBox(obj,color,0.45)
		elseif not matches and idx then
			NAmanage.RemoveEspFromPart(obj)
			table.remove(parts,idx)
		end
	end
	for _,obj in ipairs(workspace:GetDescendants()) do
		if obj:IsA("BasePart") or obj:IsA("Model") then
			NAlib.connect("esp_namechange_"..mode, obj:GetPropertyChangedSignal("Name"):Connect(function()
				handleNameChange(obj)
			end))
			handleNameChange(obj)
		end
	end
	if not NAStuff.espNameTriggers[mode] then
		NAStuff.espNameTriggers[mode] = workspace.DescendantAdded:Connect(function(obj)
			if obj:IsA("BasePart") or obj:IsA("Model") then
				NAlib.connect("esp_namechange_"..mode, obj:GetPropertyChangedSignal("Name"):Connect(function()
					handleNameChange(obj)
				end))
				handleNameChange(obj)
			end
		end)
	end
end

NAmanage.DisableNameEsp = function(mode)
	if NAStuff.espNameTriggers[mode] then
		NAStuff.espNameTriggers[mode]:Disconnect()
		NAStuff.espNameTriggers[mode] = nil
	end
	NAlib.disconnect("esp_namechange_"..mode)
	local parts = NAStuff.nameESPPartLists[mode]
	for _,part in ipairs(parts) do
		NAmanage.RemoveEspFromPart(part)
	end
	table.clear(parts)
	table.clear(NAStuff.espNameLists[mode])
end

NAmanage.EnableUnanchoredEsp = function(color)
	local col = color or Color3.fromRGB(255,220,0)
	local function update(part)
		if not part:IsA("BasePart") then return end
		local idx = Discover(NAStuff.unanchoredESPList, part)
		if part.Anchored == false and not idx then
			Insert(NAStuff.unanchoredESPList, part)
			NAmanage.CreateBox(part, col, 0.45)
		elseif part.Anchored == true and idx then
			NAmanage.RemoveEspFromPart(part)
			table.remove(NAStuff.unanchoredESPList, idx)
		end
	end
	for _,obj in ipairs(workspace:GetDescendants()) do
		if obj:IsA("BasePart") then
			update(obj)
			NAlib.connect("esp_unanchored_prop", obj:GetPropertyChangedSignal("Anchored"):Connect(function()
				update(obj)
			end))
		end
	end
	if not NAStuff.espTriggers["__unanchored"] then
		NAStuff.espTriggers["__unanchored"] = workspace.DescendantAdded:Connect(function(obj)
			if obj:IsA("BasePart") then
				update(obj)
				NAlib.connect("esp_unanchored_prop", obj:GetPropertyChangedSignal("Anchored"):Connect(function()
					update(obj)
				end))
			end
		end)
	end
end

NAmanage.DisableUnanchoredEsp = function()
	if NAStuff.espTriggers["__unanchored"] then
		NAStuff.espTriggers["__unanchored"]:Disconnect()
		NAStuff.espTriggers["__unanchored"] = nil
	end
	NAlib.disconnect("esp_unanchored_prop")
	for _,part in ipairs(NAStuff.unanchoredESPList) do
		NAmanage.RemoveEspFromPart(part)
	end
	table.clear(NAStuff.unanchoredESPList)
end

NAmanage.EnableCollisionEsp = function(targetState, color)
	local list = targetState and NAStuff.collisiontrueESPList or NAStuff.collisionfalseESPList
	local trigKey = targetState and "__cancollide_true" or "__cancollide_false"
	local propKey = targetState and "esp_cancollide_true_prop" or "esp_cancollide_false_prop"
	local col = color or (targetState and Color3.fromRGB(0,200,255) or Color3.fromRGB(255,120,120))
	local function update(part)
		if not part:IsA("BasePart") then return end
		local idx = Discover(list, part)
		local matches = part.CanCollide == targetState
		if matches and not idx then
			Insert(list, part)
			NAmanage.CreateBox(part, col, 0.45)
		elseif not matches and idx then
			NAmanage.RemoveEspFromPart(part)
			table.remove(list, idx)
		end
	end
	for _,obj in ipairs(workspace:GetDescendants()) do
		if obj:IsA("BasePart") then
			update(obj)
			NAlib.connect(propKey, obj:GetPropertyChangedSignal("CanCollide"):Connect(function()
				update(obj)
			end))
		end
	end
	if not NAStuff.espTriggers[trigKey] then
		NAStuff.espTriggers[trigKey] = workspace.DescendantAdded:Connect(function(obj)
			if obj:IsA("BasePart") then
				update(obj)
				NAlib.connect(propKey, obj:GetPropertyChangedSignal("CanCollide"):Connect(function()
					update(obj)
				end))
			end
		end)
	end
end

NAmanage.DisableCollisionEsp = function(targetState)
	local list = targetState and NAStuff.collisiontrueESPList or NAStuff.collisionfalseESPList
	local trigKey = targetState and "__cancollide_true" or "__cancollide_false"
	local propKey = targetState and "esp_cancollide_true_prop" or "esp_cancollide_false_prop"
	if NAStuff.espTriggers[trigKey] then
		NAStuff.espTriggers[trigKey]:Disconnect()
		NAStuff.espTriggers[trigKey] = nil
	end
	NAlib.disconnect(propKey)
	for _,part in ipairs(list) do
		NAmanage.RemoveEspFromPart(part)
	end
	table.clear(list)
end

NAmanage.ESP_LocatorEnsureGui = function()
	if NAStuff.ESP_LocatorGui and NAStuff.ESP_LocatorGui.Parent then return NAStuff.ESP_LocatorGui end
	local g = InstanceNew("ScreenGui")
	NaProtectUI(g)
	NAStuff.ESP_LocatorGui = g
	return g
end

NAmanage.ESP_LocatorEnable = function(force)
	if NAStuff.ESP_LocatorEnabled and not force and NAlib.isConnected("esp_locator_loop") then return end
	NAStuff.ESP_LocatorEnabled = true

	local gui = NAmanage.ESP_LocatorEnsureGui()
	NAStuff.ESP_LocatorArrows = NAStuff.ESP_LocatorArrows or setmetatable({}, { __mode = "k" })
	local arrows = NAStuff.ESP_LocatorArrows

	local function getHolder(entry)
		local holder = arrows[entry]
		if holder and holder.Parent then return holder end

		holder = InstanceNew("Frame")
		holder.Name = "locator"
		holder.Size = UDim2.fromOffset(1, 1)
		holder.AnchorPoint = Vector2.new(0.5, 0.5)
		holder.BackgroundTransparency = 1
		holder.ZIndex = 1
		holder.Visible = false
		holder.Parent = gui

		local pointer = InstanceNew("TextLabel")
		pointer.Name = "Pointer"
		pointer.Size = UDim2.fromOffset(NAStuff.ESP_LocatorSize or 26, NAStuff.ESP_LocatorSize or 26)
		pointer.AnchorPoint = Vector2.new(0.5, 0.5)
		pointer.Position = UDim2.fromOffset(0, 0)
		pointer.BackgroundTransparency = 1
		pointer.Text = "V"
		pointer.TextScaled = true
		pointer.TextStrokeTransparency = 0.5
		pointer.Font = Enum.Font.SourceSansBold
		pointer.ZIndex = 3
		pointer.Visible = true
		pointer.Parent = holder

		local label = InstanceNew("TextLabel")
		label.Name = "Name"
		label.Size = UDim2.fromOffset(150, 20)
		label.AnchorPoint = Vector2.new(0.5, 0.5)
		label.Position = UDim2.fromOffset(0, 0)
		label.BackgroundTransparency = 1
		label.Text = ""
		label.TextScaled = false
		label.TextSize = NAStuff.ESP_LocatorTextSize or 14
		label.TextWrapped = true
		label.Font = Enum.Font.SourceSansBold
		label.TextXAlignment = Enum.TextXAlignment.Center
		label.TextYAlignment = Enum.TextYAlignment.Center
		label.TextStrokeTransparency = 0.5
		label.ZIndex = 2
		label.Visible = NAStuff.ESP_LocatorShowText == true
		label.Parent = holder

		arrows[entry] = holder
		return holder
	end

	local function applyStyle(holder, col)
		local size = math.clamp(tonumber(NAStuff.ESP_LocatorSize) or 26, 12, 128)
		local showText = (NAStuff.ESP_LocatorShowText == true)
		local textSize = math.clamp(tonumber(NAStuff.ESP_LocatorTextSize) or 14, 10, 48)

		local pointer = holder:FindFirstChild("Pointer")
		local label = holder:FindFirstChild("Name")

		if pointer then
			if pointer.TextColor3 ~= col then pointer.TextColor3 = col end
			local s = UDim2.fromOffset(size,size)
			if pointer.Size ~= s then pointer.Size = s end
		end
		if label then
			if label.TextColor3 ~= col then label.TextColor3 = col end
			if label.TextSize ~= textSize then label.TextSize = textSize end
			label.Visible = showText
		end
	end

	local function measure(text, textSize, maxWidth)
		local b = TextService:GetTextSize(text, textSize, Enum.Font.SourceSansBold, Vector2.new(maxWidth, 1e5))
		local w = math.clamp(b.X + 12, 40, maxWidth)
		local h = math.max(b.Y + 6, textSize + 4)
		return w, h
	end

	NAlib.disconnect("esp_locator_loop")
	NAlib.connect("esp_locator_loop", RunService.RenderStepped:Connect(function()
		if not NAStuff.ESP_LocatorEnabled then return end
		local cam = workspace.CurrentCamera
		if not cam then return end
		local vp = cam.ViewportSize
		if vp.X <= 0 or vp.Y <= 0 then return end

		local size = math.clamp(tonumber(NAStuff.ESP_LocatorSize) or 26, 12, 128)
		local textOn = (NAStuff.ESP_LocatorShowText == true)
		local textSize = math.clamp(tonumber(NAStuff.ESP_LocatorTextSize) or 14, 10, 48)

		local cx, cy = vp.X * 0.5, vp.Y * 0.5
		local margin = 16 + size * 0.5
		local minX, maxX = margin, vp.X - margin
		local minY, maxY = margin, vp.Y - margin

		local seen = {}

		local root = nil
		if NAStuff.ESP_ShowPartDistance == true then
			local lp = Players.LocalPlayer
			local ch = lp and lp.Character
			root = ch and getRoot(ch)
		end

		for _, entry in pairs(NAStuff.partESPEntries or {}) do
			if entry and not entry.removed and entry.part and entry.part.Parent then
				local pos = NAgui.getInstanceWorldPosition(entry.part)
				if pos then
					local v3 = cam:WorldToViewportPoint(pos)
					local x, y, z = v3.X, v3.Y, v3.Z
					local holder = getHolder(entry)
					local pointer = holder:FindFirstChild("Pointer")
					local label = holder:FindFirstChild("Name")
					local col = entry.lightColor or entry.baseColor or Color3.new(1,1,1)

					applyStyle(holder, col)

					if z > 0 and x >= 0 and x <= vp.X and y >= 0 and y <= vp.Y then
						holder.Visible = false
					else
						local dirX, dirY = x - cx, y - cy
						if z <= 0 then dirX = -dirX dirY = -dirY end
						local mag = math.sqrt(dirX*dirX + dirY*dirY)
						if mag < 1e-3 then dirX, dirY = 0, -1 else dirX, dirY = dirX/mag, dirY/mag end

						local sx = (cx - margin) / math.max(1e-4, math.abs(dirX))
						local sy = (cy - margin) / math.max(1e-4, math.abs(dirY))
						local scale = math.min(sx, sy)
						local px = cx + dirX * scale
						local py = cy + dirY * scale

						if px < minX then px = minX elseif px > maxX then px = maxX end
						if py < minY then py = minY elseif py > maxY then py = maxY end

						local wantPos = UDim2.fromOffset(px, py)
						if holder.Position.X.Offset ~= wantPos.X.Offset or holder.Position.Y.Offset ~= wantPos.Y.Offset then
							holder.Position = wantPos
						end

						if pointer then
							local ang = math.deg(math.atan2(dirY, dirX)) - 90
							if pointer.Rotation ~= ang then pointer.Rotation = ang end
						end

						if textOn and label then
							local nm = entry.customName or (entry.part and entry.part.Name) or "Part"
							if NAStuff.ESP_ShowPartDistance == true and root and root.Position then
								local d = math.floor((root.Position - pos).Magnitude + 0.5)
								nm = nm.." | "..tostring(d).." studs"
							end

							local side = math.abs(dirX) > math.abs(dirY)
							local textForSide = nm
							if side then
								local nameOnly, distOnly = nm, ""
								local bar = Find(nm, "|", 1, true)
								if bar then
									nameOnly = Sub(nm, 1, bar-2)
									distOnly = Sub(nm, bar+2)
								end
								textForSide = nameOnly..(distOnly ~= "" and ("\n"..distOnly) or "")
							end

							if label.Text ~= (side and textForSide or nm) then
								label.Text = side and textForSide or nm
							end

							if side then
								local maxW = math.max(60, math.floor(size * 3.5))
								local w, h = measure(textForSide, textSize, maxW)
								if label.Size.X.Offset ~= maxW or label.Size.Y.Offset ~= h then
									label.Size = UDim2.fromOffset(maxW, h)
								end
							else
								local maxW = math.floor(vp.X * 0.25)
								local w, h = measure(nm, textSize, maxW)
								if label.Size.X.Offset ~= w or label.Size.Y.Offset ~= h then
									label.Size = UDim2.fromOffset(w, h)
								end
							end

							local gap = 6 + math.floor(size * 0.35)
							local bx, by = -dirX, -dirY
							local offX = bx * (size*0.5 + gap)
							local offY = by * (size*0.5 + gap)

							local lblAbsX = px + offX
							local lblAbsY = py + offY

							local halfW = label.Size.X.Offset * 0.5
							local halfH = label.Size.Y.Offset * 0.5

							if lblAbsX - halfW < 4 then lblAbsX = 4 + halfW end
							if lblAbsX + halfW > vp.X - 4 then lblAbsX = vp.X - 4 - halfW end
							if lblAbsY - halfH < 4 then lblAbsY = 4 + halfH end
							if lblAbsY + halfH > vp.Y - 4 then lblAbsY = vp.Y - 4 - halfH end

							local relX = lblAbsX - px
							local relY = lblAbsY - py
							local wantLabel = UDim2.fromOffset(relX, relY)
							if label.Position.X.Offset ~= wantLabel.X.Offset or label.Position.Y.Offset ~= wantLabel.Y.Offset then
								label.Position = wantLabel
							end

							if not label.Visible then label.Visible = true end
						elseif label and label.Visible then
							label.Visible = false
						end

						holder.Visible = true
					end

					seen[entry] = true
				end
			end
		end

		for entry, holder in pairs(arrows) do
			if (not entry) or entry.removed or (not seen[entry]) or (not entry.part) or (not entry.part.Parent) then
				if holder and holder.Parent then holder:Destroy() end
				arrows[entry] = nil
			end
		end
	end))
end

NAmanage.ESP_LocatorDisable = function()
	NAStuff.ESP_LocatorEnabled = false
	NAlib.disconnect("esp_locator_loop")
	if NAStuff.ESP_LocatorArrows then
		for _, a in pairs(NAStuff.ESP_LocatorArrows) do
			if a and a.Parent then a:Destroy() end
		end
	end
	NAStuff.ESP_LocatorArrows = setmetatable({}, {__mode="k"})
	if NAStuff.ESP_LocatorGui and NAStuff.ESP_LocatorGui.Parent then
		NAStuff.ESP_LocatorGui:Destroy()
		NAStuff.ESP_LocatorGui = nil
	end
end

cmd.add({"touchesp","tesp"},{"touchesp"},function()
	NAmanage.EnableEsp("TouchTransmitter", Color3.fromRGB(255,0,0), NAStuff.touchESPList)
end)

cmd.add({"untouchesp","untesp"},{"untouchesp"},function()
	NAmanage.DisableEsp("TouchTransmitter", NAStuff.touchESPList)
end)

cmd.add({"proximityesp","prxesp","proxiesp"},{"proximityesp"},function()
	NAmanage.EnableEsp("ProximityPrompt", Color3.fromRGB(0,0,255), NAStuff.proximityESPList)
end)

cmd.add({"unproximityesp","unprxesp","unproxiesp"},{"unproximityesp"},function()
	NAmanage.DisableEsp("ProximityPrompt", NAStuff.proximityESPList)
end)

cmd.add({"clickesp","cesp"},{"clickesp"},function()
	NAmanage.EnableEsp("ClickDetector", Color3.fromRGB(255,165,0), NAStuff.clickESPList)
end)

cmd.add({"unclickesp","uncesp"},{"unclickesp"},function()
	NAmanage.DisableEsp("ClickDetector", NAStuff.clickESPList)
end)

cmd.add({"sitesp","ssp"},{"sitesp"},function()
	NAmanage.EnableEsp("Seat", Color3.fromRGB(0,255,0), NAStuff.siteESPList)
end)

cmd.add({"unsitesp","unssp"},{"unsitesp"},function()
	NAmanage.DisableEsp("Seat", NAStuff.siteESPList)
end)

cmd.add({"vehiclesitesp","vsitesp","vsp"},{"vehiclesitesp"},function()
	NAmanage.EnableEsp("VehicleSeat", Color3.fromRGB(255,0,255), NAStuff.vehicleSiteESPList)
end)

cmd.add({"unvehiclesitesp","unvsitesp","unvsp"},{"unvehiclesitesp"},function()
	NAmanage.DisableEsp("VehicleSeat", NAStuff.vehicleSiteESPList)
end)

cmd.add({"pesp","esppart","partesp"},{"pesp {partname}"},function(...)
	local name = Concat({...}," ")
	if name=="" then
		NAmanage.DisableNameEsp("exact")
	else
		NAmanage.EnableNameEsp("exact", nil, name)
	end
end,true)

cmd.add({"unpesp","unesppart","unpartesp"},{"unpesp [name|All]","Remove exact-name part ESP by name or All"},function(...)
	local mode = "exact"
	local parts = NAStuff.nameESPPartLists and NAStuff.nameESPPartLists[mode] or {}
	local terms = NAStuff.espNameLists and NAStuff.espNameLists[mode] or {}
	if type(terms) ~= "table" or #terms == 0 then
		DoNotif("No exact-name ESP terms are active.", 2)
		return
	end

	local filter = Lower(Concat({...}," "))

	local function removeAll()
		NAmanage.DisableNameEsp(mode)
		DoNotif("Cleared all exact-name part ESP.", 2)
	end

	local function termMatchesName(term, name)
		return Lower(name) == term
	end

	local function removeByTerm(term)
		for i = #terms, 1, -1 do
			if terms[i] == term then
				table.remove(terms, i)
			end
		end
		for i = #parts, 1, -1 do
			local p = parts[i]
			if p and p.Parent and termMatchesName(term, p.Name) then
				NAmanage.RemoveEspFromPart(p)
				table.remove(parts, i)
			end
		end
		DoNotif("Removed exact-name ESP for '"..term.."'.", 2)
	end

	if filter ~= "" then
		if filter == "all" then
			removeAll()
			return
		end
		local picked = nil
		for _, t in ipairs(terms) do
			if t == filter then picked = t break end
		end
		if not picked then
			for _, t in ipairs(terms) do
				if Match(t, filter) then picked = t break end
			end
		end
		if picked then
			removeByTerm(picked)
		else
			DoNotif("No matching exact-name ESP term for: "..filter, 3)
		end
		return
	end

	local buttons = {}
	Insert(buttons, { Text = "All", Callback = removeAll })
	for _, t in ipairs(terms) do
		Insert(buttons, { Text = t, Callback = function() removeByTerm(t) end })
	end

	Window({
		Title = "Remove Exact Part ESP",
		Description = "Select a term to stop tracking (future spawns included).",
		Buttons = buttons
	})
end,true)

cmd.add({"pespfind","partespfind","esppartfind"},{"pespfind {partname}"},function(...)
	local name = Concat({...}," ")
	if name=="" then
		NAmanage.DisableNameEsp("partial")
	else
		NAmanage.EnableNameEsp("partial", nil, name)
	end
end,true)

cmd.add({"unpespfind","unpartespfind","unesppartfind"},{"unpespfind [name|All]","Remove partial-name part ESP by name or All"},function(...)
	local mode = "partial"
	local parts = NAStuff.nameESPPartLists and NAStuff.nameESPPartLists[mode] or {}
	local terms = NAStuff.espNameLists and NAStuff.espNameLists[mode] or {}
	if type(terms) ~= "table" or #terms == 0 then
		DoNotif("No partial-name ESP terms are active.", 2)
		return
	end

	local filter = Lower(Concat({...}," "))

	local function removeAll()
		NAmanage.DisableNameEsp(mode)
		DoNotif("Cleared all partial-name part ESP.", 2)
	end

	local function termMatchesName(term, name)
		return Find(Lower(name), term) ~= nil
	end

	local function removeByTerm(term)
		for i = #terms, 1, -1 do
			if terms[i] == term then
				table.remove(terms, i)
			end
		end
		for i = #parts, 1, -1 do
			local p = parts[i]
			if p and p.Parent and termMatchesName(term, p.Name) then
				NAmanage.RemoveEspFromPart(p)
				table.remove(parts, i)
			end
		end
		DoNotif("Removed partial-name ESP for '"..term.."'.", 2)
	end

	if filter ~= "" then
		if filter == "all" then
			removeAll()
			return
		end
		local picked = nil
		for _, t in ipairs(terms) do
			if t == filter then picked = t break end
		end
		if not picked then
			for _, t in ipairs(terms) do
				if Match(t, filter) then picked = t break end
			end
		end
		if picked then
			removeByTerm(picked)
		else
			DoNotif("No matching partial-name ESP term for: "..filter, 3)
		end
		return
	end

	local buttons = {}
	Insert(buttons, { Text = "All", Callback = removeAll })
	for _, t in ipairs(terms) do
		Insert(buttons, { Text = t, Callback = function() removeByTerm(t) end })
	end

	Window({
		Title = "Remove Partial Part ESP",
		Description = "Select a term to stop tracking (future spawns included).",
		Buttons = buttons
	})
end,true)

cmd.add({"unanchored","unanchoredesp","uaesp"},{"unanchored"},function()
	NAmanage.EnableUnanchoredEsp(Color3.fromRGB(255,220,0))
end)

cmd.add({"ununanchored","ununanchoredesp","unuaesp"},{"ununanchored"},function()
	NAmanage.DisableUnanchoredEsp()
end)

cmd.add({"collisionesp","colesp"},{"collisionesp"},function()
	NAmanage.EnableCollisionEsp(true, Color3.fromRGB(0,200,255))
end)

cmd.add({"uncollisionesp","uncolesp"},{"uncollisionesp"},function()
	NAmanage.DisableCollisionEsp(true)
end)

cmd.add({"nocollisionesp","ncolesp"},{"nocollisionesp"},function()
	NAmanage.EnableCollisionEsp(false, Color3.fromRGB(255,120,120))
end)

cmd.add({"unnocollisionesp","unncolesp"},{"unnocollisionesp"},function()
	NAmanage.DisableCollisionEsp(false)
end)

cmd.add({"esplocator","locator","trackesp"},{"esplocator",""},function()
	NAmanage.ESP_LocatorEnable(true)
end)

cmd.add({"unesplocator","unlocator","untrackesp"},{"unesplocator",""},function()
	NAmanage.ESP_LocatorDisable()
end)

originalIO.folderESPMode=function()
	return (Lower(tostring(NAStuff.ESP_FolderMode or "parts")) == "models") and "models" or "parts"
end

NAmanage.FolderESP_Enable = function(folder)
	if typeof(folder) ~= "Instance" or not folder:IsA("Folder") then
		return
	end

	if not NAStuff.folderESPMembers then NAStuff.folderESPMembers = {} end
	if not NAStuff.folderESPKeys then NAStuff.folderESPKeys = {} end

	local mode = originalIO.folderESPMode()
	local highlightColor = Color3.fromRGB(255,220,0)

	local function topModelFor(instance, rootFolder)
		if not instance or not rootFolder then
			return nil
		end
		local model = instance:IsA("Model") and instance or instance:FindFirstAncestorOfClass("Model")
		while model and model.Parent and model.Parent:IsA("Model") and model.Parent:IsDescendantOf(rootFolder) do
			model = model.Parent
		end
		if model and model:IsDescendantOf(rootFolder) then
			return model
		end
		return nil
	end

	local function modelHasBasePart(model)
		return model and model:FindFirstChildWhichIsA("BasePart", true)
	end

	local function addTarget(list, target)
		if not target or not target.Parent then
			return
		end
		if Discover(list, target) then
			return
		end
		Insert(list, target)
		NAmanage.CreateBox(target, highlightColor, 0.45)
	end

	local function removeTarget(list, target)
		if not target then
			return
		end
		local idx = Discover(list, target)
		if idx then
			NAmanage.RemoveEspFromPart(target)
			table.remove(list, idx)
		end
	end

	local function rescanFolder(rootFolder, list)
		for _, desc in ipairs(rootFolder:GetDescendants()) do
			if mode == "models" then
				if desc:IsA("Model") then
					local top = topModelFor(desc, rootFolder)
					if top == desc and modelHasBasePart(top) then
						addTarget(list, top)
					end
				elseif desc:IsA("BasePart") then
					local top = topModelFor(desc, rootFolder)
					if top and modelHasBasePart(top) then
						addTarget(list, top)
					else
						addTarget(list, desc)
					end
				end
			elseif desc:IsA("BasePart") then
				addTarget(list, desc)
			end
		end
	end

	local list = NAStuff.folderESPMembers[folder]
	if not list then
		list = {}
	else
		for i = #list, 1, -1 do
			NAmanage.RemoveEspFromPart(list[i])
			list[i] = nil
		end
	end
	NAStuff.folderESPMembers[folder] = list

	local key = NAStuff.folderESPKeys[folder]
	if not key then
		key = "esp_folder_"..tostring(folder)
		NAStuff.folderESPKeys[folder] = key
	end

	if NAlib.isConnected(key) then
		NAlib.disconnect(key)
	end

	rescanFolder(folder, list)

	local function onAdded(obj)
		if mode == "models" then
			if obj:IsA("Model") then
				local top = topModelFor(obj, folder)
				if top == obj and modelHasBasePart(top) then
					addTarget(list, top)
				end
			elseif obj:IsA("BasePart") then
				local top = topModelFor(obj, folder)
				if top and modelHasBasePart(top) then
					addTarget(list, top)
				else
					addTarget(list, obj)
				end
			end
		elseif obj:IsA("BasePart") then
			addTarget(list, obj)
		end
	end

	local function onRemoving(obj)
		if mode == "models" then
			if obj:IsA("Model") then
				removeTarget(list, obj)
			elseif obj:IsA("BasePart") then
				local top = topModelFor(obj, folder)
				if top then
					Defer(function()
						if not modelHasBasePart(top) then
							removeTarget(list, top)
						end
					end)
				end
				removeTarget(list, obj)
			end
		elseif obj:IsA("BasePart") then
			removeTarget(list, obj)
		end
	end

	NAlib.connect(key, folder.DescendantAdded:Connect(onAdded))
	NAlib.connect(key, folder.DescendantRemoving:Connect(onRemoving))
end

NAmanage.FolderESP_RefreshActive = function()
	local members = NAStuff.folderESPMembers
	if type(members) ~= "table" then
		return
	end
	local tracked = {}
	for folder, _ in pairs(members) do
		if typeof(folder) == "Instance" and folder:IsA("Folder") then
			tracked[#tracked + 1] = folder
		else
			members[folder] = nil
		end
	end
	for _, folder in ipairs(tracked) do
		NAmanage.FolderESP_Enable(folder)
	end
end

cmd.add({"folderesp","fesp"},{"folderesp {folderName}","Highlights folder contents (parts or models)"},function(...)
	local rawInput = Concat({...}, " ")
	local name = Lower(rawInput)
	if name == "" then
		return
	end

	local matches = {}
	local exactFolder

	for _, obj in ipairs(workspace:GetDescendants()) do
		if obj:IsA("Folder") then
			local lowered = Lower(obj.Name)
			if lowered == name then
				exactFolder = obj
				break
			elseif Find(lowered, name, 1, true) then
				Insert(matches, obj)
			end
		end
	end

	if exactFolder then
		NAmanage.FolderESP_Enable(exactFolder)
		return
	end

	if #matches == 0 then
		DoNotif(Format("No folders found containing '%s'.", rawInput), 3)
		return
	end

	table.sort(matches, function(a, b)
		local la, lb = Lower(a.Name), Lower(b.Name)
		local pa = Find(la, name, 1, true) or math.huge
		local pb = Find(lb, name, 1, true) or math.huge
		if pa == pb then
			if #la == #lb then
				return la < lb
			end
			return #la < #lb
		end
		return pa < pb
	end)

	local buttons = {}

	if #matches > 1 then
		Insert(buttons, {
			Text = "All Matches",
			Callback = function()
				for _, folder in ipairs(matches) do
					NAmanage.FolderESP_Enable(folder)
				end
			end
		})
	end

	for _, folder in ipairs(matches) do
		local folderRef = folder
		Insert(buttons, {
			Text = folderRef.Name,
			Callback = function()
				NAmanage.FolderESP_Enable(folderRef)
			end
		})
	end

	Window({
		Title = "Folder ESP",
		Description = "Select folder(s) to highlight. Toggle multi-select in the header to pick several.",
		Buttons = buttons
	})
end,true)

cmd.add({"unfolderesp","unfesp"},{"unfolderesp [folderName]","Disables folder ESP for a folder or all"},function(...)
	local members = NAStuff.folderESPMembers
	if type(members) ~= "table" then
		DoNotif("No folder ESP entries are active.", 2)
		return
	end

	local keysCache = NAStuff.folderESPKeys

	local function detachFolder(folder)
		if typeof(folder) ~= "Instance" then
			return false
		end

		local removed = false

		if keysCache then
			local conn = keysCache[folder]
			if conn then
				NAlib.disconnect(conn)
				keysCache[folder] = nil
				removed = true
			end
		end

		local list = members[folder]
		if list then
			for _, part in ipairs(list) do
				NAmanage.RemoveEspFromPart(part)
			end
			table.clear(list)
			members[folder] = nil
			removed = true
		end

		return removed
	end

	local function collectTrackedFolders()
		local tracked = {}
		for folder, _ in pairs(members) do
			if typeof(folder) == "Instance" then
				tracked[#tracked + 1] = folder
			else
				members[folder] = nil
			end
		end
		table.sort(tracked, function(a, b)
			return Lower(a.Name) < Lower(b.Name)
		end)
		return tracked
	end

	local function removeAllFolders()
		local tracked = collectTrackedFolders()
		local removed = 0
		for _, folder in ipairs(tracked) do
			if detachFolder(folder) then
				removed += 1
			end
		end
		if removed > 0 then
			DoNotif(Format("Stopped folder ESP for %d folder(s).", removed), 2)
		else
			DoNotif("No folder ESP entries were active.", 2)
		end
	end

	local trackedFolders = collectTrackedFolders()

	local rawInput = Concat({...}, " ")
	rawInput = (type(rawInput) == "string") and rawInput:gsub("^%s+", ""):gsub("%s+$", "") or ""
	local loweredInput = Lower(rawInput)

	if loweredInput ~= "" then
		if loweredInput == "all" or loweredInput == "*" then
			removeAllFolders()
			return
		end

		local picked = nil
		for _, folder in ipairs(trackedFolders) do
			if Lower(folder.Name) == loweredInput then
				picked = folder
				break
			end
		end

		if not picked then
			for _, folder in ipairs(trackedFolders) do
				if Match(Lower(folder.Name), loweredInput) then
					picked = folder
					break
				end
			end
		end

		if picked and detachFolder(picked) then
			DoNotif(Format("Stopped folder ESP for '%s'.", picked.Name), 2)
		else
			DoNotif(Format("No folder ESP entry matching '%s'.", rawInput ~= "" and rawInput or loweredInput), 3)
		end
		return
	end

	if #trackedFolders == 0 then
		DoNotif("No folder ESP entries are active.", 2)
		return
	end

	local buttons = {
		{
			Text = "All",
			Callback = removeAllFolders
		}
	}

	for _, folder in ipairs(trackedFolders) do
		local folderRef = folder
		buttons[#buttons + 1] = {
			Text = folderRef.Name,
			Callback = function()
				if detachFolder(folderRef) then
					DoNotif(Format("Stopped folder ESP for '%s'.", folderRef.Name), 2)
				else
					DoNotif("Folder ESP entry was not active.", 2)
				end
			end
		}
	end

	Window({
		Title = "Folder ESP",
		Description = "Select a folder ESP entry to disable.",
		Buttons = buttons
	})
end,true)

cmd.add({"viewpart", "viewp", "vpart"}, {"viewpart {partName} (viewp, vpart)", "Focuses camera on a part, model, or folder"},function(...)
	local partName = Concat({...}, " "):lower()
	local ws = workspace
	local camera = ws.CurrentCamera

	for _, obj in ipairs(ws:GetDescendants()) do
		if obj.Name:lower() == partName then
			if obj:IsA("BasePart") then
				camera.CameraSubject = obj
				return
			elseif obj:IsA("Model") or obj:IsA("Folder") then
				for _, child in ipairs(obj:GetDescendants()) do
					if child:IsA("BasePart") then
						camera.CameraSubject = child
						return
					end
				end
			end
		end
	end

	DebugNotif("No matching part, model, or folder with a BasePart found named '"..partName.."'")
end,true)

cmd.add({"unviewpart", "unviewp"}, {"unviewpart (unviewp)", "Resets the camera to the local humanoid"}, function()
	local camera = workspace.CurrentCamera
	local humanoid = getHum()
	if humanoid then
		camera.CameraSubject = humanoid
	end
end)

cmd.add({"viewpartfind", "viewpfind", "vpartfind"}, {"viewpartfind {name} (viewpfind, vpartfind)", "Focuses camera on a part, model, or folder with name containing the given text"}, function(...)
	local name = Concat({...}, " "):lower()
	local ws = workspace
	local cam = ws.CurrentCamera

	for _, obj in ipairs(ws:GetDescendants()) do
		if obj.Name:lower():find(name) then
			if obj:IsA("BasePart") then
				cam.CameraSubject = obj
				return
			elseif obj:IsA("Model") or obj:IsA("Folder") then
				for _, child in ipairs(obj:GetDescendants()) do
					if child:IsA("BasePart") then
						cam.CameraSubject = child
						return
					end
				end
			end
		end
	end

	DebugNotif("No part, model, or folder containing '"..name.."' with a BasePart found")
end, true)

cmd.add({"unviewpart", "unviewp"}, {"unviewpart (unviewp)", "Resets the camera to the local humanoid"}, function()
	local cam = workspace.CurrentCamera
	local hum = getHum()
	if hum then
		cam.CameraSubject = hum
	end
end)

cmd.add({"console", "debug"}, {"console (debug)", "Opens developer console"}, function()
	local consoleButtons = {
		{
			Text = "Roblox Console",
			Callback = function()
				StarterGui:SetCore("DevConsoleVisible", true)
			end
		},
		{
			Text = "Custom Console",
			Callback = function()
				NAgui.consoleeee()
			end
		}
	}

	Window({
		Title = "Select Console",
		Buttons = consoleButtons
	})
end)

cmd.add({"hitbox","hbox"},{"hitbox <player> {size}",""},function(pArg,sArg)
	NAStuff.HB = NAStuff.HB or {}

	NAStuff.HB.P = NAStuff.HB.P or {
		ps=setmetatable({}, {__mode="k"}),
		og=setmetatable({}, {__mode="k"}),
		ca=setmetatable({}, {__mode="k"}),
		da=setmetatable({}, {__mode="k"}),
		addConn=nil, remConn=nil,
		run=nil, cfg=nil
	}

	NAStuff.HB.N = NAStuff.HB.N or {
		ps=setmetatable({}, {__mode="k"}),
		og=setmetatable({}, {__mode="k"}),
		md=setmetatable({}, {__mode="k"}),
		wc=nil,
		run=nil, cfg=nil
	}

	local targets = getPlr(pArg)
	if #targets==0 then DoNotif("No targets found",2) return end

	local n = tonumber(sArg) or 10
	local argL = Lower(pArg)
	local npc = (argL=="npc")
	local glb = (argL=="all" or argL=="others")

	local function GetChar(t)
		if typeof(t)=="Instance" and t:IsA("Player") then
			return getPlrChar(t)
		elseif typeof(t)=="Instance" and t:IsA("Model") then
			return t
		end
	end

	local partSet = {All=true}
	for _,t in ipairs(targets) do
		local c = GetChar(t)
		if c then
			for _,p in ipairs(c:GetChildren()) do
				if p:IsA("BasePart") then
					partSet[p.Name]=true
				end
			end
		end
	end

	local btns = {}
	for limb,_ in pairs(partSet) do
		Insert(btns,{
			Text = limb,
			Callback = function()
				local sz = Vector3.new(n,n,n)
				local bc = BrickColor.new("Really black")
				local mat = Enum.Material.Neon
				local limbL = Lower(limb)
				local isAll = (limb=="All")

				local function MatchBp(bp)
					if isAll then return true end
					return Lower(bp.Name)==limbL
				end

				local function Cache(D, key, bp)
					D.og[key] = D.og[key] or setmetatable({}, {__mode="k"})
					if not D.og[key][bp] then
						D.og[key][bp] = {
							Size=bp.Size, Transparency=bp.Transparency, BrickColor=bp.BrickColor,
							Material=bp.Material, CanCollide=bp.CanCollide, Massless=bp.Massless
						}
					end
				end

				local function ApplyBp(D, key, bp)
					Cache(D, key, bp)
					if bp.Size ~= D.cfg.sz then bp.Size = D.cfg.sz end
					if bp.Transparency ~= 0.9 then bp.Transparency = 0.9 end
					if bp.BrickColor ~= D.cfg.bc then bp.BrickColor = D.cfg.bc end
					if bp.Material ~= D.cfg.mat then bp.Material = D.cfg.mat end
					if bp.CanCollide then bp.CanCollide = false end
					if not bp.Massless then bp.Massless = true end
				end

				if npc then
					local D = NAStuff.HB.N

					if D.run then D.run:Disconnect() D.run=nil end
					if D.wc then D.wc:Disconnect() D.wc=nil end
					for m,c in pairs(D.md) do
						if c then c:Disconnect() end
						D.md[m]=nil
					end
					for m,_ in pairs(D.ps) do
						D.ps[m]=nil
					end

					D.cfg = {limb=limb, limbL=limbL, sz=sz, bc=bc, mat=mat}

					local function Track(m, bp)
						if not (bp and bp.Parent) then return end
						if not bp:IsA("BasePart") then return end
						if not MatchBp(bp) then return end
						D.ps[m] = D.ps[m] or setmetatable({}, {__mode="k"})
						D.ps[m][bp] = true
						ApplyBp(D, m, bp)
					end

					local function Scan(m)
						if not (m and m.Parent) then return end
						for _,c in ipairs(m:GetChildren()) do
							if c:IsA("BasePart") then
								Track(m, c)
							end
						end
					end

					local function Setup(m)
						if not (m and m.Parent) then return end
						if D.md[m] then D.md[m]:Disconnect() end
						D.md[m] = m.DescendantAdded:Connect(function(inst)
							if inst and inst:IsA("BasePart") then
								Track(m, inst)
							end
						end)
						Scan(m)
					end

					local function IsNPC(inst)
						if inst and inst:IsA("Model") and CheckIfNPC(inst) then return inst end
						local m = inst and inst:FindFirstAncestorWhichIsA("Model") or nil
						if m and CheckIfNPC(m) then return m end
						return nil
					end

					for _,t in ipairs(targets) do
						local m = GetChar(t)
						if m then Setup(m) end
					end

					D.wc = workspace.DescendantAdded:Connect(function(inst)
						local m = IsNPC(inst)
						if m then
							Defer(function()
								if not D.md[m] then
									Setup(m)
								end
							end)
						end
					end)

					local acc = 0
					local acc2 = 0
					D.run = RunService.Heartbeat:Connect(function(dt)
						acc += dt
						acc2 += dt

						if acc >= 0.45 then
							acc = 0
							for m,set in pairs(D.ps) do
								if not (m and m.Parent) then
									D.ps[m]=nil
									D.og[m]=nil
								else
									for bp,_ in pairs(set) do
										if not (bp and bp.Parent) then
											set[bp]=nil
										else
											if MatchBp(bp) then
												ApplyBp(D, m, bp)
											end
										end
									end
								end
							end
						end

						if acc2 >= 1.2 then
							acc2 = 0
							for _,ch in ipairs(workspace:GetChildren()) do
								if ch:IsA("Model") and CheckIfNPC(ch) and not D.md[ch] then
									Setup(ch)
								end
							end
						end
					end)

				else
					local D = NAStuff.HB.P

					if D.run then D.run:Disconnect() D.run=nil end
					if D.addConn then D.addConn:Disconnect() D.addConn=nil end
					if D.remConn then D.remConn:Disconnect() D.remConn=nil end
					for k,c in pairs(D.ca) do
						if c then c:Disconnect() end
						D.ca[k]=nil
					end
					for k,c in pairs(D.da) do
						if c then c:Disconnect() end
						D.da[k]=nil
					end
					for k,_ in pairs(D.ps) do
						D.ps[k]=nil
					end

					D.cfg = {limb=limb, limbL=limbL, sz=sz, bc=bc, mat=mat}

					local function Track(k, bp)
						if not (bp and bp.Parent) then return end
						if not bp:IsA("BasePart") then return end
						if not MatchBp(bp) then return end
						D.ps[k] = D.ps[k] or setmetatable({}, {__mode="k"})
						D.ps[k][bp] = true
						ApplyBp(D, k, bp)
					end

					local function Scan(k, ch)
						if not (ch and ch.Parent) then return end
						for _,c in ipairs(ch:GetChildren()) do
							if c:IsA("BasePart") then
								Track(k, c)
							end
						end
					end

					local function SetupChar(k, ch)
						if D.da[k] then D.da[k]:Disconnect() end
						D.da[k] = ch.DescendantAdded:Connect(function(inst)
							if inst and inst:IsA("BasePart") then
								Track(k, inst)
							end
						end)
						Scan(k, ch)
					end

					local function SetupKey(k)
						local ch = GetChar(k)
						if ch then SetupChar(k, ch) end
						if typeof(k)=="Instance" and k:IsA("Player") and k.CharacterAdded then
							if D.ca[k] then D.ca[k]:Disconnect() end
							D.ca[k] = k.CharacterAdded:Connect(function(c)
								Defer(function()
									if c then SetupChar(k, c) end
								end)
							end)
						end
					end

					for _,t in ipairs(targets) do
						SetupKey(t)
					end

					if glb then
						D.addConn = Players.PlayerAdded:Connect(function(plr)
							SetupKey(plr)
						end)
						D.remConn = Players.PlayerRemoving:Connect(function(plr)
							if D.ca[plr] then D.ca[plr]:Disconnect() D.ca[plr]=nil end
							if D.da[plr] then D.da[plr]:Disconnect() D.da[plr]=nil end
							D.ps[plr]=nil
							D.og[plr]=nil
						end)
					end

					local acc = 0
					D.run = RunService.Heartbeat:Connect(function(dt)
						acc += dt
						if acc < 0.45 then return end
						acc = 0

						for k,set in pairs(D.ps) do
							local ch = GetChar(k)
							if not (ch and ch.Parent) then
								D.ps[k]=nil
							else
								for bp,_ in pairs(set) do
									if not (bp and bp.Parent) then
										set[bp]=nil
									else
										if MatchBp(bp) then
											ApplyBp(D, k, bp)
										end
									end
								end
							end
						end
					end)
				end
			end
		})
	end

	Window({Title="Hitbox Menu",Description="Choose limb to resize",Buttons=btns})
end,true)

cmd.add({"unhitbox","unhbox"},{"unhitbox <player>",""},function(pArg)
	NAStuff.HB = NAStuff.HB or {}

	NAStuff.HB.P = NAStuff.HB.P or {
		ps=setmetatable({}, {__mode="k"}),
		og=setmetatable({}, {__mode="k"}),
		ca=setmetatable({}, {__mode="k"}),
		da=setmetatable({}, {__mode="k"}),
		addConn=nil, remConn=nil,
		run=nil, cfg=nil
	}

	NAStuff.HB.N = NAStuff.HB.N or {
		ps=setmetatable({}, {__mode="k"}),
		og=setmetatable({}, {__mode="k"}),
		md=setmetatable({}, {__mode="k"}),
		wc=nil,
		run=nil, cfg=nil
	}

	local targets = getPlr(pArg)
	if #targets==0 then DoNotif("No targets found",2) return end

	local argL = Lower(pArg)
	local npc = (argL=="npc")
	local glb = (argL=="all" or argL=="others")

	local function GetChar(t)
		if typeof(t)=="Instance" and t:IsA("Player") then
			return getPlrChar(t)
		elseif typeof(t)=="Instance" and t:IsA("Model") then
			return t
		end
	end

	local function RestoreMap(mp)
		for bp,pr in pairs(mp) do
			if bp and bp.Parent then
				bp.Size = pr.Size
				bp.Transparency = pr.Transparency
				bp.BrickColor = pr.BrickColor
				bp.Material = pr.Material
				bp.CanCollide = pr.CanCollide
				bp.Massless = pr.Massless
			end
		end
	end

	if npc then
		local D = NAStuff.HB.N

		for m,mp in pairs(D.og) do
			if mp then RestoreMap(mp) end
		end

		for m,c in pairs(D.md) do
			if c then c:Disconnect() end
			D.md[m]=nil
		end

		if D.wc then D.wc:Disconnect() D.wc=nil end
		if D.run then D.run:Disconnect() D.run=nil end

		for m,_ in pairs(D.ps) do D.ps[m]=nil end
		for m,_ in pairs(D.og) do D.og[m]=nil end
		D.cfg = nil
		return
	end

	local D = NAStuff.HB.P

	for _,t in ipairs(targets) do
		local k = t
		local ch = GetChar(k)

		if D.og[k] then
			RestoreMap(D.og[k])
			D.og[k]=nil
		end

		if D.ps[k] then D.ps[k]=nil end
		if D.ca[k] then D.ca[k]:Disconnect() D.ca[k]=nil end
		if D.da[k] then D.da[k]:Disconnect() D.da[k]=nil end

		if typeof(k)=="Instance" and k:IsA("Model") and ch==k then
			if D.og[k] then
				RestoreMap(D.og[k])
				D.og[k]=nil
			end
		end
	end

	if glb then
		if D.addConn then D.addConn:Disconnect() D.addConn=nil end
		if D.remConn then D.remConn:Disconnect() D.remConn=nil end
	end

	local any = false
	for k,_ in pairs(D.ps) do any = true break end
	if not any then
		if D.run then D.run:Disconnect() D.run=nil end
		D.cfg = nil
	end
end,true)

NAStuff.PST = {
	orig   = {},
	exact  = {},
	partial= {},
	sizeE  = {},
	sizeP  = {},
}
PST = NAStuff.PST

NAmanage.cachePart = function(p)
	NAStuff.PST.orig[p] = {
		Size         = p.Size,
		Transparency = p.Transparency,
		CanCollide   = p.CanCollide,
	}
end

NAmanage.resizePart = function(p, sizeVec, store)
	if not NAStuff.PST.orig[p] then NAmanage.cachePart(p) end
	p.Size         = sizeVec
	p.Transparency = 0.5
	p.CanCollide   = false
	Insert(store, p)
end

cmd.add({"partsize","psize","sizepart"},{"partsize {name} {size}", "Grow a part or model named exactly <name> to the cube size you choose."},function(nameArg, sizeArg)
	local term, n = Lower(nameArg), tonumber(sizeArg)
	if not n then DoNotif("Invalid size",2) return end
	local sizeVec = Vector3.new(n,n,n)
	NAStuff.PST.sizeE[term] = sizeVec

	local parts, elser = {}, {}
	for _, obj in ipairs(workspace:GetDescendants()) do
		local nm = Lower(obj.Name)
		if obj:IsA("BasePart") and nm == term then
			Insert(parts, obj)
		elseif nm == term then
			Insert(elser, obj)
		end
	end

	for _, p in ipairs(parts) do
		NAmanage.resizePart(p, sizeVec, NAStuff.PST.exact)
	end
	for _, m in ipairs(elser) do
		for _, d in ipairs(m:GetDescendants()) do
			if d:IsA("BasePart") then
				NAmanage.resizePart(d, sizeVec, PST.exact)
			end
		end
	end

	if not NAlib.isConnected("partsizeExact") then
		NAlib.connect("partsizeExact", workspace.DescendantAdded:Connect(function(obj)
			if obj:IsA("BasePart") then
				local nm = Lower(obj.Name)
				local sz = NAStuff.PST.sizeE[nm]
				if sz then
					NAmanage.resizePart(obj, sz, PST.exact)
					return
				end
			else
				local sz = NAStuff.PST.sizeE[Lower(obj.Name)]
				if sz then
					for _, d in ipairs(obj:GetDescendants()) do
						if d:IsA("BasePart") then
							NAmanage.resizePart(d, sz, PST.exact)
						end
					end
				end
			end
		end))
	end
end, true)

cmd.add({"partsizefind","psizefind","sizefind","partsizef"},{"partsizefind {term} {size}", "Grow every part or model whose name contains <term> to the cube size you choose."},function(termArg, sizeArg)
	local term, n = Lower(termArg), tonumber(sizeArg)
	if not n then DoNotif("Invalid size",2) return end
	local sizeVec = Vector3.new(n,n,n)
	PST.sizeP[term] = sizeVec

	local parts, elser = {}, {}
	for _, obj in ipairs(workspace:GetDescendants()) do
		local nm = Lower(obj.Name)
		if obj:IsA("BasePart") and nm:find(term) then
			Insert(parts, obj)
		elseif nm:find(term) then
			Insert(elser, obj)
		end
	end

	for _, p in ipairs(parts) do
		NAmanage.resizePart(p, sizeVec, PST.partial)
	end
	for _, m in ipairs(elser) do
		for _, d in ipairs(m:GetDescendants()) do
			if d:IsA("BasePart") then
				NAmanage.resizePart(d, sizeVec, PST.partial)
			end
		end
	end

	if not NAlib.isConnected("partsizeFind") then
		NAlib.connect("partsizeFind", workspace.DescendantAdded:Connect(function(obj)
			if obj:IsA("BasePart") then
				local nm = Lower(obj.Name)
				for t, sz in pairs(PST.sizeP) do
					if nm:find(t) then
						NAmanage.resizePart(obj, sz, PST.partial)
						return
					end
				end
			else
				for t, sz in pairs(PST.sizeP) do
					if Lower(obj.Name):find(t) then
						for _, d in ipairs(obj:GetDescendants()) do
							if d:IsA("BasePart") then
								NAmanage.resizePart(d, sz, PST.partial)
							end
						end
						return
					end
				end
			end
		end))
	end
end, true)

cmd.add({"unpartsize","unsizepart","unpsize"},{"unpartsize", "Undo partsize—return those parts back to their original size and collision."},function()
	local parts = PST.exact
	local sizeMap = PST.sizeE

	local terms = {}
	for term, _ in pairs(sizeMap) do
		Insert(terms, term)
	end

	local function restorePart(p)
		local pr = PST.orig[p]
		if pr then
			p.Size         = pr.Size
			p.Transparency = pr.Transparency
			p.CanCollide   = pr.CanCollide
			PST.orig[p] = nil
		end
	end

	local function termMatchesPart(term, part)
		local obj = part
		while obj do
			if Lower(obj.Name) == term then
				return true
			end
			obj = obj.Parent
		end
		return false
	end

	local function removeAll()
		for _, p in ipairs(parts) do
			restorePart(p)
		end
		table.clear(parts)
		table.clear(sizeMap)
		NAlib.disconnect("partsizeExact")
		DoNotif("Cleared all exact-name partsize changes.", 2)
	end

	if #terms == 0 then
		if #parts == 0 then
			DoNotif("No exact-name partsize changes are active.", 2)
		else
			removeAll()
		end
		return
	end

	local function removeByTerm(term)
		for i = #parts, 1, -1 do
			local p = parts[i]
			if p and p.Parent and termMatchesPart(term, p) then
				restorePart(p)
				table.remove(parts, i)
			end
		end
		sizeMap[term] = nil
		if not next(sizeMap) then
			NAlib.disconnect("partsizeExact")
		end
		DoNotif("Reverted partsize for exact name '"..term.."'.", 2)
	end

	local buttons = {}
	Insert(buttons, { Text = "All", Callback = removeAll })
	for _, t in ipairs(terms) do
		Insert(buttons, { Text = t, Callback = function() removeByTerm(t) end })
	end

	Window({
		Title = "Undo Exact Partsize",
		Description = "Select a name to restore original size (future spawns included).",
		Buttons = buttons
	})
end, true)

cmd.add({"unpartsizefind","unsizefind","unpsizefind"},{"unpartsizefind", "Undo partsizefind—return those resized parts back to their original size and collision."},function()
	local parts = PST.partial
	local sizeMap = PST.sizeP

	local terms = {}
	for term, _ in pairs(sizeMap) do
		Insert(terms, term)
	end

	local function restorePart(p)
		local pr = PST.orig[p]
		if pr then
			p.Size         = pr.Size
			p.Transparency = pr.Transparency
			p.CanCollide   = pr.CanCollide
			PST.orig[p] = nil
		end
	end

	local function termMatchesPart(term, part)
		local obj = part
		while obj do
			if Find(Lower(obj.Name), term) ~= nil then
				return true
			end
			obj = obj.Parent
		end
		return false
	end

	local function removeAll()
		for _, p in ipairs(parts) do
			restorePart(p)
		end
		table.clear(parts)
		table.clear(sizeMap)
		NAlib.disconnect("partsizeFind")
		DoNotif("Cleared all partial-name partsize changes.", 2)
	end

	if #terms == 0 then
		if #parts == 0 then
			DoNotif("No partial-name partsize changes are active.", 2)
		else
			removeAll()
		end
		return
	end

	local function removeByTerm(term)
		for i = #parts, 1, -1 do
			local p = parts[i]
			if p and p.Parent and termMatchesPart(term, p) then
				restorePart(p)
				table.remove(parts, i)
			end
		end
		sizeMap[term] = nil
		if not next(sizeMap) then
			NAlib.disconnect("partsizeFind")
		end
		DoNotif("Reverted partsizefind for term '"..term.."'.", 2)
	end

	local buttons = {}
	Insert(buttons, { Text = "All", Callback = removeAll })
	for _, t in ipairs(terms) do
		Insert(buttons, { Text = t, Callback = function() removeByTerm(t) end })
	end

	Window({
		Title = "Undo Partial Partsize",
		Description = "Select a term to restore original size (future spawns included).",
		Buttons = buttons
	})
end, true)

cmd.add({"breakcars", "bcars"}, {"breakcars (bcars)", "Breaks any car"}, function()
	DebugNotif("Car breaker loaded, sit on a vehicle and be the driver")

	local Player = Players.LocalPlayer
	local Mouse = Player:GetMouse()

	local Folder = InstanceNew("Folder")
	Folder.Parent = workspace

	local Part = InstanceNew("Part")
	Part.Anchored = true
	Part.CanCollide = false
	Part.Transparency = 1
	Part.Size = Vector3.new(1, 1, 1)
	Part.Parent = Folder

	local Attachment1 = InstanceNew("Attachment")
	Attachment1.Parent = Part

	local UpdatedPosition = Mouse.Hit + Vector3.new(0, 5, 0)

	SpawnCall(function()
		while Wait() do
			for _, player in ipairs(Players:GetPlayers()) do
				if player ~= Player then
					player.MaximumSimulationRadius = 0
					opt.hiddenprop(player, "SimulationRadius", 0)
				end
			end
			Player.MaximumSimulationRadius = math.pow(math.huge, math.huge)
			setsimulationradius(math.huge)
		end
	end)

	local function applyForceToPart(part)
		if not part:IsA("BasePart") or part.Anchored then return end
		if part.Name == "Handle" then return end
		local parent = part.Parent
		if getPlrHum(parent) or getHead(parent) then return end

		Mouse.TargetFilter = part

		for _, v in ipairs(part:GetChildren()) do
			if v:IsA("BodyAngularVelocity") or v:IsA("BodyForce") or v:IsA("BodyGyro")
				or v:IsA("BodyPosition") or v:IsA("BodyThrust") or v:IsA("BodyVelocity")
				or v:IsA("RocketPropulsion") or v:IsA("Torque") or v:IsA("AlignPosition")
				or v:IsA("Attachment") then
				v:Destroy()
			end
		end

		part.CanCollide = false

		local torque = InstanceNew("Torque")
		torque.Torque = Vector3.new(100000, 100000, 100000)
		torque.Parent = part

		local alignPosition = InstanceNew("AlignPosition")
		alignPosition.MaxForce = math.huge
		alignPosition.MaxVelocity = math.huge
		alignPosition.Responsiveness = 200
		alignPosition.Parent = part

		local attachment2 = InstanceNew("Attachment")
		attachment2.Parent = part

		torque.Attachment0 = attachment2
		alignPosition.Attachment0 = attachment2
		alignPosition.Attachment1 = Attachment1
	end

	for _, descendant in ipairs(workspace:GetDescendants()) do
		applyForceToPart(descendant)
	end

	workspace.DescendantAdded:Connect(applyForceToPart)

	UserInputService.InputBegan:Connect(function(input, isChatting)
		if input.KeyCode == Enum.KeyCode.E and not isChatting then
			UpdatedPosition = Mouse.Hit + Vector3.new(0, 5, 0)
		end
	end)

	SpawnCall(function()
		while Wait() do
			Attachment1.WorldCFrame = UpdatedPosition
		end
	end)
end)

cmd.add({"setsimradius", "ssr", "simrad"},{"setsimradius <number>","Set sim radius using available methods. Usage: setsimradius <radius>"},function(...)
	local r = tonumber(...)
	if not r then
		return DoNotif("Invalid input. Usage: setsimradius <number>")
	end

	local ok = false

	if setsimulationradius then
		NACaller(function()
			setsimulationradius(r)
			ok = true
			DebugNotif("SimRadius set with setsimulationradius: "..r)
		end)
	end

	if not ok and opt.hiddenprop then
		if NACaller(function()
				opt.hiddenprop(LocalPlayer, "SimulationRadius", r)
			end) then
			ok = true
			DebugNotif("SimRadius set with sethiddenproperty: "..r)
		end
	end

	if not ok then
		if NACaller(function()
				LocalPlayer.SimulationRadius = r
			end) then
			ok = true
			DebugNotif("SimRadius set directly: "..r)
		end
	end

	if not ok then
		DebugNotif("No supported method to set sim radius.")
	end
end,true)

cmd.add({"infjump", "infinitejump"}, {"infjump (infinitejump)", "Enables infinite jumping"}, function()
	Wait()
	DebugNotif("Infinite Jump Enabled", 2)

	local function doINFJUMPY()
		NAlib.disconnect("infjump_jump")

		local debounce = false
		local humanoid = nil

		while not humanoid do Wait(.1) humanoid = getHum() end

		NAlib.connect("infjump_jump", UserInputService.JumpRequest:Connect(function()
			if not debounce and humanoid:GetState() ~= Enum.HumanoidStateType.Dead then
				debounce = true
				humanoid:ChangeState(Enum.HumanoidStateType.Jumping)

				Delay(0.25, function()
					debounce = false
				end)
			end
		end))
	end

	NAlib.disconnect("infjump_char")
	NAlib.connect("infjump_char", plr.CharacterAdded:Connect(function()
		doINFJUMPY()
	end))

	doINFJUMPY()
end)

cmd.add({"uninfjump", "uninfinitejump"}, {"uninfjump (uninfinitejump)", "Disables infinite jumping"}, function()
	Wait()
	DebugNotif("Infinite Jump Disabled", 2)

	NAlib.disconnect("infjump_jump")
	NAlib.disconnect("infjump_char")
end)

cmd.add({"flyjump"},{"flyjump","Allows you to hold space to fly up"},function()
	Wait()
	DebugNotif("FlyJump Enabled", 3)

	NAlib.disconnect("flyjump")
	NAlib.connect("flyjump", UserInputService.JumpRequest:Connect(function()
		getHum():ChangeState(Enum.HumanoidStateType.Jumping)
	end))
end)

cmd.add({"unflyjump","noflyjump"},{"unflyjump (noflyjump)","Disables flyjump"},function()
	Wait()
	DebugNotif("FlyJump Disabled", 3)

	NAlib.disconnect("flyjump")
end)

cmd.add({"xray", "xrayon"}, {"xray (xrayon)", "Enables X-ray vision to see through walls"}, function()
	Wait()
	DebugNotif("X-ray enabled")
	togXray(true)
end)

cmd.add({"unxray", "xrayoff"}, {"unxray (xrayoff)", "Disables X-ray vision"}, function()
	Wait()
	DebugNotif("X-ray disabled")
	togXray(false)
end)

NAmanage._ensureL=function()
	local st = getgenv()._LState or {}
	getgenv()._LState = st
	st.safeGet = st.safeGet or function(inst, prop) local ok,v=pcall(function() return inst[prop] end) if ok then return v end end
	st.safeSet = st.safeSet or function(inst, prop, v) return NAlib.setProperty(inst, prop, v) end
	if not st._utils then
		st._utils = true
		st.hook = function(name, fn) if not NAlib.isConnected(name) then NAlib.connect(name, fn()) end end
		st.disableTimeLoops = function()
			NAlib.disconnect("time_day")
			NAlib.disconnect("time_night")
		end
		st.disableShader = function()
			local sh = st.shader
			if not sh or not sh.enabled then return end
			sh.enabled = false
			if sh.restore then pcall(sh.restore) end
		end
		st.disableNF = function(force)
			local nf = st.nf
			if not nf then return end
			if not force and nf.sticky then return end
			local wasEnabled = nf.enabled
			if wasEnabled then
				nf.enabled = false
			end
			if force then nf.sticky = false end
			if not wasEnabled then return end
			if not ((st.fb and st.fb.enabled) or (st.nb and st.nb.enabled)) then
				if st.safeSet then
					if nf.baselineFogEnd~=nil then st.safeSet(Lighting,"FogEnd",nf.baselineFogEnd) end
					if st.safeGet(Lighting,"FogStart")~=nil and nf.baselineFogStart~=nil then st.safeSet(Lighting,"FogStart",nf.baselineFogStart) end
				end
			end
			for inst,saved in pairs(nf.cache or {}) do
				if inst and inst.Parent and saved then
					for p,v in pairs(saved) do st.safeSet(inst,p,v) end
				end
			end
		end
		st.disableFB = function()
			if st.fb and st.fb.enabled then
				if st.restoreFB then st.restoreFB() end
				st.fb.enabled = false
				getgenv().FullBrightEnabled = false
			end
		end
		st.disableNB = function()
			if st.nb and st.nb.enabled then
				if st.restoreNB then st.restoreNB() end
				st.nb.enabled = false
			end
		end
		st.cancelFor = function(mode)
			if mode=="fb" then
				st.disableTimeLoops()
				st.disableNF()
				st.disableNB()
				if st.disableNM then st.disableNM() end
				st.disableShader()
			elseif mode=="day" then
				st.disableFB()
				st.disableNB()
				if st.disableNM then st.disableNM() end
				st.disableShader()
			elseif mode=="night" then
				st.disableTimeLoops()
				st.disableFB()
				if st.disableNM then st.disableNM() end
				st.disableShader()
			elseif mode=="nf" then
				st.disableFB()
				st.disableNB()
				if st.disableNM then st.disableNM() end
				st.disableShader()
			elseif mode=="shader" then
				st.disableTimeLoops()
				st.disableFB()
				st.disableNB()
				st.disableNF(true)
				if st.disableNM then st.disableNM() end
			end
		end
	end
	return st
end

cmd.add({"fullbright","fullb","fb"},{"fullbright (fullb,fb)","makes dark games bright without destroying effects"},function()
	if not Lighting then return end
	local st = NAmanage._ensureL()
	local function ensureFB()
		st.fb = st.fb or {init=false,enabled=false,baseline={},target={Brightness=1,ClockTime=12,FogEnd=786543,GlobalShadows=false,Ambient=Color3.fromRGB(178,178,178)}}
		if st.fb.baseline.Brightness == nil then st.fb.baseline.Brightness = st.safeGet(Lighting,"Brightness") or 2 end
		if st.fb.baseline.ClockTime == nil then st.fb.baseline.ClockTime = st.safeGet(Lighting,"ClockTime") or 12 end
		if st.fb.baseline.FogEnd == nil then st.fb.baseline.FogEnd = st.safeGet(Lighting,"FogEnd") or 100000 end
		if st.fb.baseline.GlobalShadows == nil then local v=st.safeGet(Lighting,"GlobalShadows") st.fb.baseline.GlobalShadows = v~=nil and v or true end
		if st.fb.baseline.Ambient == nil then st.fb.baseline.Ambient = st.safeGet(Lighting,"Ambient") or Color3.fromRGB(128,128,128) end
		if not st.initFB then
			st.initFB = function()
				st.hook("fb_brightness", function() return Lighting:GetPropertyChangedSignal("Brightness"):Connect(function()
						if st.fb and st.fb.enabled then
							if st.safeGet(Lighting,"Brightness") ~= st.fb.target.Brightness then st.safeSet(Lighting,"Brightness",st.fb.target.Brightness) end
						else
							st.fb.baseline.Brightness = st.safeGet(Lighting,"Brightness") or st.fb.baseline.Brightness
						end
					end) end)
				st.hook("fb_clocktime", function() return Lighting:GetPropertyChangedSignal("ClockTime"):Connect(function()
						if st.fb and st.fb.enabled then
							if st.safeGet(Lighting,"ClockTime") ~= st.fb.target.ClockTime then st.safeSet(Lighting,"ClockTime",st.fb.target.ClockTime) end
						else
							st.fb.baseline.ClockTime = st.safeGet(Lighting,"ClockTime") or st.fb.baseline.ClockTime
						end
					end) end)
				st.hook("fb_fogend", function() return Lighting:GetPropertyChangedSignal("FogEnd"):Connect(function()
						if st.fb and st.fb.enabled then
							if st.safeGet(Lighting,"FogEnd") ~= st.fb.target.FogEnd then st.safeSet(Lighting,"FogEnd",st.fb.target.FogEnd) end
						else
							st.fb.baseline.FogEnd = st.safeGet(Lighting,"FogEnd") or st.fb.baseline.FogEnd
						end
					end) end)
				st.hook("fb_shadows", function() return Lighting:GetPropertyChangedSignal("GlobalShadows"):Connect(function()
						if st.fb and st.fb.enabled then
							if st.safeGet(Lighting,"GlobalShadows") ~= st.fb.target.GlobalShadows then st.safeSet(Lighting,"GlobalShadows",st.fb.target.GlobalShadows) end
						else
							local v=st.safeGet(Lighting,"GlobalShadows") if v~=nil then st.fb.baseline.GlobalShadows=v end
						end
					end) end)
				st.hook("fb_ambient", function() return Lighting:GetPropertyChangedSignal("Ambient"):Connect(function()
						if st.fb and st.fb.enabled then
							if st.safeGet(Lighting,"Ambient") ~= st.fb.target.Ambient then st.safeSet(Lighting,"Ambient",st.fb.target.Ambient) end
						else
							st.fb.baseline.Ambient = st.safeGet(Lighting,"Ambient") or st.fb.baseline.Ambient
						end
					end) end)
				st.hook("fb_loop", function() return RunService.RenderStepped:Connect(function()
						if not (st.fb and st.fb.enabled) then return end
						if st.safeGet(Lighting,"Brightness") ~= st.fb.target.Brightness then st.safeSet(Lighting,"Brightness",st.fb.target.Brightness) end
						if st.safeGet(Lighting,"ClockTime") ~= st.fb.target.ClockTime then st.safeSet(Lighting,"ClockTime",st.fb.target.ClockTime) end
						if st.safeGet(Lighting,"FogEnd") ~= st.fb.target.FogEnd then st.safeSet(Lighting,"FogEnd",st.fb.target.FogEnd) end
						local gs = st.safeGet(Lighting,"GlobalShadows")
						if gs~=nil and gs ~= st.fb.target.GlobalShadows then st.safeSet(Lighting,"GlobalShadows",st.fb.target.GlobalShadows) end
						if st.safeGet(Lighting,"Ambient") ~= st.fb.target.Ambient then st.safeSet(Lighting,"Ambient",st.fb.target.Ambient) end
					end) end)
			end
		end
		if not st.applyFB then
			st.applyFB = function()
				st.safeSet(Lighting,"Brightness",st.fb.target.Brightness)
				st.safeSet(Lighting,"ClockTime",st.fb.target.ClockTime)
				st.safeSet(Lighting,"FogEnd",st.fb.target.FogEnd)
				st.safeSet(Lighting,"GlobalShadows",st.fb.target.GlobalShadows)
				st.safeSet(Lighting,"Ambient",st.fb.target.Ambient)
			end
		end
		if not st.restoreFB then
			st.restoreFB = function()
				st.safeSet(Lighting,"Brightness",st.fb.baseline.Brightness)
				st.safeSet(Lighting,"ClockTime",st.fb.baseline.ClockTime)
				st.safeSet(Lighting,"FogEnd",st.fb.baseline.FogEnd)
				st.safeSet(Lighting,"GlobalShadows",st.fb.baseline.GlobalShadows)
				st.safeSet(Lighting,"Ambient",st.fb.baseline.Ambient)
			end
		end
		if not st.toggleFB then
			st.toggleFB = function(on)
				st.initFB()
				st.fb.enabled = on
				if on then st.applyFB() else st.restoreFB() end
				getgenv().FullBrightExecuted = true
				getgenv().FullBrightEnabled = st.fb.enabled
			end
		end
	end
	ensureFB()
	if not st.fb.enabled then st.cancelFor("fb") end
	st.toggleFB(not st.fb.enabled)
end)

cmd.add({"loopday","lday"},{"loopday","Sunshiiiine!"},function()
	if not Lighting then return end
	local st = NAmanage._ensureL()
	st.fb = st.fb or {enabled=false,baseline={},target={Brightness=1,ClockTime=12,FogEnd=786543,GlobalShadows=false,Ambient=Color3.fromRGB(178,178,178)}}
	st.fb.baseline.ClockTime = st.safeGet(Lighting,"ClockTime") or 12
	st.cancelFor("day")
	NAlib.disconnect("time_day")
	st.safeSet(Lighting,"ClockTime",14)
	NAlib.connect("time_day", Lighting:GetPropertyChangedSignal("ClockTime"):Connect(function()
		if st.safeGet(Lighting,"ClockTime") ~= 14 then st.safeSet(Lighting,"ClockTime",14) end
	end))
end)

cmd.add({"unloopday","unlday"},{"unloopday","No more sunshine"},function()
	if not Lighting then return end
	local st = getgenv()._LState
	if not st then return end
	NAlib.disconnect("time_day")
	local target = (st.fb and st.fb.enabled) and ((st.fb.target and st.fb.target.ClockTime) or 12) or ((st.fb and st.fb.baseline and st.fb.baseline.ClockTime) or (st.safeGet and st.safeGet(Lighting,"ClockTime")) or 12)
	if st.safeSet then st.safeSet(Lighting,"ClockTime",target) else Lighting.ClockTime = target end
end)

cmd.add({"loopfullbright","loopfb","lfb"},{"loopfullbright","Sunshiiiine!"},function()
	if not Lighting then return end
	local st = NAmanage._ensureL()
	local function ensureFB()
		st.fb = st.fb or {init=false,enabled=false,baseline={},target={Brightness=1,ClockTime=12,FogEnd=786543,GlobalShadows=false,Ambient=Color3.fromRGB(178,178,178)}}
		if st.fb.baseline.Brightness == nil then st.fb.baseline.Brightness = st.safeGet(Lighting,"Brightness") or 2 end
		if st.fb.baseline.ClockTime == nil then st.fb.baseline.ClockTime = st.safeGet(Lighting,"ClockTime") or 12 end
		if st.fb.baseline.FogEnd == nil then st.fb.baseline.FogEnd = st.safeGet(Lighting,"FogEnd") or 100000 end
		if st.fb.baseline.GlobalShadows == nil then local v=st.safeGet(Lighting,"GlobalShadows") st.fb.baseline.GlobalShadows = v~=nil and v or true end
		if st.fb.baseline.Ambient == nil then st.fb.baseline.Ambient = st.safeGet(Lighting,"Ambient") or Color3.fromRGB(128,128,128) end
		if not st.initFB then
			st.initFB = function()
				st.hook("fb_brightness", function() return Lighting:GetPropertyChangedSignal("Brightness"):Connect(function()
						if st.fb and st.fb.enabled then
							if st.safeGet(Lighting,"Brightness") ~= st.fb.target.Brightness then st.safeSet(Lighting,"Brightness",st.fb.target.Brightness) end
						else
							st.fb.baseline.Brightness = st.safeGet(Lighting,"Brightness") or st.fb.baseline.Brightness
						end
					end) end)
				st.hook("fb_clocktime", function() return Lighting:GetPropertyChangedSignal("ClockTime"):Connect(function()
						if st.fb and st.fb.enabled then
							if st.safeGet(Lighting,"ClockTime") ~= st.fb.target.ClockTime then st.safeSet(Lighting,"ClockTime",st.fb.target.ClockTime) end
						else
							st.fb.baseline.ClockTime = st.safeGet(Lighting,"ClockTime") or st.fb.baseline.ClockTime
						end
					end) end)
				st.hook("fb_fogend", function() return Lighting:GetPropertyChangedSignal("FogEnd"):Connect(function()
						if st.fb and st.fb.enabled then
							if st.safeGet(Lighting,"FogEnd") ~= st.fb.target.FogEnd then st.safeSet(Lighting,"FogEnd",st.fb.target.FogEnd) end
						else
							st.fb.baseline.FogEnd = st.safeGet(Lighting,"FogEnd") or st.fb.baseline.FogEnd
						end
					end) end)
				st.hook("fb_shadows", function() return Lighting:GetPropertyChangedSignal("GlobalShadows"):Connect(function()
						if st.fb and st.fb.enabled then
							if st.safeGet(Lighting,"GlobalShadows") ~= st.fb.target.GlobalShadows then st.safeSet(Lighting,"GlobalShadows",st.fb.target.GlobalShadows) end
						else
							local v=st.safeGet(Lighting,"GlobalShadows") if v~=nil then st.fb.baseline.GlobalShadows=v end
						end
					end) end)
				st.hook("fb_ambient", function() return Lighting:GetPropertyChangedSignal("Ambient"):Connect(function()
						if st.fb and st.fb.enabled then
							if st.safeGet(Lighting,"Ambient") ~= st.fb.target.Ambient then st.safeSet(Lighting,"Ambient",st.fb.target.Ambient) end
						else
							st.fb.baseline.Ambient = st.safeGet(Lighting,"Ambient") or st.fb.baseline.Ambient
						end
					end) end)
				st.hook("fb_loop", function() return RunService.RenderStepped:Connect(function()
						if not (st.fb and st.fb.enabled) then return end
						if st.safeGet(Lighting,"Brightness") ~= st.fb.target.Brightness then st.safeSet(Lighting,"Brightness",st.fb.target.Brightness) end
						if st.safeGet(Lighting,"ClockTime") ~= st.fb.target.ClockTime then st.safeSet(Lighting,"ClockTime",st.fb.target.ClockTime) end
						if st.safeGet(Lighting,"FogEnd") ~= st.fb.target.FogEnd then st.safeSet(Lighting,"FogEnd",st.fb.target.FogEnd) end
						local gs = st.safeGet(Lighting,"GlobalShadows")
						if gs~=nil and gs ~= st.fb.target.GlobalShadows then st.safeSet(Lighting,"GlobalShadows",st.fb.target.GlobalShadows) end
						if st.safeGet(Lighting,"Ambient") ~= st.fb.target.Ambient then st.safeSet(Lighting,"Ambient",st.fb.target.Ambient) end
					end) end)
			end
		end
		if not st.applyFB then
			st.applyFB = function()
				st.safeSet(Lighting,"Brightness",st.fb.target.Brightness)
				st.safeSet(Lighting,"ClockTime",st.fb.target.ClockTime)
				st.safeSet(Lighting,"FogEnd",st.fb.target.FogEnd)
				st.safeSet(Lighting,"GlobalShadows",st.fb.target.GlobalShadows)
				st.safeSet(Lighting,"Ambient",st.fb.target.Ambient)
			end
		end
		if not st.restoreFB then
			st.restoreFB = function()
				st.safeSet(Lighting,"Brightness",st.fb.baseline.Brightness)
				st.safeSet(Lighting,"ClockTime",st.fb.baseline.ClockTime)
				st.safeSet(Lighting,"FogEnd",st.fb.baseline.FogEnd)
				st.safeSet(Lighting,"GlobalShadows",st.fb.baseline.GlobalShadows)
				st.safeSet(Lighting,"Ambient",st.fb.baseline.Ambient)
			end
		end
		if not st.toggleFB then
			st.toggleFB = function(on)
				st.initFB()
				st.fb.enabled = on
				if on then st.applyFB() else st.restoreFB() end
				getgenv().FullBrightExecuted = true
				getgenv().FullBrightEnabled = st.fb.enabled
			end
		end
	end
	ensureFB()
	st.cancelFor("fb")
	st.toggleFB(true)
end)

cmd.add({"unloopfullbright","unloopfb","unlfb"},{"unloopfullbright","No more sunshine"},function()
	if not Lighting then return end
	local st = NAmanage._ensureL()
	local function ensureFB()
		st.fb = st.fb or {init=false,enabled=false,baseline={},target={Brightness=1,ClockTime=12,FogEnd=786543,GlobalShadows=false,Ambient=Color3.fromRGB(178,178,178)}}
		if st.fb.baseline.Brightness == nil then st.fb.baseline.Brightness = st.safeGet(Lighting,"Brightness") or 2 end
		if st.fb.baseline.ClockTime == nil then st.fb.baseline.ClockTime = st.safeGet(Lighting,"ClockTime") or 12 end
		if st.fb.baseline.FogEnd == nil then st.fb.baseline.FogEnd = st.safeGet(Lighting,"FogEnd") or 100000 end
		if st.fb.baseline.GlobalShadows == nil then local v=st.safeGet(Lighting,"GlobalShadows") st.fb.baseline.GlobalShadows = v~=nil and v or true end
		if st.fb.baseline.Ambient == nil then st.fb.baseline.Ambient = st.safeGet(Lighting,"Ambient") or Color3.fromRGB(128,128,128) end
		if not st.applyFB then
			st.applyFB = function()
				st.safeSet(Lighting,"Brightness",st.fb.target.Brightness)
				st.safeSet(Lighting,"ClockTime",st.fb.target.ClockTime)
				st.safeSet(Lighting,"FogEnd",st.fb.target.FogEnd)
				st.safeSet(Lighting,"GlobalShadows",st.fb.target.GlobalShadows)
				st.safeSet(Lighting,"Ambient",st.fb.target.Ambient)
			end
		end
		if not st.restoreFB then
			st.restoreFB = function()
				st.safeSet(Lighting,"Brightness",st.fb.baseline.Brightness)
				st.safeSet(Lighting,"ClockTime",st.fb.baseline.ClockTime)
				st.safeSet(Lighting,"FogEnd",st.fb.baseline.FogEnd)
				st.safeSet(Lighting,"GlobalShadows",st.fb.baseline.GlobalShadows)
				st.safeSet(Lighting,"Ambient",st.fb.baseline.Ambient)
			end
		end
	end
	ensureFB()
	if st.fb and st.fb.enabled then
		st.toggleFB(false)
	end
end)

cmd.add({"loopnight","loopn","ln"},{"loopnight","Moonlight."},function()
	if not Lighting then return end
	local st = NAmanage._ensureL()
	st.cancelFor("night")
	local function ensureNB()
		st.nb = st.nb or {init=false,enabled=false,baseline={},target={Brightness=1,ClockTime=0,FogEnd=786543,GlobalShadows=false,Ambient=Color3.fromRGB(178,178,178)}}
		if st.nb.baseline.Brightness == nil then st.nb.baseline.Brightness = st.safeGet(Lighting,"Brightness") or 2 end
		if st.nb.baseline.ClockTime == nil then st.nb.baseline.ClockTime = st.safeGet(Lighting,"ClockTime") or 12 end
		if st.nb.baseline.FogEnd == nil then st.nb.baseline.FogEnd = st.safeGet(Lighting,"FogEnd") or 100000 end
		if st.nb.baseline.GlobalShadows == nil then local v=st.safeGet(Lighting,"GlobalShadows") st.nb.baseline.GlobalShadows = v~=nil and v or true end
		if st.nb.baseline.Ambient == nil then st.nb.baseline.Ambient = st.safeGet(Lighting,"Ambient") or Color3.fromRGB(128,128,128) end
		if not st.initNB then
			st.initNB = function()
				st.hook("nb_brightness", function() return Lighting:GetPropertyChangedSignal("Brightness"):Connect(function()
						if st.nb and st.nb.enabled then
							if st.safeGet(Lighting,"Brightness") ~= st.nb.target.Brightness then st.safeSet(Lighting,"Brightness",st.nb.target.Brightness) end
						else
							st.nb.baseline.Brightness = st.safeGet(Lighting,"Brightness") or st.nb.baseline.Brightness
						end
					end) end)
				st.hook("nb_clocktime", function() return Lighting:GetPropertyChangedSignal("ClockTime"):Connect(function()
						if st.nb and st.nb.enabled then
							if st.safeGet(Lighting,"ClockTime") ~= st.nb.target.ClockTime then st.safeSet(Lighting,"ClockTime",st.nb.target.ClockTime) end
						else
							st.nb.baseline.ClockTime = st.safeGet(Lighting,"ClockTime") or st.nb.baseline.ClockTime
						end
					end) end)
				st.hook("nb_fogend", function() return Lighting:GetPropertyChangedSignal("FogEnd"):Connect(function()
						if st.nb and st.nb.enabled then
							if st.safeGet(Lighting,"FogEnd") ~= st.nb.target.FogEnd then st.safeSet(Lighting,"FogEnd",st.nb.target.FogEnd) end
						else
							st.nb.baseline.FogEnd = st.safeGet(Lighting,"FogEnd") or st.nb.baseline.FogEnd
						end
					end) end)
				st.hook("nb_shadows", function() return Lighting:GetPropertyChangedSignal("GlobalShadows"):Connect(function()
						if st.nb and st.nb.enabled then
							if st.safeGet(Lighting,"GlobalShadows") ~= st.nb.target.GlobalShadows then st.safeSet(Lighting,"GlobalShadows",st.nb.target.GlobalShadows) end
						else
							local v=st.safeGet(Lighting,"GlobalShadows") if v~=nil then st.nb.baseline.GlobalShadows=v end
						end
					end) end)
				st.hook("nb_ambient", function() return Lighting:GetPropertyChangedSignal("Ambient"):Connect(function()
						if st.nb and st.nb.enabled then
							if st.safeGet(Lighting,"Ambient") ~= st.nb.target.Ambient then st.safeSet(Lighting,"Ambient",st.nb.target.Ambient) end
						else
							st.nb.baseline.Ambient = st.safeGet(Lighting,"Ambient") or st.nb.baseline.Ambient
						end
					end) end)
				st.hook("nb_loop", function() return RunService.RenderStepped:Connect(function()
						if not (st.nb and st.nb.enabled) then return end
						if st.safeGet(Lighting,"Brightness") ~= st.nb.target.Brightness then st.safeSet(Lighting,"Brightness",st.nb.target.Brightness) end
						if st.safeGet(Lighting,"ClockTime") ~= st.nb.target.ClockTime then st.safeSet(Lighting,"ClockTime",st.nb.target.ClockTime) end
						if st.safeGet(Lighting,"FogEnd") ~= st.nb.target.FogEnd then st.safeSet(Lighting,"FogEnd",st.nb.target.FogEnd) end
						local gs = st.safeGet(Lighting,"GlobalShadows")
						if gs~=nil and gs ~= st.nb.target.GlobalShadows then st.safeSet(Lighting,"GlobalShadows",st.nb.target.GlobalShadows) end
						if st.safeGet(Lighting,"Ambient") ~= st.nb.target.Ambient then st.safeSet(Lighting,"Ambient",st.nb.target.Ambient) end
					end) end)
			end
		end
		if not st.applyNB then
			st.applyNB = function()
				st.safeSet(Lighting,"Brightness",st.nb.target.Brightness)
				st.safeSet(Lighting,"ClockTime",st.nb.target.ClockTime)
				st.safeSet(Lighting,"FogEnd",st.nb.target.FogEnd)
				st.safeSet(Lighting,"GlobalShadows",st.nb.target.GlobalShadows)
				st.safeSet(Lighting,"Ambient",st.nb.target.Ambient)
			end
		end
		if not st.restoreNB then
			st.restoreNB = function()
				st.safeSet(Lighting,"Brightness",st.nb.baseline.Brightness)
				st.safeSet(Lighting,"ClockTime",st.nb.baseline.ClockTime)
				st.safeSet(Lighting,"FogEnd",st.nb.baseline.FogEnd)
				st.safeSet(Lighting,"GlobalShadows",st.nb.baseline.GlobalShadows)
				st.safeSet(Lighting,"Ambient",st.nb.baseline.Ambient)
			end
		end
		if not st.toggleNB then
			st.toggleNB = function(on)
				st.initNB()
				st.nb.enabled = on
				if on then st.applyNB() else st.restoreNB() end
			end
		end
	end
	ensureNB()
	st.toggleNB(true)
end)

cmd.add({"unloopnight","unloopn","unln"},{"unloopnight","No more moonlight."},function()
	if not Lighting then return end
	local st = NAmanage._ensureL()
	local function ensureNB()
		st.nb = st.nb or {init=false,enabled=false,baseline={},target={Brightness=1,ClockTime=0,FogEnd=786543,GlobalShadows=false,Ambient=Color3.fromRGB(178,178,178)}}
		if not st.restoreNB then
			st.restoreNB = function()
				st.safeSet(Lighting,"Brightness",st.nb.baseline.Brightness)
				st.safeSet(Lighting,"ClockTime",st.nb.baseline.ClockTime)
				st.safeSet(Lighting,"FogEnd",st.nb.baseline.FogEnd)
				st.safeSet(Lighting,"GlobalShadows",st.nb.baseline.GlobalShadows)
				st.safeSet(Lighting,"Ambient",st.nb.baseline.Ambient)
			end
		end
	end
	ensureNB()
	if st.nb and st.nb.enabled then
		st.toggleNB(false)
	end
end)

cmd.add({"loopnoeffect","lnoeffect","loopne","lne"},{"loopnoeffect","Keeps Lighting and CurrentCamera effects disabled"},function()
	if not Lighting then return end
	local st = NAmanage._ensureL()
	local w = workspace
	st.ne = st.ne or {init=false,enabled=false,cache=setmetatable({},{__mode="k"}),sticky=false}
	local ne = st.ne
	ne.cache = ne.cache or setmetatable({},{__mode="k"})
	local function cacheProperty(inst,prop,value)
		if not inst then return end
		local saved = ne.cache[inst]
		if not saved then
			saved={}
			ne.cache[inst]=saved
		end
		if saved[prop]==nil then
			local v=value
			if v==nil then v=st.safeGet(inst,prop) end
			if v~=nil then saved[prop]=v end
		end
	end
	local function disableEffect(inst)
		if not inst or not inst.Parent then return end
		if inst:IsA("PostEffect") then
			local enabled=st.safeGet(inst,"Enabled")
			if enabled~=nil then
				cacheProperty(inst,"Enabled",enabled)
				if enabled~=false then st.safeSet(inst,"Enabled",false) end
			end
		end
		if inst:IsA("Atmosphere") then
			local density=st.safeGet(inst,"Density")
			if density~=nil then cacheProperty(inst,"Density",density); if density~=0 then st.safeSet(inst,"Density",0) end end
			local haze=st.safeGet(inst,"Haze")
			if haze~=nil then cacheProperty(inst,"Haze",haze); if haze~=0 then st.safeSet(inst,"Haze",0) end end
			local glare=st.safeGet(inst,"Glare")
			if glare~=nil then cacheProperty(inst,"Glare",glare); if glare~=0 then st.safeSet(inst,"Glare",0) end end
		end
	end
	local function processLighting()
		for _,inst in ipairs(Lighting:GetDescendants()) do disableEffect(inst) end
	end
	local function processCamera()
		local cam = w.CurrentCamera
		if not cam then
			ne.lastCamera=nil
			return
		end
		if ne.lastCamera~=cam then
			ne.lastCamera=cam
		end
		for _,inst in ipairs(cam:GetDescendants()) do disableEffect(inst) end
	end
	local function attachCameraWatcher()
		if ne.camDescConn then
			pcall(function() ne.camDescConn:Disconnect() end)
			ne.camDescConn=nil
		end
		local cam = w.CurrentCamera
		if not cam then
			ne.lastCamera=nil
			return
		end
		ne.lastCamera = cam
		processCamera()
		local ok,conn=pcall(function()
			return cam.DescendantAdded:Connect(function(child)
				if not (st.ne and st.ne.enabled) then return end
				if not ne.lastCamera or (child and not child:IsDescendantOf(ne.lastCamera)) then return end
				disableEffect(child)
			end)
		end)
		if ok and conn then
			ne.camDescConn=conn
		end
	end
	if not ne.init then
		ne.init=true
		st.hook("ne_camera_changed", function() return w:GetPropertyChangedSignal("CurrentCamera"):Connect(function()
				if not (st.ne and st.ne.enabled) then return end
				attachCameraWatcher()
			end) end)
		st.hook("ne_loop", function() return RunService.RenderStepped:Connect(function()
				if not (st.ne and st.ne.enabled) then return end
				processLighting()
				processCamera()
			end) end)
	end
	ne.enabled=true
	ne.sticky=true
	processLighting()
	processCamera()
	attachCameraWatcher()
end)

cmd.add({"unloopnoeffect","unlnoeffect","unloopne","unlne"},{"unloopnoeffect","Restores Lighting and CurrentCamera effects"},function()
	if not Lighting then return end
	local st = getgenv()._LState
	if not st or not st.ne then return end
	local ne = st.ne
	ne.sticky=false
	ne.enabled=false
	if ne.camDescConn then
		pcall(function() ne.camDescConn:Disconnect() end)
		ne.camDescConn=nil
	end
	for inst,saved in pairs(ne.cache or {}) do
		if inst and inst.Parent and saved then
			for prop,value in pairs(saved) do
				if st.safeSet then st.safeSet(inst,prop,value) else pcall(function() inst[prop]=value end) end
			end
		end
	end
end)

cmd.add({"noeffect","cleareffects","disableeffects"},{"noeffect","Disables Lighting and CurrentCamera effects"},function()
	if not Lighting then return end
	local st = NAmanage._ensureL()
	local function disableEffect(inst)
		if not inst then return end
		if inst:IsA("PostEffect") then
			local enabled=st.safeGet(inst,"Enabled")
			if enabled~=nil and enabled~=false then st.safeSet(inst,"Enabled",false) end
		end
		if inst:IsA("Atmosphere") then
			local density=st.safeGet(inst,"Density")
			if density~=nil and density~=0 then st.safeSet(inst,"Density",0) end
			local haze=st.safeGet(inst,"Haze")
			if haze~=nil and haze~=0 then st.safeSet(inst,"Haze",0) end
			local glare=st.safeGet(inst,"Glare")
			if glare~=nil and glare~=0 then st.safeSet(inst,"Glare",0) end
		end
	end
	for _,inst in ipairs(Lighting:GetDescendants()) do disableEffect(inst) end
	local cam = workspace.CurrentCamera
	if cam then
		for _,inst in ipairs(cam:GetDescendants()) do disableEffect(inst) end
	end
end)

cmd.add({"loopnofog","lnofog","lnf","loopnf"},{"loopnofog","See clearly forever!"},function()
	if not Lighting then return end
	local st = NAmanage._ensureL()
	if st.disableNM then st.disableNM() end
	st.nf = st.nf or {init=false,enabled=false,baselineFogEnd=st.safeGet(Lighting,"FogEnd") or 100000,baselineFogStart=st.safeGet(Lighting,"FogStart") or 0,cache=setmetatable({},{__mode="k"}),sticky=false}
	local nf = st.nf
	local function cacheOnce(inst, props)
		if nf.cache[inst] then return end
		local saved = {}
		for _,p in ipairs(props) do local v = st.safeGet(inst,p); if v~=nil then saved[p]=v end end
		nf.cache[inst]=saved
	end
	local function disableEffect(inst)
		if inst and inst:IsA("PostEffect") then cacheOnce(inst,{"Enabled"}); st.safeSet(inst,"Enabled",false) end
		if inst and inst:IsA("Atmosphere") then cacheOnce(inst,{"Density","Haze","Glare"}); st.safeSet(inst,"Density",0); st.safeSet(inst,"Haze",0); st.safeSet(inst,"Glare",0) end
	end
	local function enforceNoFog()
		if not (st.nf and st.nf.enabled) then return end
		st.safeSet(Lighting,"FogEnd",786543)
		if st.safeGet(Lighting,"FogStart") ~= nil then
			st.safeSet(Lighting,"FogStart",0)
		end
		for inst,_ in pairs(nf.cache) do
			if inst and inst.Parent then
				disableEffect(inst)
			end
		end
	end
	if not nf.init then
		nf.init = true
		local scanAccumulator = 0
		st.hook("nf_prop_end", function() return Lighting:GetPropertyChangedSignal("FogEnd"):Connect(function()
				if st.nf and st.nf.enabled then
					if st.safeGet(Lighting,"FogEnd") ~= 786543 then st.safeSet(Lighting,"FogEnd",786543) end
				end
			end) end)
		st.hook("nf_prop_start", function() return Lighting:GetPropertyChangedSignal("FogStart"):Connect(function()
				if st.nf and st.nf.enabled then
					if st.safeGet(Lighting,"FogStart") ~= 0 then st.safeSet(Lighting,"FogStart",0) end
				end
			end) end)
		st.hook("nf_added", function() return Lighting.DescendantAdded:Connect(function(inst)
				if not (st.nf and st.nf.enabled) then return end
				disableEffect(inst)
			end) end)
		st.hook("nf_loop", function() return RunService.RenderStepped:Connect(function(dt)
				if not (st.nf and st.nf.enabled) then return end
				enforceNoFog()
				scanAccumulator = scanAccumulator + dt
				if scanAccumulator >= 0.5 then
					scanAccumulator = 0
					for _, inst in ipairs(Lighting:GetDescendants()) do
						disableEffect(inst)
					end
				end
			end) end)
	end
	nf.enabled = true
	enforceNoFog()
	nf.sticky = true
	nf.baselineFogEnd = st.safeGet(Lighting,"FogEnd") or nf.baselineFogEnd
	nf.baselineFogStart = st.safeGet(Lighting,"FogStart") or nf.baselineFogStart
	st.safeSet(Lighting,"FogEnd",786543)
	st.safeSet(Lighting,"FogStart",0)
	for _,v in ipairs(Lighting:GetDescendants()) do disableEffect(v) end
end)

cmd.add({"unloopnofog","unlnofog","unlnf","unloopnf","unnf"},{"unloopnofog","No more sight."},function()
	if not Lighting then return end
	local st = getgenv()._LState
	if not st or not st.nf then return end
	st.nf.sticky = false
	st.nf.enabled = false
	if not ((st.fb and st.fb.enabled) or (st.nb and st.nb.enabled)) then
		if st.safeSet then
			st.safeSet(Lighting,"FogEnd",st.nf.baselineFogEnd or 100000)
			if st.safeGet(Lighting,"FogStart")~=nil then st.safeSet(Lighting,"FogStart",st.nf.baselineFogStart or 0) end
		end
	end
	for inst,saved in pairs(st.nf.cache) do
		if inst and inst.Parent and saved then
			for p,v in pairs(saved) do st.safeSet(inst,p,v) end
		end
	end
end)

cmd.add({"nofog"},{"nofog","Removes all fog from the game"},function()
	if not Lighting then return end
	local st = NAmanage._ensureL()
	local function disableEffect(inst)
		if inst and inst:IsA("PostEffect") then st.safeSet(inst,"Enabled",false) end
		if inst and inst:IsA("Atmosphere") then
			if st.safeGet(inst,"Density")~=nil then st.safeSet(inst,"Density",0) end
			if st.safeGet(inst,"Haze")~=nil then st.safeSet(inst,"Haze",0) end
			if st.safeGet(inst,"Glare")~=nil then st.safeSet(inst,"Glare",0) end
		end
	end
	st.safeSet(Lighting,"FogEnd",786543)
	if st.safeGet(Lighting,"FogStart")~=nil then st.safeSet(Lighting,"FogStart",0) end
	for _,v in ipairs(Lighting:GetDescendants()) do disableEffect(v) end
end)

cmd.add({"nightmare","nm"},{"nightmare","Make it dark and spooky"},function()
	if not Lighting then return end
	local st = NAmanage._ensureL()
	if not st.disableNM then
		local prevCancel = st.cancelFor
		st.disableNM = function()
			NAlib.disconnect("nm_brightness")
			NAlib.disconnect("nm_clocktime")
			NAlib.disconnect("nm_fogstart")
			NAlib.disconnect("nm_fogend")
			NAlib.disconnect("nm_shadows")
			NAlib.disconnect("nm_ambient")
			NAlib.disconnect("nm_loop")
			if st.nm and st.nm.enabled then
				if st.restoreNM then st.restoreNM() end
				st.nm.enabled = false
			end
		end
		st.cancelFor = function(mode)
			if prevCancel then prevCancel(mode) end
			if mode=="nm" then
				st.disableTimeLoops()
				if st.disableNB then st.disableNB() end
				st.disableFB()
				st.disableNF(true)
				st.disableNM()
			end
		end
	end
	st.cancelFor("nm")
	st.nm = st.nm or {enabled=false,baseline={},target={Brightness=0.4,ClockTime=0,FogStart=0,FogEnd=28,GlobalShadows=true,Ambient=Color3.fromRGB(50,50,65)},effects={}}
	local function ensureEffect(className, key)
		local name = "NA_nm_"..key
		local inst = Lighting:FindFirstChild(name)
		if not inst then inst = InstanceNew(className); inst.Name = name; inst.Parent = Lighting end
		st.nm.effects[key] = inst
		return inst
	end
	if not st.captureNM then
		st.captureNM = function()
			st.nm.baseline = {
				Brightness = st.safeGet(Lighting,"Brightness") or 2,
				ClockTime = st.safeGet(Lighting,"ClockTime") or 12,
				FogStart = st.safeGet(Lighting,"FogStart"),
				FogEnd = st.safeGet(Lighting,"FogEnd") or 100000,
				GlobalShadows = st.safeGet(Lighting,"GlobalShadows"),
				Ambient = st.safeGet(Lighting,"Ambient") or Color3.fromRGB(128,128,128)
			}
		end
	end
	if not st.applyNM then
		st.applyNM = function()
			st.captureNM()
			st.safeSet(Lighting,"Brightness",st.nm.target.Brightness)
			st.safeSet(Lighting,"ClockTime",st.nm.target.ClockTime)
			if st.safeGet(Lighting,"FogStart")~=nil then st.safeSet(Lighting,"FogStart",st.nm.target.FogStart) end
			st.safeSet(Lighting,"FogEnd",st.nm.target.FogEnd)
			local gs = st.safeGet(Lighting,"GlobalShadows"); if gs~=nil then st.safeSet(Lighting,"GlobalShadows",st.nm.target.GlobalShadows) end
			st.safeSet(Lighting,"Ambient",st.nm.target.Ambient)
			local cc = ensureEffect("ColorCorrectionEffect","cc")
			st.safeSet(cc,"Enabled",true)
			st.safeSet(cc,"Brightness",-0.05)
			st.safeSet(cc,"Contrast",0.2)
			st.safeSet(cc,"Saturation",-0.25)
			st.safeSet(cc,"TintColor",Color3.fromRGB(180,170,255))
			local bloom = ensureEffect("BloomEffect","bloom")
			st.safeSet(bloom,"Enabled",true)
			st.safeSet(bloom,"Intensity",0.15)
			st.safeSet(bloom,"Size",20)
			local dof = ensureEffect("DepthOfFieldEffect","dof")
			st.safeSet(dof,"Enabled",true)
			st.safeSet(dof,"NearIntensity",0.15)
			st.safeSet(dof,"FarIntensity",0.6)
			st.safeSet(dof,"FocusDistance",25)
			st.safeSet(dof,"InFocusRadius",14)
			local blur = ensureEffect("BlurEffect","blur")
			st.safeSet(blur,"Enabled",true)
			st.safeSet(blur,"Size",1)
		end
	end
	if not st.restoreNM then
		st.restoreNM = function()
			st.safeSet(Lighting,"Brightness",st.nm.baseline.Brightness)
			st.safeSet(Lighting,"ClockTime",st.nm.baseline.ClockTime)
			if st.nm.baseline.FogStart~=nil then st.safeSet(Lighting,"FogStart",st.nm.baseline.FogStart) end
			st.safeSet(Lighting,"FogEnd",st.nm.baseline.FogEnd)
			if st.nm.baseline.GlobalShadows~=nil then st.safeSet(Lighting,"GlobalShadows",st.nm.baseline.GlobalShadows) end
			st.safeSet(Lighting,"Ambient",st.nm.baseline.Ambient)
			for _,inst in pairs(st.nm.effects) do if inst and inst.Parent then inst:Destroy() end end
			st.nm.effects = {}
		end
	end
	local function rehookNM()
		NAlib.disconnect("nm_brightness")
		NAlib.disconnect("nm_clocktime")
		NAlib.disconnect("nm_fogstart")
		NAlib.disconnect("nm_fogend")
		NAlib.disconnect("nm_shadows")
		NAlib.disconnect("nm_ambient")
		NAlib.disconnect("nm_loop")
		NAlib.connect("nm_brightness", Lighting:GetPropertyChangedSignal("Brightness"):Connect(function()
			if st.nm and st.nm.enabled and st.safeGet(Lighting,"Brightness") ~= st.nm.target.Brightness then st.safeSet(Lighting,"Brightness",st.nm.target.Brightness) end
		end))
		NAlib.connect("nm_clocktime", Lighting:GetPropertyChangedSignal("ClockTime"):Connect(function()
			if st.nm and st.nm.enabled and st.safeGet(Lighting,"ClockTime") ~= st.nm.target.ClockTime then st.safeSet(Lighting,"ClockTime",st.nm.target.ClockTime) end
		end))
		NAlib.connect("nm_fogstart", Lighting:GetPropertyChangedSignal("FogStart"):Connect(function()
			if st.nm and st.nm.enabled then local fs = st.safeGet(Lighting,"FogStart"); if fs==nil or fs ~= st.nm.target.FogStart then st.safeSet(Lighting,"FogStart",st.nm.target.FogStart) end end
		end))
		NAlib.connect("nm_fogend", Lighting:GetPropertyChangedSignal("FogEnd"):Connect(function()
			if st.nm and st.nm.enabled and st.safeGet(Lighting,"FogEnd") ~= st.nm.target.FogEnd then st.safeSet(Lighting,"FogEnd",st.nm.target.FogEnd) end
		end))
		NAlib.connect("nm_shadows", Lighting:GetPropertyChangedSignal("GlobalShadows"):Connect(function()
			if st.nm and st.nm.enabled then local gs = st.safeGet(Lighting,"GlobalShadows"); if gs==nil or gs ~= st.nm.target.GlobalShadows then st.safeSet(Lighting,"GlobalShadows",st.nm.target.GlobalShadows) end end
		end))
		NAlib.connect("nm_ambient", Lighting:GetPropertyChangedSignal("Ambient"):Connect(function()
			if st.nm and st.nm.enabled and st.safeGet(Lighting,"Ambient") ~= st.nm.target.Ambient then st.safeSet(Lighting,"Ambient",st.nm.target.Ambient) end
		end))
		NAlib.connect("nm_loop", RunService.RenderStepped:Connect(function()
			if not (st.nm and st.nm.enabled) then return end
			if st.safeGet(Lighting,"Brightness") ~= st.nm.target.Brightness then st.safeSet(Lighting,"Brightness",st.nm.target.Brightness) end
			if st.safeGet(Lighting,"ClockTime") ~= st.nm.target.ClockTime then st.safeSet(Lighting,"ClockTime",st.nm.target.ClockTime) end
			local fs = st.safeGet(Lighting,"FogStart"); if fs==nil or fs ~= st.nm.target.FogStart then st.safeSet(Lighting,"FogStart",st.nm.target.FogStart) end
			if st.safeGet(Lighting,"FogEnd") ~= st.nm.target.FogEnd then st.safeSet(Lighting,"FogEnd",st.nm.target.FogEnd) end
			local gs = st.safeGet(Lighting,"GlobalShadows"); if gs==nil or gs ~= st.nm.target.GlobalShadows then st.safeSet(Lighting,"GlobalShadows",st.nm.target.GlobalShadows) end
			if st.safeGet(Lighting,"Ambient") ~= st.nm.target.Ambient then st.safeSet(Lighting,"Ambient",st.nm.target.Ambient) end
			ensureEffect("ColorCorrectionEffect","cc")
			ensureEffect("BloomEffect","bloom")
			ensureEffect("DepthOfFieldEffect","dof")
			ensureEffect("BlurEffect","blur")
			local cc = st.nm.effects.cc
			if cc then
				if st.safeGet(cc,"Enabled") ~= true then st.safeSet(cc,"Enabled",true) end
				if st.safeGet(cc,"Brightness") ~= -0.05 then st.safeSet(cc,"Brightness",-0.05) end
				if st.safeGet(cc,"Contrast") ~= 0.2 then st.safeSet(cc,"Contrast",0.2) end
				if st.safeGet(cc,"Saturation") ~= -0.25 then st.safeSet(cc,"Saturation",-0.25) end
				if st.safeGet(cc,"TintColor") ~= Color3.fromRGB(180,170,255) then st.safeSet(cc,"TintColor",Color3.fromRGB(180,170,255)) end
			end
			local bloom = st.nm.effects.bloom
			if bloom then
				if st.safeGet(bloom,"Enabled") ~= true then st.safeSet(bloom,"Enabled",true) end
				if st.safeGet(bloom,"Intensity") ~= 0.15 then st.safeSet(bloom,"Intensity",0.15) end
				if st.safeGet(bloom,"Size") ~= 20 then st.safeSet(bloom,"Size",20) end
			end
			local dof = st.nm.effects.dof
			if dof then
				if st.safeGet(dof,"Enabled") ~= true then st.safeSet(dof,"Enabled",true) end
				if st.safeGet(dof,"NearIntensity") ~= 0.15 then st.safeSet(dof,"NearIntensity",0.15) end
				if st.safeGet(dof,"FarIntensity") ~= 0.6 then st.safeSet(dof,"FarIntensity",0.6) end
				if st.safeGet(dof,"FocusDistance") ~= 25 then st.safeSet(dof,"FocusDistance",25) end
				if st.safeGet(dof,"InFocusRadius") ~= 14 then st.safeSet(dof,"InFocusRadius",14) end
			end
			local blur = st.nm.effects.blur
			if blur then
				if st.safeGet(blur,"Enabled") ~= true then st.safeSet(blur,"Enabled",true) end
				if st.safeGet(blur,"Size") ~= 1 then st.safeSet(blur,"Size",1) end
			end
		end))
	end
	st.nm.enabled = true
	st.applyNM()
	rehookNM()
end)

cmd.add({"unnightmare","unnm"},{"unnightmare (unnm)","Disable nightmare mode"},function()
	if not Lighting then return end
	local st = NAmanage._ensureL()
	if st.disableNM then st.disableNM() end
end)

cmd.add({"brightness"},{"brightness <number>","Changes the brightness lighting property"},function(num)
	loopBrightnessValue = tonumber(num)
	Lighting.Brightness = loopBrightnessValue
end,true)

cmd.add({"loopbrightness","loopbri","loopb"},{"loopbrightness (loopbri,loopb)","Lock the brightness lighting property"},function(num)
	loopBrightnessValue = tonumber(num)
	NAlib.disconnect("loopbrightness")
	Lighting.Brightness = loopBrightnessValue
	NAlib.connect("loopbrightness", Lighting:GetPropertyChangedSignal("Brightness"):Connect(function()
		if Lighting.Brightness ~= loopBrightnessValue then
			Lighting.Brightness = loopBrightnessValue
		end
	end))
end,true)

cmd.add({"unloopbrightness","unloopbri","unloopb"},{"unloopbrightness (unloopbri,unloopb)","Stop locking brightness"},function()
	NAlib.disconnect("loopbrightness")
end)

cmd.add({"globalshadows","gshadows"},{"globalshadows","Enables global shadows"},function()
	Lighting.GlobalShadows=true
end)

cmd.add({"unglobalshadows","nogshadows","ungshadows","noglobalshadows"},{"unglobalshadows (nogshadows,ungshadows,noglobalshadows)","Disables global shadows"},function()
	Lighting.GlobalShadows=false
end)

cmd.add({"gamma", "exposure"},{"gamma (exposure)","gamma vision (real)"},function(num)
	expose = tonumber(num) or 0
	Lighting.ExposureCompensation = expose
end,true)

cmd.add({"loopgamma", "loopexposure"},{"loopgamma (loopexposure)","loop gamma vision (mega real)"},function(num)
	expose = tonumber(num) or 0
	NAlib.disconnect("loopgamma")
	Lighting.ExposureCompensation = expose
	NAlib.connect("loopgamma", Lighting:GetPropertyChangedSignal("ExposureCompensation"):Connect(function()
		if Lighting.ExposureCompensation ~= expose then
			Lighting.ExposureCompensation = expose
		end
	end))
end, true)

cmd.add({"unloopgamma", "unlgamma", "unloopexposure", "unlexposure"},{"unloopgamma (unlgamma, unloopexposure, unlexposure)","stop gamma vision (real)"},function()
	NAlib.disconnect("loopgamma")
end)

cmd.add({"firstp","1stp","firstperson","fp"},{"firstperson (1stp,firstp,fp)","Makes you go in first person mode"},function()
	Player.CameraMode="LockFirstPerson"
end)

cmd.add({"thirdp","3rdp","thirdperson"},{"thirdperson (3rdp,thirdp)","Makes you go in third person mode"},function()
	Player.CameraMaxZoomDistance=math.huge
	Player.CameraMode="Classic"
end)

cmd.add({"maxzoom"},{"maxzoom <amount>","Set your maximum camera distance"},function(num)
	local num=tonumber(num) or 128
	Players.LocalPlayer.CameraMaxZoomDistance=num
end,true)

cmd.add({"minzoom"},{"minzoom <amount>","Set your minimum camera distance"},function(...)
	local args={...}
	local num=args[1]

	if num==nil then
		num=0
	else
		num=tonumber(num)
	end
	Players.LocalPlayer.CameraMinZoomDistance=num
end,true)

cmd.add({"cameranoclip","camnoclip","cnoclip","nccam"},{"cameranoclip (camnoclip,cnoclip,nccam)","Makes your camera clip through walls"}, function()
	local player = Players.LocalPlayer
	local camera = workspace.CurrentCamera

	local SetConstant = (debug and debug.setconstant) or setconstant
	local GetConstants = (debug and debug.getconstants) or getconstants
	local HasAdvancedAccess = (getgc and SetConstant and GetConstants)

	local function useAdvancedMode()
		if not HasAdvancedAccess then return end
		local PlayerModule = player:FindFirstChild("PlayerScripts") and player.PlayerScripts:FindFirstChild("PlayerModule")
		local Popper = PlayerModule and PlayerModule:FindFirstChild("CameraModule") and PlayerModule.CameraModule:FindFirstChild("ZoomController") and PlayerModule.CameraModule.ZoomController:FindFirstChild("Popper")

		if Popper then
			for i, v in pairs(getgc()) do
				if type(v) == "function" and getfenv(v).script == Popper then
					for i2, v2 in pairs(GetConstants(v)) do
						if tonumber(v2) == 0.25 then
							SetConstant(v, i2, 0)
						elseif tonumber(v2) == 0 then
							SetConstant(v, i2, 0.25)
						end
					end
				end
			end
		end
	end

	local function useInvisCamMode()
		if NAlib.isConnected("ilovesolara") then
			NAlib.disconnect("ilovesolara")
			player.DevCameraOcclusionMode = Enum.DevCameraOcclusionMode.Zoom
			return
		end
		NAlib.connect("ilovesolara", player:GetPropertyChangedSignal("DevCameraOcclusionMode"):Connect(function()
			if player.DevCameraOcclusionMode ~= Enum.DevCameraOcclusionMode.Invisicam then
				player.DevCameraOcclusionMode = Enum.DevCameraOcclusionMode.Invisicam
			end
		end))
		player.DevCameraOcclusionMode = Enum.DevCameraOcclusionMode.Invisicam
	end

	local currentMode = NAStuff.cameranoclipMode
	if currentMode == "advanced" then
		useAdvancedMode()
		NAStuff.cameranoclipMode = nil
		return
	elseif currentMode == "invis" then
		useInvisCamMode()
		NAStuff.cameranoclipMode = nil
		return
	elseif NAlib.isConnected("ilovesolara") then
		useInvisCamMode()
		NAStuff.cameranoclipMode = nil
		return
	end

	if not HasAdvancedAccess then
		useInvisCamMode()
		NAStuff.cameranoclipMode = "invis"
		return
	end

	local show = Window or DoWindow
	local buttons = {
		{
			Text = "Invisicam (DevCameraOcclusionMode.Invisicam)",
			Callback = function()
				useInvisCamMode()
				NAStuff.cameranoclipMode = "invis"
			end
		},
		{
			Text = "Current method (Popper getgc tweak)",
			Callback = function()
				useAdvancedMode()
				NAStuff.cameranoclipMode = "advanced"
			end
		},
	}

	if type(show) == "function" then
		show({
			Title = "Camera noclip mode",
			Description = "Choose how cameranoclip should behave.",
			Buttons = buttons
		})
	else
		useAdvancedMode()
		NAStuff.cameranoclipMode = "advanced"
	end
end)

cmd.add({"uncameranoclip","uncamnoclip","uncnoclip","unnccam"},{"uncameranoclip (uncamnoclip,uncnoclip,unnccam)","Restores normal camera"}, function()
	local player = Players.LocalPlayer
	local camera = workspace.CurrentCamera

	local SetConstant = (debug and debug.setconstant) or setconstant
	local GetConstants = (debug and debug.getconstants) or getconstants
	local HasAdvancedAccess = (getgc and SetConstant and GetConstants)

	local mode = NAStuff.cameranoclipMode
	NAStuff.cameranoclipMode = nil

	if mode == "advanced" and HasAdvancedAccess then
		local PlayerModule = player:FindFirstChild("PlayerScripts") and player.PlayerScripts:FindFirstChild("PlayerModule")
		local Popper = PlayerModule and PlayerModule:FindFirstChild("CameraModule") and PlayerModule.CameraModule:FindFirstChild("ZoomController") and PlayerModule.CameraModule.ZoomController:FindFirstChild("Popper")

		if Popper then
			for i, v in pairs(getgc()) do
				if type(v) == "function" and getfenv(v).script == Popper then
					for i2, v2 in pairs(GetConstants(v)) do
						if tonumber(v2) == 0.25 then
							SetConstant(v, i2, 0)
						elseif tonumber(v2) == 0 then
							SetConstant(v, i2, 0.25)
						end
					end
				end
			end
		end
	end

	if NAlib.isConnected("ilovesolara") then
		NAlib.disconnect("ilovesolara")
	end

	if player and player.DevCameraOcclusionMode then
		player.DevCameraOcclusionMode = Enum.DevCameraOcclusionMode.Zoom
	end
end)

cmd.add({"oganims"},{"oganims","Old animations from 2007"},function()
	Wait();
	DebugNotif("OG animations set")
	loadstring(game:HttpGet(('https://pastebin.com/raw/6GNkQUu6'),true))()
end)

cmd.add({"fakechat"},{"fakechat","Fake a chat gui"},function()
	loadstring(game:HttpGet("https://raw.githubusercontent.com/ltseverydayyou/Nameless-Admin/main/fake%20chatte"))()
end)

cmd.add({"fpscap"},{"fpscap <number>","Sets the fps cap to whatever you want"},function(arg)
	local cap = tonumber(arg)
	if cap then
		setfpscap(math.clamp(cap, 1, 999))
	else
		DoNotif("invalid input",1.3)
	end
end,true)

cmd.add({"toolinvisible", "tinvis"}, {"toolinvisible (tinvis)", "Be invisible while still being able to use tools"}, function()
	local offset = 1100
	invisible = false
	local grips = {}
	local heldTool
	local gripChanged
	local handle
	local weld
	HH = getHum().HipHeight

	function setDisplayDistance(distance)
		for _, player in pairs(Players:GetPlayers()) do
			if getPlrChar(player) and getPlrHum(player) then
				getPlrHum(player).NameDisplayDistance = distance
				getPlrHum(player).HealthDisplayDistance = distance
			end
		end
	end

	local tool = InstanceNew("Tool", Players.LocalPlayer.Backpack)
	tool.Name = "Turn Invisible"
	tool.RequiresHandle = false
	tool.CanBeDropped = false

	tool.Equipped:Connect(function()
		Wait()
		if not invisible then
			invisible = true
			tool.Name = "Visible Enabled"

			if handle then
				handle:Destroy()
			end
			if weld then
				weld:Destroy()
			end

			handle = InstanceNew("Part", workspace)
			handle.Name = "Handle"
			handle.Transparency = 1
			handle.CanCollide = false
			handle.Size = Vector3.new(2, 1, 1)

			weld = InstanceNew("Weld", handle)
			weld.Part0 = handle
			weld.Part1 = getRoot(getChar())
			weld.C0 = CFrame.new(0, offset - 1.5, 0)

			setDisplayDistance(offset + 100)
			workspace.CurrentCamera.CameraSubject = handle
			getRoot(getChar()).CFrame = getRoot(getChar()).CFrame * CFrame.new(0, offset, 0)
			getHum().HipHeight = offset
			getHum():ChangeState(11)

			for _, child in pairs(Players.LocalPlayer.Backpack:GetChildren()) do
				if child:IsA("Tool") and child ~= tool then
					grips[child] = child.Grip
				end
			end
			if getHum() then
				getHum():SetStateEnabled("Seated", false)
				getHum().Sit = true
			end
		else
			invisible = false
			tool.Name = "Visible Disabled"

			if handle then
				handle:Destroy()
			end
			if weld then
				weld:Destroy()
			end

			for _, child in pairs(getChar():GetChildren()) do
				if child:IsA("Tool") then
					child.Parent = Players.LocalPlayer.Backpack
				end
			end

			for tool, grip in pairs(grips) do
				if tool then
					tool.Grip = grip
				end
			end

			heldTool = nil
			setDisplayDistance(100)
			workspace.CurrentCamera.CameraSubject = getHum()
			getRoot(getChar()).CFrame = getRoot(getChar()).CFrame * CFrame.new(0, -offset, 0)
			getHum().HipHeight = HH

			if getHum() then
				getHum():SetStateEnabled("Seated", true)
				getHum().Sit = false
			end
		end

		tool.Parent = Players.LocalPlayer.Backpack
	end)

	getChar().ChildAdded:Connect(function(child)
		Wait()
		if invisible and child:IsA("Tool") and child ~= heldTool and child ~= tool then
			heldTool = child
			local lastGrip = heldTool.Grip

			if not grips[heldTool] then
				grips[heldTool] = lastGrip
			end

			for _, track in pairs(getHum():GetPlayingAnimationTracks()) do
				track:Stop()
			end

			getChar().Animate.Disabled = true
			heldTool.Grip = heldTool.Grip * (CFrame.new(0, offset - 1.5, 1.5) * CFrame.Angles(math.rad(-90), 0, 0))
			heldTool.Parent = Players.LocalPlayer.Backpack
			heldTool.Parent = getChar()

			if gripChanged then
				gripChanged:Disconnect()
			end

			gripChanged = heldTool:GetPropertyChangedSignal("Grip"):Connect(function()
				Wait()
				if not invisible then
					gripChanged:Disconnect()
				end

				if heldTool.Grip ~= lastGrip then
					lastGrip = heldTool.Grip * (CFrame.new(0, offset - 1.5, 1.5) * CFrame.Angles(math.rad(-90), 0, 0))
					heldTool.Grip = lastGrip
					heldTool.Parent = Players.LocalPlayer.Backpack
					heldTool.Parent = getChar()
				end
			end)
		end
	end)
end)

invisBtnlol = nil
invisKeybindConnection = nil
IsInvis = false
InvisibleCharacter = nil
OriginalPosition = nil
InvisBindLol = Enum.KeyCode.E

cmd.add({"invisible", "invis"},{"invisible (invis)", "Sets invisibility to scare people or something"}, function()
	if invisKeybindConnection then
		DebugNotif("Invisibility is already loaded!")
		return
	end

	local Character = Players.LocalPlayer.Character or Players.LocalPlayer.CharacterAdded:Wait()
	Character.Archivable = true
	OriginalPosition = getRoot(Character).CFrame

	local function TurnVisible()
		if not IsInvis then return end
		IsInvis = false
		OriginalPosition = getRoot(InvisibleCharacter).CFrame
		if InvisibleCharacter then
			InvisibleCharacter:Destroy()
			InvisibleCharacter = nil
		end
		Players.LocalPlayer.Character = Character
		Character.Parent = workspace
		RunService.Heartbeat:Wait()
		local root = getRoot(Character)
		if root then
			root.CFrame = OriginalPosition
		end
		DebugNotif("Invisibility turned off.")
		StarterGui:SetCore("ResetButtonCallback", true)
	end

	local function ToggleInvisibility()
		if not IsInvis then
			IsInvis = true
			InvisibleCharacter = Character:Clone()
			InvisibleCharacter.Parent = workspace
			for _, v in ipairs(InvisibleCharacter:GetDescendants()) do
				if v:IsA("BasePart") then
					v.Transparency = v.Name:lower() == "humanoidrootpart" and 1 or 0.5
				end
			end
			local root = getRoot(Character)
			if root then
				OriginalPosition = root.CFrame
				root.CFrame = CFrame.new(0, math.pi * 1000000, 0)
			end
			Wait(0.1)
			Character.Parent = ReplicatedStorage
			local invisRoot = getRoot(InvisibleCharacter)
			if invisRoot then
				invisRoot.CFrame = OriginalPosition
			end
			Players.LocalPlayer.Character = InvisibleCharacter
			workspace.CurrentCamera.CameraSubject = getPlrHum(InvisibleCharacter)
			DebugNotif("You are now invisible.")
			StarterGui:SetCore("ResetButtonCallback", false)
		else
			TurnVisible()
		end
	end

	if invisKeybindConnection then
		invisKeybindConnection:Disconnect()
		invisKeybindConnection = nil
	end

	invisKeybindConnection = UserInputService.InputBegan:Connect(function(input, gameProcessed)
		if input.UserInputType == Enum.UserInputType.Keyboard and input.KeyCode == InvisBindLol and not gameProcessed then
			ToggleInvisibility()
		end
	end)

	local humanoid = getPlrHum(Character)
	if humanoid then
		humanoid.Died:Connect(function()
			cmd.run({"vis"})
		end)
	end

	if IsOnMobile then
		if invisBtnlol then invisBtnlol:Destroy() invisBtnlol = nil end
		invisBtnlol = InstanceNew("ScreenGui")
		local TextButton = InstanceNew("TextButton")
		local UICorner = InstanceNew("UICorner")
		local UIAspectRatioConstraint = InstanceNew("UIAspectRatioConstraint")
		NaProtectUI(invisBtnlol)
		invisBtnlol.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
		TextButton.Parent = invisBtnlol
		TextButton.BackgroundColor3 = Color3.fromRGB(12, 4, 20)
		TextButton.BackgroundTransparency = 0.14
		TextButton.Position = UDim2.new(0.9, 0, 0.8, 0)
		TextButton.Size = UDim2.new(0.1, 0, 0.1, 0)
		TextButton.Font = Enum.Font.SourceSansBold
		TextButton.Text = "Invisible"
		TextButton.TextColor3 = Color3.new(1, 1, 1)
		TextButton.TextSize = 15
		TextButton.TextWrapped = true
		TextButton.TextScaled = true
		TextButton.Active = true
		UICorner.Parent = TextButton
		UIAspectRatioConstraint.Parent = TextButton
		UIAspectRatioConstraint.AspectRatio = 1
		NAgui.draggerV2(TextButton)
		MouseButtonFix(TextButton, function()
			ToggleInvisibility()
			TextButton.Text = IsInvis and "Visible" or "Invisible"
		end)
	end

	Wait()
	DebugNotif("Invisible loaded. Press "..InvisBindLol.Name.." or use the mobile button",2.5)
end)

cmd.add({"visible", "vis"}, {"visible", "turn visible"}, function()
	if invisKeybindConnection then
		invisKeybindConnection:Disconnect()
		invisKeybindConnection = nil
	end
	if invisBtnlol then
		invisBtnlol:Destroy()
		invisBtnlol = nil
	end
	local Character = Players.LocalPlayer.Character or Players.LocalPlayer.CharacterAdded:Wait()
	if IsInvis then
		IsInvis = false
		if InvisibleCharacter then InvisibleCharacter:Destroy() InvisibleCharacter = nil end
		Players.LocalPlayer.Character = Character
		Character.Parent = workspace
	end
	DebugNotif("Invisibility Disabled",2)
end)

cmd.add({"invisbind", "invisiblebind","bindinvis"}, {"invisbind (invisiblebind, bindinvis)", "set a custom keybind for the 'Invisible' command"}, function(...)
	local args = {...}
	if args[1] then
		InvisBindLol = Enum.KeyCode[args[1]] or Enum.KeyCode[args[1]:upper()]
		if InvisBindLol then
			DebugNotif("Invis bind set to "..InvisBindLol.Name)
		else
			DebugNotif("Invalid keybind, defaulting to E")
			InvisBindLol = Enum.KeyCode.E
		end
	else
		DebugNotif("No keybind provided")
	end
end,true)

cmd.add({"fireremotes", "fremotes", "frem"}, {"fireremotes (fremotes, frem)", "Fires every remote with arguments"}, function()
	local remoteCount = 0
	local failedCount = 0

	for _, obj in ipairs(game:GetDescendants()) do
		if not obj:IsDescendantOf(COREGUI) and (obj:IsA("RemoteEvent") or obj:IsA("RemoteFunction")) then
			SpawnCall(function()
				local ok
				if obj:IsA("RemoteEvent") then
					ok = pcall(function() obj:FireServer() end)
				elseif obj:IsA("RemoteFunction") then
					ok = pcall(function() obj:InvokeServer() end)
				end

				if ok then
					remoteCount=remoteCount + 1
				else
					failedCount=failedCount + 1
				end
			end)
		end
	end

	Delay(2, function()
		DebugNotif("Fired "..remoteCount.." remotes\nFailed: "..failedCount.." remotes")
	end)
end)

cmd.add({"keepna"}, {"keepna", "keep executing "..adminName.." every time you teleport"}, function()
	NAQoTEnabled = true
	NAmanage.NASettingsSet("queueOnTeleport", true)
	DoNotif(adminName.." will now auto-load after teleport (QueueOnTeleport enabled)")
end)

cmd.add({"unkeepna"}, {"unkeepna", "Stop executing "..adminName.." every time you teleport"}, function()
	NAQoTEnabled = false
	NAmanage.NASettingsSet("queueOnTeleport", false)
	DoNotif("QueueOnTeleport has been disabled. "..adminName.." will no longer auto-run after teleport")
end)

do
	local SafeInstanceNew = InstanceNew
	if type(SafeInstanceNew) ~= "function" then
		SafeInstanceNew = function(className, parent)
			local inst = InstanceNew(className)
			if parent then inst.Parent = parent end
			inst.Name = "\0"
			return inst
		end
		InstanceNew = SafeInstanceNew
	end

	local FOVhandler = {mem={o=nil,r=nil,u=nil,base={}}, loop=false, cam=nil, refreshConn=nil, loopHoldConn=nil, watchConn=nil}

	local function disconnectFovRefresh()
		if FOVhandler.refreshConn then
			pcall(function() FOVhandler.refreshConn:Disconnect() end)
			FOVhandler.refreshConn = nil
		end
		if NAlib and NAlib.disconnect then
			pcall(NAlib.disconnect, "fov_refresh")
		end
	end

	local function setFovRefreshConnection(conn)
		disconnectFovRefresh()
		FOVhandler.refreshConn = conn
		if conn and NAlib and NAlib.connect then
			pcall(NAlib.connect, "fov_refresh", conn)
		end
	end

	local function hasFovRefresh()
		if FOVhandler.refreshConn then
			return true
		end
		if NAlib and NAlib.isConnected then
			local ok, result = pcall(NAlib.isConnected, "fov_refresh")
			if ok and result then
				return true
			end
		end
		return false
	end

	local function disconnectLoopHold()
		if FOVhandler.loopHoldConn then
			pcall(function() FOVhandler.loopHoldConn:Disconnect() end)
			FOVhandler.loopHoldConn = nil
		end
		if NAlib and NAlib.disconnect then
			pcall(NAlib.disconnect, "fov_loop_hold")
		end
	end

	local function setLoopHoldConnection(conn)
		disconnectLoopHold()
		FOVhandler.loopHoldConn = conn
		if conn and NAlib and NAlib.connect then
			pcall(NAlib.connect, "fov_loop_hold", conn)
		end
	end

	local function connectCameraWatcher()
		if FOVhandler.watchConn then
			pcall(function() FOVhandler.watchConn:Disconnect() end)
			FOVhandler.watchConn = nil
		end
		if NAlib and NAlib.disconnect then
			pcall(NAlib.disconnect, "fov_watch_cc")
		end
		local ok, conn = pcall(function()
			return workspace:GetPropertyChangedSignal("CurrentCamera"):Connect(function()
				FOVhandler.cam = workspace.CurrentCamera
			end)
		end)
		if ok and conn then
			FOVhandler.watchConn = conn
			if NAlib and NAlib.connect then
				pcall(NAlib.connect, "fov_watch_cc", conn)
			end
		end
		FOVhandler.cam = workspace.CurrentCamera
	end

	originalIO.FOVstep=function()
		local parent = NAmanage.guiCHECKINGAHHHHH(); if not parent then return end
		FOVhandler.mem.o = (FOVhandler.mem.o and FOVhandler.mem.o.Parent) and FOVhandler.mem.o or SafeInstanceNew("NumberValue", parent)
		FOVhandler.mem.r = (FOVhandler.mem.r and FOVhandler.mem.r.Parent) and FOVhandler.mem.r or SafeInstanceNew("Vector3Value", parent)
		FOVhandler.mem.u = (FOVhandler.mem.u and FOVhandler.mem.u.Parent) and FOVhandler.mem.u or SafeInstanceNew("Vector3Value", parent)

		local o = FOVhandler.mem.o.Value or 0
		local sum = 0
		for i=1,#FOVhandler.mem.base do
			local v = FOVhandler.mem.base[i]
			if not v or not v.Parent then v = SafeInstanceNew("NumberValue", parent); FOVhandler.mem.base[i] = v end
			sum += (v.Value or 0)
		end
		local target = (o ~= 0 and o) or sum
		local cam = workspace.CurrentCamera; if not cam then return end

		if cam ~= FOVhandler.cam then
			FOVhandler.cam = cam
			setFovRefreshConnection(cam:GetPropertyChangedSignal("FieldOfView"):Connect(function()
				if not FOVhandler.loop then return end
				local t = (FOVhandler.mem.o and FOVhandler.mem.o.Value) or 0
				if t > 0 then
					local vis = math.clamp(t, 25, 120)
					if cam.FieldOfView ~= vis then cam.FieldOfView = vis end
				end
			end))
		end

		if FOVhandler.loop and target > 0 then
			local vis = math.clamp(target, 25, 120)
			if cam.FieldOfView ~= vis then cam.FieldOfView = vis end
		end

		if target <= 120 or target == 0 then
			if FOVhandler.mem.r.Value.Magnitude > 0 then FOVhandler.mem.r.Value = Vector3.new() end
			if FOVhandler.mem.u.Value.Magnitude > 0 then FOVhandler.mem.u.Value = Vector3.new() end
			return
		end

		local f = math.clamp((target - 120) * 0.005, 0, 0.9)
		local v = Vector3.new(f,f,f)
		if FOVhandler.mem.r.Value ~= v then FOVhandler.mem.r.Value = v end
		if FOVhandler.mem.u.Value ~= v then FOVhandler.mem.u.Value = v end

		local c = cam.CFrame
		local p = c.Position
		local r = c.RightVector
		local u = c.UpVector
		local l = -c.LookVector
		local rs = Vector3.new(1,1,1) - FOVhandler.mem.r.Value
		local us = Vector3.new(1,1,1) - FOVhandler.mem.u.Value
		cam.CFrame = CFrame.fromMatrix(p, Vector3.new(r.X*rs.X, r.Y*rs.Y, r.Z*rs.Z), Vector3.new(u.X*us.X, u.Y*us.Y, u.Z*us.Z), l)
	end

	pcall(function() RunService:UnbindFromRenderStep("FOV_SYS") end)
	RunService:BindToRenderStep("FOV_SYS", Enum.RenderPriority.Camera.Value+1, originalIO.FOVstep)

	connectCameraWatcher()

	cmd.add({"fov"}, {"fov <number>", "Sets your FOV to a custom value (1–300)"}, function(num)
		local t = math.clamp(tonumber(num) or 70, 1, 300)
		local parent = NAmanage.guiCHECKINGAHHHHH(); if not parent then return end
		if FOVhandler.loop then
			FOVhandler.mem.o = (FOVhandler.mem.o and FOVhandler.mem.o.Parent) and FOVhandler.mem.o or SafeInstanceNew("NumberValue", parent)
			FOVhandler.mem.o.Value = t
		else
			FOVhandler.mem.base[1] = (FOVhandler.mem.base[1] and FOVhandler.mem.base[1].Parent) and FOVhandler.mem.base[1] or SafeInstanceNew("NumberValue", parent)
			FOVhandler.mem.base[1].Value = t
		end
		local cam = workspace.CurrentCamera
		if cam then
			local vis = math.clamp(t, 25, 120)
			TweenService:Create(cam, TweenInfo.new(0.2, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut), {FieldOfView = vis}):Play()
		end
	end, true)

	cmd.add({"loopfov","lfov"}, {"loopfov <number> (lfov)", "Locks your FOV target (1–300)"}, function(num)
		local t = math.clamp(tonumber(num) or 70, 1, 300)
		local parent = NAmanage.guiCHECKINGAHHHHH(); if not parent then return end
		FOVhandler.mem.o = (FOVhandler.mem.o and FOVhandler.mem.o.Parent) and FOVhandler.mem.o or SafeInstanceNew("NumberValue", parent)
		FOVhandler.mem.o.Value = t
		FOVhandler.loop = true
		if not hasFovRefresh() then
			FOVhandler.cam = nil
		end
		setLoopHoldConnection(RunService.RenderStepped:Connect(function()
			local p = NAmanage.guiCHECKINGAHHHHH()
			if not FOVhandler.mem.o or not FOVhandler.mem.o.Parent then FOVhandler.mem.o = SafeInstanceNew("NumberValue", p) end
		end))
		local cam = workspace.CurrentCamera
		if cam then
			local vis = math.clamp(t, 25, 120)
			if cam.FieldOfView ~= vis then cam.FieldOfView = vis end
		end
	end, true)

	cmd.add({"unloopfov","unlfov"}, {"unloopfov (unlfov)", "Stops FOV loop"}, function()
		FOVhandler.loop = false
		disconnectLoopHold()
		disconnectFovRefresh()
		if FOVhandler.mem.o and FOVhandler.mem.o.Parent then FOVhandler.mem.o.Value = 0 end
		if FOVhandler.mem.r and FOVhandler.mem.r.Parent then FOVhandler.mem.r.Value = Vector3.new() end
		if FOVhandler.mem.u and FOVhandler.mem.u.Parent then FOVhandler.mem.u.Value = Vector3.new() end
	end)
end

cmd.add({"homebrew"},{"homebrew","Executes homebrew admin"},function()
	getgenv().CustomUI=false
	loadstring(game:HttpGet(('https://raw.githubusercontent.com/mgamingpro/HomebrewAdmin/master/Main'),true))()
end)

cmd.add({"fatesadmin"},{"fatesadmin","Executes fates admin"},function()
	loadstring(game:HttpGet("https://raw.githubusercontent.com/fatesc/fates-admin/main/main.lua"))();
end)

storedTools = {}

cmd.add({"savetools", "stools"}, {"savetools (stools)", "Saves your tools to memory"}, function()
	storedTools = {}

	for _, tool in pairs(LocalPlayer.Backpack:GetChildren()) do
		if tool:IsA("Tool") then
			local clonedTool = tool:Clone()
			Insert(storedTools, clonedTool)
		end
	end

	for _, tool in pairs(LocalPlayer.Character:GetChildren()) do
		if tool:IsA("Tool") then
			local clonedTool = tool:Clone()
			Insert(storedTools, clonedTool)
		end
	end

	DebugNotif("Tools saved: "..#storedTools,2)
end)

cmd.add({"loadtools", "ltools"}, {"loadtools (ltools)", "Restores your saved tools to your backpack"}, function()
	for _, tool in pairs(storedTools) do
		if not LocalPlayer.Backpack:FindFirstChild(tool.Name) then
			local clonedTool = tool:Clone()
			clonedTool.Parent = LocalPlayer.Backpack
		end
	end

	DebugNotif("Tools loaded: "..#storedTools,2)
end)

cmd.add({"preventtools", "noequip", "antiequip"}, {"preventtools (noequip,antiequip)", "Prevents any item from being equipped"}, function()
	local p = Players.LocalPlayer
	local c = p.Character

	NAlib.disconnect("noequip_char")
	NAlib.disconnect("noequip_hum")

	local h = getHum()
	if not h then return end

	h:UnequipTools()

	local function onTool(t)
		if t:IsA("Tool") then
			t.Enabled = false
			Defer(function()
				h:UnequipTools()
				DebugNotif("Tool "..t.Name.." blocked", 2)
			end)
		end
	end

	NAlib.connect("noequip_char", c.ChildAdded:Connect(onTool))
	NAlib.connect("noequip_hum", h.ChildAdded:Connect(onTool))

	DebugNotif("Tool prevention on", 3)
end)

cmd.add({"unpreventtools", "unnoequip", "unantiequip"}, {"unpreventtools (unnoequip,unantiequip)", "Self-explanatory"}, function()
	NAlib.disconnect("noequip_char")
	NAlib.disconnect("noequip_hum")
	DebugNotif("Tool prevention off", 2)
end)

cmd.add({"ws", "speed", "walkspeed"}, {"walkspeed <number> (speed,ws)", "Sets your WalkSpeed"}, function(...)
	local a = {...}
	local s = tonumber(a[2] or a[1]) or 16
	local h = getHum()
	if s and h then
		h.WalkSpeed = s
	end
end, true)

cmd.add({"jp", "jumppower"}, {"jumppower <number> (jp)", "Sets your JumpPower"}, function(...)
	local a = {...}
	local j = tonumber(a[1]) or 50
	local h = getHum()
	if j and h then
		if h.UseJumpPower then
			h.JumpPower = j
		else
			h.JumpHeight = j
		end
	end
end, true)

NAmanage.isCoreFunc=function(fn)
	local ok, env = pcall(getfenv, fn)
	if not ok or type(env) ~= "table" then return false end
	local sc = rawget(env, "script")
	return typeof(sc) == "Instance" and sc:IsDescendantOf(COREGUI)
end

NAmanage.BlockRemote = function(remote, mode)
	mode = mode or "fakeok"
	if not Discover(NAStuff.BlockedRemotes, remote) then
		Insert(NAStuff.BlockedRemotes, remote)
	end
	NAStuff.BlockedRemoteModes[remote] = mode
	if remote:IsA("RemoteEvent") then
		NAStuff.BlockedSignals[remote.OnClientEvent] = true
		if typeof(getconnections) == "function" then
			local saved = {funcs = {}}
			for _, c in ipairs(getconnections(remote.OnClientEvent)) do
				local ok, f = pcall(function() return c.Function end)
				if ok and type(f) == "function" and not NAmanage.isCoreFunc(f) then
					Insert(saved.funcs, f)
					pcall(function() c:Disconnect() end)
				end
			end
			NAStuff.BlockedEventSaved[remote] = saved
		end
	elseif remote:IsA("RemoteFunction") then
		if NAStuff.BlockedInvokeSaved[remote] == nil then
			local ok, current = pcall(function() return remote.OnClientInvoke end)
			NAStuff.BlockedInvokeSaved[remote] = ok and type(current)=="function" and current or NAStuff.NIL_SENTINEL
		end
		remote.OnClientInvoke = function(...)
			local m = NAStuff.BlockedRemoteModes[remote] or "fakeok"
			if m == "error" then
				error("Blocked remote: "..remote:GetFullName().." [OnClientInvoke]", 0)
			else
				local ret = NAStuff.BlockedRemoteReturns[remote]
				if ret == nil then ret = NAStuff.RemoteFakeReturn end
				return ret
			end
		end
	end
	DebugNotif(("Blocked: %s (%s)"):format(remote:GetFullName(), NAStuff.BlockedRemoteModes[remote]), 3, "Remote Block")
end

NAmanage.UnblockRemote = function(remote)
	local idx = Discover(NAStuff.BlockedRemotes, remote)
	if idx then
		local name = NAStuff.BlockedRemotes[idx]:GetFullName()
		table.remove(NAStuff.BlockedRemotes, idx)
		NAStuff.BlockedRemoteModes[remote] = nil
		NAStuff.BlockedRemoteReturns[remote] = nil
		if remote:IsA("RemoteEvent") then
			NAStuff.BlockedSignals[remote.OnClientEvent] = nil
			local saved = NAStuff.BlockedEventSaved[remote]
			if saved and saved.funcs then
				for _, f in ipairs(saved.funcs) do
					pcall(function() remote.OnClientEvent:Connect(f) end)
				end
			end
			NAStuff.BlockedEventSaved[remote] = nil
		elseif remote:IsA("RemoteFunction") then
			local saved = NAStuff.BlockedInvokeSaved[remote]
			if saved == NAStuff.NIL_SENTINEL then
				remote.OnClientInvoke = nil
			elseif type(saved) == "function" then
				remote.OnClientInvoke = saved
			else
				remote.OnClientInvoke = nil
			end
			NAStuff.BlockedInvokeSaved[remote] = nil
		end
		DebugNotif(("Unblocked: %s"):format(name), 3, "Remote Block")
	end
end

NAmanage.EnsureHook = function()
	if getgenv().NA_BlockHooked then return end
	local mt = getrawmetatable(game)
	local oldNamecall = mt.__namecall
	setreadonly(mt, false)
	mt.__namecall = newcclosure(function(self, ...)
		local method = getnamecallmethod()
		if (method == "FireServer" or method == "InvokeServer") and Discover(NAStuff.BlockedRemotes, self) then
			local m = NAStuff.BlockedRemoteModes[self] or "fakeok"
			if NAStuff.nuhuhNotifs then Defer(DebugNotif, ("Blocked -> %s (%s) [%s]"):format(self:GetFullName(), method, m == "error" and "ERROR" or "FAKEOK"), 2, "Remote Block") end
			if m == "error" then error("Blocked remote: "..self:GetFullName().." ["..method.."]", 0) end
			if method == "InvokeServer" then
				local ret = NAStuff.BlockedRemoteReturns[self]
				if ret == nil then ret = NAStuff.RemoteFakeReturn end
				return ret
			end
			return
		end
		if NAStuff.BlockedSignals[self] then
			if method == "Connect" or method == "Once" then
				local cb = select(1, ...)
				if type(cb) == "function" and NAmanage.isCoreFunc(cb) then
					return oldNamecall(self, ...)
				end
				if NAStuff.nuhuhNotifs then Defer(DebugNotif, "Blocked OnClientEvent:"..method.."()", 2, "Remote Block") end
				local conn = oldNamecall(self, function() end)
				pcall(function() conn:Disconnect() end)
				return conn
			elseif method == "Wait" then
				local mode = "fakeok"
				for r,_ in pairs(NAStuff.BlockedRemotes) do
					if typeof(r)=="Instance" and r:IsA("RemoteEvent") and self==r.OnClientEvent then
						mode = NAStuff.BlockedRemoteModes[r] or "fakeok"
						break
					end
				end
				if NAStuff.nuhuhNotifs then Defer(DebugNotif, "Blocked OnClientEvent:Wait()", 2, "Remote Block") end
				if mode == "error" then error("Blocked OnClientEvent:Wait()", 0) end
				return nil
			end
		end
		return oldNamecall(self, ...)
	end)
	setreadonly(mt, true)
	getgenv().NA_BlockHooked = true
end

cmd.add({"blockremote","br"},{"blockremote [name]","Block a remote event/function by name (or pick from list)"},function(name)
	local function scanAll()
		local list, seen = {}, {}
		local function scan(parent)
			for _, obj in ipairs(parent:GetDescendants()) do
				if (obj:IsA("RemoteEvent") or obj:IsA("RemoteFunction")) and not seen[obj] then
					seen[obj] = true
					Insert(list, obj)
				end
			end
		end
		scan(ReplicatedStorage)
		local plr = Players.LocalPlayer
		local pg = PlrGui or plr:FindFirstChildOfClass("PlayerGui")
		if pg then scan(pg) else scan(plr) end
		return list
	end
	local function exactByName(q)
		local out, lq = {}, Lower(q)
		for _, r in ipairs(scanAll()) do
			if Lower(r.Name) == lq then Insert(out, r) end
		end
		return out
	end
	local function fuzzyByName(q)
		local out, lq = {}, Lower(q)
		for _, r in ipairs(scanAll()) do
			if Find(Lower(r.Name), lq, 1, true) then Insert(out, r) end
		end
		return out
	end
	local function openPicker(list, titleText, modeSel)
		if #list == 0 then DebugNotif("No remotes found.", 3, "Remote Block") return end
		local buttons = {}
		for _, r in ipairs(list) do
			Insert(buttons, {
				Text = ("%s | %s"):format(r.Name, r:GetFullName()),
				Callback = function()
					NAmanage.EnsureHook()
					NAmanage.BlockRemote(r, modeSel)
				end
			})
		end
		Window({ Title = titleText, Buttons = buttons })
	end
	local function afterMode(modeSel)
		local q = tostring(name or ""):gsub("^%s+",""):gsub("%s+$","")
		if q ~= "" then
			local exact = exactByName(q)
			if #exact >= 1 then
				NAmanage.EnsureHook()
				for _, r in ipairs(exact) do
					NAmanage.BlockRemote(r, modeSel)
				end
				return
			end
			local fuzzy = fuzzyByName(q)
			if #fuzzy == 1 then
				NAmanage.EnsureHook()
				NAmanage.BlockRemote(fuzzy[1], modeSel)
				return
			end
			openPicker(fuzzy, ("Select remote(s) to BLOCK for '%s'"):format(q), modeSel)
			return
		end
		openPicker(scanAll(), "Select remote(s) to BLOCK", modeSel)
	end
	Window({
		Title = "Remote Block Mode",
		Buttons = {
			{ Text = "Fake Success", Callback = function() afterMode("fakeok") end },
			{ Text = "Error",        Callback = function() afterMode("error")  end }
		}
	})
end,true)

cmd.add({"unblockremote","ubr"},{"unblockremote [name|all]","Unblock a remote by name, or pick from blocked list"},function(name)
	if not name or name == "" then
		local blocked = NAStuff.BlockedRemotes
		if #blocked == 0 then
			DebugNotif("No remotes are currently blocked.", 3, "Remote Block")
			return
		end
		local buttons = {}
		for _, r in ipairs(blocked) do
			Insert(buttons, {
				Text = ("%s | %s"):format(r.Name, r:GetFullName()),
				Callback = function() NAmanage.UnblockRemote(r) end
			})
		end
		Insert(buttons, {
			Text = "[ Unblock ALL ]",
			Callback = function()
				for i = #blocked, 1, -1 do
					NAmanage.UnblockRemote(blocked[i])
				end
			end
		})
		Window({ Title = "Blocked Remotes", Buttons = buttons })
		return
	end
	if Lower(name) == "all" or name == "*" then
		for i = #NAStuff.BlockedRemotes, 1, -1 do
			NAmanage.UnblockRemote(NAStuff.BlockedRemotes[i])
		end
		return
	end
	local lname = Lower(name)
	local exact, suggestions = {}, {}
	for _, r in ipairs(NAStuff.BlockedRemotes) do
		if Lower(r.Name) == lname then
			Insert(exact, r)
		elseif Find(Lower(r.Name), lname, 1, true) then
			Insert(suggestions, r)
		end
	end
	if #exact > 0 then
		for _, r in ipairs(exact) do
			NAmanage.UnblockRemote(r)
		end
		return
	end
	if #suggestions == 0 then
		DebugNotif(("No BLOCKED remotes match '%s'"):format(name), 3, "Remote Block")
		return
	end
	local buttons = {}
	for _, r in ipairs(suggestions) do
		Insert(buttons, {
			Text = ("%s | %s"):format(r.Name, r:GetFullName()),
			Callback = function() NAmanage.UnblockRemote(r) end
		})
	end
	Window({ Title = ("Select remote to UNBLOCK for '%s'"):format(name), Buttons = buttons })
end,true)

NAmanage.EnsureWalkSpeedBypassHook = function()
	if getgenv().NA_WSBP_Hooked then return end
	local mt = getrawmetatable(game)
	local oldIndex = mt.__index
	setreadonly(mt, false)
	mt.__index = newcclosure(function(self, key)
		if key == "WalkSpeed" then
			return 16
		end
		return oldIndex(self, key)
	end)
	setreadonly(mt, true)
	getgenv().NA_WSBP_Hooked = true
	DebugNotif("WalkSpeed bypass installed", 2, "Bypass Speed")
end

NAmanage.ApplyBypassSpeedOnce = function(val)
	local hum = getHum()
	if hum and val and val > 0 then
		hum.WalkSpeed = val
		DebugNotif(("BypassSpeed set to %s"):format(val), 2, "Bypass Speed")
	end
end

NAmanage.StartBypassSpeedLoop = function(val)
	if not val or val <= 0 then return end
	getgenv().NA_BPS_Enabled = true
	getgenv().NA_BPS_Val = val
	NAlib.disconnect("na_bps_apply")
	NAlib.disconnect("na_bps_char")
	local plr = Players.LocalPlayer
	NAmanage.ApplyBypassSpeedOnce(val)
	NAlib.connect("na_bps_apply", RunService.Heartbeat:Connect(function()
		if not getgenv().NA_BPS_Enabled then return end
		local hum = getHum()
		if hum and hum.WalkSpeed ~= getgenv().NA_BPS_Val then
			hum.WalkSpeed = getgenv().NA_BPS_Val
		end
	end))
	NAlib.connect("na_bps_char", plr.CharacterAdded:Connect(function(char)
		NAmanage.EnsureWalkSpeedBypassHook()
		while not getHum() do Wait(.05) end
		if getgenv().NA_BPS_Enabled then
			NAmanage.ApplyBypassSpeedOnce(getgenv().NA_BPS_Val)
		end
	end))
	DebugNotif(("LoopBypassSpeed: %s"):format(val), 2, "Bypass Speed")
end

NAmanage.StopBypassSpeedLoop = function()
	getgenv().NA_BPS_Enabled = false
	NAlib.disconnect("na_bps_apply")
	NAlib.disconnect("na_bps_char")
	DebugNotif("LoopBypassSpeed: OFF", 2, "Bypass Speed")
end

cmd.add({"bypassspeed","bps","bypasswalkspeed","bpws"},{"bypassspeed <number> (bps,bpws)","Set WalkSpeed (bypass variant)"},function(...)
	local a = {...}
	local arg = tostring(a[2] or a[1] or "")
	if arg == "" then return end
	if Lower(arg) == "off" then
		NAmanage.StopBypassSpeedLoop()
		return
	end
	local val = tonumber(arg)
	if not val or val <= 0 then return end
	NAmanage.EnsureWalkSpeedBypassHook()
	NAmanage.ApplyBypassSpeedOnce(val)
end, true)

cmd.add({"loopbypassspeed","lbps","loopbypasswalkspeed","lbws"},{"loopbypassspeed <number|off> (lbps,lbws)","Loop WalkSpeed (bypass variant)"},function(...)
	local arg = tostring((...) or "")
	if arg == "" then return end
	if Lower(arg) == "off" then
		NAmanage.StopBypassSpeedLoop()
		return
	end
	local val = tonumber(arg)
	if not val or val <= 0 then return end
	NAmanage.EnsureWalkSpeedBypassHook()
	NAmanage.StartBypassSpeedLoop(val)
end, true)

cmd.add({"unloopbypassspeed","unlbps","unloopbypasswalkspeed","unlbws"},{"unloopbypassspeed (unlbps,unlbws)","Disable loop WalkSpeed (bypass variant)"},function()
	NAmanage.StopBypassSpeedLoop()
end)

cmd.add({"oofspam"},{"oofspam","Spams oof"},function()
	getgenv().enabled = true
	getgenv().speed = 100
	local HRP = Humanoid.RootPart or getRoot(Humanoid.Parent)
	if not Humanoid or not getgenv().enabled then
		if Humanoid and Humanoid.Health <= 0 then
			Humanoid:Destroy()
		end
		return
	end
	Humanoid:SetStateEnabled(Enum.HumanoidStateType.Dead, false)
	Humanoid.BreakJointsOnDeath = false
	Humanoid.RequiresNeck = false

	NAlib.connect("oofspam_forcerun", RunService.Stepped:Connect(function()
		if not Humanoid then return NAlib.disconnect("oofspam_forcerun") end
		Humanoid:ChangeState(Enum.HumanoidStateType.Running)
	end))

	LocalPlayer.Character = nil
	LocalPlayer.Character = Character
	Wait(Players.RespawnTime + 0.1)

	NAlib.connect("oofspam_loop", RunService.Heartbeat:Connect(function()
		if not getgenv().enabled then
			NAlib.disconnect("oofspam_loop")
			return
		end
		Humanoid:ChangeState(Enum.HumanoidStateType.Dead)
	end))
end)

cmd.add({"httpspy"},{"httpspy","HTTP Spy"},function()
	loadstring(game:HttpGet('https://raw.githubusercontent.com/ltseverydayyou/Nameless-Admin/main/httpspy.lua'))()
end)

cmd.add({"keystroke"},{"keystroke","Executes a keystroke ui script"},function()
	loadstring(game:HttpGet("https://system-exodus.com/scripts/misc-releases/Keystrokes.lua",true))()
end)

cmd.add({"errorchat"},{"errorchat","Makes the chat error appear when roblox chat is slow"},function()
	for i=1,3 do
		NAlib.LocalPlayerChat("\0","All")
	end
end)

cmd.add({"clearerror", "noerror"}, {"clearerror", "Clears any current error or disconnected UI immediately"}, function()
	GuiService:ClearError()
end)

cmd.add({"antierror"}, {"antierror", "Continuously blocks and clears any future error or disconnected UI"}, function()
	NAlib.disconnect("antierror")
	NAlib.connect("antierror", GuiService.ErrorMessageChanged:Connect(function()
		GuiService:ClearError()
	end))
	DebugNotif("Anti Error is now enabled!", 2)
end)

cmd.add({"unantierror", "noantierror"}, {"unantierror", "Disables Anti Error"}, function()
	NAlib.disconnect("antierror")
	DebugNotif("Anti Error is now disabled!",2)
end)

-- [[ Body Mods Section ]] --
do
	originalIO.bodyModsState = originalIO.bodyModsState or {
		boobs = { active = false, size = 1, conn = nil, ox = 0.5, oy = -0.4, oz = nil, sy = 0, vy = 0, sz = 0, vz = 0, sx = 0, vx = 0, rx = 0, vrx = 0, ry = 0, rv = 0, yw = 0, vyw = 0, llv = Vector3.zero, hcf = nil, ccf = nil },
		ass = { active = false, size = 1, conn = nil, ox = 0.48, oy = nil, oz = nil, sy = 0, vy = 0, sz = 0, vz = 0, sx = 0, vx = 0, rx = 0, vrx = 0, ry = 0, rv = 0, yw = 0, vyw = 0, llv = Vector3.zero, hcf = nil },
		pp = { active = false, len = 1, animConn = nil, wS = nil, wTip = nil, sh = nil, dr = nil, sy = 0, vy = 0, sz = 0, vz = 0, sx = 0, vx = 0, rx = 0, vrx = 0, ry = 0, vry = 0, baseC0 = nil },
		colorConn = nil,
		spawnConn = nil,
		apConn = nil
	}

	local state = originalIO.bodyModsState
	local pinkColor = Color3.fromRGB(255, 100, 150)
	local ringColor = Color3.fromRGB(225, 80, 120)

	originalIO.bodyModsSpring = originalIO.bodyModsSpring or function(u, v, target, stiffness, damping, dt)
		local accel = -stiffness * u - damping * v + stiffness * target
		v = v + accel * dt
		u = u + v * dt
		return u, v
	end

	originalIO.bodyModsDisconnectConnection = function(conn)
		if conn and conn.Connected then
			conn:Disconnect()
		end
		return nil
	end

	originalIO.bodyModsConnectAppearanceLoaded = originalIO.bodyModsConnectAppearanceLoaded or function(object, callback)
		if not object or type(callback) ~= "function" then
			return nil
		end
		local ok, signal = pcall(function()
			return object.CharacterAppearanceLoaded
		end)
		if ok and typeof(signal) == "RBXScriptSignal" then
			return signal:Connect(callback)
		end
		Defer(callback)
		return nil
	end

	originalIO.bodyModsGetCharacter = function(waitFor)
		local character = Players.LocalPlayer and Players.LocalPlayer.Character
		if character or not waitFor then
			return character
		end
		local ok, result = pcall(function()
			return Players.LocalPlayer.Character or Players.LocalPlayer.CharacterAdded:Wait()
		end)
		return ok and result or nil
	end

	originalIO.bodyModsGetHumanoid = function(waitFor)
		local character = originalIO.bodyModsGetCharacter(waitFor)
		if not character then
			return nil
		end
		local humanoid = character:FindFirstChildOfClass("Humanoid")
		if humanoid or not waitFor then
			return humanoid
		end
		local ok, result = pcall(function()
			return character:WaitForChild("Humanoid", 10)
		end)
		return ok and result or nil
	end

	originalIO.bodyModsWaitFor = function(partNames, timeout)
		local deadline = os.clock() + (timeout or 10)
		while os.clock() < deadline do
			local character = Players.LocalPlayer and Players.LocalPlayer.Character
			if character then
				for _, name in ipairs(partNames) do
					local part = character:FindFirstChild(name)
					if part then
						return part
					end
				end
			end
			Wait(0.05)
		end
		return nil
	end

	originalIO.bodyModsGetTorso = function(forBoobs)
		local character = originalIO.bodyModsGetCharacter(true)
		local humanoid = originalIO.bodyModsGetHumanoid(true)
		if not character or not humanoid then
			return nil
		end
		if forBoobs then
			return character:FindFirstChild("UpperTorso")
				or character:FindFirstChild("Torso")
				or originalIO.bodyModsWaitFor({ "UpperTorso", "Torso" }, 5)
		end
		if humanoid.RigType == Enum.HumanoidRigType.R15 then
			return character:FindFirstChild("LowerTorso") or originalIO.bodyModsWaitFor({ "LowerTorso" }, 5)
		end
		return character:FindFirstChild("Torso") or originalIO.bodyModsWaitFor({ "Torso" }, 5)
	end

	originalIO.bodyModsGetSkinColor = function()
		local character = Players.LocalPlayer and Players.LocalPlayer.Character
		if not character then
			return Color3.new(1, 0.8, 0.6)
		end
		local part =
			character:FindFirstChild("LeftUpperArm") or
			character:FindFirstChild("Left Arm") or
			character:FindFirstChild("RightUpperArm") or
			character:FindFirstChild("Right Arm") or
			character:FindFirstChild("LeftUpperLeg") or
			character:FindFirstChild("Left Leg") or
			character:FindFirstChild("UpperTorso") or
			character:FindFirstChild("Torso")
		return (part and part.Color) or Color3.new(1, 0.8, 0.6)
	end

	originalIO.bodyModsAnyActive = function()
		return state.boobs.active or state.ass.active or state.pp.active
	end

	originalIO.bodyModsDisconnectColorWatcher = function()
		state.colorConn = originalIO.bodyModsDisconnectConnection(state.colorConn)
	end

	originalIO.bodyModsEnsureColorWatcher = function()
		if not originalIO.bodyModsAnyActive() then
			originalIO.bodyModsDisconnectColorWatcher()
			return
		end
		if state.colorConn and state.colorConn.Connected then
			return
		end
		state.colorConn = RunService.Heartbeat:Connect(function()
			if not originalIO.bodyModsAnyActive() then
				originalIO.bodyModsDisconnectColorWatcher()
				return
			end
			local character = Players.LocalPlayer and Players.LocalPlayer.Character
			if not character then
				return
			end
			local skin = originalIO.bodyModsGetSkinColor()
			for _, part in ipairs(character:GetChildren()) do
				if part:IsA("BasePart") then
					if part.Name == "Boob" or part.Name == "Cheek" or part.Name == "Balls" or (part.Name == "penis" and part.Shape == Enum.PartType.Cylinder) then
						if part.Color ~= skin then
							part.Color = skin
						end
					elseif part.Name == "Nipple" or (part.Name == "penis" and part.Shape == Enum.PartType.Ball) then
						if part.Color ~= pinkColor then
							part.Color = pinkColor
						end
					elseif part.Name == "Areola" then
						if part.Color ~= ringColor then
							part.Color = ringColor
						end
					end
				end
			end
		end)
	end

	originalIO.bodyModsOnAppearanceLoaded = function()
		Defer(function()
			local character = Players.LocalPlayer and Players.LocalPlayer.Character
			if not character then
				return
			end
			local skin = originalIO.bodyModsGetSkinColor()
			for _, part in ipairs(character:GetChildren()) do
				if part:IsA("BasePart") then
					if part.Name == "Boob" or part.Name == "Cheek" or part.Name == "Balls" or (part.Name == "penis" and part.Shape == Enum.PartType.Cylinder) then
						part.Color = skin
					end
				end
			end
		end)
	end

	originalIO.bodyModsAppear = function(parts, scale, time)
		local tweenInfo = TweenInfo.new(time or 0.25, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
		for _, part in ipairs(parts) do
			if part and part:IsA("BasePart") then
				local target = part.Size
				part.Transparency = 1
				part.Size = target * (scale or 0.2)
				TweenService:Create(part, tweenInfo, { Transparency = 0, Size = target }):Play()
			end
		end
	end

	originalIO.bodyModsApplyBoobs = function(size)
		local character = originalIO.bodyModsGetCharacter(true)
		local humanoid = originalIO.bodyModsGetHumanoid(true)
		if not character or not humanoid then
			return
		end
		local torso = originalIO.bodyModsGetTorso(true)
		if not torso then
			return
		end

		for _, part in ipairs(character:GetChildren()) do
			if part:IsA("BasePart") and (part.Name == "Boob" or part.Name == "Nipple" or part.Name == "Areola") then
				part:Destroy()
			end
		end

		local skin = originalIO.bodyModsGetSkinColor()
		local baseSize = Vector3.new(1.2, 1.2, 1.2)
		local baseNipple = Vector3.new(0.32, 0.32, 0.32)
		local boobSize = baseSize * size
		local nippleSize = baseNipple * size
		local areolaSize = nippleSize * 2
		local popForward = 0.02
		local backGap = math.max(0.03, nippleSize.Z * 0.45)
		local nudge = 0.02
		local radius = boobSize.Z * 0.5
		local torsoFront = torso.Size.Z * 0.5
		state.boobs.oz = torsoFront + math.max(0.12, radius * 0.75) - 0.06

		local function offsetToFront(sphereSize, attachSize)
			local sphereRadius = (sphereSize and sphereSize.Z or baseSize.Z) * 0.5
			local attachRadius = (attachSize and attachSize.Z or baseNipple.Z) * 0.5
			local offset = sphereRadius - (attachRadius * 0.5) - 0.005
			if offset < 0 then
				offset = 0
			end
			return offset
		end

		local function createHalf(side)
			local boob = InstanceNew("Part")
			boob.Shape = Enum.PartType.Ball
			boob.Size = boobSize
			boob.Color = skin
			boob.Material = Enum.Material.SmoothPlastic
			boob.Anchored = false
			boob.CanCollide = false
			boob.CanTouch = false
			boob.CanQuery = false
			boob.Name = "Boob"
			boob.Parent = character

			local nipple = InstanceNew("Part")
			nipple.Shape = Enum.PartType.Ball
			nipple.Size = nippleSize
			nipple.Color = pinkColor
			nipple.Material = Enum.Material.SmoothPlastic
			nipple.Anchored = false
			nipple.CanCollide = false
			nipple.CanTouch = false
			nipple.CanQuery = false
			nipple.Name = "Nipple"
			nipple.Parent = boob

			local areola = InstanceNew("Part")
			areola.Shape = Enum.PartType.Ball
			areola.Size = areolaSize
			areola.Color = ringColor
			areola.Material = Enum.Material.SmoothPlastic
			areola.Anchored = false
			areola.CanCollide = false
			areola.CanTouch = false
			areola.CanQuery = false
			areola.Name = "Areola"
			areola.Parent = boob

			local nippleWeld = InstanceNew("Weld")
			nippleWeld.Part0 = nipple
			nippleWeld.Part1 = boob
			nippleWeld.C0 = CFrame.new(0, 0, offsetToFront(boob.Size, nipple.Size) + popForward)
			nippleWeld.Parent = nipple

			local areolaWeld = InstanceNew("Weld")
			areolaWeld.Part0 = areola
			areolaWeld.Part1 = boob
			areolaWeld.C0 = CFrame.new(0, 0, offsetToFront(boob.Size, areola.Size) - (backGap - nudge))
			areolaWeld.Parent = areola

			local weld = InstanceNew("Weld")
			weld.Part0 = boob
			weld.Part1 = torso
			weld.C0 = CFrame.new(side * state.boobs.ox, state.boobs.oy, state.boobs.oz)
			weld.Parent = boob

			return boob, nipple, areola, weld, nippleWeld, areolaWeld
		end

		local left, leftNipple, leftAreola, leftWeld, leftNippleWeld, leftAreolaWeld = createHalf(-1)
		local right, rightNipple, rightAreola, rightWeld, rightNippleWeld, rightAreolaWeld = createHalf(1)

		state.boobs.size = size
		state.boobs.active = true
		state.boobs.conn = originalIO.bodyModsDisconnectConnection(state.boobs.conn)
		state.boobs.sy = state.boobs.sy or 0
		state.boobs.vy = state.boobs.vy or 0
		state.boobs.sz = state.boobs.sz or 0
		state.boobs.vz = state.boobs.vz or 0
		state.boobs.sx = state.boobs.sx or 0
		state.boobs.vx = state.boobs.vx or 0
		state.boobs.rx = state.boobs.rx or 0
		state.boobs.vrx = state.boobs.vrx or 0
		state.boobs.ry = state.boobs.ry or 0
		state.boobs.rv = state.boobs.rv or 0
		state.boobs.yw = state.boobs.yw or 0
		state.boobs.vyw = state.boobs.vyw or 0
		state.boobs.llv = state.boobs.llv or Vector3.zero
		state.boobs.ccf = nil
		state.boobs.hcf = nil

		state.boobs.conn = RunService.RenderStepped:Connect(function(dt)
			local currentChar = originalIO.bodyModsGetCharacter()
			if not currentChar or not currentChar.Parent then
				return
			end
			local hrp = currentChar:FindFirstChild("HumanoidRootPart")
			if not hrp then
				return
			end
			local camera = workspace.CurrentCamera
			local velocity = hrp.AssemblyLinearVelocity or hrp.Velocity
			local localVel = hrp.CFrame:VectorToObjectSpace(velocity)
			local angular = hrp.AssemblyAngularVelocity or Vector3.zero
			local localAng = hrp.CFrame:VectorToObjectSpace(angular)
			local camAng = Vector3.zero
			if camera and state.boobs.ccf then
				local rel = state.boobs.ccf:ToObjectSpace(camera.CFrame)
				local x, y, z = rel:ToEulerAnglesXYZ()
				camAng = Vector3.new(x, y, z) / math.max(dt, 1/240)
			end
			state.boobs.ccf = camera and camera.CFrame or nil
			local useCam = (Players.LocalPlayer and Players.LocalPlayer.CameraMode == Enum.CameraMode.LockFirstPerson) or (UserInputService.MouseBehavior == Enum.MouseBehavior.LockCenter)
			local angInput = useCam and camAng or localAng
			local accel = (localVel - state.boobs.llv) / math.max(dt, 1/240)
			state.boobs.llv = localVel
			local speed = localVel.Magnitude
			local sizeScale = math.clamp((state.boobs.size or 1) / 3, 0.4, 2.4)
			local softness = math.clamp(speed / 26, 0, 1)

			local targetY = math.clamp(((-localVel.Y * 0.016) - accel.Y * 0.0065) * (0.7 + sizeScale * 0.5), -0.14, 0.14)
			local targetZ = math.clamp(((-localVel.Z * 0.022) - accel.Z * 0.0065) * (0.7 + sizeScale * 0.6), -0.16, 0.16)
			local targetX = math.clamp((-localVel.X * 0.018) * (0.7 + sizeScale * 0.5), -0.14, 0.14)

			local targetPitch = math.clamp(((-localVel.Y * 0.016) - accel.Y * 0.006) * (0.4 + sizeScale * 0.4) + angInput.X * 0.65, -0.45, 0.45)
			local targetRoll = math.clamp((-localVel.X * 0.065) * (0.5 + sizeScale * 0.3) + (-angInput.Y * 0.75), -0.46, 0.46)
			local targetYaw = math.clamp((localVel.X * 0.065) * (0.5 + sizeScale * 0.3) + (angInput.Z * 0.75), -0.46, 0.46)

			local kBase = 80
			local dBase = 4.2
			local kTrans = kBase - 18 * softness
			local dTrans = dBase - 1.2 * softness
			local kRot = kBase - 20 * softness
			local dRot = 4.0 - 1.1 * softness

			kTrans = kTrans / math.max(sizeScale, 0.5)
			kRot = kRot / math.max(sizeScale * 0.9, 0.5)

			state.boobs.sy, state.boobs.vy = originalIO.bodyModsSpring(state.boobs.sy, state.boobs.vy, targetY, kTrans, dTrans, dt)
			state.boobs.sz, state.boobs.vz = originalIO.bodyModsSpring(state.boobs.sz, state.boobs.vz, targetZ, kTrans, dTrans, dt)
			state.boobs.sx, state.boobs.vx = originalIO.bodyModsSpring(state.boobs.sx, state.boobs.vx, targetX, kTrans, dTrans, dt)
			state.boobs.rx, state.boobs.vrx = originalIO.bodyModsSpring(state.boobs.rx, state.boobs.vrx, targetPitch, kRot, dRot, dt)
			state.boobs.ry, state.boobs.rv = originalIO.bodyModsSpring(state.boobs.ry, state.boobs.rv, targetRoll, kRot, dRot, dt)
			state.boobs.yw, state.boobs.vyw = originalIO.bodyModsSpring(state.boobs.yw, state.boobs.vyw, targetYaw, kRot, dRot, dt)

			state.boobs.sy = math.clamp(state.boobs.sy, -0.50, 0.50)
			state.boobs.sz = math.clamp(state.boobs.sz, -0.42, 0.42)
			state.boobs.sx = math.clamp(state.boobs.sx, -0.42, 0.42)
			state.boobs.ry = math.clamp(state.boobs.ry, -0.5, 0.5)

			local sxCap = math.clamp(state.boobs.sx, -state.boobs.ox * 0.4, state.boobs.ox * 0.4)
			local forwardZ = state.boobs.oz + state.boobs.sz * 0.10
			local leftOffset = CFrame.new(-state.boobs.ox + (-sxCap), state.boobs.oy + state.boobs.sy, forwardZ) * CFrame.Angles(state.boobs.rx, state.boobs.yw, state.boobs.ry)
			local rightOffset = CFrame.new(state.boobs.ox + sxCap, state.boobs.oy + state.boobs.sy, forwardZ) * CFrame.Angles(state.boobs.rx, -state.boobs.yw, -state.boobs.ry)

			if leftWeld then leftWeld.C0 = leftOffset end
			if rightWeld then rightWeld.C0 = rightOffset end
			if leftNippleWeld and left then leftNippleWeld.C0 = CFrame.new(0, 0, offsetToFront(left.Size, leftNipple.Size) + popForward) end
			if rightNippleWeld and right then rightNippleWeld.C0 = CFrame.new(0, 0, offsetToFront(right.Size, rightNipple.Size) + popForward) end
			if leftAreolaWeld and left then leftAreolaWeld.C0 = CFrame.new(0, 0, offsetToFront(left.Size, leftAreola.Size) - (backGap - nudge)) end
			if rightAreolaWeld and right then rightAreolaWeld.C0 = CFrame.new(0, 0, offsetToFront(right.Size, rightAreola.Size) - (backGap - nudge)) end
		end)

		originalIO.bodyModsEnsureColorWatcher()
		originalIO.bodyModsConnectAppearanceLoaded(Players.LocalPlayer, function()
			Defer(function()
				local refreshed = originalIO.bodyModsGetSkinColor()
				for _, part in ipairs({ left, right }) do
					if part and part.Parent then
						part.Color = refreshed
					end
				end
			end)
		end)

		originalIO.bodyModsEnsureSpawnConnection()
		DebugNotif("Boobs "..tostring(size),1.5)
	end

	originalIO.bodyModsRemoveBoobs = function()
		local character = originalIO.bodyModsGetCharacter()
		if not character then
			return
		end

		state.boobs.conn = originalIO.bodyModsDisconnectConnection(state.boobs.conn)
		state.boobs.active = false

		local toRemove = {}
		for _, part in ipairs(character:GetChildren()) do
			if part:IsA("BasePart") and (part.Name == "Boob" or part.Name == "Nipple" or part.Name == "Areola") then
				Insert(toRemove, part)
			end
		end
		for _, part in ipairs(toRemove) do
			part.CanCollide = false
			part.CanTouch = false
			part.CanQuery = false
			TweenService:Create(part, TweenInfo.new(0.28, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), { Transparency = 1 }):Play()
		end
		Delay(0.30, function()
			for _, part in ipairs(toRemove) do
				if part and part.Parent then
					part:Destroy()
				end
			end
		end)

		originalIO.bodyModsEnsureColorWatcher()
		DebugNotif("Boobs Removed",1.5)
	end

	originalIO.bodyModsApplyAss = function(size)
		local character = originalIO.bodyModsGetCharacter(true)
		local humanoid = originalIO.bodyModsGetHumanoid(true)
		if not character or not humanoid then
			return
		end
		local torso = originalIO.bodyModsGetTorso(false)
		if not torso then
			return
		end

		for _, part in ipairs(character:GetChildren()) do
			if part:IsA("BasePart") and part.Name == "Cheek" then
				part:Destroy()
			end
		end

		local skin = originalIO.bodyModsGetSkinColor()
		local baseSize = Vector3.new(1.1, 1.1, 1.1)
		local cheekSize = baseSize * size
		local radius = cheekSize.Y * 0.5

		state.ass.oy = (humanoid.RigType == Enum.HumanoidRigType.R15) and (-(torso.Size.Y * 0.35)) or 0.75
		state.ass.oz = -(torso.Size.Z * 0.5 + radius * 0.45)

		local function createCheek(side)
			local cheek = InstanceNew("Part")
			cheek.Shape = Enum.PartType.Ball
			cheek.Size = cheekSize
			cheek.Color = skin
			cheek.Material = Enum.Material.SmoothPlastic
			cheek.Anchored = false
			cheek.CanCollide = false
			cheek.CanTouch = false
			cheek.CanQuery = false
			cheek.Name = "Cheek"
			cheek.Parent = character

			local weld = InstanceNew("Weld")
			weld.Part0 = cheek
			weld.Part1 = torso
			weld.C0 = CFrame.new(side * state.ass.ox, state.ass.oy, state.ass.oz)
			weld.Parent = cheek

			return cheek, weld
		end

		local left, leftWeld = createCheek(-1)
		local right, rightWeld = createCheek(1)

		state.ass.size = size
		state.ass.active = true
		state.ass.conn = originalIO.bodyModsDisconnectConnection(state.ass.conn)
		state.ass.sy = state.ass.sy or 0
		state.ass.vy = state.ass.vy or 0
		state.ass.sz = state.ass.sz or 0
		state.ass.vz = state.ass.vz or 0
		state.ass.sx = state.ass.sx or 0
		state.ass.vx = state.ass.vx or 0
		state.ass.rx = state.ass.rx or 0
		state.ass.vrx = state.ass.vrx or 0
		state.ass.ry = state.ass.ry or 0
		state.ass.rv = state.ass.rv or 0
		state.ass.yw = state.ass.yw or 0
		state.ass.vyw = state.ass.vyw or 0
		state.ass.llv = state.ass.llv or Vector3.zero
		state.ass.hcf = nil

		state.ass.conn = RunService.RenderStepped:Connect(function(dt)
			local currentChar = originalIO.bodyModsGetCharacter()
			if not currentChar or not currentChar.Parent then
				return
			end
			local hrp = currentChar:FindFirstChild("HumanoidRootPart")
			if not hrp then
				return
			end
			local velocity = hrp.AssemblyLinearVelocity or hrp.Velocity
			local localVel = hrp.CFrame:VectorToObjectSpace(velocity)
			local angular = hrp.AssemblyAngularVelocity or Vector3.zero
			local localAng = hrp.CFrame:VectorToObjectSpace(angular)
			local accel = (localVel - state.ass.llv) / math.max(dt, 1/240)
			state.ass.llv = localVel
			local speed = localVel.Magnitude
			local sizeScale = math.clamp((state.ass.size or 1) / 3, 0.4, 2.5)
			local softness = math.clamp(speed / 24, 0, 1)

			local targetY = math.clamp((-localVel.Y * 0.055 - accel.Y * 0.010) * (0.7 + sizeScale * 0.5), -0.28, 0.28)
			local targetZ = math.clamp((localVel.Z * 0.048 + accel.Z * 0.008) * (0.7 + sizeScale * 0.6), -0.24, 0.24)
			local targetX = math.clamp((localVel.X * 0.052) * (0.7 + sizeScale * 0.5), -0.24, 0.24)

			local targetPitch = math.clamp(localAng.X * 0.80 * (0.6 + sizeScale * 0.4), -0.55, 0.55)
			local targetRoll = math.clamp(-localAng.Y * 0.80 * (0.6 + sizeScale * 0.4), -0.55, 0.55)
			local targetYaw = math.clamp(-localAng.Z * 0.70 * (0.6 + sizeScale * 0.4), -0.48, 0.48)

			local kTransBase, dTransBase = 52, 2.6
			local kRotBase, dRotBase = 48, 2.4
			local kTrans = kTransBase - 14 * softness
			local dTrans = dTransBase - 0.7 * softness
			local kRot = kRotBase - 12 * softness
			local dRot = dRotBase - 0.6 * softness

			kTrans = kTrans / math.max(sizeScale * 0.85, 0.5)
			kRot = kRot / math.max(sizeScale, 0.5)

			state.ass.sy, state.ass.vy = originalIO.bodyModsSpring(state.ass.sy, state.ass.vy, targetY, kTrans, dTrans, dt)
			state.ass.sz, state.ass.vz = originalIO.bodyModsSpring(state.ass.sz, state.ass.vz, targetZ, kTrans, dTrans, dt)
			state.ass.sx, state.ass.vx = originalIO.bodyModsSpring(state.ass.sx, state.ass.vx, targetX, kTrans, dTrans, dt)
			state.ass.rx, state.ass.vrx = originalIO.bodyModsSpring(state.ass.rx, state.ass.vrx, targetPitch, kRot, dRot, dt)
			state.ass.ry, state.ass.rv = originalIO.bodyModsSpring(state.ass.ry, state.ass.rv, targetRoll, kRot, dRot, dt)
			state.ass.yw, state.ass.vyw = originalIO.bodyModsSpring(state.ass.yw, state.ass.vyw, targetYaw, kRot, dRot, dt)

			state.ass.sy = math.clamp(state.ass.sy, -0.32, 0.32)
			state.ass.sz = math.clamp(state.ass.sz, -0.24, 0.24)
			state.ass.sx = math.clamp(state.ass.sx, -0.26, 0.26)

			local sxCap = math.clamp(state.ass.sx, -state.ass.ox * 0.55, state.ass.ox * 0.55)
			local tzCap = math.clamp(state.ass.sz, -0.18, 0.18)
			local leftOffset = CFrame.new(-state.ass.ox + (-sxCap), state.ass.oy + state.ass.sy, state.ass.oz + tzCap) * CFrame.Angles(state.ass.rx, state.ass.yw, state.ass.ry)
			local rightOffset = CFrame.new(state.ass.ox + sxCap, state.ass.oy + state.ass.sy, state.ass.oz + tzCap) * CFrame.Angles(state.ass.rx, -state.ass.yw, -state.ass.ry)

			if leftWeld then leftWeld.C0 = leftOffset end
			if rightWeld then rightWeld.C0 = rightOffset end
		end)

		originalIO.bodyModsEnsureColorWatcher()
		originalIO.bodyModsConnectAppearanceLoaded(Players.LocalPlayer, originalIO.bodyModsOnAppearanceLoaded)
		originalIO.bodyModsEnsureSpawnConnection()
		DebugNotif("Ass "..tostring(size),1.5)
	end

	originalIO.bodyModsRemoveAss = function()
		local character = originalIO.bodyModsGetCharacter()
		if not character then
			return
		end

		state.ass.conn = originalIO.bodyModsDisconnectConnection(state.ass.conn)
		state.ass.active = false

		local toRemove = {}
		for _, part in ipairs(character:GetChildren()) do
			if part:IsA("BasePart") and part.Name == "Cheek" then
				Insert(toRemove, part)
			end
		end
		for _, part in ipairs(toRemove) do
			part.CanCollide = false
			part.CanTouch = false
			part.CanQuery = false
			TweenService:Create(part, TweenInfo.new(0.28, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), { Transparency = 1 }):Play()
		end
		Delay(0.30, function()
			for _, part in ipairs(toRemove) do
				if part and part.Parent then
					part:Destroy()
				end
			end
		end)

		originalIO.bodyModsEnsureColorWatcher()
		DebugNotif("Ass Removed",1.5)
	end

	originalIO.bodyModsApplyPP = function(length)
		local character = originalIO.bodyModsGetCharacter(true)
		local humanoid = originalIO.bodyModsGetHumanoid(true)
		if not character or not humanoid then
			return
		end
		local torso = originalIO.bodyModsGetTorso(false)
		if not torso then
			return
		end

		for _, part in ipairs(character:GetChildren()) do
			if part:IsA("BasePart") and (part.Name == "Balls" or part.Name == "penis") then
				part:Destroy()
			end
		end

		local value = tonumber(length) or state.pp.len or 1
		value = math.clamp(value, 0.5, 6)
		state.pp.len = value

		local skin = originalIO.bodyModsGetSkinColor()
		local shaftBaseLength = 2.0
		local shaftLength = shaftBaseLength * value

		local function createPart(shape, size, color, name)
			local part = InstanceNew("Part")
			part.Shape = shape
			part.Size = size
			part.Color = color
			part.Material = Enum.Material.SmoothPlastic
			part.Anchored = false
			part.CanCollide = false
			part.CanTouch = false
			part.CanQuery = false
			part.Name = name
			part.Parent = character
			return part
		end

		local function weldConstraint(part0, part1)
			local weld = InstanceNew("WeldConstraint")
			weld.Part0 = part0
			weld.Part1 = part1
			weld.Parent = part0
		end

		local offsetY = (humanoid.RigType == Enum.HumanoidRigType.R15) and -1.0 or -1.5
		local leftBall = createPart(Enum.PartType.Ball, Vector3.new(1.2, 1.2, 1.2), skin, "Balls")
		local rightBall = createPart(Enum.PartType.Ball, Vector3.new(1.2, 1.2, 1.2), skin, "Balls")
		local shaft = createPart(Enum.PartType.Cylinder, Vector3.new(shaftLength, 0.70, 0.70), skin, "penis")
		local tip = createPart(Enum.PartType.Ball, Vector3.new(0.70, 0.70, 0.70), pinkColor, "penis")

		leftBall.CFrame = torso.CFrame * CFrame.new(-0.25, offsetY, -0.80)
		rightBall.CFrame = torso.CFrame * CFrame.new(0.25, offsetY, -0.80)
		local forwardShift = (shaftLength - shaftBaseLength) * 0.5
		shaft.CFrame = torso.CFrame * CFrame.new(0.00, offsetY + 0.70, -1.35) * CFrame.Angles(0, math.rad(270), 0) * CFrame.new(-forwardShift, 0, 0)
		tip.CFrame = shaft.CFrame * CFrame.new(-shaftLength * 0.5, 0, 0)

		weldConstraint(leftBall, torso)
		weldConstraint(rightBall, torso)
		weldConstraint(tip, shaft)

		local shaftWeld = InstanceNew("Weld")
		shaftWeld.Part0 = torso
		shaftWeld.Part1 = shaft
		shaftWeld.C0 = torso.CFrame:ToObjectSpace(shaft.CFrame)
		shaftWeld.C1 = CFrame.new()
		shaftWeld.Parent = shaft

		state.pp.active = true
		state.pp.sh = shaft
		state.pp.dr = tip
		state.pp.wS = shaftWeld
		state.pp.sy = 0
		state.pp.vy = 0
		state.pp.sz = 0
		state.pp.vz = 0
		state.pp.sx = 0
		state.pp.vx = 0
		state.pp.rx = 0
		state.pp.vrx = 0
		state.pp.ry = 0
		state.pp.vry = 0
		state.pp.baseC0 = shaftWeld.C0

		state.pp.animConn = originalIO.bodyModsDisconnectConnection(state.pp.animConn)
		state.pp.animConn = RunService.RenderStepped:Connect(function(dt)
			local currentChar = originalIO.bodyModsGetCharacter()
			if not currentChar or not currentChar.Parent then
				return
			end
			local hrp = currentChar:FindFirstChild("HumanoidRootPart")
			if not hrp or not state.pp.wS or not state.pp.baseC0 then
				return
			end

			local velocity = hrp.AssemblyLinearVelocity or hrp.Velocity
			local localVel = hrp.CFrame:VectorToObjectSpace(velocity)
			local angular = hrp.AssemblyAngularVelocity or Vector3.zero
			local localAng = hrp.CFrame:VectorToObjectSpace(angular)
			local speed = localVel.Magnitude

			local targetY = math.clamp((-localVel.Y * 0.020) - (localAng.X * 0.010), -0.20, 0.20)
			local targetZ = math.clamp(-localVel.Z * (0.028 + 0.002 * value), -0.30, 0.30)
			local targetX = math.clamp(-localVel.X * 0.020, -0.20, 0.20)
			local targetPitch = math.clamp(localAng.Z * 0.030, -0.25, 0.25)
			local targetRoll = math.clamp(localAng.X * 0.030, -0.25, 0.25)

			local softness = math.clamp(speed / 28, 0, 1)
			local kTrans = 54 - 16 * softness + value * 3
			local dTrans = 3.2 - 0.8 * softness
			local kRot = 42 - 10 * softness + value * 2
			local dRot = 2.3 - 0.5 * softness

			state.pp.sy, state.pp.vy = originalIO.bodyModsSpring(state.pp.sy, state.pp.vy, targetY, kTrans, dTrans, dt)
			state.pp.sz, state.pp.vz = originalIO.bodyModsSpring(state.pp.sz, state.pp.vz, targetZ, kTrans, dTrans, dt)
			state.pp.sx, state.pp.vx = originalIO.bodyModsSpring(state.pp.sx, state.pp.vx, targetX, kTrans, dTrans, dt)
			state.pp.rx, state.pp.vrx = originalIO.bodyModsSpring(state.pp.rx, state.pp.vrx, targetPitch, kRot, dRot, dt)
			state.pp.ry, state.pp.vry = originalIO.bodyModsSpring(state.pp.ry, state.pp.vry, targetRoll, kRot, dRot, dt)

			state.pp.sy = math.clamp(state.pp.sy, -0.22, 0.22)
			state.pp.sz = math.clamp(state.pp.sz, -0.30, 0.30)
			state.pp.sx = math.clamp(state.pp.sx, -0.22, 0.22)
			state.pp.rx = math.clamp(state.pp.rx, -0.26, 0.26)
			state.pp.ry = math.clamp(state.pp.ry, -0.26, 0.26)

			local sway = CFrame.new(state.pp.sx, state.pp.sy, state.pp.sz) * CFrame.Angles(state.pp.rx, 0, state.pp.ry)
			state.pp.wS.C0 = state.pp.baseC0 * sway
		end)

		originalIO.bodyModsEnsureColorWatcher()
		originalIO.bodyModsConnectAppearanceLoaded(Players.LocalPlayer, originalIO.bodyModsOnAppearanceLoaded)
		originalIO.bodyModsEnsureSpawnConnection()
		DebugNotif("penis "..tostring(value),1.5)
	end

	originalIO.bodyModsRemovePP = function()
		local character = originalIO.bodyModsGetCharacter()
		if not character then
			return
		end

		local toRemove = {}
		for _, part in ipairs(character:GetChildren()) do
			if part:IsA("BasePart") and (part.Name == "Balls" or part.Name == "penis") then
				Insert(toRemove, part)
			end
		end
		for _, part in ipairs(toRemove) do
			part.CanCollide = false
			part.CanTouch = false
			part.CanQuery = false
			TweenService:Create(part, TweenInfo.new(0.25, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), { Transparency = 1 }):Play()
		end
		Delay(0.27, function()
			for _, part in ipairs(toRemove) do
				if part and part.Parent then
					part:Destroy()
				end
			end
		end)

		state.pp.animConn = originalIO.bodyModsDisconnectConnection(state.pp.animConn)
		state.pp.active = false
		state.pp.wS = nil
		state.pp.wTip = nil
		state.pp.sh = nil
		state.pp.dr = nil
		state.pp.baseC0 = nil
		state.pp.sy = 0
		state.pp.sz = 0
		state.pp.sx = 0
		state.pp.rx = 0
		state.pp.ry = 0

		originalIO.bodyModsEnsureColorWatcher()
		DebugNotif("PP Removed",1.5)
	end

	originalIO.bodyModsReapplyOnSpawn = function(newCharacter)
		Spawn(function()
			local humanoid = newCharacter:WaitForChild("Humanoid", 10)
			if state.boobs.active then
				Spawn(function()
					if originalIO.bodyModsWaitFor({ "UpperTorso", "Torso" }, 10) then
						originalIO.bodyModsApplyBoobs(state.boobs.size or 1)
					end
				end)
			end
			if state.ass.active then
				Spawn(function()
					if humanoid and humanoid.RigType == Enum.HumanoidRigType.R15 then
						if originalIO.bodyModsWaitFor({ "LowerTorso" }, 10) then
							originalIO.bodyModsApplyAss(state.ass.size or 1)
						end
					else
						if originalIO.bodyModsWaitFor({ "Torso" }, 10) then
							originalIO.bodyModsApplyAss(state.ass.size or 1)
						end
					end
				end)
			end
			if state.pp.active then
				Spawn(function()
					if humanoid and humanoid.RigType == Enum.HumanoidRigType.R15 then
						if originalIO.bodyModsWaitFor({ "LowerTorso" }, 10) then
							originalIO.bodyModsApplyPP(state.pp.len or 1)
						end
					else
						if originalIO.bodyModsWaitFor({ "Torso" }, 10) then
							originalIO.bodyModsApplyPP(state.pp.len or 1)
						end
					end
				end)
			end
		end)
	end

	originalIO.bodyModsEnsureSpawnConnection = function()
		if state.spawnConn and state.spawnConn.Connected then
			return
		end
		state.spawnConn = Players.LocalPlayer.CharacterAdded:Connect(originalIO.bodyModsReapplyOnSpawn)
	end

	originalIO.bodyModsEnsurePlayerAppearanceHook = function()
		state.apConn = originalIO.bodyModsDisconnectConnection(state.apConn)
		state.apConn = originalIO.bodyModsConnectAppearanceLoaded(Players.LocalPlayer, originalIO.bodyModsOnAppearanceLoaded)
	end

	originalIO.bodyModsEnsurePlayerAppearanceHook()
	originalIO.bodyModsEnsureSpawnConnection()

	cmd.add({"boobs","boobies"},{"boobs <size> (boobies)","Boobs"},function(arg)
		local value = tonumber(arg) or state.boobs.size or 1
		value = math.clamp(value, 1, 8)
		originalIO.bodyModsApplyBoobs(value)
	end,true)

	cmd.add({"unboobs","unboobies","noboobs","noboobies"},{"unboobs (unboobies,noboobs,noboobies)","Boobs"},function()
		originalIO.bodyModsRemoveBoobs()
	end)

	cmd.add({"ass","booty"},{"ass <size> (booty)","Ass"},function(arg)
		local value = tonumber(arg) or state.ass.size or 1
		value = math.clamp(value, 1, 8)
		originalIO.bodyModsApplyAss(value)
	end,true)

	cmd.add({"unass","noass"},{"unass (noass)","Ass"},function()
		originalIO.bodyModsRemoveAss()
	end)

	cmd.add({"penis","pp"},{"penis <length> (pp)","penis"},function(arg)
		local value = tonumber(arg) or state.pp.len or 1
		value = math.clamp(value, 0.5, 6)
		originalIO.bodyModsApplyPP(value)
	end,true)

	cmd.add({"unpenis","unpp","nopenis","nopp"},{"unpenis (unpp,nopenis,nopp)","penis"},function()
		originalIO.bodyModsRemovePP()
	end)
end

-- [[ NPC SECTION ]] --
cmd.add({"flingnpcs"}, {"flingnpcs", "Flings NPCs"}, function()
	local npcs = {}

	local function disappear(hum)
		if hum:IsA("Humanoid") and CheckIfNPC(hum.Parent) then
			Insert(npcs,{hum,hum.HipHeight})
			hum.HipHeight = 1024
		end
	end
	for _,hum in pairs(workspace:GetDescendants()) do
		disappear(hum)
	end
end)

cmd.add({"npcfollow"}, {"npcfollow", "Makes NPCS follow you"}, function()
	local npcs = {}

	local function disappear(hum)
		if hum:IsA("Humanoid") and CheckIfNPC(hum.Parent) then
			Insert(npcs,{hum,hum.HipHeight})
			local rootPart = getRoot(hum.Parent)
			local targetPos = getRoot(LocalPlayer.Character).Position
			hum:MoveTo(targetPos)
		end
	end
	for _,hum in pairs(workspace:GetDescendants()) do
		disappear(hum)
	end
end)

npcfollowloop = false
cmd.add({"loopnpcfollow"}, {"loopnpcfollow", "Makes NPCS follow you in a loop"}, function()
	npcfollowloop = true

	repeat Wait(0.1)
		local npcs = {}

		local function disappear(hum)
			if hum:IsA("Humanoid") and CheckIfNPC(hum.Parent) then
				Insert(npcs,{hum,hum.HipHeight})
				local rootPart = getRoot(hum.Parent)
				local targetPos = getRoot(LocalPlayer.Character).Position
				hum:MoveTo(targetPos)
			end
		end
		for _,hum in pairs(workspace:GetDescendants()) do
			disappear(hum)
		end
	until npcfollowloop == false
end)

cmd.add({"unloopnpcfollow"}, {"unloopnpcfollow", "Makes NPCS not follow you in a loop"}, function()
	npcfollowloop = false
end)

cmd.add({"sitnpcs"}, {"sitnpcs", "Makes NPCS sit"}, function()
	local npcs = {}

	local function disappear(hum)
		if hum:IsA("Humanoid") and CheckIfNPC(hum.Parent) then
			Insert(npcs,{hum,hum.HipHeight})
			local rootPart = getRoot(hum.Parent)
			if rootPart then
				hum.Sit = true
			end
		end
	end
	for _,hum in pairs(workspace:GetDescendants()) do
		disappear(hum)
	end
end)

cmd.add({"unsitnpcs"}, {"unsitnpcs", "Makes NPCS unsit"}, function()
	local npcs = {}

	local function disappear(hum)
		if hum:IsA("Humanoid") and CheckIfNPC(hum.Parent) then
			Insert(npcs,{hum,hum.HipHeight})
			local rootPart = getRoot(hum.Parent)
			if rootPart then
				hum.Sit = true
			end
		end
	end
	for _,hum in pairs(workspace:GetDescendants()) do
		disappear(hum)
	end
end)

cmd.add({"killnpcs"}, {"killnpcs", "Kills NPCs"}, function()
	local npcs = {}

	local function disappear(hum)
		if hum:IsA("Humanoid") and CheckIfNPC(hum.Parent) then
			Insert(npcs,{hum,hum.HipHeight})
			local rootPart = getRoot(hum.Parent)
			if rootPart then
				hum.Health = 0
			end
		end
	end
	for _,hum in pairs(workspace:GetDescendants()) do
		disappear(hum)
	end
end)

cmd.add({"npcwalkspeed","npcws"},{"npcwalkspeed <speed>","Sets all NPC WalkSpeed to <speed> (default 16)"},function(speedStr)
	local speed = tonumber(speedStr) or 16
	for _, hum in pairs(workspace:GetDescendants()) do
		if hum:IsA("Humanoid") and CheckIfNPC(hum.Parent) then
			local root = getRoot(hum.Parent)
			if root then hum.WalkSpeed = speed end
		end
	end
end,true)

cmd.add({"npcjumppower","npcjp"},{"npcjumppower <power>","Sets all NPC JumpPower to <power> (default 50)"},function(powerStr)
	local power=tonumber(powerStr) or 50
	for _,hum in pairs(workspace:GetDescendants()) do
		if hum:IsA("Humanoid") and CheckIfNPC(hum.Parent) then
			local root=getRoot(hum.Parent)
			if root then hum.JumpPower=power end
		end
	end
end,true)

cmd.add({"bringnpcs"}, {"bringnpcs", "Brings NPCs"}, function()
	local npcs = {}

	local function disappear(hum)
		if hum:IsA("Humanoid") and CheckIfNPC(hum.Parent) then
			Insert(npcs,{hum,hum.HipHeight})
			local rootPart = getRoot(hum.Parent)
			if rootPart then
				rootPart.CFrame = getRoot(LocalPlayer.Character).CFrame
			end
		end
	end
	for _,hum in pairs(workspace:GetDescendants()) do
		disappear(hum)
	end
end)

npcCache = {}
cmd.add({"loopbringnpcs", "lbnpcs"}, {"loopbringnpcs (lbnpcs)", "Loops NPC bringing"}, function()
	if NAlib.isConnected("loopbringnpcs") then NAlib.disconnect("loopbringnpcs") end
	table.clear(npcCache)
	for _, hum in ipairs(workspace:GetDescendants()) do
		if hum:IsA("Humanoid") and CheckIfNPC(hum.Parent) then
			Insert(npcCache, hum)
		end
	end

	NAlib.connect("loopbringnpcs", RunService.Stepped:Connect(function()
		for _, hum in ipairs(npcCache) do
			if hum.Parent and hum.Health > 0 then
				local model = hum.Parent
				local rootPart = getRoot(model)
				local localRoot = LocalPlayer.Character and getRoot(LocalPlayer.Character)
				if rootPart and localRoot then
					rootPart.CFrame = localRoot.CFrame
				end
				SpawnCall(function()
					for _, part in ipairs(model:GetDescendants()) do
						if part:IsA("BasePart") then
							if NAlib.isProperty(part, "CanCollide") then
								NAlib.setProperty(part, "CanCollide", false)
							end
						end
					end
				end)
			end
		end
	end))
end)

cmd.add({"unloopbringnpcs", "unlbnpcs"}, {"unloopbringnpcs (unlbnpcs)", "Stops NPC bring loop"}, function()
	NAlib.disconnect("loopbringnpcs")
end)

cmd.add({"gotonpcs"}, {"gotonpcs", "Teleports to each NPC"}, function()
	local LocalPlayer = Players.LocalPlayer
	local npcs = {}
	for _, d in pairs(workspace:GetDescendants()) do
		if d:IsA("Humanoid") and CheckIfNPC(d.Parent) then
			local root = getRoot(d.Parent)
			if root then
				Insert(npcs, root)
			end
		end
	end
	SpawnCall(function()
		for _, npcRoot in ipairs(npcs) do
			local char = LocalPlayer.Character
			if char and getRoot(char) then
				getRoot(char).CFrame = npcRoot.CFrame + Vector3.new(0, 3, 0)
			end
		end
	end)
end)

NAStuff.NPCControl = {
	Enabled = false,
	Connection = nil,
	CurrentTarget = nil,
	MoveCooldown = 0
}

NPCControl = NAStuff.NPCControl

cmd.add({"actnpc"}, {"actnpc", "Start acting like an NPC"}, function()
	if NPCControl.Enabled then return end
	NPCControl.Enabled = true

	local function moveToRandom()
		local char = LocalPlayer.Character
		local hum = getHum()
		local root = getRoot(char)
		if not (char and hum and root) then return end

		local randomOffset = Vector3.new(math.random(-30, 30), 0, math.random(-30, 30))
		local targetPos = root.Position + randomOffset

		NPCControl.CurrentTarget = targetPos
		hum:MoveTo(targetPos)

		DebugNotif("Moving to: "..Format("X: %.0f, Y: %.0f, Z: %.0f", targetPos.X, targetPos.Y, targetPos.Z), 1.5)
	end

	NPCControl.Connection = RunService.Heartbeat:Connect(function(dt)
		local char = LocalPlayer.Character
		local hum = getHum()
		local root = getRoot(char)
		if not (char and hum and root) then return end

		NPCControl.MoveCooldown=NPCControl.MoveCooldown - dt
		NPCControl._jumpCooldown = (NPCControl._jumpCooldown or 0) - dt
		NPCControl._moveTimeout = (NPCControl._moveTimeout or 0) + dt

		if hum.Sit then
			DebugNotif("Sitting detected — jumping to escape", 1.5)
			hum.Sit = false
			hum:ChangeState(Enum.HumanoidStateType.Jumping)
			NPCControl._jumpCooldown = 1.5
			return
		end

		if NPCControl.CurrentTarget and (root.Position - NPCControl.CurrentTarget).Magnitude < 2 then
			DebugNotif("Reached target", 1.5)
			NPCControl.CurrentTarget = nil
		end

		if not NPCControl.CurrentTarget or NPCControl._moveTimeout > 5 then
			if NPCControl._moveTimeout > 5 then
				DebugNotif("Stuck — retrying new path", 1.5)
			end
			if NPCControl.MoveCooldown <= 0 then
				moveToRandom()
				NPCControl.MoveCooldown = math.random(2, 4)
				NPCControl._moveTimeout = 0
			end
		end

		local forward = root.CFrame.LookVector
		local origin = root.Position + Vector3.new(0, 2, 0)
		local rayParams = RaycastParams.new()
		rayParams.FilterType = Enum.RaycastFilterType.Blacklist
		rayParams.FilterDescendantsInstances = {char}
		local result = workspace:Raycast(origin, forward * 3 + Vector3.new(0, -2, 0), rayParams)

		if result and NPCControl._jumpCooldown <= 0 then
			local part = result.Instance
			local model = part:FindFirstAncestorOfClass("Model")
			local isPlayerChar = model and Players:GetPlayerFromCharacter(model)

			if part.CanCollide and not isPlayerChar then
				if hum:GetState() == Enum.HumanoidStateType.Running then
					DebugNotif("Obstacle detected — jumping", 1.5)
					hum:ChangeState(Enum.HumanoidStateType.Jumping)
					NPCControl._jumpCooldown = 1.5
				end
			end
		end
	end)
end)

cmd.add({"unactnpc", "stopnpc"}, {"unactnpc (stopnpc)", "Stop acting like an NPC"}, function()
	if not NPCControl.Enabled then return end
	NPCControl.Enabled = false
	if NPCControl.Connection then
		NPCControl.Connection:Disconnect()
		NPCControl.Connection = nil
	end
end)

NAStuff.clickkillUI = nil
NAStuff.clickkillEnabled = false

cmd.add({"clickkillnpc", "cknpc"}, {"clickkillnpc (cknpc)", "Click on an NPC to kill it"}, function()
	NAStuff.clickkillEnabled = true

	if NAStuff.clickkillUI then NAStuff.clickkillUI:Destroy() end
	NAlib.disconnect("clickkill_mouse")

	local Mouse = player:GetMouse()

	NAStuff.clickkillUI = InstanceNew("ScreenGui")
	NaProtectUI(NAStuff.clickkillUI)

	local toggleButton = InstanceNew("TextButton")
	toggleButton.Size = UDim2.new(0, 120, 0, 40)
	toggleButton.Text = "ClickKill: ON"
	toggleButton.Position = UDim2.new(0.5, -60, 0, 10)
	toggleButton.TextScaled = 16
	toggleButton.TextColor3 = Color3.new(1, 1, 1)
	toggleButton.Font = Enum.Font.GothamBold
	toggleButton.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
	toggleButton.BackgroundTransparency = 0.2
	toggleButton.Parent = NAStuff.clickkillUI

	local uiCorner = InstanceNew("UICorner")
	uiCorner.CornerRadius = UDim.new(0, 8)
	uiCorner.Parent = toggleButton

	NAgui.draggerV2(toggleButton)

	MouseButtonFix(toggleButton, function()
		NAStuff.clickkillEnabled = not NAStuff.clickkillEnabled
		toggleButton.Text = NAStuff.clickkillEnabled and "ClickKill: ON" or "ClickKill: OFF"
	end)

	NAlib.connect("clickkill_mouse", Mouse.Button1Down:Connect(function()
		if not NAStuff.clickkillEnabled then return end

		local Target = Mouse.Target
		if Target and Target.Parent then
			local Character = Target.Parent
			if CheckIfNPC(Character) then
				local Humanoid = getPlrHum(Character)
				if Humanoid then
					Humanoid.Health = 0
				end
			end
		end
	end))
end)

cmd.add({"unclickkillnpc", "uncknpc"}, {"unclickkillnpc (uncknpc)", "Disable clickkillnpc"}, function()
	NAStuff.clickkillEnabled = false
	if NAStuff.clickkillUI then NAStuff.clickkillUI:Destroy() end
	NAlib.disconnect("clickkill_mouse")
end)

cmd.add({"voidnpcs", "vnpcs"}, {"voidnpcs (vnpcs)", "Teleports NPC's to void"}, function()
	for _, d in ipairs(workspace:GetDescendants()) do
		if d:IsA("Humanoid") and CheckIfNPC(d.Parent) then
			local root = getPlrHum(d.Parent)
			if root then
				root.HipHeight = math.huge
			end
		end
	end
end)

clickVoidUI = nil
clickVoidEnabled = false

cmd.add({"clickvoidnpc", "cvnpc"}, {"clickvoidnpc (cvnpc)", "Click to void NPCs"}, function()
	clickVoidEnabled = true

	if clickVoidUI then clickVoidUI:Destroy() end
	NAlib.disconnect("clickvoid_mouse")

	clickVoidUI = InstanceNew("ScreenGui")
	NaProtectUI(clickVoidUI)

	local button = InstanceNew("TextButton")
	button.Size = UDim2.new(0, 120, 0, 40)
	button.Text = "ClickVoid: ON"
	button.Position = UDim2.new(0.5, -60, 0, 10)
	button.TextScaled = true
	button.TextColor3 = Color3.new(1, 1, 1)
	button.Font = Enum.Font.GothamBold
	button.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
	button.BackgroundTransparency = 0.2
	button.Parent = clickVoidUI

	local corner = InstanceNew("UICorner", button)
	corner.CornerRadius = UDim.new(0, 8)
	NAgui.draggerV2(button)

	MouseButtonFix(button, function()
		clickVoidEnabled = not clickVoidEnabled
		button.Text = clickVoidEnabled and "ClickVoid: ON" or "ClickVoid: OFF"
	end)

	local mouse = player:GetMouse()
	NAlib.connect("clickvoid_mouse", mouse.Button1Down:Connect(function()
		if not clickVoidEnabled then return end

		local target = mouse.Target
		if target and target.Parent and CheckIfNPC(target.Parent) then
			local root = getPlrHum(target.Parent)
			if root then
				root.HipHeight = math.huge
			end
		end
	end))
end)

cmd.add({"unclickvoidnpc", "uncvnpc"}, {"unclickvoidnpc (uncvnpc)","Disable click-void"}, function()
	clickVoidEnabled = false
	if clickVoidUI then clickVoidUI:Destroy() end
	NAlib.disconnect("clickvoid_mouse")
end)

clickSpeedUI,clickSpeedEnabled=nil,false

cmd.add({"clicknpcws","cnpcws"},{"clicknpcws","Click on an NPC to set its WalkSpeed"},function()
	clickSpeedEnabled=true
	if clickSpeedUI then clickSpeedUI:Destroy() end
	NAlib.disconnect("clickspeed_mouse")
	local player=Players.LocalPlayer
	local mouse=player:GetMouse()
	clickSpeedUI=InstanceNew("ScreenGui")
	NaProtectUI(clickSpeedUI)
	local btn=InstanceNew("TextButton")
	btn.Size=UDim2.new(0,120,0,40)
	btn.Position=UDim2.new(0.5,-130,0,10)
	btn.Text="SetSpeed: ON"
	btn.TextSize=16
	btn.TextColor3=Color3.new(1,1,1)
	btn.Font=Enum.Font.GothamBold
	btn.BackgroundColor3=Color3.fromRGB(40,40,40)
	btn.BackgroundTransparency=0.2
	btn.Parent=clickSpeedUI
	local cor1=InstanceNew("UICorner")
	cor1.CornerRadius=UDim.new(0,8)
	cor1.Parent=btn
	NAgui.draggerV2(btn)
	local tb=InstanceNew("TextBox")
	tb.Size=UDim2.new(0,120,0,40)
	tb.Position=UDim2.new(0.5,10,0,10)
	tb.Text="16"
	tb.PlaceholderText="Speed"
	tb.TextSize=16
	tb.TextColor3=Color3.new(1,1,1)
	tb.Font=Enum.Font.Gotham
	tb.BackgroundColor3=Color3.fromRGB(50,50,50)
	tb.BackgroundTransparency=0.2
	tb.Parent=clickSpeedUI
	local cor2=InstanceNew("UICorner")
	cor2.CornerRadius=UDim.new(0,8)
	cor2.Parent=tb
	NAgui.draggerV2(tb)
	local speedNumber=16
	tb.FocusLost:Connect(function(enterPressed)
		local n=tonumber(tb.Text)
		if n then speedNumber=n else tb.Text=tostring(speedNumber) end
	end)
	MouseButtonFix(btn,function()
		clickSpeedEnabled=not clickSpeedEnabled
		btn.Text=clickSpeedEnabled and "SetSpeed: ON" or "SetSpeed: OFF"
	end)
	NAlib.connect("clickspeed_mouse",mouse.Button1Down:Connect(function()
		if not clickSpeedEnabled then return end
		local hit=mouse.Target
		if hit and hit.Parent and CheckIfNPC(hit.Parent) then
			local hum=getPlrHum(hit.Parent)
			if hum then hum.WalkSpeed=speedNumber end
		end
	end))
end)

cmd.add({"unclicknpcws","uncnpcws"},{"unclicknpcws","Disable clicknpcws"},function()
	clickSpeedEnabled=false
	if clickSpeedUI then clickSpeedUI:Destroy() end
	NAlib.disconnect("clickspeed_mouse")
end)

clickJumpUI,clickJumpEnabled=nil,false

cmd.add({"clicknpcjp","cnpcjp"},{"clicknpcjp","Click on an NPC to set its JumpPower"},function()
	clickJumpEnabled=true
	if clickJumpUI then clickJumpUI:Destroy() end
	NAlib.disconnect("clickjump_mouse")
	local player=Players.LocalPlayer
	local mouse=player:GetMouse()
	clickJumpUI=InstanceNew("ScreenGui")
	NaProtectUI(clickJumpUI)
	local btn=InstanceNew("TextButton")
	btn.Size=UDim2.new(0,120,0,40)
	btn.Position=UDim2.new(0.5,-130,0,10)
	btn.Text="SetJump: ON"
	btn.TextSize=16
	btn.TextColor3=Color3.new(1,1,1)
	btn.Font=Enum.Font.GothamBold
	btn.BackgroundColor3=Color3.fromRGB(40,40,40)
	btn.BackgroundTransparency=0.2
	btn.Parent=clickJumpUI
	local cor1=InstanceNew("UICorner")
	cor1.CornerRadius=UDim.new(0,8)
	cor1.Parent=btn
	NAgui.draggerV2(btn)
	local tb=InstanceNew("TextBox")
	tb.Size=UDim2.new(0,120,0,40)
	tb.Position=UDim2.new(0.5,10,0,10)
	tb.Text="50"
	tb.PlaceholderText="JumpPower"
	tb.TextSize=16
	tb.TextColor3=Color3.new(1,1,1)
	tb.Font=Enum.Font.Gotham
	tb.BackgroundColor3=Color3.fromRGB(50,50,50)
	tb.BackgroundTransparency=0.2
	tb.Parent=clickJumpUI
	local cor2=InstanceNew("UICorner")
	cor2.CornerRadius=UDim.new(0,8)
	cor2.Parent=tb
	NAgui.draggerV2(tb)
	local jumpPowerNumber=50
	tb.FocusLost:Connect(function(enterPressed)
		local n=tonumber(tb.Text)
		if n then jumpPowerNumber=n else tb.Text=tostring(jumpPowerNumber) end
	end)
	MouseButtonFix(btn,function()
		clickJumpEnabled=not clickJumpEnabled
		btn.Text=clickJumpEnabled and "SetJump: ON" or "SetJump: OFF"
	end)
	NAlib.connect("clickjump_mouse",mouse.Button1Down:Connect(function()
		if not clickJumpEnabled then return end
		local hit=mouse.Target
		if hit and hit.Parent and CheckIfNPC(hit.Parent) then
			local hum=getPlrHum(hit.Parent)
			if hum then hum.JumpPower=jumpPowerNumber end
		end
	end))
end)

cmd.add({"unclicknpcjp","uncnpcjp"},{"unclicknpcjp","Disable clicknpcjp"},function()
	clickJumpEnabled=false
	if clickJumpUI then clickJumpUI:Destroy() end
	NAlib.disconnect("clickjump_mouse")
end)

--[[ FUNCTIONALITY ]]--
LocalPlayer.Chatted:Connect(function(str)
	NAlib.parseCommand(str)
	NAmanage.ExecuteBindings("OnChatted", LocalPlayer, str)
end)

--[[ Admin Player]]
function IsAdminAndRun(Message, Player)
	if Admin[Player.UserId] or isRelAdmin(Player) then
		NAlib.parseCommand(Message, Player)
	end
end

function CheckPermissions(Player)
	Player.Chatted:Connect(function(Message)
		IsAdminAndRun(Message,Player)
	end)
end

--[[function Getmodel(id)
	local ob23e232323=nil
	s,r=NACaller(function()
		ob23e232323=game:GetObjects(id)[1]
	end)
	if s and ob23e232323 then
		return ob23e232323
	end
	Wait(1)
	warn("retrying")
	return Getmodel(id)
end]]

--[[ GUI VARIABLES ]]--
originalIO.NAfetchUILoaderSource=function()
	if NAmanage and NAmanage.getPrefetchedRemote and opt and opt.NAUILOADER then
		local cached = NAmanage.getPrefetchedRemote(opt.NAUILOADER)
		if type(cached) == "string" and cached ~= "" then
			return cached
		end
	end
	local ok, body = pcall(game.HttpGet, game, opt.NAUILOADER)
	if ok and type(body) == "string" and body ~= "" then
		return body
	end
	return nil, body
end

repeat
	local NASUC, resexy = pcall(function()
		local src, err = originalIO.NAfetchUILoaderSource()
		if not src then
			error(tostring(err or "no UI loader source"))
		end
		return loadstring(src)()
	end)

	if NASUC and resexy then
		NAStuff.NASCREENGUI = resexy
	else
		warn(Format("%d | Failed to load UI module: %s | retrying...", math.random(1, 999999), tostring(resexy)))
		Wait(0.3)
	end
until NAStuff.NASCREENGUI
rPlayer=Players:FindFirstChildWhichIsA("Player")
coreGuiProtection={}
if not RunService:IsStudio() then
else
	repeat Wait() until player:FindFirstChild("AdminUI",true)
	NAStuff.NASCREENGUI=player:FindFirstChild("AdminUI",true)
end
--repeat Wait() until ScreenGui~=nil -- if it loads late then I'll just add this here

NaProtectUI(NAStuff.NASCREENGUI)

NAUIMANAGER = {
	description = NAStuff.NASCREENGUI:FindFirstChild("Description"),
	AUTOSCALER = NAStuff.NASCREENGUI:FindFirstChild("AutoScale"),
	cmdBar = NAStuff.NASCREENGUI:FindFirstChild("CmdBar"),
	centerBar = NAStuff.NASCREENGUI:FindFirstChild("CmdBar") and (NAStuff.NASCREENGUI:FindFirstChild("CmdBar")):FindFirstChild("CenterBar"),
	cmdInput = NAStuff.NASCREENGUI:FindFirstChild("CmdBar") and (NAStuff.NASCREENGUI:FindFirstChild("CmdBar")):FindFirstChild("CenterBar") and ((NAStuff.NASCREENGUI:FindFirstChild("CmdBar")):FindFirstChild("CenterBar")):FindFirstChild("Input"),
	cmdAutofill = NAStuff.NASCREENGUI:FindFirstChild("CmdBar") and (NAStuff.NASCREENGUI:FindFirstChild("CmdBar")):FindFirstChild("Autofill"),
	cmdExample = NAStuff.NASCREENGUI:FindFirstChild("CmdBar") and (NAStuff.NASCREENGUI:FindFirstChild("CmdBar")):FindFirstChild("Autofill") and ((NAStuff.NASCREENGUI:FindFirstChild("CmdBar")):FindFirstChild("Autofill")):FindFirstChildWhichIsA("Frame"),
	leftFill = NAStuff.NASCREENGUI:FindFirstChild("CmdBar") and (NAStuff.NASCREENGUI:FindFirstChild("CmdBar")):FindFirstChild("LeftFill"),
	rightFill = NAStuff.NASCREENGUI:FindFirstChild("CmdBar") and (NAStuff.NASCREENGUI:FindFirstChild("CmdBar")):FindFirstChild("RightFill"),
	chatLogsFrame = NAStuff.NASCREENGUI:FindFirstChild("ChatLogs"),
	chatLogs = NAStuff.NASCREENGUI:FindFirstChild("ChatLogs") and (NAStuff.NASCREENGUI:FindFirstChild("ChatLogs")):FindFirstChild("Container") and ((NAStuff.NASCREENGUI:FindFirstChild("ChatLogs")):FindFirstChild("Container")):FindFirstChild("Logs"),
	chatExample = NAStuff.NASCREENGUI:FindFirstChild("ChatLogs") and (NAStuff.NASCREENGUI:FindFirstChild("ChatLogs")):FindFirstChild("Container") and ((NAStuff.NASCREENGUI:FindFirstChild("ChatLogs")):FindFirstChild("Container")):FindFirstChild("Logs") and (((NAStuff.NASCREENGUI:FindFirstChild("ChatLogs")):FindFirstChild("Container")):FindFirstChild("Logs")):FindFirstChildWhichIsA("TextLabel"),
	NAconsoleFrame = NAStuff.NASCREENGUI:FindFirstChild("soRealConsole"),
	NAconsoleLogs = NAStuff.NASCREENGUI:FindFirstChild("soRealConsole") and (NAStuff.NASCREENGUI:FindFirstChild("soRealConsole")):FindFirstChild("Container") and ((NAStuff.NASCREENGUI:FindFirstChild("soRealConsole")):FindFirstChild("Container")):FindFirstChild("Logs"),
	NAconsoleExample = NAStuff.NASCREENGUI:FindFirstChild("soRealConsole") and (NAStuff.NASCREENGUI:FindFirstChild("soRealConsole")):FindFirstChild("Container") and ((NAStuff.NASCREENGUI:FindFirstChild("soRealConsole")):FindFirstChild("Container")):FindFirstChild("Logs") and (((NAStuff.NASCREENGUI:FindFirstChild("soRealConsole")):FindFirstChild("Container")):FindFirstChild("Logs")):FindFirstChildWhichIsA("TextLabel"),
	NAcontainer = NAStuff.NASCREENGUI:FindFirstChild("soRealConsole") and (NAStuff.NASCREENGUI:FindFirstChild("soRealConsole")):FindFirstChild("Container"),
	NAfilter = NAStuff.NASCREENGUI:FindFirstChild("soRealConsole") and (NAStuff.NASCREENGUI:FindFirstChild("soRealConsole")):FindFirstChild("Container") and ((NAStuff.NASCREENGUI:FindFirstChild("soRealConsole")):FindFirstChild("Container")):FindFirstChild("Filter"),
	commandsFrame = NAStuff.NASCREENGUI:FindFirstChild("Commands"),
	commandsFilter = NAStuff.NASCREENGUI:FindFirstChild("Commands") and (NAStuff.NASCREENGUI:FindFirstChild("Commands")):FindFirstChild("Container") and ((NAStuff.NASCREENGUI:FindFirstChild("Commands")):FindFirstChild("Container")):FindFirstChild("Filter"),
	commandsList = NAStuff.NASCREENGUI:FindFirstChild("Commands") and (NAStuff.NASCREENGUI:FindFirstChild("Commands")):FindFirstChild("Container") and ((NAStuff.NASCREENGUI:FindFirstChild("Commands")):FindFirstChild("Container")):FindFirstChild("List"),
	commandExample = NAStuff.NASCREENGUI:FindFirstChild("Commands") and (NAStuff.NASCREENGUI:FindFirstChild("Commands")):FindFirstChild("Container") and ((NAStuff.NASCREENGUI:FindFirstChild("Commands")):FindFirstChild("Container")):FindFirstChild("List") and (((NAStuff.NASCREENGUI:FindFirstChild("Commands")):FindFirstChild("Container")):FindFirstChild("List")):FindFirstChild("TextLabel"),
	resizeFrame = NAStuff.NASCREENGUI:FindFirstChild("Resizeable"),
	ModalFixer = NAStuff.NASCREENGUI:FindFirstChildWhichIsA("ImageButton"),
	SettingsFrame = NAStuff.NASCREENGUI:FindFirstChild("setsettings"),
	SettingsContainer = NAStuff.NASCREENGUI:FindFirstChild("setsettings") and (NAStuff.NASCREENGUI:FindFirstChild("setsettings")):FindFirstChild("Container"),
	SettingsTabContainer = NAStuff.NASCREENGUI:FindFirstChild("setsettings") and (NAStuff.NASCREENGUI:FindFirstChild("setsettings")):FindFirstChild("Container") and ((NAStuff.NASCREENGUI:FindFirstChild("setsettings")):FindFirstChild("Container")):FindFirstChild("TabContainer"),
	SettingsTabs = NAStuff.NASCREENGUI:FindFirstChild("setsettings") and (NAStuff.NASCREENGUI:FindFirstChild("setsettings")):FindFirstChild("Container") and ((NAStuff.NASCREENGUI:FindFirstChild("setsettings")):FindFirstChild("Container")):FindFirstChild("TabContainer") and (((NAStuff.NASCREENGUI:FindFirstChild("setsettings")):FindFirstChild("Container")):FindFirstChild("TabContainer")):FindFirstChild("TabList"),
	SettingsPages = NAStuff.NASCREENGUI:FindFirstChild("setsettings") and (NAStuff.NASCREENGUI:FindFirstChild("setsettings")):FindFirstChild("Container") and ((NAStuff.NASCREENGUI:FindFirstChild("setsettings")):FindFirstChild("Container")):FindFirstChild("TabContainer") and (((NAStuff.NASCREENGUI:FindFirstChild("setsettings")):FindFirstChild("Container")):FindFirstChild("TabContainer")):FindFirstChild("Pages"),
	SettingsList = NAStuff.NASCREENGUI:FindFirstChild("setsettings") and (NAStuff.NASCREENGUI:FindFirstChild("setsettings")):FindFirstChild("Container") and ((NAStuff.NASCREENGUI:FindFirstChild("setsettings")):FindFirstChild("Container")):FindFirstChild("TabContainer") and (((NAStuff.NASCREENGUI:FindFirstChild("setsettings")):FindFirstChild("Container")):FindFirstChild("TabContainer")):FindFirstChild("Pages") and ((((NAStuff.NASCREENGUI:FindFirstChild("setsettings")):FindFirstChild("Container")):FindFirstChild("TabContainer")):FindFirstChild("Pages")):FindFirstChild("List"),
	SettingsSearchBox = NAStuff.NASCREENGUI:FindFirstChild("setsettings") and (NAStuff.NASCREENGUI:FindFirstChild("setsettings")):FindFirstChild("Container") and ((NAStuff.NASCREENGUI:FindFirstChild("setsettings")):FindFirstChild("Container")):FindFirstChild("TabContainer") and (((NAStuff.NASCREENGUI:FindFirstChild("setsettings")):FindFirstChild("Container")):FindFirstChild("TabContainer")):FindFirstChild("SearchBox"),
	SettingsTabButton = NAStuff.NASCREENGUI:FindFirstChild("setsettings") and (NAStuff.NASCREENGUI:FindFirstChild("setsettings")):FindFirstChild("Container") and ((NAStuff.NASCREENGUI:FindFirstChild("setsettings")):FindFirstChild("Container")):FindFirstChild("TabContainer") and (((NAStuff.NASCREENGUI:FindFirstChild("setsettings")):FindFirstChild("Container")):FindFirstChild("TabContainer")):FindFirstChild("TabList") and ((((NAStuff.NASCREENGUI:FindFirstChild("setsettings")):FindFirstChild("Container")):FindFirstChild("TabContainer")):FindFirstChild("TabList")):FindFirstChild("TabButton"),
	SettingsButton = NAStuff.NASCREENGUI:FindFirstChild("setsettings") and (NAStuff.NASCREENGUI:FindFirstChild("setsettings")):FindFirstChild("Container") and ((NAStuff.NASCREENGUI:FindFirstChild("setsettings")):FindFirstChild("Container")):FindFirstChild("TabContainer") and (((NAStuff.NASCREENGUI:FindFirstChild("setsettings")):FindFirstChild("Container")):FindFirstChild("TabContainer")):FindFirstChild("Pages") and ((((NAStuff.NASCREENGUI:FindFirstChild("setsettings")):FindFirstChild("Container")):FindFirstChild("TabContainer")):FindFirstChild("Pages")):FindFirstChild("List") and (((((NAStuff.NASCREENGUI:FindFirstChild("setsettings")):FindFirstChild("Container")):FindFirstChild("TabContainer")):FindFirstChild("Pages")):FindFirstChild("List")):FindFirstChild("Button"),
	SettingsColorPicker = NAStuff.NASCREENGUI:FindFirstChild("setsettings") and (NAStuff.NASCREENGUI:FindFirstChild("setsettings")):FindFirstChild("Container") and ((NAStuff.NASCREENGUI:FindFirstChild("setsettings")):FindFirstChild("Container")):FindFirstChild("TabContainer") and (((NAStuff.NASCREENGUI:FindFirstChild("setsettings")):FindFirstChild("Container")):FindFirstChild("TabContainer")):FindFirstChild("Pages") and ((((NAStuff.NASCREENGUI:FindFirstChild("setsettings")):FindFirstChild("Container")):FindFirstChild("TabContainer")):FindFirstChild("Pages")):FindFirstChild("List") and (((((NAStuff.NASCREENGUI:FindFirstChild("setsettings")):FindFirstChild("Container")):FindFirstChild("TabContainer")):FindFirstChild("Pages")):FindFirstChild("List")):FindFirstChild("ColorPicker"),
	SettingsSectionTitle = NAStuff.NASCREENGUI:FindFirstChild("setsettings") and (NAStuff.NASCREENGUI:FindFirstChild("setsettings")):FindFirstChild("Container") and ((NAStuff.NASCREENGUI:FindFirstChild("setsettings")):FindFirstChild("Container")):FindFirstChild("TabContainer") and (((NAStuff.NASCREENGUI:FindFirstChild("setsettings")):FindFirstChild("Container")):FindFirstChild("TabContainer")):FindFirstChild("Pages") and ((((NAStuff.NASCREENGUI:FindFirstChild("setsettings")):FindFirstChild("Container")):FindFirstChild("TabContainer")):FindFirstChild("Pages")):FindFirstChild("List") and (((((NAStuff.NASCREENGUI:FindFirstChild("setsettings")):FindFirstChild("Container")):FindFirstChild("TabContainer")):FindFirstChild("Pages")):FindFirstChild("List")):FindFirstChild("SectionTitle"),
	SettingsToggle = NAStuff.NASCREENGUI:FindFirstChild("setsettings") and (NAStuff.NASCREENGUI:FindFirstChild("setsettings")):FindFirstChild("Container") and ((NAStuff.NASCREENGUI:FindFirstChild("setsettings")):FindFirstChild("Container")):FindFirstChild("TabContainer") and (((NAStuff.NASCREENGUI:FindFirstChild("setsettings")):FindFirstChild("Container")):FindFirstChild("TabContainer")):FindFirstChild("Pages") and ((((NAStuff.NASCREENGUI:FindFirstChild("setsettings")):FindFirstChild("Container")):FindFirstChild("TabContainer")):FindFirstChild("Pages")):FindFirstChild("List") and (((((NAStuff.NASCREENGUI:FindFirstChild("setsettings")):FindFirstChild("Container")):FindFirstChild("TabContainer")):FindFirstChild("Pages")):FindFirstChild("List")):FindFirstChild("Toggle"),
	SettingsInput = NAStuff.NASCREENGUI:FindFirstChild("setsettings") and (NAStuff.NASCREENGUI:FindFirstChild("setsettings")):FindFirstChild("Container") and ((NAStuff.NASCREENGUI:FindFirstChild("setsettings")):FindFirstChild("Container")):FindFirstChild("TabContainer") and (((NAStuff.NASCREENGUI:FindFirstChild("setsettings")):FindFirstChild("Container")):FindFirstChild("TabContainer")):FindFirstChild("Pages") and ((((NAStuff.NASCREENGUI:FindFirstChild("setsettings")):FindFirstChild("Container")):FindFirstChild("TabContainer")):FindFirstChild("Pages")):FindFirstChild("List") and (((((NAStuff.NASCREENGUI:FindFirstChild("setsettings")):FindFirstChild("Container")):FindFirstChild("TabContainer")):FindFirstChild("Pages")):FindFirstChild("List")):FindFirstChild("Input"),
	SettingsKeybind = NAStuff.NASCREENGUI:FindFirstChild("setsettings") and (NAStuff.NASCREENGUI:FindFirstChild("setsettings")):FindFirstChild("Container") and ((NAStuff.NASCREENGUI:FindFirstChild("setsettings")):FindFirstChild("Container")):FindFirstChild("TabContainer") and (((NAStuff.NASCREENGUI:FindFirstChild("setsettings")):FindFirstChild("Container")):FindFirstChild("TabContainer")):FindFirstChild("Pages") and ((((NAStuff.NASCREENGUI:FindFirstChild("setsettings")):FindFirstChild("Container")):FindFirstChild("TabContainer")):FindFirstChild("Pages")):FindFirstChild("List") and (((((NAStuff.NASCREENGUI:FindFirstChild("setsettings")):FindFirstChild("Container")):FindFirstChild("TabContainer")):FindFirstChild("Pages")):FindFirstChild("List")):FindFirstChild("Keybind"),
	SettingsSlider = NAStuff.NASCREENGUI:FindFirstChild("setsettings") and (NAStuff.NASCREENGUI:FindFirstChild("setsettings")):FindFirstChild("Container") and ((NAStuff.NASCREENGUI:FindFirstChild("setsettings")):FindFirstChild("Container")):FindFirstChild("TabContainer") and (((NAStuff.NASCREENGUI:FindFirstChild("setsettings")):FindFirstChild("Container")):FindFirstChild("TabContainer")):FindFirstChild("Pages") and ((((NAStuff.NASCREENGUI:FindFirstChild("setsettings")):FindFirstChild("Container")):FindFirstChild("TabContainer")):FindFirstChild("Pages")):FindFirstChild("List") and (((((NAStuff.NASCREENGUI:FindFirstChild("setsettings")):FindFirstChild("Container")):FindFirstChild("TabContainer")):FindFirstChild("Pages")):FindFirstChild("List")):FindFirstChild("Slider"),
	WaypointFrame = NAStuff.NASCREENGUI:FindFirstChild("SuchWaypoint"),
	WaypointContainer = NAStuff.NASCREENGUI:FindFirstChild("SuchWaypoint") and (NAStuff.NASCREENGUI:FindFirstChild("SuchWaypoint")):FindFirstChild("Container"),
	WaypointList = NAStuff.NASCREENGUI:FindFirstChild("SuchWaypoint") and (NAStuff.NASCREENGUI:FindFirstChild("SuchWaypoint")):FindFirstChild("Container") and ((NAStuff.NASCREENGUI:FindFirstChild("SuchWaypoint")):FindFirstChild("Container")):FindFirstChild("List"),
	filterBox = NAStuff.NASCREENGUI:FindFirstChild("SuchWaypoint") and (NAStuff.NASCREENGUI:FindFirstChild("SuchWaypoint")):FindFirstChild("Container") and ((NAStuff.NASCREENGUI:FindFirstChild("SuchWaypoint")):FindFirstChild("Container")):FindFirstChildWhichIsA("TextBox"),
	WPFrame = NAStuff.NASCREENGUI:FindFirstChild("SuchWaypoint") and (NAStuff.NASCREENGUI:FindFirstChild("SuchWaypoint")):FindFirstChild("Container") and ((NAStuff.NASCREENGUI:FindFirstChild("SuchWaypoint")):FindFirstChild("Container")):FindFirstChild("List") and (((NAStuff.NASCREENGUI:FindFirstChild("SuchWaypoint")):FindFirstChild("Container")):FindFirstChild("List")):FindFirstChild("WP"),
	BindersFrame = NAStuff.NASCREENGUI:FindFirstChild("binders"),
	BindersContainer = NAStuff.NASCREENGUI:FindFirstChild("binders") and (NAStuff.NASCREENGUI:FindFirstChild("binders")):FindFirstChild("Container"),
	BindersList = NAStuff.NASCREENGUI:FindFirstChild("binders") and (NAStuff.NASCREENGUI:FindFirstChild("binders")):FindFirstChild("Container") and ((NAStuff.NASCREENGUI:FindFirstChild("binders")):FindFirstChild("Container")):FindFirstChild("List")
};

originalIO.resizeCursors = function(key, fallback)
	if type(getcustomasset) ~= "function" then
		return fallback;
	end;
	if not (NAfiles and NAfiles.NAASSETSFILEPATH and NAImageAssets and NAImageAssets[key]) then
		return fallback;
	end;
	local suc, res = pcall(getcustomasset, NAfiles.NAASSETSFILEPATH .. "/" .. NAImageAssets[key]);
	if suc and res then
		return res;
	end;
	return fallback;
end;

NAStuff.resizeVerticalAsset = originalIO.resizeCursors("ResizeVertical", "rbxassetid://2911850935")
NAStuff.resizeHorizontalAsset = originalIO.resizeCursors("ResizeHorizontal", "rbxassetid://2911851464")
NAStuff.resizeDiagonal1Asset = originalIO.resizeCursors("ResizeDiagonal1", "rbxassetid://2911851859")
NAStuff.resizeDiagonal2Asset = originalIO.resizeCursors("ResizeDiagonal2", "rbxassetid://2911852219")

resizeXY = {
	Top = {
		Vector2.new(0, -1),
		Vector2.new(0, -1),
		NAStuff.resizeVerticalAsset
	},
	Bottom = {
		Vector2.new(0, 1),
		Vector2.new(0, 0),
		NAStuff.resizeVerticalAsset
	},
	Left = {
		Vector2.new(-1, 0),
		Vector2.new(1, 0),
		NAStuff.resizeHorizontalAsset
	},
	Right = {
		Vector2.new(1, 0),
		Vector2.new(0, 0),
		NAStuff.resizeHorizontalAsset
	},
	TopLeft = {
		Vector2.new(-1, -1),
		Vector2.new(1, -1),
		NAStuff.resizeDiagonal2Asset
	},
	TopRight = {
		Vector2.new(1, -1),
		Vector2.new(0, -1),
		NAStuff.resizeDiagonal1Asset
	},
	BottomLeft = {
		Vector2.new(-1, 1),
		Vector2.new(1, 0),
		NAStuff.resizeDiagonal1Asset
	},
	BottomRight = {
		Vector2.new(1, 1),
		Vector2.new(0, 0),
		NAStuff.resizeDiagonal2Asset
	}
};

fillSizes = {
	right = NAUIMANAGER.rightFill.Size,
	left = NAUIMANAGER.leftFill.Size
};
if NAUIMANAGER.cmdExample then
	NAUIMANAGER.cmdExample.Parent = nil;
end;
if NAUIMANAGER.chatExample then
	NAUIMANAGER.chatExample.Parent = nil;
end;
if NAUIMANAGER.NAconsoleExample then
	NAUIMANAGER.NAconsoleExample.Parent = nil;
end;
if NAUIMANAGER.commandExample then
	NAUIMANAGER.commandExample.Parent = nil;
end;
if NAUIMANAGER.resizeFrame then
	NAUIMANAGER.resizeFrame.Parent = nil;
end;
if NAUIMANAGER.SettingsButton then
	NAUIMANAGER.SettingsButton.Parent = nil;
end;
if NAUIMANAGER.SettingsColorPicker then
	NAUIMANAGER.SettingsColorPicker.Parent = nil;
end;
if NAUIMANAGER.SettingsSectionTitle then
	NAUIMANAGER.SettingsSectionTitle.Parent = nil;
end;
if NAUIMANAGER.SettingsToggle then
	NAUIMANAGER.SettingsToggle.Parent = nil;
end;
if NAUIMANAGER.SettingsInput then
	NAUIMANAGER.SettingsInput.Parent = nil;
end;
if NAUIMANAGER.SettingsKeybind then
	NAUIMANAGER.SettingsKeybind.Parent = nil;
end;
if NAUIMANAGER.SettingsSlider then
	NAUIMANAGER.SettingsSlider.Parent = nil;
end;
if NAUIMANAGER.SettingsTabButton then
	NAUIMANAGER.SettingsTabButton.Parent = nil;
end;
if NAUIMANAGER.WPFrame then
	NAUIMANAGER.WPFrame.Parent = nil;
end;
templates = {
	Button = NAUIMANAGER.SettingsButton,
	ColorPicker = NAUIMANAGER.SettingsColorPicker,
	SectionTitle = NAUIMANAGER.SettingsSectionTitle,
	Toggle = NAUIMANAGER.SettingsToggle,
	Input = NAUIMANAGER.SettingsInput,
	Keybind = NAUIMANAGER.SettingsKeybind,
	Slider = NAUIMANAGER.SettingsSlider,
	WaypointerFrame = NAUIMANAGER.WPFrame
};
TabManager = {
	holder = NAUIMANAGER.SettingsTabs,
	container = NAUIMANAGER.SettingsPages,
	template = NAUIMANAGER.SettingsTabButton,
	defaultPage = NAUIMANAGER.SettingsList,
	tabs = {},
	order = {},
	current = nil,
	fallback = nil,
	fallbackIndex = 0
};

BUILDER_ICON_FONT_PATH = "rbxasset://LuaPackages/Packages/_Index/BuilderIcons/BuilderIcons/BuilderIcons.json"

originalIO.escapeRichTextText = function(text)
	text = tostring(text or "");
	if text == "" then
		return "";
	end;
	return ((text:gsub("&", "&amp;")):gsub("<", "&lt;")):gsub(">", "&gt;");
end;
originalIO.colorValueToHex = function(color)
	if typeof(color) == "Color3" then
		local r = math.clamp(math.floor(color.R * 255 + 0.5), 0, 255);
		local g = math.clamp(math.floor(color.G * 255 + 0.5), 0, 255);
		local b = math.clamp(math.floor(color.B * 255 + 0.5), 0, 255);
		return Format("#%02X%02X%02X", r, g, b);
	elseif type(color) == "string" and color ~= "" then
		return color;
	end;
	return nil;
end;
originalIO.resolveTabIconMarkup = function(iconOption, opts)
	if iconOption == nil then
		return nil;
	end;
	opts = opts or {};
	local isActive = opts.isActive == true;
	local defaultColor = opts.defaultColor;
	local name = iconOption;
	local gap;
	local tint;
	local stateBold;
	if type(iconOption) == "table" then
		name = iconOption.icon or iconOption.name or iconOption[1];
		gap = iconOption.gap or iconOption.spacing;
		if iconOption.color or iconOption.tint then
			tint = iconOption.color or iconOption.tint;
		end;
		if isActive and iconOption.activeBold ~= nil then
			stateBold = iconOption.activeBold;
		elseif not isActive and iconOption.inactiveBold ~= nil then
			stateBold = iconOption.inactiveBold;
		elseif isActive and iconOption.activeFilled ~= nil then
			stateBold = iconOption.activeFilled;
		elseif not isActive and iconOption.inactiveFilled ~= nil then
			stateBold = iconOption.inactiveFilled;
		end;
		if stateBold == nil then
			if iconOption.bold ~= nil then
				stateBold = iconOption.bold;
			elseif iconOption.filled ~= nil then
				stateBold = iconOption.filled;
			elseif iconOption.weight == "bold" or iconOption.variant == "filled" then
				stateBold = true;
			end;
		end;
	end;
	if type(name) ~= "string" then
		return nil;
	end;
	local trimmed = name:match("^%s*(.-)%s*$");
	if not trimmed or trimmed == "" then
		return nil;
	end;
	local glyph = trimmed:gsub("%s+", "");
	glyph = originalIO.escapeRichTextText(glyph);
	if glyph == "" then
		return nil;
	end;
	if stateBold == nil then
		stateBold = isActive;
	end;
	if stateBold then
		glyph = "<b>" .. glyph .. "</b>";
	end;
	local markup = Format("<font family=\"%s\">%s</font>", BUILDER_ICON_FONT_PATH, glyph);
	local colorHex = originalIO.colorValueToHex(tint or defaultColor);
	if colorHex then
		markup = Format("<font color=\"%s\">%s</font>", colorHex, markup);
	end;
	local iconGap = " ";
	if type(gap) == "number" and gap > 0 then
		iconGap = string.rep(" ", math.clamp(math.floor(gap + 0.5), 1, 8));
	elseif type(gap) == "string" and gap ~= "" then
		iconGap = gap;
	end;
	return markup, iconGap;
end;
originalIO.composeTabTitleText = function(info, opts)
	if not info then
		return "";
	end;
	opts = opts or {};
	local rawTitle = info.displayName;
	if type(rawTitle) ~= "string" or rawTitle == "" then
		rawTitle = info.name or "";
	end;
	local safeDisplay = originalIO.escapeRichTextText(rawTitle);
	if safeDisplay == "" and info.name and info.name ~= rawTitle then
		safeDisplay = originalIO.escapeRichTextText(info.name);
	end;
	local iconMarkup, iconGap = originalIO.resolveTabIconMarkup(info.textIcon, {
		isActive = opts.isActive,
		defaultColor = opts.defaultColor
	});
	if iconMarkup then
		return iconMarkup .. (iconGap or " ") .. safeDisplay;
	end;
	return safeDisplay;
end;
originalIO.applyTabDisplayText = function(info, opts)
	if not info or (not info.button) then
		return;
	end;
	opts = opts or {};
	local title = info.button:FindFirstChild("Title");
	if not title then
		return;
	end;
	if title.RichText ~= true then
		title.RichText = true;
	end;
	local isActive = opts.isActive;
	if isActive == nil then
		isActive = info._isActive;
	end;
	local defaultColor = opts.defaultColor;
	if defaultColor == nil then
		defaultColor = NAUISTROKER or DEFAULT_UI_STROKE_COLOR;
	end;
	title.Text = originalIO.composeTabTitleText(info, {
		isActive = isActive,
		defaultColor = defaultColor
	});
end;
NAStuff.tabsLayout = TabManager.holder and (TabManager.holder:FindFirstChildWhichIsA("UIListLayout") or TabManager.holder:FindFirstChildWhichIsA("UIGridLayout"));
if NAStuff.tabsLayout and NAStuff.tabsLayout.SortOrder ~= Enum.SortOrder.LayoutOrder then
	pcall(function()
		NAStuff.tabsLayout.SortOrder = Enum.SortOrder.LayoutOrder;
	end);
end;

if TabManager.template then
	TabManager.template.Visible = false;
end;
if TabManager.defaultPage then
	local maxOrder = 0;
	for _, child in ipairs(TabManager.defaultPage:GetChildren()) do
		if child:IsA("GuiObject") and child.Name ~= "UIListLayout" then
			maxOrder = math.max(maxOrder, child.LayoutOrder or 0);
		end;
	end;
	TabManager.pageTemplate = TabManager.defaultPage:Clone();
	TabManager.pageTemplate.Name = "TabPageTemplate";
	TabManager.pageTemplate.CanvasPosition = Vector2.new(0, 0);
	TabManager.pageTemplate.Parent = nil;
	TabManager.fallback = {
		page = TabManager.defaultPage,
		layoutIndex = maxOrder
	};
	TabManager.fallbackIndex = maxOrder;
	TabManager.defaultPage.Visible = true;
end;
NAmanage.registerElementForCurrentTab = function(instance)
	if not instance then
		return;
	end;
	local currentName = TabManager.current;
	if not currentName or TAB_ALL and currentName == TAB_ALL then
		return;
	end;
	if not NAStuff.elementOriginalParent[instance] then
		NAStuff.elementOriginalParent[instance] = instance.Parent;
	end;
	pcall(function()
		instance:SetAttribute("NAOriginalTab", currentName);
	end);
end;
NAmanage.clearAllTabWrappers = function(page)
	if not page then
		return;
	end;
	for _, child in ipairs(page:GetChildren()) do
		if child:IsA("GuiObject") and child:GetAttribute("NAAllWrapper") then
			for _, element in ipairs(child:GetChildren()) do
				if element:IsA("GuiObject") then
					local originalParent = NAStuff.elementOriginalParent[element];
					if not originalParent then
						local originalTab = element:GetAttribute("NAOriginalTab");
						if originalTab and TabManager.tabs then
							local info = TabManager.tabs[originalTab];
							originalParent = info and info.page;
						end;
					end;
					originalParent = originalParent or page;
					local origOrder = element:GetAttribute("NAOrigOrder");
					if typeof(origOrder) == "number" then
						element.LayoutOrder = origOrder;
					end;
					if element.Parent ~= originalParent then
						element.Parent = originalParent;
					end;
				end;
			end;
			child:Destroy();
		end;
	end;
end;
NAmanage.restoreAllTabElements = function()
	local allInfo = TabManager.tabs and TAB_ALL and TabManager.tabs[TAB_ALL] or nil;
	if allInfo and allInfo.page then
		NAmanage.clearAllTabWrappers(allInfo.page);
	end;
end;
NAmanage.collectTabElements = function(tabInfo, tabName)
	local elements = {};
	if not tabInfo or (not tabInfo.page) then
		return elements;
	end;
	for _, child in ipairs(tabInfo.page:GetChildren()) do
		if child:IsA("GuiObject") and (not child:GetAttribute("NAAllWrapper")) and (not child:IsA("UIListLayout")) and (not child:IsA("UIPadding")) and (not child:IsA("UIPageLayout")) then
			Insert(elements, child);
		end;
	end;
	table.sort(elements, function(a, b)
		return (a.LayoutOrder or 0) < (b.LayoutOrder or 0);
	end);
	tabInfo.elements = elements;
	for _, element in ipairs(elements) do
		if not NAStuff.elementOriginalParent[element] then
			NAStuff.elementOriginalParent[element] = tabInfo.page;
		end;
		pcall(function()
			element:SetAttribute("NAOriginalTab", tabName);
		end);
	end;
	return elements;
end;
NAmanage.prepareAllTabDisplay = function(allInfo)
	if not allInfo or (not allInfo.page) then
		return;
	end;
	NAmanage.clearAllTabWrappers(allInfo.page);
	local page = allInfo.page;
	local layout = page:FindFirstChildWhichIsA("UIListLayout");
	if not layout then
		layout = InstanceNew("UIListLayout");
		layout.FillDirection = Enum.FillDirection.Vertical;
		layout.SortOrder = Enum.SortOrder.LayoutOrder;
		layout.Padding = UDim.new(0, 10);
		layout.Parent = page;
	else
		layout.SortOrder = Enum.SortOrder.LayoutOrder;
	end;
	if page:IsA("ScrollingFrame") then
		page.AutomaticCanvasSize = Enum.AutomaticSize.Y;
		page.CanvasPosition = Vector2.new(0, 0);
	end;
	local merged = InstanceNew("Frame");
	merged.Name = "NAAllMerged";
	merged.BackgroundTransparency = 1;
	merged.Size = UDim2.new(1, 0, 0, 0);
	merged.AutomaticSize = Enum.AutomaticSize.Y;
	merged.LayoutOrder = -1;
	merged:SetAttribute("NAAllWrapper", true);
	merged.Parent = page;
	local ml = InstanceNew("UIListLayout");
	ml.FillDirection = Enum.FillDirection.Vertical;
	ml.SortOrder = Enum.SortOrder.LayoutOrder;
	ml.Padding = UDim.new(0, 6);
	ml.Parent = merged;
	local cursor = 0;
	for _, tabName in ipairs(TabManager.order) do
		if tabName ~= TAB_ALL then
			local tabInfo = TabManager.tabs[tabName];
			if tabInfo and tabInfo.page then
				local elements = NAmanage.collectTabElements(tabInfo, tabName);
				for _, element in ipairs(elements) do
					if element:GetAttribute("NAOrigOrder") == nil then
						element:SetAttribute("NAOrigOrder", element.LayoutOrder or 0);
					end;
					element.LayoutOrder = cursor;
					cursor += 1;
					if element.Parent ~= merged then
						element.Parent = merged;
					end;
				end;
			end;
		end;
	end;
end;
NAmanage.updateTabVisual = function(tabInfo, isActive)
	if not tabInfo then
		return;
	end;
	tabInfo._isActive = isActive and true or false;
	if not tabInfo.button then
		return;
	end;
	local btn = tabInfo.button;
	btn.BackgroundTransparency = isActive and 0.1 or 0.25;
	local stroke = btn:FindFirstChildWhichIsA("UIStroke", true);
	if stroke then
		NAgui.RegisterColoredStroke(stroke);
		local computeColor = NAmanage.getTabStrokeColor;
		if typeof(computeColor) == "function" then
			stroke.Color = computeColor(isActive);
		else
			stroke.Color = NAUISTROKER or DEFAULT_UI_STROKE_COLOR;
		end;
	end;
	local title = btn:FindFirstChild("Title");
	if title then
		if originalIO.applyTabDisplayText then
			originalIO.applyTabDisplayText(tabInfo, {
				isActive = isActive,
				defaultColor = NAUISTROKER or DEFAULT_UI_STROKE_COLOR
			});
		end;
		title.TextColor3 = isActive and Color3.fromRGB(255, 255, 255) or Color3.fromRGB(234, 234, 244);
	end;
end;
NAgui.getActiveTab = function()
	return TabManager.current;
end;

NAgui._nextLayoutOrder = function()
	local active = TabManager.current and TabManager.tabs[TabManager.current];
	if active then
		active.layoutIndex = (active.layoutIndex or 0) + 1;
		return active.layoutIndex;
	elseif TabManager.fallback then
		TabManager.fallback.layoutIndex = (TabManager.fallback.layoutIndex or 0) + 1;
		TabManager.fallbackIndex = TabManager.fallback.layoutIndex;
		return TabManager.fallback.layoutIndex;
	else
		TabManager.fallbackIndex = (TabManager.fallbackIndex or 0) + 1;
		return TabManager.fallbackIndex;
	end;
end;
NAgui.setTab = function(name)
	local info = name and TabManager.tabs[name];
	if not info then
		return nil;
	end;
	local previousTab = TabManager.current;
	if previousTab == TAB_ALL and name ~= TAB_ALL then
		NAmanage.restoreAllTabElements();
	end;
	TabManager.current = name;
	if name == TAB_BASIC_INFO and NAgui.RefreshBasicInfo then
		pcall(NAgui.RefreshBasicInfo);
	end;
	if info.page then
		NAUIMANAGER.SettingsList = info.page;
	end;
	for tabName, tabInfo in pairs(TabManager.tabs) do
		local isActive = tabName == name;
		if tabInfo.page then
			tabInfo.page.Visible = isActive;
		end;
		NAmanage.updateTabVisual(tabInfo, isActive);
	end;
	if name == TAB_ALL then
		NAmanage.prepareAllTabDisplay(info);
	end;
	return info.page;
end;
NAmanage.SetSearch = NAmanage.SetSearch or {};
NAmanage.SetSearch.state = NAmanage.SetSearch.state or {
	active = false,
	last = "",
	vis = setmetatable({}, {
		__mode = "k"
	})
};
function NAmanage.SetSearch.ignore(element)
	if not element or typeof(element) ~= "Instance" then
		return true;
	end;
	if not element:IsA("GuiObject") then
		return true;
	end;
	return element:IsA("UIListLayout") or element:IsA("UIPadding") or element:IsA("UIPageLayout");
end;
function NAmanage.SetSearch.scan(handler)
	if type(handler) ~= "function" then
		return;
	end;
	local list = NAUIMANAGER.SettingsList;
	if not list or typeof(list) ~= "Instance" then
		return;
	end;
	local root = list;
	for _, child in ipairs(list:GetChildren()) do
		if child:IsA("GuiObject") and child:GetAttribute("NAAllWrapper") then
			root = child;
			break;
		end;
	end;
	for _, child in ipairs(root:GetChildren()) do
		if not NAmanage.SetSearch.ignore(child) then
			handler(child);
		end;
	end;
end;
function NAmanage.SetSearch.tag(element, labelText)
	if not element or typeof(element) ~= "Instance" then
		return;
	end;
	if typeof(labelText) ~= "string" or labelText == "" then
		return;
	end;
	local cleaned = NAmanage.SetSearch.clean(labelText);
	pcall(function()
		element:SetAttribute("NASearchLabel", labelText);
		element:SetAttribute("NASearchText", cleaned);
	end);
end;
function NAmanage.SetSearch.label(element)
	if not element then
		return "";
	end;
	local stored = element:GetAttribute("NASearchLabel");
	if type(stored) == "string" and stored ~= "" then
		return stored;
	end;
	local title = element:FindFirstChild("Title", true);
	if title and (title:IsA("TextLabel") or title:IsA("TextBox") or title:IsA("TextButton")) then
		return title.Text or "";
	end;
	local fallbackNames = {
		"Description",
		"Desc",
		"Information"
	};
	for _, name in ipairs(fallbackNames) do
		local descendant = element:FindFirstChild(name, true);
		if descendant and descendant:IsA("TextLabel") then
			return descendant.Text or "";
		end;
	end;
	local fallback = element:FindFirstChildWhichIsA("TextLabel", true);
	if fallback then
		return fallback.Text or "";
	end;
	return element.Name or "";
end;
function NAmanage.SetSearch.info(element)
	if not element then
		return "";
	end;
	local rawText = NAmanage.SetSearch.collectText and NAmanage.SetSearch.collectText(element) or "";
	if rawText == "" then
		rawText = NAmanage.SetSearch.label(element);
	end;
	local cleaned = NAmanage.SetSearch.clean(rawText);
	pcall(function()
		element:SetAttribute("NASearchText", cleaned);
	end);
	return cleaned;
end;
function NAmanage.SetSearch.norm(text)
	text = text or "";
	if NAgui.normalizeCommandFilter then
		text = NAgui.normalizeCommandFilter(text);
	else
		text = Lower(text);
	end;
	text = GSub(text, "^%s*(.-)%s*$", "%1");
	return text;
end;
function NAmanage.SetSearch.clean(text)
	text = text or "";
	local lowered = Lower(text);
	lowered = GSub(lowered, "<[^>]+>", "");
	lowered = GSub(lowered, "%s+", " ");
	lowered = GSub(lowered, "^%s*(.-)%s*$", "%1");
	return lowered;
end;
function NAmanage.SetSearch.collectText(element)
	if not element or typeof(element) ~= "Instance" then
		return "";
	end;
	local parts = {};
	local function walk(obj)
		if not obj or typeof(obj) ~= "Instance" then
			return;
		end;
		if obj:IsA("TextLabel") or obj:IsA("TextButton") or obj:IsA("TextBox") then
			local t = obj.Text;
			if type(t) == "string" and t ~= "" then
				Insert(parts, t);
			end;
		end;
		for _, child in ipairs(obj:GetChildren()) do
			walk(child);
		end;
	end;
	walk(element);
	return Concat(parts, " ");
end;
function NAmanage.SetSearch.reset()
	for element, original in pairs(NAmanage.SetSearch.state.vis) do
		if typeof(element) == "Instance" and element:IsA("GuiObject") then
			element.Visible = original;
		end;
	end;
	table.clear(NAmanage.SetSearch.state.vis);
	NAmanage.SetSearch.state.active = false;
	NAmanage.SetSearch.state.last = "";
end;
function NAmanage.SetSearch.match(element, query)
	if query == "" then
		return true;
	end;
	local info = NAmanage.SetSearch.info(element);
	if info == "" then
		return false;
	end;
	if Sub(info, 1, #query) == query then
		return true;
	end;
	return Find(info, query, 1, true) ~= nil;
end;
function NAmanage.SetSearch.isSect(element)
	if not element or typeof(element) ~= "Instance" then
		return false;
	end;
	if element:GetAttribute("NASettingsSection") == true then
		return true;
	end;
	return element.Name == "SectionTitle" and element:IsA("GuiObject");
end;
function NAmanage.SetSearch.sectVis(list, matchesMap)
	if not list then
		return;
	end;
	local root = list;
	for _, child in ipairs(list:GetChildren()) do
		if child:IsA("GuiObject") and child:GetAttribute("NAAllWrapper") then
			root = child;
			break;
		end;
	end;
	local children = root:GetChildren();
	for index = 1, #children do
		local child = children[index];
		if child and (not NAmanage.SetSearch.ignore(child)) and NAmanage.SetSearch.isSect(child) then
			local visible = matchesMap[child];
			if not visible then
				visible = false;
				for j = index + 1, #children do
					local candidate = children[j];
					if candidate and (not NAmanage.SetSearch.ignore(candidate)) then
						if NAmanage.SetSearch.isSect(candidate) then
							break;
						end;
						if candidate.Visible then
							visible = true;
							break;
						end;
					end;
				end;
			end;
			child.Visible = visible and true or false;
		end;
	end;
end;
function NAmanage.SetSearch.apply(rawText)
	local list = NAUIMANAGER.SettingsList;
	if not list then
		return;
	end;
	local query = NAmanage.SetSearch.norm(rawText);
	NAmanage.SetSearch.state.last = rawText or "";
	if query == "" then
		if NAmanage.SetSearch.state.active then
			NAmanage.SetSearch.reset();
		end;
		return;
	end;
	NAmanage.SetSearch.state.active = true;
	local matchesMap = {};
	NAmanage.SetSearch.scan(function(element)
		if NAmanage.SetSearch.state.vis[element] == nil then
			NAmanage.SetSearch.state.vis[element] = element.Visible;
		end;
		local matches = NAmanage.SetSearch.match(element, query);
		matchesMap[element] = matches;
		element.Visible = matches;
	end);
	NAmanage.SetSearch.sectVis(list, matchesMap);
end;
function NAmanage.SetSearch.init()
	local input = NAUIMANAGER.SettingsSearchBox;
	if not input then
		return;
	end;
	(input:GetPropertyChangedSignal("Text")):Connect(function()
		NAmanage.SetSearch.apply(input.Text or "");
	end);
	NAmanage.SetSearch.apply(input.Text or "");
end;
NAmanage.SetSearch.init();

originalIO.applyTabIDK=function()
	local baseSetTab = NAgui.setTab
	NAgui.setTab = function(name)
		local page = baseSetTab(name)
		if page then
			NAUIMANAGER.SettingsList = page
		end
		if NAmanage.SetSearch.state.active and NAmanage.SetSearch.state.last ~= "" then
			NAmanage.SetSearch.apply(NAmanage.SetSearch.state.last)
		end
		return page
	end
end
originalIO.applyTabIDK()

NAgui.addTab=function(name, options)
	if type(name) ~= "string" or name == "" then
		return nil
	end
	local textIconOption = options and options.textIcon
	if TabManager.tabs[name] then
		local existingInfo = TabManager.tabs[name]
		if textIconOption ~= nil and existingInfo then
			existingInfo.textIcon = textIconOption
			if originalIO.applyTabDisplayText then
				originalIO.applyTabDisplayText(existingInfo, { isActive = existingInfo._isActive })
			end
		end
		if options and options.default then
			NAgui.setTab(name)
		end
		return existingInfo
	end

	local displayName = tostring((options and options.displayText) or name)
	local button
	local layoutOrder = options and options.order or (#TabManager.order + 1)
	if TabManager.holder then
		local holderLayout = TabManager.holder:FindFirstChildWhichIsA("UIListLayout") or TabManager.holder:FindFirstChildWhichIsA("UIGridLayout")
		if holderLayout then
			pcall(function() holderLayout.SortOrder = Enum.SortOrder.LayoutOrder end)
		end
	end
	if TabManager.template and TabManager.holder then
		button = TabManager.template:Clone()
		button.Visible = true
		button.Name = name.."Tab"
		local title = button:FindFirstChild("Title")
		if title then
			title.Text = displayName
		end
		button.LayoutOrder = layoutOrder
		button.Parent = TabManager.holder
		NAgui.RegisterStrokesFrom(button)
		local interact = button:FindFirstChild("Interact") or button
		MouseButtonFix(interact, function()
			NAgui.setTab(name)
		end)
	end

	local info
	if TabManager.fallback and TabManager.fallback.page then
		info = {
			name = name;
			displayName = displayName;
			page = TabManager.fallback.page;
			button = button;
			layoutIndex = TabManager.fallback.layoutIndex or 0;
			textIcon = textIconOption;
			_isActive = false;
		}
		TabManager.fallback = nil
	else
		local pageTemplate = TabManager.pageTemplate
		local page = pageTemplate and pageTemplate:Clone() or (TabManager.defaultPage and TabManager.defaultPage:Clone()) or InstanceNew("ScrollingFrame")
		page.Name = name.." Page"
		page.Visible = false
		page.CanvasPosition = Vector2.new(0, 0)
		if not page:FindFirstChildWhichIsA("UIListLayout") and TabManager.defaultPage then
			local layout = TabManager.defaultPage:FindFirstChildWhichIsA("UIListLayout")
			if layout then
				layout:Clone().Parent = page
			end
		end
		page.Parent = TabManager.container or (TabManager.defaultPage and TabManager.defaultPage.Parent)
		info = {
			name = name;
			displayName = displayName;
			page = page;
			button = button;
			layoutIndex = 0;
			textIcon = textIconOption;
			_isActive = false;
		}
	end

	if info.page then
		NAgui.RegisterStrokesFrom(info.page)
	end
	if info.button and originalIO.applyTabDisplayText then
		originalIO.applyTabDisplayText(info, { isActive = info._isActive })
	end

	info.order = layoutOrder
	info.elements = info.elements or {}
	TabManager.tabs[name] = info
	Insert(TabManager.order, name)
	table.sort(TabManager.order, function(a, b)
		local infoA = TabManager.tabs[a]
		local infoB = TabManager.tabs[b]
		local orderA = infoA and infoA.order or math.huge
		local orderB = infoB and infoB.order or math.huge
		if orderA == orderB then
			return tostring(a) < tostring(b)
		end
		return orderA < orderB
	end)
	for _, orderedName in ipairs(TabManager.order) do
		local tab = TabManager.tabs[orderedName]
		if tab and tab.button then
			tab.button.LayoutOrder = tab.order or layoutOrder
		end
	end

	local shouldSet = (options and options.default) or not TabManager.current
	if shouldSet then
		NAgui.setTab(name)
	else
		if info.page then
			info.page.Visible = false
		end
		NAmanage.updateTabVisual(info, false)
	end

	return info
end

SpawnCall(function()
	for _,v in ipairs(NAStuff.NASCREENGUI:GetDescendants()) do
		if v:IsA("UIStroke") then
			NAgui.RegisterColoredStroke(v)
		end
	end
end)

NAmanage.stripChar = function(text, trimWhitespace)
	if not text then
		return ""
	end
	local cleaned = text:gsub("\t", "")
	if trimWhitespace ~= false then
		cleaned = cleaned:gsub("^%s*(.-)%s*$", "%1")
	end
	return cleaned
end

predictionInput = NAUIMANAGER.cmdInput:Clone()
predictionInput.Name = "predictionInput"
predictionInput.TextEditable = false
predictionInput.TextTransparency = 1
predictionInput.TextColor3 = Color3.fromRGB(180, 180, 180)
predictionInput.BackgroundTransparency = 1
predictionInput.ZIndex = NAUIMANAGER.cmdInput.ZIndex + 1
predictionInput.Parent = NAUIMANAGER.cmdInput.Parent
predictionInput.PlaceholderText = ""

opt.NAAUTOSCALER = NAUIMANAGER.AUTOSCALER

	--[[NACaller(function()
		for i,v in pairs(NAStuff.NASCREENGUI:GetDescendants()) do
			coreGuiProtection[v]=rPlayer.Name
		end
		NAStuff.NASCREENGUI.DescendantAdded:Connect(function(v)
			coreGuiProtection[v]=rPlayer.Name
		end)
		coreGuiProtection[NAStuff.NASCREENGUI]=rPlayer.Name
	
		local meta=getrawmetatable(game)
		local tostr=meta.__tostring
		setreadonly(meta,false)
		meta.__tostring=newcclosure(function(t)
			if coreGuiProtection[t] and not checkcaller() then
				return coreGuiProtection[t]
			end
			return tostr(t)
		end)
	end)
	if not RunService:IsStudio() then
		local newGui=COREGUI:FindFirstChildWhichIsA("NAStuff.NASCREENGUI")
		newGui.DescendantAdded:Connect(function(v)
			coreGuiProtection[v]=rPlayer.Name
		end)
		for i,v in pairs(NAStuff.NASCREENGUI:GetChildren()) do
			v.Parent=newGui
		end
		NAStuff.NASCREENGUI=newGui
	end]]

cmd.add({"rename"}, {"rename <text>", "Renames the admin UI placeholder to the given name"}, function(...)
	local newName = Concat({...}, " ")
	adminName = newName
	if NAUIMANAGER.cmdInput and NAUIMANAGER.cmdInput.PlaceholderText then
		NAUIMANAGER.cmdInput.PlaceholderText = newName
	end
	if NAmanage.UpdateAdminInfoTabDisplayName then
		NAmanage.UpdateAdminInfoTabDisplayName()
	end
end, true)

cmd.add({"unname"}, {"unname", "Resets the admin UI placeholder name to default"}, function()
	adminName = getgenv().NATestingVer and "NA Testing" or "Nameless Admin"
	if NAUIMANAGER.cmdInput and NAUIMANAGER.cmdInput.PlaceholderText then
		NAUIMANAGER.cmdInput.PlaceholderText = isAprilFools() and '🤡 '..adminName..curVer..' 🤡' or getSeasonEmoji()..' '..adminName..curVer..' '..getSeasonEmoji()
	end
	if NAmanage.UpdateAdminInfoTabDisplayName then
		NAmanage.UpdateAdminInfoTabDisplayName()
	end
end)

NAStuff.LastInputConns = NAStuff.LastInputConns or {}
NAStuff.LastInputPatched = NAStuff.LastInputPatched or false

originalIO.ApplyLastInputPatch = function()
	if not IsOnMobile then
		return
	end

	if getconnections and not NAStuff.LastInputPatched then
		table.clear(NAStuff.LastInputConns)
		for _, c in ipairs(getconnections(UserInputService.LastInputTypeChanged)) do
			table.insert(NAStuff.LastInputConns, c)
			pcall(function()
				if c.Disable then
					c:Disable()
				end
			end)
		end
	end

	pcall(function()
		GS.TouchControlsEnabled = true
	end)

	if NAlib and NAlib.connect and NAlib.disconnect then
		NAlib.disconnect("NA_LastInputTouch")
		NAlib.connect("NA_LastInputTouch", GuiService:GetPropertyChangedSignal("TouchControlsEnabled"):Connect(function()
			if IsOnMobile then
				pcall(function()
					GuiService.TouchControlsEnabled = true
				end)
			end
		end))
	else
		GuiService:GetPropertyChangedSignal("TouchControlsEnabled"):Connect(function()
			if IsOnMobile then
				pcall(function()
					GuiService.TouchControlsEnabled = true
				end)
			end
		end)
	end

	NAStuff.LastInputPatched = true
end

originalIO.RevertLastInputPatch = function()
	if NAlib and NAlib.disconnect then
		NAlib.disconnect("NA_LastInputTouch")
	end

	if getconnections and NAStuff.LastInputConns and #NAStuff.LastInputConns > 0 then
		for _, c in ipairs(NAStuff.LastInputConns) do
			pcall(function()
				if c.Enable then
					c:Enable()
				end
			end)
		end
	end

	NAStuff.LastInputPatched = false
end

--[[ GUI FUNCTIONS ]]--
local patchedCommandColor = Color3.fromRGB(255, 115, 115)
local pluginCommandColor = Color3.fromRGB(255, 196, 125)
local cmdIntegrationColor = Color3.fromRGB(120, 180, 255)

local function addPatchedLabel(text)
	if not text then return text end
	if Lower(text):find("patched", 1, true) then
		return text
	end
	return "[PATCHED] "..text
end

NAgui.txtSize=function(ui,x,y)
	local textService=TextService
	return textService:GetTextSize(ui.Text,ui.TextSize,ui.Font,Vector2.new(x,y))
end
NAmanage.buildCommandEntries=function()
	local entries = {}
	local metaByName = {}
	local used = {}

	local function addNACommand(name, data)
		if not name or name == "" then return end
		local displayText = fixStupidSearchGoober(name, data)
		if displayText and displayText ~= "" then
			if type(data[2]) == "table" then
				data[2][1] = displayText
			end
		else
			displayText = (type(data[2]) == "table" and data[2][1]) or name
		end
		local aliasList = {}
		local _, extraAliases = fixStupidSearchGoober(name, data)
		for _, alias in ipairs(extraAliases or {}) do
			Insert(aliasList, alias:lower())
		end
		local commandMeta = (type(data[4]) == "table") and data[4] or {}
		local isPatched = commandMeta.patched == true
		local isPluginCmd, pluginType = NAmanage.IsPluginCommand and NAmanage.IsPluginCommand(name)
		local pluginTag = nil
		if isPluginCmd then
			pluginTag = pluginType or true -- keep a marker even if type is unknown so coloring works
		end
		local finalText = displayText
		if isPluginCmd then
			finalText = finalText.." ["..(pluginType and (pluginType.." plugin") or "plugin").."]"
		end
		if isPatched then
			finalText = addPatchedLabel(finalText)
		end
		if isAprilFools() then
			finalText = maybeMock(finalText)
		end
		local desc = ""
		if type(data[2]) == "table" then
			desc = data[2][2] or ""
		end
		if isPatched then
			if desc == "" then
				desc = "Patched / may not work"
			elseif not Lower(desc):find("patched", 1, true) then
				desc = desc.." (patched)"
			end
		end
		used[Lower(name)] = true
		local searchable = NAmanage.stripMarkup(Lower(finalText or displayText or name))
		if isPatched then
			searchable = searchable.." patched"
		end
		metaByName[name] = {
			origin = "na";
			displayText = finalText;
			searchable = searchable;
			aliases = aliasList;
			pluginType = pluginTag;
			desc = desc;
			patched = isPatched;
		}
		entries[#entries + 1] = {
			name = name;
			display = finalText;
			meta = metaByName[name];
		}
	end

	for name, data in pairs(cmds.Commands) do
		addNACommand(name, data)
	end

	local cmdList = NAStuff.CmdIntegrationCommands
	if type(cmdList) == "table" then
		for _, info in ipairs(cmdList) do
			local baseName = info and info.name
			if baseName then
				baseName = tostring(baseName)
			end
			if baseName and baseName ~= "" then
				local key = baseName
				local duplicate = used[Lower(baseName)] == true
				if duplicate then
					key = "cmd:"..baseName
				end
				local aliases = {}
				local displayAliases = {}
				local seenDisplayAliases = {}
				local function addDisplayAlias(alias)
					if type(alias) ~= "string" then return end
					local str = tostring(alias)
					if str == "" then return end
					local lowerStr = str:lower()
					if lowerStr == "" then return end
					if lowerStr ~= key:lower() and lowerStr ~= baseName:lower() and not seenDisplayAliases[lowerStr] then
						seenDisplayAliases[lowerStr] = true
						Insert(displayAliases, str)
					end
				end
				if type(info.aliases) == "table" then
					for _, a in ipairs(info.aliases) do
						local aa = tostring(a or "")
						if aa ~= "" then
							Insert(aliases, aa:lower())
							addDisplayAlias(aa)
						end
					end
				end
				Insert(aliases, key:lower())
				if duplicate then
					Insert(aliases, baseName:lower())
				end
				local displayName = tostring(baseName)
				local desc = ""
				if type(info.desc) == "string" then
					desc = info.desc
				end
				local finalText = "[Cmd] "..displayName
				if duplicate then
					finalText = "[Cmd] "..displayName.." (use cmd:"..baseName..")"
				end
				if #displayAliases > 0 then
					finalText = finalText.." ("..Concat(displayAliases, ", ")..")"
				end
				local searchable = NAmanage.stripMarkup(Lower(displayName))
				if #aliases > 0 then
					searchable = searchable.." "..Concat(aliases, " ")
				end
				if desc ~= "" then
					searchable = searchable.." "..NAmanage.stripMarkup(Lower(desc))
				end
				used[Lower(key)] = true
				metaByName[key] = {
					origin = "cmd";
					displayText = finalText;
					searchable = searchable;
					aliases = aliases;
					sourceName = baseName;
					duplicate = duplicate;
					desc = desc;
				}
				entries[#entries + 1] = {
					name = key;
					display = finalText;
					meta = metaByName[key];
				}
			end
		end
	end

	table.sort(entries, function(a, b)
		return Lower(tostring(a.display or a.name)) < Lower(tostring(b.display or b.name))
	end)

	NAStuff.AutofillMetaByName = metaByName
	return entries, metaByName
end

NAmanage.totalCommandCount=function()
	local count = countDictNA(cmds.Commands)
	if type(NAStuff.CmdIntegrationCommands) == "table" then
		count = count + #NAStuff.CmdIntegrationCommands
	end
	return count
end
NAgui.commands = function()
	local cFrame, cList = NAUIMANAGER.commandsFrame, NAUIMANAGER.commandsList
	local defaultCmdColor = NAUIMANAGER.commandExample and NAUIMANAGER.commandExample.TextColor3
	NAStuff.CommandLabelPool = NAStuff.CommandLabelPool or {}
	local pool = NAStuff.CommandLabelPool

	if not cFrame.Visible then
		cFrame.Visible = true
		cList.CanvasSize = UDim2.new(0, 0, 0, 0)
	end

	local yOffset = 5
	local active = {}
	local entries = NAmanage.buildCommandEntries()
	for _, entry in ipairs(entries) do
		local cmdName = entry.name
		local meta = entry.meta or {}
		local tbl = cmds.Commands[cmdName]
		local Cmd = pool[cmdName]
		if not Cmd then
			Cmd = NAUIMANAGER.commandExample:Clone()
			Cmd.Parent = cList
			Cmd.Name = cmdName
			Cmd.MouseEnter:Connect(function()
				local desc = Cmd:GetAttribute("CmdDesc")
				if type(desc) == "string" and desc ~= "" then
					NAUIMANAGER.description.Visible = true
					NAUIMANAGER.description.Text = desc
				else
					NAUIMANAGER.description.Visible = false
					NAUIMANAGER.description.Text = ""
				end
			end)
			Cmd.MouseLeave:Connect(function()
				NAUIMANAGER.description.Visible = false
				NAUIMANAGER.description.Text = ""
			end)
			pool[cmdName] = Cmd
		end
		active[cmdName] = true

		local finalText = meta.displayText or entry.display or cmdName
		local isPatched = meta.patched == true
		local isCmdIntegration = meta.origin == "cmd"
		local pluginType = meta.pluginType
		local isPluginCmd = pluginType ~= nil
		if not isPluginCmd and NAmanage.IsPluginCommand then
			isPluginCmd = NAmanage.IsPluginCommand(cmdName)
		end
		if isPatched then
			Cmd.TextColor3 = patchedCommandColor
			if Cmd.SetAttribute then
				Cmd:SetAttribute("IsPatchedCommand", true)
				Cmd:SetAttribute("IsPluginCommand", false)
				Cmd:SetAttribute("IsCmdIntegration", false)
			end
			finalText = addPatchedLabel(finalText)
		elseif isCmdIntegration then
			Cmd.TextColor3 = cmdIntegrationColor
			if Cmd.SetAttribute then
				Cmd:SetAttribute("IsCmdIntegration", true)
				Cmd:SetAttribute("IsPatchedCommand", false)
				Cmd:SetAttribute("IsPluginCommand", false)
			end
		elseif isPluginCmd then
			Cmd.TextColor3 = pluginCommandColor
			if Cmd.SetAttribute then
				Cmd:SetAttribute("IsPluginCommand", true)
				Cmd:SetAttribute("IsPatchedCommand", false)
				Cmd:SetAttribute("IsCmdIntegration", false)
			end
		else
			if defaultCmdColor then
				Cmd.TextColor3 = defaultCmdColor
			end
			if Cmd.SetAttribute then
				Cmd:SetAttribute("IsPluginCommand", false)
				Cmd:SetAttribute("IsPatchedCommand", false)
				Cmd:SetAttribute("IsCmdIntegration", false)
			end
		end

		local function resolveDesc()
			local desc = meta.desc
			if desc == nil and tbl and type(tbl[2]) == "table" then
				desc = tbl[2][2]
			end
			if desc ~= nil then
				desc = tostring(desc)
			end
			desc = desc or ""
			if desc ~= "" and isAprilFools() then
				desc = maybeMock(desc)
			end
			return desc
		end

		if Cmd.SetAttribute then
			Cmd:SetAttribute("CmdDesc", resolveDesc())
		end

		Cmd.Text = " "..finalText
		Cmd.Position = UDim2.new(0, 0, 0, yOffset)
		Cmd.Visible = true

		yOffset = yOffset + 20
	end

	for name, label in pairs(pool) do
		if not active[name] and label.Parent == cList then
			label.Visible = false
		end
	end

	cList.CanvasSize = UDim2.new(0, 0, 0, yOffset)
	NAmanage.centerFrame(cFrame)
	if NAgui.filterCommandList then
		NAgui.filterCommandList(NAUIMANAGER.commandsFilter and NAUIMANAGER.commandsFilter.Text or "")
	end
end
NAgui.chatlogs = function()
	if NAUIMANAGER.chatLogsFrame then
		if not NAUIMANAGER.chatLogsFrame.Visible then
			NAUIMANAGER.chatLogsFrame.Visible = true
		end
		--NAUIMANAGER.chatLogsFrame.Position = UDim2.new(0.43, 0, 0.4, 0)
		NAmanage.centerFrame(NAUIMANAGER.chatLogsFrame)
	end
end
NAgui.doModal = function(v)
	NAUIMANAGER.ModalFixer.Modal = v
end
NAgui.consoleeee = function()
	if NAUIMANAGER.NAconsoleFrame then
		if not NAUIMANAGER.NAconsoleFrame.Visible then
			NAUIMANAGER.NAconsoleFrame.Visible = true
		end
		--NAUIMANAGER.NAconsoleFrame.Position = UDim2.new(0.43, 0, 0.4, 0)
		NAmanage.centerFrame(NAUIMANAGER.NAconsoleFrame)
	end
end
NAgui.settingss = function()
	if NAUIMANAGER.SettingsFrame then
		if not NAUIMANAGER.SettingsFrame.Visible then
			NAUIMANAGER.SettingsFrame.Visible = true
		end
		--NAUIMANAGER.SettingsFrame.Position = UDim2.new(0.43, 0, 0.4, 0)
		NAmanage.centerFrame(NAUIMANAGER.SettingsFrame)
	end
end
NAgui.waypointers = function()
	if NAUIMANAGER.WaypointFrame then
		if not NAUIMANAGER.WaypointFrame.Visible then
			NAUIMANAGER.WaypointFrame.Visible = true
		end
		--NAUIMANAGER.WaypointFrame.Position = UDim2.new(0.43, 0, 0.4, 0)
		NAmanage.centerFrame(NAUIMANAGER.WaypointFrame)
	end
end
NAgui.eventbinders = function()
	if NAUIMANAGER.BindersFrame then
		if not NAUIMANAGER.BindersFrame.Visible then
			NAUIMANAGER.BindersFrame.Visible = true
		end
		--NAUIMANAGER.BindersFrame.Position = UDim2.new(0.43, 0, 0.4, 0)
		NAmanage.centerFrame(NAUIMANAGER.BindersFrame)
	end
end
NAgui.tween = function(obj, style, direction, duration, goal, callback)
	style = style or "Sine"
	direction = direction or "Out"
	local tweenInfo = TweenInfo.new(duration, Enum.EasingStyle[style], Enum.EasingDirection[direction])
	local tween = TweenService:Create(obj, tweenInfo, goal)
	if callback then tween.Completed:Connect(callback) end
	tween:Play()
	return tween
end
	NAgui.resizeable = function(ui, min, max)
		if not ui or not ui:IsA("GuiObject") then return function() end end
		min = min or Vector2.new(ui.AbsoluteSize.X, ui.AbsoluteSize.Y)
		max = max or Vector2.new(5000, 5000)

		local screenGui = ui:FindFirstAncestorWhichIsA("ScreenGui") or ui:FindFirstAncestorWhichIsA("LayerCollector") or ui.Parent
		local scale = (NAUIMANAGER.AUTOSCALER and NAUIMANAGER.AUTOSCALER.Scale) or 1
		local mouse
		pcall(function()
			if Players and Players.LocalPlayer then
				mouse = Players.LocalPlayer:GetMouse()
			end
		end)

		local rgui = NAUIMANAGER.resizeFrame and NAUIMANAGER.resizeFrame:Clone()
		if not rgui then return function() end end
	rgui.Parent = screenGui
	rgui.BackgroundTransparency = 1
	rgui.ClipsDescendants = false

	local function updateOverlay()
		local ok = pcall(function()
			if not ui or not ui.Parent or not rgui or not rgui.Parent or not screenGui then
				return
			end
			local absPos = ui.AbsolutePosition
			local absSize = ui.AbsoluteSize
			local rootPos = screenGui.AbsolutePosition or Vector2.new(0, 0)
			local relPos = absPos - rootPos
			rgui.Position = UDim2.new(0, relPos.X, 0, relPos.Y)
			rgui.Size = UDim2.new(0, absSize.X, 0, absSize.Y)
		end)
		if not ok then end
	end

	local function updateVisibility()
		local ok = pcall(function()
			if not ui or not ui.Parent or not rgui or not rgui.Parent then
				return
			end
			rgui.Visible = ui.Visible
		end)
		if not ok then end
	end

	updateOverlay()
	updateVisibility()

	local overlayConns = {}
	pcall(function()
		Insert(overlayConns, ui:GetPropertyChangedSignal("AbsoluteSize"):Connect(updateOverlay))
	end)
	pcall(function()
		Insert(overlayConns, ui:GetPropertyChangedSignal("AbsolutePosition"):Connect(updateOverlay))
	end)
	pcall(function()
		Insert(overlayConns, ui:GetPropertyChangedSignal("Visible"):Connect(updateVisibility))
	end)

	local dragging = false
	local mode
	local UIPos
	local lastSize
	local lastPos = Vector2.new()
	local dragInput
	local dragEndedConn
	local cursorSaved
	local cursorActive = false

	local function isMenuMinimized()
		return ui and ui.GetAttribute and ui:GetAttribute("NAMenuMinimized") == true
	end

	local function ensureMouse()
		if mouse then return mouse end
		pcall(function()
			if Players and Players.LocalPlayer then
				mouse = Players.LocalPlayer:GetMouse()
			end
		end)
		return mouse
	end

	local function setCursor(icon)
		if not ensureMouse() then return end
		if not mouse then return end
		if not cursorActive then
			cursorSaved = mouse.Icon
			cursorActive = true
		end
		mouse.Icon = icon or ""
	end

	local function restoreCursor()
		if not mouse then return end
		if cursorActive then
			mouse.Icon = cursorSaved or ""
			cursorSaved = nil
			cursorActive = false
		elseif mouse.Icon ~= "" then
			mouse.Icon = ""
		end
	end

	local function endDrag()
		dragging = false
		mode = nil
		dragInput = nil
		if dragEndedConn then dragEndedConn:Disconnect() dragEndedConn = nil end
		restoreCursor()
	end

	local function updateResize(currentPos)
		local ok, err = pcall(function()
			if isMenuMinimized() then return end
			if not dragging or not mode or not screenGui or not screenGui.AbsoluteSize then return end
			local map = resizeXY and resizeXY[mode.Name]
			if not map then return end

			local parentSize = screenGui.AbsoluteSize
			local delta = (currentPos - lastPos) / scale

			local resizeDelta = Vector2.new(delta.X * map[1].X, delta.Y * map[1].Y)
			local newSize = Vector2.new(
				math.clamp(lastSize.X + resizeDelta.X, min.X, max.X),
				math.clamp(lastSize.Y + resizeDelta.Y, min.Y, max.Y)
			)

			ui.Size = UDim2.new(0, newSize.X, 0, newSize.Y)

			local dx = (lastSize.X - newSize.X) / parentSize.X
			local dy = (lastSize.Y - newSize.Y) / parentSize.Y

			local sx = UIPos.X.Scale
			local sy = UIPos.Y.Scale
			if map[1].X < 0 then sx = sx + dx end
			if map[1].Y < 0 then sy = sy + dy end

			ui.Position = UDim2.new(sx, 0, sy, 0)
		end)
		if not ok then warn("Resize update failed:", err) end
	end

	pcall(function()
		UserInputService.InputChanged:Connect(function(input)
			pcall(function()
				if dragging and (input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch) then
					updateResize(Vector2.new(input.Position.X, input.Position.Y))
				end
			end)
		end)
	end)

	pcall(function()
		UserInputService.InputEnded:Connect(function(input)
			pcall(function()
				if not dragging then return end
				if input.UserInputType == Enum.UserInputType.MouseButton1 then
					endDrag()
				elseif input.UserInputType == Enum.UserInputType.Touch and input == dragInput then
					endDrag()
				end
			end)
		end)
	end)

	for _, button in ipairs(rgui:GetChildren()) do
		if button:IsA("GuiObject") then
			button.Active = true
			pcall(function()
				button.InputBegan:Connect(function(input)
					pcall(function()
						if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
							mode = button
							dragging = true
							local p = input.Position
							lastPos = Vector2.new(p.X, p.Y)
							lastSize = ui.AbsoluteSize
							UIPos = ui.Position
							dragInput = input
							if dragEndedConn then dragEndedConn:Disconnect() end
							dragEndedConn = input.Changed:Connect(function()
								if input.UserInputState == Enum.UserInputState.End then
									endDrag()
								end
							end)
						end
					end)
				end)
			end)

			pcall(function()
				button.InputEnded:Connect(function(input)
					pcall(function()
						if not dragging or mode ~= button or input.UserInputState ~= Enum.UserInputState.End then return end
						if input.UserInputType == Enum.UserInputType.MouseButton1 then
							endDrag()
						elseif input.UserInputType == Enum.UserInputType.Touch and input == dragInput then
							endDrag()
						end
					end)
				end)
			end)

			pcall(function()
				button.MouseEnter:Connect(function()
					pcall(function()
						local map = resizeXY and resizeXY[button.Name]
						if map then setCursor(map[3]) end
					end)
				end)
			end)

			pcall(function()
				button.MouseLeave:Connect(function()
					pcall(function()
						if not dragging then restoreCursor() end
					end)
				end)
			end)
		end
	end

	return function()
		for _, conn in ipairs(overlayConns) do
			pcall(function() conn:Disconnect() end)
		end
		pcall(function() if dragEndedConn then dragEndedConn:Disconnect() end end)
		pcall(restoreCursor)
		pcall(function() rgui:Destroy() end)
	end
end
NAmanage.UpdateWaypointList=function()
	local list = NAUIMANAGER.WaypointList
	local rawFilter = NAUIMANAGER.filterBox and NAUIMANAGER.filterBox.Text or ""
	local filterText = rawFilter:lower()
	for _, child in ipairs(list:GetChildren()) do
		if not child:IsA("UIListLayout") then
			child:Destroy()
		end
	end
	for name, entry in pairs(Waypoints) do
		if filterText == "" or name:lower():find(filterText, 1, true) then
			local row = NAUIMANAGER.WPFrame:Clone()
			row.Name = name
			row.Parent = list
			local nameBtn = row:FindFirstChildWhichIsA("TextButton")
			if nameBtn then nameBtn.Text = name end
			local actionFrame = row:FindFirstChildWhichIsA("Frame")
			if actionFrame then
				local copyBtn = actionFrame:FindFirstChild("CopyBtn")
				local delBtn = actionFrame:FindFirstChild("DelBtn")
				local tpBtn = actionFrame:FindFirstChild("TPBtn")
				if copyBtn then
					MouseButtonFix(copyBtn, function()
						local comps = entry.Components
						if type(comps) ~= "table" then
							return DebugNotif("Waypoint data missing", 3)
						end
						local posX, posY, posZ = comps[1], comps[2], comps[3]
						if type(posX) ~= "number" or type(posY) ~= "number" or type(posZ) ~= "number" then
							return DebugNotif("Waypoint position is invalid", 3)
						end
						local copyText = Format("%f, %f, %f", posX, posY, posZ)
						if setclipboard then
							pcall(setclipboard, copyText)
							DebugNotif("Copied "..name)
						else
							DebugNotif("Copy not supported")
						end
					end)
				end
				if delBtn then
					MouseButtonFix(delBtn, function()
						Waypoints[name] = nil
						NAmanage.SaveWaypoints()
						NAmanage.UpdateWaypointList()
						DebugNotif("Removed '"..name.."'")
					end)
				end
				if tpBtn then
					MouseButtonFix(tpBtn, function()
						local comps = entry.Components
						local cf = CFrame.new(unpack(comps))
						local char = getChar()
						if char then
							char:PivotTo(cf)
						end
					end)
				end
			end
		end
	end
end

NAgui.addButton = function(label, callback)
	if not NAUIMANAGER.SettingsList then return end
	local button = templates.Button:Clone()
	button.Title.Text = label
	NAmanage.SetSearch.tag(button, label)
	button.Parent = NAUIMANAGER.SettingsList
	button.LayoutOrder = NAgui._nextLayoutOrder()
	NAmanage.registerElementForCurrentTab(button)
	if NAgui.RegisterStrokesFrom then
		NAgui.RegisterStrokesFrom(button)
	end

	MouseButtonFix(button.Interact,function()
		pcall(callback)
	end)
	return button
end

NAgui.addSection = function(titleText)
	if not NAUIMANAGER.SettingsList then return end
	local section = templates.SectionTitle:Clone()
	section.Title.Text = titleText
	pcall(function()
		section:SetAttribute("NASettingsSection", true)
	end)
	NAmanage.SetSearch.tag(section, titleText)
	section.Parent = NAUIMANAGER.SettingsList
	section.LayoutOrder = NAgui._nextLayoutOrder()
	NAmanage.registerElementForCurrentTab(section)
	if NAgui.RegisterStrokesFrom then
		NAgui.RegisterStrokesFrom(section)
	end
end

NAgui.getInputMinWidth=function(frame, fallback)
	fallback = fallback or 32
	if not (frame and frame.GetAttribute) then
		return fallback
	end
	local ok, attr = pcall(function()
		return frame:GetAttribute("NAMinWidth")
	end)
	local minAttr = tonumber(ok and attr or nil)
	if not minAttr then
		return fallback
	end
	return math.max(fallback, minAttr)
end

NAgui.getInputTextWidth=function(box, padding)
	padding = padding or 24
	if not box then
		return padding
	end

	local okBounds, bounds = pcall(function()
		return box.TextBounds
	end)
	if okBounds and bounds and type(bounds.X) == "number" then
		return bounds.X + padding
	end

	if TextService then
		local okSize, size = pcall(function()
			return TextService:GetTextSize(tostring(box.Text or ""), box.TextSize or 14, box.Font or Enum.Font.SourceSans, Vector2.new(1e4, 1e3))
		end)
		if okSize and size and type(size.X) == "number" then
			return size.X + padding
		end
	end

	return 56
end

NAgui.addInfo = function(label, value)
	if not NAUIMANAGER.SettingsList then return nil end

	local info = templates.Input:Clone()
	info.Name = "Info"
	info.Title.Text = label
	NAmanage.SetSearch.tag(info, label)

	info.LayoutOrder = NAgui._nextLayoutOrder()
	info.Parent = NAUIMANAGER.SettingsList
	NAmanage.registerElementForCurrentTab(info)
	if NAgui.RegisterStrokesFrom then
		NAgui.RegisterStrokesFrom(info)
	end

	local frame = info.InputFrame
	if not frame then
		return nil
	end

	local box = frame.InputBox
	if not box then
		return nil
	end

	box.Text = value or ""
	box.PlaceholderText = ""
	box.ClearTextOnFocus = false
	box.TextEditable = false
	box.Active = false
	box.Selectable = false
	box.CursorPosition = -1
	box.TextXAlignment = Enum.TextXAlignment.Center
	box.TextWrapped = false
	box.TextTruncate = Enum.TextTruncate.None
	box.ClipsDescendants = true
	frame.ClipsDescendants = true

	box.Focused:Connect(function()
		box:ReleaseFocus()
	end)

	local lastW

	local function resize()
		if not (info and frame and box) then
			return
		end
		local textW = NAgui.getInputTextWidth(box)
		local minW = NAgui.getInputMinWidth(frame)
		local maxW

		local cw = info.AbsoluteSize.X
		if cw and cw > 0 then
			local tw = (info.Title and info.Title.TextBounds.X or 0)
			local gap = 32
			maxW = cw - tw - gap
		end

		local w = math.max(textW, minW)
		local hit = false
		if maxW then
			local clamped = math.max(minW, math.min(w, maxW))
			hit = clamped >= (maxW - 0.5)
			w = clamped
		end

		box.TextXAlignment = hit and Enum.TextXAlignment.Left or Enum.TextXAlignment.Center

		if type(w) ~= "number" then
			return
		end

		if not lastW or math.abs(lastW - w) > 0.5 then
			lastW = w
			frame.Size = UDim2.new(0, w, 0, 30)
		end
	end

	box:GetPropertyChangedSignal("Text"):Connect(resize)
	info:GetPropertyChangedSignal("AbsoluteSize"):Connect(resize)
	resize()

	local interact = frame:FindFirstChild("Interact")
	if interact then
		interact.Visible = false
	end

	return box, info
end

NAgui._toggleRegistry = NAgui._toggleRegistry or {}
NAgui._colorPickerRegistry = NAgui._colorPickerRegistry or {}
NAgui._sliderRegistry = NAgui._sliderRegistry or {}
NAgui._inputRegistry = NAgui._inputRegistry or {}

NAgui.addToggle = function(label, defaultValue, callback)
	if not NAUIMANAGER.SettingsList then return end
	local toggle = templates.Toggle:Clone()
	local switch = toggle:FindFirstChild("Switch")
	local indicator = switch and switch:FindFirstChild("Indicator")
	local stroke = indicator and indicator:FindFirstChild("UIStroke")

	toggle.Title.Text = label
	NAmanage.SetSearch.tag(toggle, label)
	toggle.Parent = NAUIMANAGER.SettingsList
	toggle.LayoutOrder = NAgui._nextLayoutOrder()
	NAmanage.registerElementForCurrentTab(toggle)

	local state = defaultValue and true or false

	local function updateVisual()
		if state then
			indicator.Position = UDim2.new(1, -20, 0.5, 0)
			indicator.BackgroundColor3 = Color3.fromRGB(60, 200, 80)
			stroke.Color = Color3.fromRGB(50, 255, 80)
		else
			indicator.Position = UDim2.new(1, -40, 0.5, 0)
			indicator.BackgroundColor3 = Color3.fromRGB(111, 111, 121)
			stroke.Color = Color3.fromRGB(80, 80, 80)
		end
	end

	local function setState(newValue, opts)
		opts = opts or {}
		local desired = newValue and true or false
		if not opts.force and state == desired then
			if opts.fire then
				pcall(callback, state)
			end
			return
		end
		state = desired
		updateVisual()
		if opts.fire ~= false then
			pcall(callback, state)
		end
	end

	setState(state, { force = true, fire = false })

	MouseButtonFix(toggle.Interact,function()
		setState(not state, { force = true, fire = true })
	end)

	local entry = {
		button = toggle;
		get = function()
			return state
		end;
		set = function(value, opts)
			opts = opts or {}
			if opts.force == nil then opts.force = true end
			setState(value, opts)
		end;
	}
	NAgui._toggleRegistry[label] = entry

	toggle:GetPropertyChangedSignal("Parent"):Connect(function()
		if not toggle.Parent and NAgui._toggleRegistry[label] == entry then
			NAgui._toggleRegistry[label] = nil
		end
	end)

	return toggle
end

NAgui.setToggleState = function(label, value, opts)
	local entry = NAgui._toggleRegistry and NAgui._toggleRegistry[label]
	if not entry then return end
	entry.set(value, opts)
end

NAgui.addColorPicker = function(label, defaultColor, callback, opts)
	if not NAUIMANAGER.SettingsList then return end

	local cfg = opts or {}

	local picker = templates.ColorPicker:Clone()
	picker.Title.Text = label
	NAmanage.SetSearch.tag(picker, label)
	picker.Parent = NAUIMANAGER.SettingsList
	picker.LayoutOrder = NAgui._nextLayoutOrder()
	NAmanage.registerElementForCurrentTab(picker)

	local bg = picker.CPBackground
	local disp = bg.Display
	local main = bg.MainCP
	local sl = picker.ColorSlider
	local rgb = picker.RGB
	local hex = picker.HexInput

	local rgbTog = picker:FindFirstChild("RGBToggle")
	local rgbBtn, rgbSw, rgbDot, rgbTit

	local function getSaved()
		if type(label) ~= "string" then return nil end
		if not (NAmanage and type(NAmanage.NASettingsGet) == "function") then return nil end
		local st = NAmanage.NASettingsGet("colorPickerAutoRGB")
		if type(st) ~= "table" then return nil end
		local v = st[label]
		if type(v) == "boolean" then return v end
		return nil
	end

	local function saveState(sta)
		if type(label) ~= "string" then return end
		if not (NAmanage and type(NAmanage.NASettingsGet) == "function" and type(NAmanage.NASettingsSet) == "function") then return end
		local st = NAmanage.NASettingsGet("colorPickerAutoRGB")
		if type(st) ~= "table" then st = {} end
		local nxt = {}
		for k,v in pairs(st) do nxt[k] = v end
		nxt[label] = sta and true or false
		NAmanage.NASettingsSet("colorPickerAutoRGB", nxt)
	end

	local function mkTog()
		local f = InstanceNew("Frame")
		f.Name = "RGBToggle"
		f.BackgroundColor3 = Color3.fromRGB(44, 44, 49)
		f.BorderSizePixel = 0
		f.Size = UDim2.new(0, 240, 0, 32)
		f.Position = UDim2.new(0, 20, 0, 115)
		f.ZIndex = 5
		f.Parent = picker

		local c = InstanceNew("UICorner")
		c.Parent = f

		local st = InstanceNew("UIStroke")
		st.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
		st.Color = Color3.fromRGB(71, 71, 71)
		st.Parent = f

		local t = InstanceNew("TextLabel")
		t.Name = "Title"
		t.BackgroundTransparency = 1
		t.Font = Enum.Font.Gotham
		t.TextSize = 14
		t.TextColor3 = Color3.fromRGB(244, 244, 249)
		t.TextXAlignment = Enum.TextXAlignment.Left
		t.AnchorPoint = Vector2.new(0, 0.5)
		t.Position = UDim2.new(0, 12, 0.5, 0)
		t.Size = UDim2.new(1, -60, 0, 16)
		t.Text = "RGB Cycle"
		t.ZIndex = 5
		t.Parent = f

		return f
	end

	if not (rgbTog and rgbTog:IsA("GuiObject")) then
		rgbTog = mkTog()
	end

	rgbTit = rgbTog:FindFirstChild("Title")

	rgbBtn = rgbTog:FindFirstChild("Interact")
	if not (rgbBtn and rgbBtn:IsA("GuiButton")) then
		rgbBtn = InstanceNew("TextButton")
		rgbBtn.Name = "Interact"
		rgbBtn.BackgroundTransparency = 1
		rgbBtn.AutoButtonColor = false
		rgbBtn.BorderSizePixel = 0
		rgbBtn.Text = ""
		rgbBtn.Size = UDim2.new(1, 0, 1, 0)
		rgbBtn.ZIndex = (rgbTog.ZIndex or 1) + 1
		rgbBtn.Parent = rgbTog
	end

	rgbSw = rgbTog:FindFirstChild("Switch")
	if not (rgbSw and rgbSw:IsA("GuiObject")) then
		rgbSw = InstanceNew("Frame")
		rgbSw.Name = "Switch"
		rgbSw.BorderSizePixel = 0
		rgbSw.AnchorPoint = Vector2.new(1, 0.5)
		rgbSw.Position = UDim2.new(1, -12, 0.5, 0)
		rgbSw.Size = UDim2.new(0, 45, 0, 22)
		rgbSw.BackgroundColor3 = Color3.fromRGB(49, 49, 54)
		rgbSw.Parent = rgbTog

		local c = InstanceNew("UICorner")
		c.CornerRadius = UDim.new(0, 12)
		c.Parent = rgbSw

		local st = InstanceNew("UIStroke")
		st.Color = Color3.fromRGB(71, 71, 71)
		st.Parent = rgbSw
	end

	rgbDot = rgbSw:FindFirstChild("Indicator")
	if not (rgbDot and rgbDot:IsA("GuiObject")) then
		rgbDot = InstanceNew("Frame")
		rgbDot.Name = "Indicator"
		rgbDot.BorderSizePixel = 0
		rgbDot.AnchorPoint = Vector2.new(0, 0.5)
		rgbDot.Position = UDim2.new(0, 2, 0.5, 0)
		rgbDot.Size = UDim2.new(0, 18, 0, 18)
		rgbDot.BackgroundColor3 = Color3.fromRGB(114, 114, 124)
		rgbDot.Parent = rgbSw

		local c = InstanceNew("UICorner")
		c.CornerRadius = UDim.new(1, 0)
		c.Parent = rgbDot

		local st = InstanceNew("UIStroke")
		st.Color = Color3.fromRGB(83, 83, 83)
		st.Parent = rgbDot
	end

	local rgbOn = false
	local rgbSpd = 0.1

	local function updTog()
		if rgbSw then
			rgbSw.BackgroundColor3 = rgbOn and Color3.fromRGB(70, 49, 104) or Color3.fromRGB(49, 49, 54)
		end
		if rgbDot then
			local w = rgbDot.Size.X.Offset
			if w == 0 then w = math.max(rgbDot.AbsoluteSize.X, 18) end
			local pad = 2
			rgbDot.Position = rgbOn and UDim2.new(1, -w - pad, 0.5, 0) or UDim2.new(0, pad, 0.5, 0)
			rgbDot.BackgroundColor3 = rgbOn and Color3.fromRGB(154, 99, 255) or Color3.fromRGB(114, 114, 124)
		end
		if rgbTit and rgbTit:IsA("TextLabel") then
			rgbTit.Text = rgbOn and "RGB Cycle (ON)" or "RGB Cycle"
			rgbTit.TextColor3 = rgbOn and Color3.fromRGB(194, 194, 255) or Color3.fromRGB(244, 244, 249)
		end
	end

	local function setRGB(sta, opt)
		opt = opt or {}
		local ns = sta and true or false
		if rgbOn == ns then
			if not opt.skipVis then updTog() end
			return
		end
		rgbOn = ns
		if not opt.skipSave then
			saveState(rgbOn)
		end
		updTog()
	end

	local sv = getSaved()
	if type(sv) == "boolean" then
		setRGB(sv, { skipVis = true, skipSave = true })
	end
	updTog()

	if rgbBtn then
		MouseButtonFix(rgbBtn, function()
			setRGB(not rgbOn)
		end)
	end

	if typeof(defaultColor) ~= "Color3" then
		defaultColor = Color3.fromRGB(255, 255, 255)
	end

	local h, s, v = defaultColor:ToHSV()
	local dM, dS = false, false
	local inM, inS

	local function updUI(push, opt)
		opt = opt or {}
		local col = Color3.fromHSV(h, s, v)
		disp.BackgroundColor3 = col
		bg.BackgroundColor3 = Color3.fromHSV(h, 1, 1)
		main.MainPoint.Position = UDim2.new(s, 0, 1 - v, 0)
		sl.SliderPoint.Position = UDim2.new(h, 0, 0.5, 0)

		local r = math.floor(col.R * 255 + 0.5)
		local g = math.floor(col.G * 255 + 0.5)
		local b = math.floor(col.B * 255 + 0.5)

		if push then
			rgb.RInput.InputBox.Text = tostring(r)
			rgb.GInput.InputBox.Text = tostring(g)
			rgb.BInput.InputBox.Text = tostring(b)
			hex.InputBox.Text = Format("#%02X%02X%02X", r, g, b)
		end

		if opt.fire ~= false then
			pcall(function()
				callback(col, opt)
			end)
		end
	end

	local function parseRGB()
		setRGB(false)
		local r = tonumber(rgb.RInput.InputBox.Text) or 0
		local g = tonumber(rgb.GInput.InputBox.Text) or 0
		local b = tonumber(rgb.BInput.InputBox.Text) or 0
		r = math.clamp(r, 0, 255)
		g = math.clamp(g, 0, 255)
		b = math.clamp(b, 0, 255)
		h, s, v = Color3.fromRGB(r, g, b):ToHSV()
		updUI(false)
	end

	rgb.RInput.InputBox.FocusLost:Connect(parseRGB)
	rgb.GInput.InputBox.FocusLost:Connect(parseRGB)
	rgb.BInput.InputBox.FocusLost:Connect(parseRGB)

	hex.InputBox.FocusLost:Connect(function()
		setRGB(false)
		local txt = (hex.InputBox.Text or ""):gsub("#", ""):upper()
		if txt:match("^[0-9A-F]+$") and #txt == 6 then
			local r = tonumber(txt:sub(1, 2), 16)
			local g = tonumber(txt:sub(3, 4), 16)
			local b = tonumber(txt:sub(5, 6), 16)
			if r and g and b then
				h, s, v = Color3.fromRGB(r, g, b):ToHSV()
				updUI(true)
				return
			end
		end
		local col = Color3.fromHSV(h, s, v)
		hex.InputBox.Text = Format("#%02X%02X%02X",
			math.floor(col.R * 255 + 0.5),
			math.floor(col.G * 255 + 0.5),
			math.floor(col.B * 255 + 0.5)
		)
	end)

	pcall(function() main.MainPoint.AnchorPoint = Vector2.new(0.5, 0.5) end)
	pcall(function() sl.SliderPoint.AnchorPoint = Vector2.new(0.5, 0.5) end)

	local UIS = SafeGetService("UserInputService")
	local RS = SafeGetService("RunService")

	local function v2(p)
		if typeof(p) == "Vector2" then return p end
		if typeof(p) == "Vector3" then return Vector2.new(p.X, p.Y) end
		return UIS and UIS:GetMouseLocation() or Vector2.new(0, 0)
	end

	local function updMain(pos)
		local sz = main.AbsoluteSize
		if sz.X <= 0 or sz.Y <= 0 then return end
		local ap = main.AbsolutePosition
		local rx = math.clamp(pos.X - ap.X, 0, sz.X)
		local ry = math.clamp(pos.Y - ap.Y, 0, sz.Y)
		s = rx / sz.X
		v = 1 - (ry / sz.Y)
		updUI(true)
	end

	local function updSl(pos)
		local sz = sl.AbsoluteSize
		if sz.X <= 0 then return end
		local ap = sl.AbsolutePosition
		local rx = math.clamp(pos.X - ap.X, 0, sz.X)
		h = rx / sz.X
		updUI(true)
	end

	local function hit(obj)
		if obj:IsA("GuiButton") then
			pcall(function() obj.Active = true end)
			return obj
		end
		pcall(function() obj.Active = true end)
		local b = obj:FindFirstChild("__Hit")
		if not (b and b:IsA("TextButton")) then
			b = InstanceNew("TextButton")
			b.Name = "__Hit"
			b.BackgroundTransparency = 1
			b.AutoButtonColor = false
			b.BorderSizePixel = 0
			b.Text = ""
			b.Size = UDim2.new(1, 0, 1, 0)
			b.ZIndex = (obj.ZIndex or 1) + 20
			b.Parent = obj
		end
		return b
	end

	local mHit = hit(main)
	local sHit = hit(sl)
	pcall(function() main.MainPoint.Interactable = false end)
	pcall(function() sl.SliderPoint.Interactable = false end)
	pcall(function() picker.Interact.Interactable = false end)

	local function beg(t, input)
		if input.UserInputType ~= Enum.UserInputType.MouseButton1 and input.UserInputType ~= Enum.UserInputType.Touch then
			return
		end
		setRGB(false)
		if t == "m" then
			dM = true
			inM = input
			updMain(v2(input.Position))
		else
			dS = true
			inS = input
			updSl(v2(input.Position))
		end
	end

	mHit.InputBegan:Connect(function(i) beg("m", i) end)
	sHit.InputBegan:Connect(function(i) beg("s", i) end)

	if UIS then
		UIS.InputChanged:Connect(function(input)
			if dM then
				if inM and inM.UserInputType == Enum.UserInputType.Touch then
					if input == inM then
						updMain(v2(input.Position))
					end
				else
					if input.UserInputType == Enum.UserInputType.MouseMovement then
						updMain(v2(input.Position))
					end
				end
			end
			if dS then
				if inS and inS.UserInputType == Enum.UserInputType.Touch then
					if input == inS then
						updSl(v2(input.Position))
					end
				else
					if input.UserInputType == Enum.UserInputType.MouseMovement then
						updSl(v2(input.Position))
					end
				end
			end
		end)

		UIS.InputEnded:Connect(function(input)
			if input.UserInputType == Enum.UserInputType.MouseButton1 then
				dM, dS = false, false
				inM, inS = nil, nil
				return
			end
			if input.UserInputType == Enum.UserInputType.Touch then
				if inM == input then dM, inM = false, nil end
				if inS == input then dS, inS = false, nil end
			end
		end)
	end

	if RS then
		RS.RenderStepped:Connect(function(dt)
			if rgbOn and not dM and not dS then
				local step = math.clamp(dt or 0.016, 0.001, 0.1)
				h = (h + step * rgbSpd) % 1
				updUI(true)
			end
		end)
	end

	local entry = {
		get = function()
			return Color3.fromHSV(h, s, v)
		end,
		set = function(col, opt)
			if typeof(col) ~= "Color3" then return end
			h, s, v = col:ToHSV()
			updUI(true, opt or {})
		end,
		getAutoRGB = function()
			return rgbOn
		end,
		setAutoRGB = function(sta)
			setRGB(sta)
		end,
	}

	NAgui._colorPickerRegistry[label] = entry

	picker:GetPropertyChangedSignal("Parent"):Connect(function()
		if not picker.Parent and NAgui._colorPickerRegistry[label] == entry then
			NAgui._colorPickerRegistry[label] = nil
		end
	end)

	local initOpts = {
		fire = cfg.fireOnInit ~= false;
		context = "init";
	}
	updUI(true, initOpts)

	return picker
end

NAgui.setColorPickerValue = function(label, color, opts)
	local entry = NAgui._colorPickerRegistry and NAgui._colorPickerRegistry[label]
	if not entry then return end
	entry.set(color, opts or { fire = false })
end

NAgui.setColorPickerAutoRGB = function(label, enabled)
	local entry = NAgui._colorPickerRegistry and NAgui._colorPickerRegistry[label]
	if not entry or not entry.setAutoRGB then return end
	entry.setAutoRGB(enabled)
end

NAgui.getColorPickerAutoRGB = function(label)
	local entry = NAgui._colorPickerRegistry and NAgui._colorPickerRegistry[label]
	if not entry or not entry.getAutoRGB then return nil end
	return entry.getAutoRGB()
end

NAgui.addInput = function(label, placeholder, defaultText, callback)
	if not NAUIMANAGER.SettingsList then return end

	local input = templates.Input:Clone()
	local frame = input.InputFrame
	local box = frame.InputBox

	input.Title.Text = label
	NAmanage.SetSearch.tag(input, label)
	box.Text = defaultText or ""
	box.PlaceholderText = placeholder or ""
	box.TextXAlignment = Enum.TextXAlignment.Center
	box.TextTruncate = Enum.TextTruncate.None

	input.LayoutOrder = NAgui._nextLayoutOrder()
	input.Parent = NAUIMANAGER.SettingsList
	NAmanage.registerElementForCurrentTab(input)

	local lastW

	local function resize()
		if not (input and frame and box) then
			return
		end

		local textW = NAgui.getInputTextWidth(box)
		local minW = NAgui.getInputMinWidth(frame)
		local maxW

		local cw = input.AbsoluteSize.X
		if cw and cw > 0 then
			local tw = (input.Title and input.Title.TextBounds.X or 0)
			local gap = 32
			maxW = cw - tw - gap
		end

		local w = math.max(textW, minW)
		local hit = false
		if maxW then
			local clamped = math.max(minW, math.min(w, maxW))
			hit = clamped >= (maxW - 0.5)
			w = clamped
		end

		box.TextXAlignment = hit and Enum.TextXAlignment.Left or Enum.TextXAlignment.Center

		if type(w) ~= "number" then
			return
		end

		if not lastW or math.abs(lastW - w) > 0.5 then
			lastW = w
			frame.Size = UDim2.new(0, w, 0, 30)
		end
	end

	box.FocusLost:Connect(function()
		pcall(callback, box.Text)
	end)

	box:GetPropertyChangedSignal("Text"):Connect(resize)
	input:GetPropertyChangedSignal("AbsoluteSize"):Connect(resize)

	local function setText(newValue, opts)
		opts = opts or {}
		local text = tostring(newValue or "")
		if not opts.force and box.Text == text then
			if opts.fire then
				pcall(callback, text)
			end
			return
		end
		box.Text = text
		if opts.fire then
			pcall(callback, text)
		end
	end

	local entry = {
		input = input;
		get = function()
			return box.Text
		end;
		set = function(v, opts)
			setText(v, opts)
		end;
	}

	NAgui._inputRegistry[label] = entry

	input:GetPropertyChangedSignal("Parent"):Connect(function()
		if not input.Parent and NAgui._inputRegistry[label] == entry then
			NAgui._inputRegistry[label] = nil
		end
	end)

	resize()

	return input
end

NAgui.setInputValue = function(label, value, opts)
	local entry = NAgui._inputRegistry and NAgui._inputRegistry[label]
	if not entry then return end
	entry.set(value, opts or { fire = false })
end

NAmanage.SyncPrefixUI = function(opts)
	if not (NAgui and NAgui.setInputValue) then return end
	local prefixValue = opt and tostring(opt.prefix or "") or ""
	if prefixValue == "" then
		prefixValue = ";"
	end
	opts = opts or {}
	local setterOpts = {
		force = opts.force ~= false,
		fire = opts.fire == true,
	}
	NAgui.setInputValue("Prefix", prefixValue, setterOpts)
end

NAmanage._uiAutoSync = NAmanage._uiAutoSync or { toggles = {} }

NAmanage.RegisterToggleAutoSync = function(label, getter, opts)
	if type(label) ~= "string" or type(getter) ~= "function" then return end
	local store = NAmanage._uiAutoSync
	local entry = store.toggles[label]
	if not entry then
		entry = { getter = getter, last = nil, opts = opts }
		store.toggles[label] = entry
	else
		entry.getter = getter
		entry.opts = opts or entry.opts
	end
end

NAmanage.RunUIAutoSync = function()
	local store = NAmanage._uiAutoSync
	if not store then return end
	local toggleStore = store.toggles
	if toggleStore and NAgui and NAgui.setToggleState then
		for label, watcher in pairs(toggleStore) do
			local success, rawValue = pcall(watcher.getter)
			if success then
				local normalized = nil
				if watcher.opts and type(watcher.opts.normalize) == "function" then
					local ok, result = pcall(watcher.opts.normalize, rawValue)
					if ok then
						normalized = result
					end
				end
				if normalized == nil then
					normalized = rawValue and true or false
				end
				local registry = NAgui._toggleRegistry
				if registry and registry[label] then
					if watcher.last == nil or watcher.last ~= normalized then
						watcher.last = normalized
						local fireCallback = watcher.opts and watcher.opts.fire == true
						NAgui.setToggleState(label, normalized, {
							force = true,
							fire = fireCallback and true or false,
						})
					end
				else
					watcher.last = nil
				end
			end
		end
	end
end

NAmanage.StartUIAutoSyncLoop = function()
	if NAmanage._uiAutoSyncLoopStarted then return end
	NAmanage._uiAutoSyncLoopStarted = true
	Spawn(function()
		while true do
			local store = NAmanage._uiAutoSync
			local hasToggles = store and store.toggles and next(store.toggles) ~= nil

			if not hasToggles then
				Wait(1)
			else
				Wait(0.25)
				local ok, err = pcall(NAmanage.RunUIAutoSync)
				if not ok then
					warn("[NA] UI auto-sync failed:", err)
				end
			end
		end
	end)
end

NAmanage.StartUIAutoSyncLoop()

NAgui.addKeybind = function(label, defaultKey, callback)
	if not NAUIMANAGER.SettingsList then return end
	local keybind = templates.Keybind:Clone()
	keybind.Title.Text = label
	NAmanage.SetSearch.tag(keybind, label)
	keybind.KeybindFrame.KeybindBox.Text = defaultKey

	keybind.LayoutOrder = NAgui._nextLayoutOrder()
	keybind.Parent = NAUIMANAGER.SettingsList
	NAmanage.registerElementForCurrentTab(keybind)

	local capturing = false

	keybind.KeybindFrame.KeybindBox.Focused:Connect(function()
		capturing = true
		keybind.KeybindFrame.KeybindBox.Text = ""
	end)

	keybind.KeybindFrame.KeybindBox.FocusLost:Connect(function()
		capturing = false
		if keybind.KeybindFrame.KeybindBox.Text == "" then
			keybind.KeybindFrame.KeybindBox.Text = defaultKey
		end
	end)

	UserInputService.InputBegan:Connect(function(input, processed)
		if capturing and input.KeyCode ~= Enum.KeyCode.Unknown then
			local keyName = tostring(input.KeyCode):split(".")[3]
			keybind.KeybindFrame.KeybindBox:ReleaseFocus()
			keybind.KeybindFrame.KeybindBox.Text = keyName
			capturing = false
			pcall(callback, keyName)
		elseif not capturing and keybind.KeybindFrame.KeybindBox.Text ~= "" then
			if tostring(input.KeyCode) == "Enum.KeyCode."..keybind.KeybindFrame.KeybindBox.Text and not processed then
				pcall(callback)
			end
		end
	end)

	keybind.KeybindFrame.KeybindBox:GetPropertyChangedSignal("Text"):Connect(function()
		keybind.KeybindFrame:TweenSize(
			UDim2.new(0, keybind.KeybindFrame.KeybindBox.TextBounds.X + 24, 0, 30),
			Enum.EasingDirection.Out,
			Enum.EasingStyle.Exponential,
			0.2,
			true
		)
	end)
end

NAgui.addSlider = function(label, min, max, defaultValue, increment, suffix, callback)
	if not NAUIMANAGER.SettingsList then return end
	local slider = templates.Slider:Clone()
	slider.Title.Text = label
	NAmanage.SetSearch.tag(slider, label)

	slider.LayoutOrder = NAgui._nextLayoutOrder()
	slider.Parent = NAUIMANAGER.SettingsList
	NAmanage.registerElementForCurrentTab(slider)

	local interact = slider.Main.Interact
	local progress = slider.Main.Progress
	local infoText = slider.Main.Information

	local dragging = false
	local currentValue = defaultValue
	local step = tonumber(increment) or 0
	local range = max - min

	local function quantize(value)
		if step == 0 then
			return math.clamp(value, min, max)
		end
		local scaled = (value - min) / step
		local rounded = math.floor(scaled + 0.5)
		local quantized = min + rounded * step
		if quantized < min then quantized = min end
		if quantized > max then quantized = max end
		return quantized
	end

	local function applyValue(value, opts)
		opts = opts or {}
		local quantized = quantize(value)
		currentValue = quantized
		local percent = (range ~= 0) and ((quantized - min) / range) or 0
		progress.Size = UDim2.new(percent, 0, 1, 0)
		infoText.Text = Format("%.14g", quantized)..(suffix or "")
		if opts.fire ~= false then
			pcall(callback, quantized)
		end
	end

	local function updateSliderValueFromPos(x)
		local relX = math.clamp(x - interact.AbsolutePosition.X, 0, interact.AbsoluteSize.X)
		local percent = relX / interact.AbsoluteSize.X
		local value = min + range * percent
		applyValue(value)
	end

	interact.InputBegan:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
			dragging = true
		end
	end)

	interact.InputEnded:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
			dragging = false
		end
	end)

	RunService.RenderStepped:Connect(function()
		if dragging then
			updateSliderValueFromPos(UserInputService:GetMouseLocation().X)
		end
	end)

	applyValue(defaultValue, { fire = false })

	local entry = {
		get = function()
			return currentValue
		end;
		set = function(value, opts)
			applyValue(value, opts or {})
		end;
	}
	NAgui._sliderRegistry[label] = entry

	slider:GetPropertyChangedSignal("Parent"):Connect(function()
		if not slider.Parent and NAgui._sliderRegistry[label] == entry then
			NAgui._sliderRegistry[label] = nil
		end
	end)

	return slider
end

NAgui.setSliderValue = function(label, value, opts)
	local entry = NAgui._sliderRegistry and NAgui._sliderRegistry[label]
	if not entry then return end
	entry.set(value, opts or { fire = false })
end

NAmanage.Topbar_PlayTween=function(key,instance,info,props)
	NAmanage._tweens=NAmanage._tweens or {}
	if NAmanage._tweens[key] then NAmanage._tweens[key]:Cancel() end
	local t=TweenService:Create(instance,info,props)
	NAmanage._tweens[key]=t
	t:Play()
	return t
end

NAmanage.Topbar_ButtonCount=function()
	local n=0
	for _ in ipairs(TopBarApp.buttonDefs) do n+=1 end
	return n
end

NAmanage.Topbar_ComputedSize=function()
	local pad=8
	local count=NAmanage.Topbar_ButtonCount()
	local cam=workspace.CurrentCamera
	local vpX=cam and cam.ViewportSize.X or 1280
	local margin=8
	if TopBarApp.mode=="bottom" then
		local tile=44
		local cols=math.max(1, math.min(5, count))
		local rows=math.max(1, math.min(5, math.ceil(count/5)))
		local w=cols*tile+(cols-1)*pad+12
		local h=rows*tile+(rows-1)*pad+12
		w=math.min(w, vpX - margin*2)
		return w,h
	else
		local tile = 48
		local visible = math.max(1, math.min(4, count))
		local w = visible*tile + (visible-1)*pad + 12
		local h = tile + 12
		local maxW = vpX - margin*2
		if w > maxW then
			w = maxW
		end
		return w,h
	end
end

function Topbar_GetMaxOffset()
	if not (TopBarApp and TopBarApp.frame and TopBarApp.toggle) then
		return nil
	end
	local fw = TopBarApp.frame.AbsoluteSize.X
	local bw = TopBarApp.toggle.AbsoluteSize.X
	if fw <= 0 then
		return nil
	end
	local maxOffset = (fw - bw) * 0.5
	if maxOffset < 0 then
		maxOffset = 0
	end
	return maxOffset
end

NAmanage.Topbar_SavePositionPreference=function(opts)
	opts = opts or {}
	if not NATopbarKeepPosition and not opts.force then
		return
	end
	local maxOffset = Topbar_GetMaxOffset()
	if not maxOffset then
		return
	end
	local offset = opts.offset
	if type(offset) ~= "number" then
		if not (TopBarApp and TopBarApp.toggle) then
			return
		end
		offset = TopBarApp.toggle.Position.X.Offset
	end
	local ratio = 0
	if maxOffset > 0 then
		ratio = math.clamp(offset / maxOffset, -1, 1)
	end
	NATopbarPositionRatio = ratio
	NAmanage.NASettingsSet("topbarPositionRatio", ratio)
end

NAmanage.Topbar_ResetPositionPreference=function()
	NATopbarPositionRatio = 0
	NAmanage.NASettingsSet("topbarPositionRatio", 0)
	if TopBarApp and TopBarApp.toggle then
		local pos = TopBarApp.toggle.Position
		TopBarApp.toggle.Position = UDim2.new(0.5, 0, pos.Y.Scale, pos.Y.Offset)
		if TopBarApp.isOpen then
			NAmanage.Topbar_PositionPanel()
		end
	end
end

NAmanage.Topbar_ApplySavedPosition=function()
	if not NATopbarKeepPosition then
		return
	end
	local maxOffset = Topbar_GetMaxOffset()
	if not maxOffset then
		return
	end
	local ratio = math.clamp(NATopbarPositionRatio or 0, -1, 1)
	local offset = ratio * maxOffset
	if TopBarApp and TopBarApp.toggle then
		local pos = TopBarApp.toggle.Position
		TopBarApp.toggle.Position = UDim2.new(0.5, offset, pos.Y.Scale, pos.Y.Offset)
		if TopBarApp.isOpen then
			NAmanage.Topbar_PositionPanel()
		end
	end
end

NAmanage.Topbar_ApplyDock=function(dock)
	dock = dock == "bottom" and "bottom" or "top"
	NATopbarDock = dock
	TopBarApp.dock = dock
	NAmanage.topbar_writeDock(dock)
	if TopBarApp.frame then
		TopBarApp.frame.AnchorPoint = Vector2.new(0, dock == "bottom" and 1 or 0)
		TopBarApp.frame.Position = dock == "bottom" and UDim2.new(0,0,1,0) or UDim2.new(0,0,0,0)
	end
	if TopBarApp.toggle then
		local currentX = TopBarApp.toggle.Position.X.Offset
		local anchor = dock == "bottom" and Vector2.new(0.5,1) or Vector2.new(0.5,0)
		local yScale = dock == "bottom" and 1 or 0
		local yOffset = dock == "bottom" and -10 or 10
		TopBarApp.toggle.AnchorPoint = anchor
		TopBarApp.toggle.Position = UDim2.new(0.5, currentX, yScale, yOffset)
	end
	if NATopbarKeepPosition then
		NAmanage.Topbar_ApplySavedPosition()
	else
		NAmanage.Topbar_ClampToggle()
	end
	if TopBarApp.isOpen then
		NAmanage.Topbar_PositionPanel()
	end
end

NAmanage.Topbar_ChooseSide=function()
	local cam=workspace.CurrentCamera
	if not cam then return end
	local vp=cam.ViewportSize
	local ap,sz=TopBarApp.toggle.AbsolutePosition,TopBarApp.toggle.AbsoluteSize
	local w=NAmanage.Topbar_ComputedSize()
	local canRight=(ap.X+sz.X+8+w)<= (vp.X-8)
	local canLeft=(ap.X-8-w)>=8
	if TopBarApp.sidePref=="right" and not canRight and canLeft then
		TopBarApp.sidePref="left"
	elseif TopBarApp.sidePref=="left" and not canLeft and canRight then
		TopBarApp.sidePref="right"
	elseif not canRight and canLeft then
		TopBarApp.sidePref="left"
	elseif canRight and not canLeft then
		TopBarApp.sidePref="right"
	end
end

NAmanage.Topbar_PositionPanel=function()
	if not (TopBarApp.panel and TopBarApp.toggle) then return end

	local cam = workspace.CurrentCamera
	if not cam then return end

	local vp = cam.ViewportSize
	local tap, tsz = TopBarApp.toggle.AbsolutePosition, TopBarApp.toggle.AbsoluteSize
	local w, h = NAmanage.Topbar_ComputedSize()
	local marginX, gap = 8, 10
	local dock = TopBarApp.dock or NATopbarDock or "top"

	if TopBarApp.mode == "bottom" then
		TopBarApp.panel.Parent = TopBarApp.toggle
		TopBarApp.panel.Size = UDim2.new(0, w, 0, TopBarApp.isOpen and h or 0)

		local openDown = dock ~= "bottom"
		TopBarApp.panel.AnchorPoint = openDown and Vector2.new(0.5, 0) or Vector2.new(0.5, 1)
		TopBarApp.panel.Position = openDown
			and UDim2.new(0.5, 0, 1, gap)
			or  UDim2.new(0.5, 0, 0, -gap)

		local ap = TopBarApp.panel.AbsolutePosition
		local aw = TopBarApp.panel.AbsoluteSize.X
		local dx = 0

		if ap.X < marginX then
			dx = marginX - ap.X
		end
		if ap.X + aw > vp.X - marginX then
			dx = (vp.X - marginX) - (ap.X + aw)
		end

		if dx ~= 0 then
			if openDown then
				TopBarApp.panel.Position = UDim2.new(0.5, dx, 1, gap)
			else
				TopBarApp.panel.Position = UDim2.new(0.5, dx, 0, -gap)
			end
		end
	else
		TopBarApp.panel.Parent = TopBarApp.top
		TopBarApp.panel.Size = UDim2.new(0, w, 0, TopBarApp.isOpen and h or 0)

		local canRight = (tap.X + tsz.X + gap + w) <= vp.X - marginX
		local canLeft  = (tap.X - gap - w) >= marginX

		if TopBarApp.sidePref == "right" and not canRight and canLeft then
			TopBarApp.sidePref = "left"
		elseif TopBarApp.sidePref == "left" and not canLeft and canRight then
			TopBarApp.sidePref = "right"
		elseif not canRight and not canLeft then
			TopBarApp.sidePref = ((vp.X - (tap.X + tsz.X)) >= tap.X) and "right" or "left"
		end

		local dock  = TopBarApp.dock or NATopbarDock or "top"
		local baseY = tap.Y + tsz.Y*0.5
		local y

		if dock == "bottom" then
			y = math.max(baseY + 55, h*0.5 + 4)
		else
			y = math.clamp(baseY, h*0.5 + 8, vp.Y - h*0.5 - 8)
		end

		if TopBarApp.sidePref == "right" then
			TopBarApp.panel.AnchorPoint = Vector2.new(0, 0.5)
			local x = math.min(tap.X + tsz.X + gap, vp.X - marginX - w)
			TopBarApp.panel.Position = UDim2.new(0, x, 0, y)
		else
			TopBarApp.panel.AnchorPoint = Vector2.new(1, 0.5)
			local x = math.max(tap.X - gap, marginX + w)
			TopBarApp.panel.Position = UDim2.new(0, x, 0, y)
		end
	end
end

NAmanage.Topbar_AnimateIcon=function(iconText)
	local ti=TweenInfo.new(0.1,Enum.EasingStyle.Sine,Enum.EasingDirection.Out)
	local ti2=TweenInfo.new(0.1,Enum.EasingStyle.Sine,Enum.EasingDirection.InOut)
	NAmanage.Topbar_PlayTween("icon_shrink",TopBarApp.icon,ti,{TextSize=0}).Completed:Wait()
	TopBarApp.icon.Text=iconText or ""
	TopBarApp.icon.TextSize=0
	NAmanage.Topbar_PlayTween("icon_grow",TopBarApp.icon,ti2,{TextSize=24})
end

NAmanage.Topbar_UpdateToggleVisual=function(open)
	local ti=TweenInfo.new(0.1,Enum.EasingStyle.Sine,Enum.EasingDirection.InOut)
	local function clamp01(v, fallback)
		local n = tonumber(v)
		if n == nil then return fallback end
		if n < 0 then n = 0 elseif n > 1 then n = 1 end
		return n
	end
	local baseGlass = clamp01(NAStuff.TopbarGlassTransparency or 0.12, 0.12)
	local baseStroke = clamp01(NAStuff.TopbarStrokeTransparency or 0.15, 0.15)
	local bgTarget=open and math.max(0, baseGlass - 0.06) or baseGlass
	local strokeT=open and math.max(0, baseStroke - 0.1) or baseStroke
	NAmanage.Topbar_PlayTween("tglass_bg",TopBarApp.tGlass,ti,{BackgroundTransparency=bgTarget})
	if TopBarApp.tStroke then NAmanage.Topbar_PlayTween("tglass_stroke",TopBarApp.tStroke,ti,{Transparency=strokeT}) end
	local CLOSED_ICON="three-bars-horizontal"
	local OPENED_ICON="twitter"
	if open then
		NAmanage.Topbar_AnimateIcon(OPENED_ICON)
	else
		NAmanage.Topbar_AnimateIcon(CLOSED_ICON)
	end
end

NAmanage.Topbar_SetOpen=function(state)
	if not TopBarApp.panel then return end
	TopBarApp.isOpen=state
	local w,h=NAmanage.Topbar_ComputedSize()
	TopBarApp.panel.Visible=true
	TopBarApp.underlay.Visible = state
	TopBarApp.scroll.Visible = state
	TopBarApp.underlay.ZIndex=201
	TopBarApp.scroll.ZIndex=202
	NAlib.disconnect("tb_follow")
	TopBarApp.animating=true
	NAmanage.Topbar_PositionPanel()
	local ts=TweenService
	local dur=0.18
	local ease=TweenInfo.new(dur,Enum.EasingStyle.Sine,Enum.EasingDirection.InOut)
	if state then
		TopBarApp.panel.Size=UDim2.new(0,w,0,0)
		local tween=ts:Create(TopBarApp.panel,ease,{Size=UDim2.new(0,w,0,h)})
		tween:Play()
		tween.Completed:Connect(function()
			TopBarApp.animating=false
		end)
		NAlib.connect("tb_follow",RunService.RenderStepped:Connect(function()
			NAmanage.Topbar_PositionPanel()
		end))
	else
		local tween=ts:Create(TopBarApp.panel,ease,{Size=UDim2.new(0,w,0,0)})
		tween:Play()
		tween.Completed:Connect(function()
			if not TopBarApp.isOpen then TopBarApp.panel.Visible=false end
			TopBarApp.animating=false
		end)
	end
	NAmanage.Topbar_UpdateToggleVisual(state)
end

NAmanage.Topbar_Toggle=function()
	NAmanage.Topbar_SetOpen(not TopBarApp.isOpen)
end

NAmanage.Topbar_Rebuild=function()
	if TopBarApp.scroll then TopBarApp.scroll:Destroy() TopBarApp.scroll=nil end
	TopBarApp.scroll=InstanceNew("ScrollingFrame",TopBarApp.panel)
	TopBarApp.scroll.BackgroundTransparency=1
	TopBarApp.scroll.BorderSizePixel=0
	TopBarApp.scroll.Size=UDim2.new(1,0,1,0)
	TopBarApp.scroll.ZIndex=202
	TopBarApp.scroll.ScrollBarThickness=4
	for _,c in ipairs(TopBarApp.scroll:GetChildren()) do c:Destroy() end
	for btn,_ in pairs(TopBarApp.childButtons) do TopBarApp.childButtons[btn]=nil end
	local pad=InstanceNew("UIPadding",TopBarApp.scroll)
	pad.PaddingTop=UDim.new(0,6)
	pad.PaddingBottom=UDim.new(0,6)
	pad.PaddingLeft=UDim.new(0,6)
	pad.PaddingRight=UDim.new(0,6)
	if TopBarApp.layout then TopBarApp.layout:Destroy() TopBarApp.layout=nil end
	local tileBottom=44
	local tileSide=48
	if TopBarApp.mode=="bottom" then
		TopBarApp.scroll.ScrollingDirection=Enum.ScrollingDirection.Y
		local grid=InstanceNew("UIGridLayout",TopBarApp.scroll)
		grid.CellSize=UDim2.new(0,tileBottom,0,tileBottom)
		grid.CellPadding=UDim2.new(0,8,0,8)
		grid.HorizontalAlignment=Enum.HorizontalAlignment.Center
		grid.VerticalAlignment=Enum.VerticalAlignment.Top
		grid.SortOrder=Enum.SortOrder.LayoutOrder
		TopBarApp.layout=grid
	else
		TopBarApp.scroll.ScrollingDirection = Enum.ScrollingDirection.X
		local list = InstanceNew("UIListLayout", TopBarApp.scroll)
		list.FillDirection = Enum.FillDirection.Horizontal
		list.HorizontalAlignment = Enum.HorizontalAlignment.Left
		list.VerticalAlignment = Enum.VerticalAlignment.Center
		list.Padding = UDim.new(0,8)
		list.SortOrder = Enum.SortOrder.LayoutOrder
		TopBarApp.layout = list
	end
	local i=0
	for _,def in ipairs(TopBarApp.buttonDefs) do
		i+=1
		local btn=InstanceNew("TextButton",TopBarApp.scroll)
		btn.Name=def.name.."Btn"
		btn.Size=UDim2.new(0, TopBarApp.mode=="bottom" and tileBottom or tileSide, 0, TopBarApp.mode=="bottom" and tileBottom or tileSide)
		btn.BackgroundTransparency=1
		btn.BorderSizePixel=0
		btn.LayoutOrder=i
		btn.Text=''
		btn.TextTransparency=1
		btn.ZIndex=205
		local bg=InstanceNew("Frame",btn)
		bg.ZIndex=203
		bg.Size=UDim2.new(1,0,1,0)
		bg.BackgroundColor3=Color3.fromRGB(25,25,28)
		bg.BackgroundTransparency=0.18
		bg.BorderSizePixel=0
		local cr=InstanceNew("UICorner",bg); cr.CornerRadius=UDim.new(0,12)
		local stroke=InstanceNew("UIStroke",bg)
		stroke.Thickness=1
		stroke.Color=NAUISTROKER or Color3.fromRGB(148,93,255)
		stroke.Transparency=0.15
		NAgui.RegisterColoredStroke(stroke)
		local ic=InstanceNew("TextLabel",bg)
		ic.ZIndex=204
		ic.BackgroundTransparency=1
		ic.Size=UDim2.new(0.65,0,0.65,0)
		ic.Position=UDim2.new(0.5,0,0.5,0)
		ic.AnchorPoint=Vector2.new(0.5,0.5)
		ic.FontFace=TopBarApp.icon.FontFace
		ic.Text=def.icon or def.name or ""
		ic.TextColor3=Color3.new(1,1,1)
		ic.TextScaled=false
		ic.TextSize=24
		TopBarApp.childButtons[btn]=def.func
		MouseButtonFix(btn,def.func)
	end
	local function updateCanvas()
		if TopBarApp.mode == "bottom" then
			TopBarApp.scroll.CanvasSize = UDim2.new(0,0,0,TopBarApp.layout.AbsoluteContentSize.Y+12)
		else
			TopBarApp.scroll.CanvasSize = UDim2.new(0,TopBarApp.layout.AbsoluteContentSize.X+12,0,0)
		end
		if not TopBarApp.animating then
			NAmanage.Topbar_PositionPanel()
		end
	end
	NAlib.disconnect("tb_canvas")
	NAlib.connect("tb_canvas",TopBarApp.layout:GetPropertyChangedSignal("AbsoluteContentSize"):Connect(updateCanvas))
	updateCanvas()
end

NAmanage.Topbar_AddButton=function(def)
	TopBarApp.buttonDefs[#TopBarApp.buttonDefs+1]=def
	NAmanage.Topbar_Rebuild()
	NAmanage.SideSwipe_Rebuild()
	if TopBarApp.isOpen then NAmanage.Topbar_PositionPanel() end
end

NAmanage.Topbar_ClampToggle=function()
	if not (TopBarApp and TopBarApp.frame and TopBarApp.toggle) then
		return
	end
	if NATopbarKeepPosition then
		NAmanage.Topbar_ApplySavedPosition()
		return
	end
	local fw=TopBarApp.frame.AbsoluteSize.X
	local bw=TopBarApp.toggle.AbsoluteSize.X
	local maxOffset=math.max((fw-bw)*0.5,0)
	local off=math.clamp(TopBarApp.toggle.Position.X.Offset,-maxOffset,maxOffset)
	local pos=TopBarApp.toggle.Position
	TopBarApp.toggle.Position=UDim2.new(0.5,off,pos.Y.Scale,pos.Y.Offset)
	if TopBarApp.isOpen then
		NAmanage.Topbar_PositionPanel()
	end
end

NAmanage.Topbar_MakeDraggableHorizontal=function(ui)
	local dragging=false
	local dragInput,dragStart,startPos
	ui.InputBegan:Connect(function(input)
		if input.UserInputType==Enum.UserInputType.MouseButton1 or input.UserInputType==Enum.UserInputType.Touch then
			dragging=true
			dragStart=input.Position
			startPos=ui.Position
			input.Changed:Connect(function()
				if input.UserInputState==Enum.UserInputState.End then
					dragging=false
					if NATopbarKeepPosition then
						NAmanage.Topbar_SavePositionPreference()
					end
				end
			end)
		end
	end)
	ui.InputChanged:Connect(function(input)
		if input.UserInputType==Enum.UserInputType.MouseMovement or input.UserInputType==Enum.UserInputType.Touch then
			dragInput=input
		end
	end)
	local lastStep=0
	UserInputService.InputChanged:Connect(function(input)
		if input==dragInput and dragging then
			local now=os.clock()
			if now-lastStep<(1/60) then return end
			lastStep=now
			local delta=input.Position-dragStart
			local fw=TopBarApp.frame.AbsoluteSize.X
			local bw=ui.AbsoluteSize.X
			local base=startPos.X.Offset
			local newX=math.clamp(base+delta.X,-(fw-bw)/2,(fw-bw)/2)
			ui.Position=UDim2.new(0.5,newX,startPos.Y.Scale,startPos.Y.Offset)
			if TopBarApp.isOpen then NAmanage.Topbar_PositionPanel() end
		end
	end)
	ui.Active=true
end

NAmanage.Topbar_SetMode=function(mode)
	if mode~="bottom" and mode~="side" then return end
	TopBarApp.mode=mode
	NAmanage.topbar_writeMode(mode)
	NAmanage.Topbar_Rebuild()
	if TopBarApp.isOpen then NAmanage.Topbar_PositionPanel() end
end

NAmanage.Topbar_SetDock=function(dock)
	dock = dock == "bottom" and "bottom" or "top"
	NATopbarDock = dock
	TopBarApp.dock = dock
	NAmanage.topbar_writeDock(dock)
	NAmanage.Topbar_ApplyDock(dock)
end

NAmanage.Topbar_BuildBaseButtons=function()
	return {
		{name="settings",icon="gear",func=function()
			if NAUIMANAGER.SettingsFrame then
				NAUIMANAGER.SettingsFrame.Visible=not NAUIMANAGER.SettingsFrame.Visible
				NAmanage.centerFrame(NAUIMANAGER.SettingsFrame)
			end
		end},
		{name="cmds",icon="list-bulleted",func=NAgui.commands},
		{name="chatlogs",icon="speech-bubble-align-center",func=function()
			if NAUIMANAGER.chatLogsFrame then
				NAUIMANAGER.chatLogsFrame.Visible=not NAUIMANAGER.chatLogsFrame.Visible
				NAmanage.centerFrame(NAUIMANAGER.chatLogsFrame)
			end
		end},
		{name="console",icon="pencil-square",func=function()
			if NAUIMANAGER.NAconsoleFrame then
				NAUIMANAGER.NAconsoleFrame.Visible=not NAUIMANAGER.NAconsoleFrame.Visible
				NAmanage.centerFrame(NAUIMANAGER.NAconsoleFrame)
			end
		end},
		{name="waypp",icon="location-pin",func=function()
			if NAUIMANAGER.WaypointFrame then
				NAUIMANAGER.WaypointFrame.Visible=not NAUIMANAGER.WaypointFrame.Visible
				NAmanage.centerFrame(NAUIMANAGER.WaypointFrame)
			end
		end},
		{name="bindd",icon="hammer-code",func=function()
			if NAUIMANAGER.BindersFrame then
				NAUIMANAGER.BindersFrame.Visible=not NAUIMANAGER.BindersFrame.Visible
				NAmanage.centerFrame(NAUIMANAGER.BindersFrame)
			end
		end},
	}
end

NAmanage.Topbar_Init=function()
	if TopBarApp.top and TopBarApp.top.Parent then TopBarApp.top:Destroy() end
	NATopbarDock = NAmanage.topbar_readDock()
	TopBarApp.top=InstanceNew("ScreenGui")
	TopBarApp.top.Name="NA_Topbar_Styled"
	TopBarApp.top.ZIndexBehavior=Enum.ZIndexBehavior.Global
	TopBarApp.top.DisplayOrder=9999
	TopBarApp.top.IgnoreGuiInset=true
	NaProtectUI(TopBarApp.top)
	TopBarApp.top.Enabled=NATOPBARVISIBLE
	TopBarApp.frame=InstanceNew("Frame")
	TopBarApp.frame.Size=UDim2.new(1,0,0,36)
	TopBarApp.frame.Position=UDim2.new(0,0,0,0)
	TopBarApp.frame.BackgroundTransparency=1
	TopBarApp.frame.Parent=TopBarApp.top
	TopBarApp.toggle=InstanceNew("TextButton",TopBarApp.frame)
	TopBarApp.toggle.Name="TopbarToggle"
	TopBarApp.toggle.Size=UDim2.new(0,42,0,42)
	TopBarApp.toggle.Position=UDim2.new(0.5,0,0,10)
	TopBarApp.toggle.AnchorPoint=Vector2.new(0.5,0)
	TopBarApp.toggle.BackgroundTransparency=1
	TopBarApp.toggle.BorderSizePixel=0
	TopBarApp.toggle.ClipsDescendants=false
	TopBarApp.toggle.ZIndex=110
	TopBarApp.toggle.Text=''
	TopBarApp.toggle.TextTransparency=1
	TopBarApp.tGlass=InstanceNew("Frame",TopBarApp.toggle)
	TopBarApp.tGlass.Size=UDim2.new(1,0,1,0)
	TopBarApp.tGlass.BackgroundColor3=Color3.fromRGB(20,20,24)
	TopBarApp.tGlass.BackgroundTransparency=NAStuff.TopbarGlassTransparency or 0.12
	TopBarApp.tGlass.ZIndex=111
	local tCorner=InstanceNew("UICorner",TopBarApp.tGlass); tCorner.CornerRadius=UDim.new(0.5,0)
	TopBarApp.tStroke=InstanceNew("UIStroke",TopBarApp.tGlass)
	TopBarApp.tStroke.Thickness=1.25
	TopBarApp.tStroke.Color=NAUISTROKER or Color3.fromRGB(148,93,255)
	TopBarApp.tStroke.Transparency=NAStuff.TopbarStrokeTransparency or 0.15
	NAgui.RegisterColoredStroke(TopBarApp.tStroke)
	TopBarApp.icon=InstanceNew("TextLabel",TopBarApp.toggle)
	TopBarApp.icon.AnchorPoint=Vector2.new(0.5,0.5)
	TopBarApp.icon.Position=UDim2.new(0.5,0,0.5,0)
	TopBarApp.icon.Size=UDim2.new(0.8,0,0.8,0)
	TopBarApp.icon.BackgroundTransparency=1
	TopBarApp.icon.ZIndex=112
	TopBarApp.icon.FontFace=Font.new("rbxasset://LuaPackages/Packages/_Index/BuilderIcons/BuilderIcons/BuilderIcons.json",Enum.FontWeight.Bold,Enum.FontStyle.Normal)
	TopBarApp.icon.TextColor3=Color3.new(1,1,1)
	TopBarApp.icon.TextScaled=false
	TopBarApp.icon.TextSize=24
	TopBarApp.dock = NATopbarDock or TopBarApp.dock or "top"
	NAmanage.Topbar_ApplyDock(TopBarApp.dock)
	TopBarApp.panel=InstanceNew("Frame",TopBarApp.top)
	TopBarApp.panel.Visible=false
	TopBarApp.panel.ClipsDescendants=true
	TopBarApp.panel.BackgroundTransparency=1
	TopBarApp.panel.ZIndex=200
	TopBarApp.underlay=InstanceNew("Frame",TopBarApp.panel)
	TopBarApp.underlay.Size=UDim2.new(1,0,1,0)
	TopBarApp.underlay.BackgroundColor3=Color3.fromRGB(18,18,22)
	TopBarApp.underlay.BackgroundTransparency=0.1
	TopBarApp.underlay.ZIndex=201
	local pCorner=InstanceNew("UICorner",TopBarApp.underlay); pCorner.CornerRadius=UDim.new(0,12)
	local pStroke=InstanceNew("UIStroke",TopBarApp.underlay)
	pStroke.Thickness=1
	pStroke.Color=NAUISTROKER or Color3.fromRGB(148,93,255)
	pStroke.Transparency=0.2
	NAgui.RegisterColoredStroke(pStroke)
	TopBarApp.buttonDefs=NAmanage.Topbar_BuildBaseButtons()
	NAmanage.Topbar_Rebuild()
	NAmanage.Topbar_SetOpen(false)
	MouseButtonFix(TopBarApp.toggle,NAmanage.Topbar_Toggle)
	NAmanage.Topbar_MakeDraggableHorizontal(TopBarApp.toggle)
	NAmanage.Topbar_ClampToggle()
	NAlib.connect("tb_repos_frame",TopBarApp.frame:GetPropertyChangedSignal("AbsoluteSize"):Connect(function()
		NAmanage.Topbar_ClampToggle()
		if TopBarApp.isOpen then NAmanage.Topbar_PositionPanel() end
	end))
	if workspace.CurrentCamera then
		NAlib.connect("tb_repos_vp",workspace.CurrentCamera:GetPropertyChangedSignal("ViewportSize"):Connect(function()
			NAmanage.Topbar_ClampToggle()
			if TopBarApp.isOpen then NAmanage.Topbar_PositionPanel() end
		end))
	end
end

NAmanage.Topbar_Destroy=function()
	NAlib.disconnect("tb_canvas")
	NAlib.disconnect("tb_repos_frame")
	NAlib.disconnect("tb_repos_vp")
	NAlib.disconnect("tb_follow")
	if TopBarApp and TopBarApp.top then TopBarApp.top:Destroy() end
	TopBarApp={ top=nil; frame=nil; toggle=nil; tGlass=nil; tStroke=nil; icon=nil; panel=nil; underlay=nil; scroll=nil; layout=nil; isOpen=false; childButtons={}; buttonDefs={}, mode=NAmanage.topbar_readMode(), sidePref="right", dock=NAmanage.topbar_readDock() }
end

NAmanage.SideSwipe_GetButtons=function()
	if TopBarApp and TopBarApp.buttonDefs and #TopBarApp.buttonDefs > 0 then
		return TopBarApp.buttonDefs
	end
	return NAmanage.Topbar_BuildBaseButtons()
end

NAmanage.SideSwipe_PositionHandles=function()
	if not (SideSwipeApp.gui and (SideSwipeApp.handles.left or SideSwipeApp.handles.right)) then return end
	local cam = workspace.CurrentCamera
	local vp = cam and cam.ViewportSize or Vector2.new(1280, 720)
	local y = vp.Y * 0.5
	local inset = 6
	local handleH = math.clamp(vp.Y * 0.22, 90, 180)
	if SideSwipeApp.handles.left then
		SideSwipeApp.handles.left.Position = UDim2.new(0, inset, 0, y)
		SideSwipeApp.handles.left.Size = UDim2.new(0, 16, 0, handleH)
	end
	if SideSwipeApp.handles.right then
		SideSwipeApp.handles.right.Position = UDim2.new(1, -inset, 0, y)
		SideSwipeApp.handles.right.Size = UDim2.new(0, 16, 0, handleH)
	end
end

NAmanage.SideSwipe_UpdateHandleColors=function(color)
	local mainColor = typeof(color) == "Color3" and color or NAUISTROKER or DEFAULT_UI_STROKE_COLOR or Color3.fromRGB(148,93,255)
	if SideSwipeApp.handles.left then
		SideSwipeApp.handles.left.BackgroundColor3 = mainColor
	end
	if SideSwipeApp.handles.right then
		SideSwipeApp.handles.right.BackgroundColor3 = mainColor
	end
end

NAmanage.SideSwipe_UpdateHandleSide=function()
	local side = SideSwipeApp.side or "left"
	if SideSwipeApp.handles.left then
		SideSwipeApp.handles.left.Visible = side == "left"
		SideSwipeApp.handles.left.Active = side == "left"
	end
	if SideSwipeApp.handles.right then
		SideSwipeApp.handles.right.Visible = side == "right"
		SideSwipeApp.handles.right.Active = side == "right"
	end
	NAmanage.SideSwipe_PositionHandles()
end

NAmanage.SideSwipe_PointInside=function(gui, point)
	if not (gui and gui.Visible) then return false end
	local pos = gui.AbsolutePosition
	local size = gui.AbsoluteSize
	return point.X >= pos.X and point.X <= pos.X + size.X and point.Y >= pos.Y and point.Y <= pos.Y + size.Y
end

NAmanage.SideSwipe_ShouldCloseFrom=function(point)
	if NAmanage.SideSwipe_PointInside(SideSwipeApp.panel, point)
		or NAmanage.SideSwipe_PointInside(SideSwipeApp.underlay, point)
		or NAmanage.SideSwipe_PointInside(SideSwipeApp.scroll, point) then
		return false
	end
	if NAmanage.SideSwipe_PointInside(SideSwipeApp.handles.left, point) or NAmanage.SideSwipe_PointInside(SideSwipeApp.handles.right, point) then
		return false
	end
	return true
end

NAmanage.SideSwipe_PositionPanel=function(opts)
	opts = opts or {}
	if not SideSwipeApp.panel then return end
	local cam = workspace.CurrentCamera
	local vp = cam and cam.ViewportSize or Vector2.new(1280, 720)
	local size = SideSwipeApp.panel.AbsoluteSize
	local margin = 10
	local xOn, xOff
	local side = SideSwipeApp.side or "left"
	local anchor = Vector2.new(0, 0.5)
	if side == "right" then
		anchor = Vector2.new(1, 0.5)
		xOn = vp.X - margin
		xOff = vp.X + size.X + margin
	else
		xOn = margin
		xOff = -size.X - margin
	end
	local hClamp = math.clamp(vp.Y * 0.5, size.Y * 0.5 + margin, vp.Y - size.Y * 0.5 - margin)
	local targetY = hClamp
	if opts.state == false then
		SideSwipeApp.panel.AnchorPoint = anchor
		SideSwipeApp.panel.Position = UDim2.new(0, xOff, 0, targetY)
	else
		SideSwipeApp.panel.AnchorPoint = anchor
		SideSwipeApp.panel.Position = UDim2.new(0, xOn, 0, targetY)
	end
end

NAmanage.SideSwipe_UpdateCanvas=function()
	if not (SideSwipeApp.scroll and SideSwipeApp.layout and SideSwipeApp.panel and SideSwipeApp.underlay) then return end
	local content = SideSwipeApp.layout.AbsoluteContentSize
	local totalH = content.Y + 16
	local cam = workspace.CurrentCamera
	local vp = cam and cam.ViewportSize or Vector2.new(1280, 720)
	local maxH = math.max(120, vp.Y - 40)
	local height = math.min(totalH + 16, maxH)
	local width = math.clamp(tonumber(NAStuff.SideSwipeWidth) or 80, 60, 200)
	SideSwipeApp.panel.Size = UDim2.new(0, width, 0, height)
	SideSwipeApp.underlay.Size = UDim2.new(1, 0, 1, 0)
	SideSwipeApp.scroll.CanvasSize = UDim2.new(0, 0, 0, totalH)
	if not SideSwipeApp.animating then
		NAmanage.SideSwipe_PositionPanel({ state = SideSwipeApp.isOpen })
	end
end

NAmanage.SideSwipe_Rebuild=function()
	if not (SideSwipeApp.panel and SideSwipeApp.underlay) then return end
	if SideSwipeApp.scroll then SideSwipeApp.scroll:Destroy() end
	for _, c in ipairs(SideSwipeApp.underlay:GetChildren()) do
		local keep = c:IsA("UIStroke") or c:IsA("UICorner")
		if not keep then
			c:Destroy()
		end
	end
	SideSwipeApp.scroll = InstanceNew("ScrollingFrame", SideSwipeApp.underlay)
	SideSwipeApp.scroll.BackgroundTransparency = 1
	SideSwipeApp.scroll.BorderSizePixel = 0
	SideSwipeApp.scroll.Size = UDim2.new(1, 0, 1, 0)
	SideSwipeApp.scroll.CanvasSize = UDim2.new(0, 0, 0, 0)
	SideSwipeApp.scroll.ScrollBarThickness = 4
	SideSwipeApp.scroll.VerticalScrollBarInset = Enum.ScrollBarInset.ScrollBar
	local pad = InstanceNew("UIPadding", SideSwipeApp.scroll)
	pad.PaddingTop = UDim.new(0, 8)
	pad.PaddingBottom = UDim.new(0, 8)
	pad.PaddingLeft = UDim.new(0, 8)
	pad.PaddingRight = UDim.new(0, 8)
	if SideSwipeApp.layout then SideSwipeApp.layout:Destroy() end
	local list = InstanceNew("UIListLayout", SideSwipeApp.scroll)
	list.FillDirection = Enum.FillDirection.Vertical
	list.HorizontalAlignment = Enum.HorizontalAlignment.Center
	list.VerticalAlignment = Enum.VerticalAlignment.Top
	list.Padding = UDim.new(0, 8)
	list.SortOrder = Enum.SortOrder.LayoutOrder
	SideSwipeApp.layout = list
	local tile = 48
	local buttons = NAmanage.SideSwipe_GetButtons()
	for i, def in ipairs(buttons) do
		local btn = InstanceNew("TextButton", SideSwipeApp.scroll)
		btn.Name = (def.name or ("btn"..i)).."Swipe"
		btn.Size = UDim2.new(1, -6, 0, tile)
		btn.BackgroundTransparency = 1
		btn.BorderSizePixel = 0
		btn.LayoutOrder = i
		btn.Text = ""
		btn.TextTransparency = 1
		btn.AutoButtonColor = false
		btn.ZIndex = 520
		local bg = InstanceNew("Frame", btn)
		bg.ZIndex = 518
		bg.Size = UDim2.new(1, 0, 1, 0)
		bg.BackgroundColor3 = Color3.fromRGB(25,25,28)
		bg.BackgroundTransparency = 0.16
		bg.BorderSizePixel = 0
		local cr = InstanceNew("UICorner", bg)
		cr.CornerRadius = UDim.new(0, 12)
		local stroke = InstanceNew("UIStroke", bg)
		stroke.Thickness = 1
		stroke.Color = NAUISTROKER or Color3.fromRGB(148,93,255)
		stroke.Transparency = 0.15
		NAgui.RegisterColoredStroke(stroke)
		local ic = InstanceNew("TextLabel", bg)
		ic.ZIndex = 519
		ic.BackgroundTransparency = 1
		ic.Size = UDim2.new(0.65, 0, 0.65, 0)
		ic.Position = UDim2.new(0.5, 0, 0.5, 0)
		ic.AnchorPoint = Vector2.new(0.5, 0.5)
		ic.FontFace = TopBarApp.icon and TopBarApp.icon.FontFace or Font.new("rbxasset://LuaPackages/Packages/_Index/BuilderIcons/BuilderIcons/BuilderIcons.json",Enum.FontWeight.Bold,Enum.FontStyle.Normal)
		ic.Text = def.icon or def.name or ""
		ic.TextColor3 = Color3.new(1,1,1)
		ic.TextScaled = false
		ic.TextSize = 24
		SideSwipeApp.scroll.CanvasSize = UDim2.new(0, 0, 0, tile * i)
		SideSwipeApp.scroll.Active = true
		if def.func then
			MouseButtonFix(btn, def.func)
		end
	end
	local function update()
		NAmanage.SideSwipe_UpdateCanvas()
	end
	NAlib.disconnect("ss_canvas")
	NAlib.connect("ss_canvas", SideSwipeApp.layout:GetPropertyChangedSignal("AbsoluteContentSize"):Connect(update))
	update()
end

NAmanage.SideSwipe_SetOpen=function(state)
	if not SideSwipeApp.panel then return end
	if SideSwipeApp.animating then return end
	local wasOpen = SideSwipeApp.isOpen
	SideSwipeApp.isOpen = state and true or false
	SideSwipeApp.animating = true
	SideSwipeApp.panel.Visible = true
	NAmanage.SideSwipe_UpdateCanvas()
	local cam = workspace.CurrentCamera
	local vp = cam and cam.ViewportSize or Vector2.new(1280, 720)
	local size = SideSwipeApp.panel.AbsoluteSize
	local margin = 10
	local side = SideSwipeApp.side or "left"
	local anchor = side == "right" and Vector2.new(1, 0.5) or Vector2.new(0, 0.5)
	local xOn = side == "right" and (vp.X - margin) or margin
	local xOff = side == "right" and (vp.X + size.X + margin) or (-size.X - margin)
	local y = math.clamp(vp.Y * 0.5, size.Y * 0.5 + margin, vp.Y - size.Y * 0.5 - margin)
	local startX = SideSwipeApp.isOpen and xOff or xOn
	if wasOpen == SideSwipeApp.isOpen then
		startX = SideSwipeApp.panel.Position.X.Offset
	end
	local targetX = SideSwipeApp.isOpen and xOn or xOff
	SideSwipeApp.panel.AnchorPoint = anchor
	SideSwipeApp.panel.Position = UDim2.new(0, startX, 0, y)
	local ease = TweenInfo.new(0.22, Enum.EasingStyle.Quart, Enum.EasingDirection.Out)
	local tween = TweenService:Create(SideSwipeApp.panel, ease, { Position = UDim2.new(0, targetX, 0, y) })
	if SideSwipeApp.underlay then
		local underGoal = SideSwipeApp.isOpen and 0.08 or 0.35
		TweenService:Create(SideSwipeApp.underlay, TweenInfo.new(0.18, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut), { BackgroundTransparency = underGoal }):Play()
	end
	tween:Play()
	tween.Completed:Connect(function()
		if not SideSwipeApp.isOpen then
			SideSwipeApp.panel.Visible = false
		end
		SideSwipeApp.animating = false
	end)
end

NAmanage.SideSwipe_SetSide=function(side, opts)
	opts = opts or {}
	local resolved = side == "right" and "right" or "left"
	if SideSwipeApp.side == resolved and not opts.force then
		NAmanage.SideSwipe_UpdateHandleSide()
		return
	end
	SideSwipeApp.side = resolved
	NASideSwipeSide = resolved
	if NAmanage.NASettingsSet then
		NAmanage.NASettingsSet("sideSwipeSide", resolved)
	end
	NAmanage.SideSwipe_UpdateHandleSide()
	if opts.skipAnimate then
		NAmanage.SideSwipe_PositionPanel({ state = SideSwipeApp.isOpen })
	else
		NAmanage.SideSwipe_SetOpen(SideSwipeApp.isOpen)
	end
end

NAmanage.SideSwipe_WireHandle=function(btn, side)
	if not btn then return end
	local SWIPE_THRESHOLD = 28
	local dragging = false
	local dragStart
	local dragInput
	local function resetDrag()
		dragging = false
		dragStart = nil
		dragInput = nil
	end
	btn.MouseButton1Down:Connect(function()
		NAmanage.SideSwipe_SetSide(side, { skipAnimate = true })
	end)
	btn.InputBegan:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
			NAmanage.SideSwipe_SetSide(side, { skipAnimate = true })
			dragging = true
			dragStart = input.Position
			dragInput = input
			input.Changed:Connect(function()
				if input.UserInputState == Enum.UserInputState.End or input.UserInputState == Enum.UserInputState.Cancel then
					resetDrag()
				end
			end)
		end
	end)
	btn.InputChanged:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
			dragInput = input
		end
	end)
	UserInputService.InputChanged:Connect(function(input)
		if input == dragInput and dragging and dragStart then
			local delta = input.Position - dragStart
			if side == "left" and delta.X > SWIPE_THRESHOLD then
				resetDrag()
				NAmanage.SideSwipe_SetOpen(true)
			elseif side == "right" and delta.X < -SWIPE_THRESHOLD then
				resetDrag()
				NAmanage.SideSwipe_SetOpen(true)
			elseif SideSwipeApp.isOpen then
				if side == "left" and delta.X < -SWIPE_THRESHOLD then
					resetDrag()
					NAmanage.SideSwipe_SetOpen(false)
				elseif side == "right" and delta.X > SWIPE_THRESHOLD then
					resetDrag()
					NAmanage.SideSwipe_SetOpen(false)
				end
			end
		end
	end)
end

NAmanage.SideSwipe_Init=function()
	if SideSwipeApp.gui and SideSwipeApp.gui.Parent then return true end
	SideSwipeApp.gui = InstanceNew("ScreenGui")
	SideSwipeApp.gui.Name = "NA_SideSwipe"
	SideSwipeApp.gui.Enabled = NASideSwipeEnabled
	NaProtectUI(SideSwipeApp.gui)
	SideSwipeApp.panel = InstanceNew("Frame", SideSwipeApp.gui)
	SideSwipeApp.panel.BackgroundTransparency = 1
	SideSwipeApp.panel.ClipsDescendants = true
	SideSwipeApp.panel.Visible = false
	SideSwipeApp.panel.ZIndex = 510
	SideSwipeApp.underlay = InstanceNew("Frame", SideSwipeApp.panel)
	SideSwipeApp.underlay.Size = UDim2.new(1,0,1,0)
	SideSwipeApp.underlay.BackgroundColor3 = Color3.fromRGB(18,18,22)
	SideSwipeApp.underlay.BackgroundTransparency = 0.35
	SideSwipeApp.underlay.ZIndex = 511
	local uCorner = InstanceNew("UICorner", SideSwipeApp.underlay); uCorner.CornerRadius = UDim.new(0, 14)
	local uStroke = InstanceNew("UIStroke", SideSwipeApp.underlay)
	uStroke.Thickness = 1
	uStroke.Color = NAUISTROKER or Color3.fromRGB(148,93,255)
	uStroke.Transparency = 0.18
	NAgui.RegisterColoredStroke(uStroke)
	NAmanage.SideSwipe_Rebuild()
	local mainColor = NAUISTROKER or DEFAULT_UI_STROKE_COLOR or Color3.fromRGB(148,93,255)
	SideSwipeApp.handles.left = InstanceNew("TextButton", SideSwipeApp.gui)
	SideSwipeApp.handles.left.BackgroundColor3 = mainColor
	SideSwipeApp.handles.left.BackgroundTransparency = NAStuff.SideSwipeHandleTransparency or 0.72
	SideSwipeApp.handles.left.BorderSizePixel = 0
	SideSwipeApp.handles.left.AutoButtonColor = false
	SideSwipeApp.handles.left.Text = ""
	SideSwipeApp.handles.left.AnchorPoint = Vector2.new(0,0.5)
	SideSwipeApp.handles.left.ZIndex = 470
	local lCorner = InstanceNew("UICorner", SideSwipeApp.handles.left); lCorner.CornerRadius = UDim.new(1,0)
	NAmanage.SideSwipe_WireHandle(SideSwipeApp.handles.left, "left")
	SideSwipeApp.handles.right = InstanceNew("TextButton", SideSwipeApp.gui)
	SideSwipeApp.handles.right.BackgroundColor3 = mainColor
	SideSwipeApp.handles.right.BackgroundTransparency = NAStuff.SideSwipeHandleTransparency or 0.72
	SideSwipeApp.handles.right.BorderSizePixel = 0
	SideSwipeApp.handles.right.AutoButtonColor = false
	SideSwipeApp.handles.right.Text = ""
	SideSwipeApp.handles.right.AnchorPoint = Vector2.new(1,0.5)
	SideSwipeApp.handles.right.ZIndex = 470
	local rCorner = InstanceNew("UICorner", SideSwipeApp.handles.right); rCorner.CornerRadius = UDim.new(1,0)
	NAmanage.SideSwipe_WireHandle(SideSwipeApp.handles.right, "right")
	NAmanage.SideSwipe_UpdateHandleColors(mainColor)
	SideSwipeApp.side = NASideSwipeSide or SideSwipeApp.side
	NAmanage.SideSwipe_SetSide(SideSwipeApp.side, { skipAnimate = true, force = true })
	NAmanage.SideSwipe_PositionHandles()
	if workspace.CurrentCamera then
		NAlib.connect("ss_vp", workspace.CurrentCamera:GetPropertyChangedSignal("ViewportSize"):Connect(function()
			NAmanage.SideSwipe_PositionHandles()
			NAmanage.SideSwipe_UpdateCanvas()
		end))
	end
	local function SideSwipe_HookOutsideClose()
		NAlib.disconnect("ss_click")

		local function onInputBegan(input)
			if not SideSwipeApp.isOpen then return end

			if input.UserInputType ~= Enum.UserInputType.MouseButton1
				and input.UserInputType ~= Enum.UserInputType.Touch then
				return
			end

			local pos = input.Position
			local p = typeof(pos) == "Vector2" and pos or Vector2.new(pos.X, pos.Y)

			if NAmanage.SideSwipe_ShouldCloseFrom(p) then
				NAmanage.SideSwipe_SetOpen(false)
			end
		end

		NAlib.connect("ss_click", UserInputService.InputBegan:Connect(onInputBegan))
	end
	SideSwipe_HookOutsideClose()
	return true
end

NAmanage.SideSwipe_Destroy=function()
	NAlib.disconnect("ss_canvas")
	NAlib.disconnect("ss_vp")
	NAlib.disconnect("ss_click")
	if SideSwipeApp.gui then SideSwipeApp.gui:Destroy() end
	SideSwipeApp={ gui=nil; panel=nil; underlay=nil; scroll=nil; layout=nil; handles={left=nil,right=nil}; isOpen=false; animating=false; side=NASideSwipeSide or "left" }
end

NAgui.menu = function(menu)
	if menu:IsA("Frame") then menu.AnchorPoint = Vector2.new(0, 0) end
	local exitButton = menu:FindFirstChild("Exit", true)
	local minimizeButton = menu:FindFirstChild("Minimize", true)
	local minimized = false
	local isAnimating = false
	local sizeX = InstanceNew("IntValue", menu)
	local sizeY = InstanceNew("IntValue", menu)
	local function setMinAtt(value)
		minimized = value
		if menu and menu.SetAttribute then
			menu:SetAttribute("NAMenuMinimized", value)
		end
	end
	setMinAtt(false)

	local function toggleMinimize()
		if isAnimating then return end
		local nextState = not minimized
		setMinAtt(nextState)
		isAnimating = true

		if nextState then
			sizeX.Value = menu.Size.X.Offset
			sizeY.Value = menu.Size.Y.Offset
			NAgui.tween(menu, "Quart", "Out", 0.5, {Size = UDim2.new(0, sizeX.Value, 0, 35)})
				.Completed:Connect(function()
					isAnimating = false
				end)
		else
			NAgui.tween(menu, "Quart", "Out", 0.5, {Size = UDim2.new(0, sizeX.Value, 0, sizeY.Value)})
				.Completed:Connect(function()
					isAnimating = false
				end)
		end
	end

	MouseButtonFix(minimizeButton, toggleMinimize)
	MouseButtonFix(exitButton, function()
		menu.Visible = false
	end)
	NAgui.draggerV2(menu, menu.Topbar)
	menu.Visible = false
end

NAgui.menuv2 = function(menu)
	NACaller(function()
		if menu:IsA("Frame") then
			menu.AnchorPoint = Vector2.new(0, 0)
		end
	end)

	local exitButton = menu:FindFirstChild("Exit", true)
	local minimizeButton = menu:FindFirstChild("Minimize", true)
	local clearButton = menu:FindFirstChild("Clear", true)

	local minimized = false
	local isAnimating = false
	local sizeX = InstanceNew("IntValue", menu)
	local sizeY = InstanceNew("IntValue", menu)
	local function setMinAtt(value)
		minimized = value
		if menu and menu.SetAttribute then
			menu:SetAttribute("NAMenuMinimized", value)
		end
	end
	setMinAtt(false)

	local function toggleMinimize()
		local success, err = NACaller(function()
			if isAnimating then return end
			local nextState = not minimized
			setMinAtt(nextState)
			isAnimating = true

			if nextState then
				sizeX.Value = menu.Size.X.Offset
				sizeY.Value = menu.Size.Y.Offset
				NAgui.tween(menu, "Quart", "Out", 0.5, {
					Size = UDim2.new(0, sizeX.Value, 0, 35)
				}).Completed:Connect(function()
					isAnimating = false
				end)
			else
				NAgui.tween(menu, "Quart", "Out", 0.5, {
					Size = UDim2.new(0, sizeX.Value, 0, sizeY.Value)
				}).Completed:Connect(function()
					isAnimating = false
				end)
			end
		end)
		if not success then warn("menuv2 toggleMinimize error:", err) end
	end

	NACaller(function()
		MouseButtonFix(minimizeButton, toggleMinimize)
	end)

	NACaller(function()
		MouseButtonFix(exitButton, function()
			local ok, err = NACaller(function()
				menu.Visible = false
			end)
			if not ok then warn("menuv2 exit button error:", err) end
		end)
	end)

	if clearButton then
		NACaller(function()
			clearButton.Visible = true
			MouseButtonFix(clearButton, function()
				local ok, err = NACaller(function()
					local container = menu:FindFirstChild("Container", true)
					if container then
						local scrollingFrame = container:FindFirstChildOfClass("ScrollingFrame")
						if scrollingFrame then
							local layout = scrollingFrame:FindFirstChildOfClass("UIListLayout", true)
							if layout then
								for _, v in ipairs(layout.Parent:GetChildren()) do
									if v:IsA("TextLabel") then
										v:Destroy()
									end
								end
							end
						end
					end
				end)
				if not ok then warn("menuv2 clear button error:", err) end
			end)
		end)
	end

	if translateButton and NAStuff.ChatTranslator then
		NACaller(function()
			NAStuff.ChatTranslator:registerButton(translateButton)
		end)
	end

	NACaller(function()
		NAgui.draggerV2(menu, menu.Topbar)
	end)

	NACaller(function()
		menu.Visible = false
	end)
end

NAgui.menuv3 = function(menu)
	if not menu then return end
	NAgui.menuv2(menu)
	local translator = NAStuff.ChatTranslator
	local translateButton = menu:FindFirstChild("Translate", true)
	local translateInput = menu:FindFirstChild("TranslateInput", true)

	if translator then
		translator:attachControls(translateButton, translateInput)
	end
end

NAgui.hideFill = function()
	for i, v in ipairs(CMDAUTOFILL) do
		if v:IsA("Frame") then
			v.Visible = false
		end
	end
end

NAgui.loadCMDS = function()
	for _, v in pairs(NAUIMANAGER.cmdAutofill:GetChildren()) do
		if v:IsA("GuiObject") and v.Name ~= "UIListLayout" then
			v:Destroy()
		end
	end
	local layout = NAUIMANAGER.cmdAutofill and NAUIMANAGER.cmdAutofill:FindFirstChildOfClass("UIListLayout")
	if layout then
		layout.SortOrder = Enum.SortOrder.LayoutOrder
	end
	local templateInput = NAUIMANAGER.cmdExample and NAUIMANAGER.cmdExample:FindFirstChild("Input")
	local defaultInputColor = templateInput and templateInput.TextColor3
	NAStuff.defaultCmdClear = nil
	NAStuff.autofillSelecting = false
	NAStuff.cmdFocusGuardUntil = 0
	NAStuff.autofillRefocusGuard = 0
	local function wireAutofillClick(btn, textObj, fillText)
		local function applyFill()
			if not NAUIMANAGER.cmdInput then
				return
			end
			if NAStuff.defaultCmdClear == nil then
				NAStuff.defaultCmdClear = NAUIMANAGER.cmdInput.ClearTextOnFocus
			end
			local raw = fillText or (textObj and textObj.Text) or (btn and btn.Text) or ""
			local sanitizedText = NAmanage.stripChar(raw)
			task.defer(function()
				NAStuff.cmdFocusGuardUntil = os.clock() + 0.45
				NAStuff.autofillRefocusGuard = os.clock() + 0.25
				NAUIMANAGER.cmdInput.Text = sanitizedText
				local caret = #sanitizedText + 1
				NAUIMANAGER.cmdInput.CursorPosition = caret
				if NAUIMANAGER.cmdInput.ClearTextOnFocus ~= false then
					NAUIMANAGER.cmdInput.ClearTextOnFocus = false
				end
				if NAUIMANAGER.cmdInput.SelectionStart then
					pcall(function()
						NAUIMANAGER.cmdInput.SelectionStart = caret
						NAUIMANAGER.cmdInput.SelectionEnd = caret
					end)
				end
				if predictionInput then
					predictionInput.Text = ""
				end
				if not IsOnMobile then
					NAgui.ensureCmdFocus(true)
				else
					NAStuff.autofillSelecting = true
					NAUIMANAGER.cmdInput:ReleaseFocus()
					task.delay(0.2, function()
						if NAUIMANAGER and NAUIMANAGER.cmdInput then
							NAUIMANAGER.cmdInput:CaptureFocus()
							NAUIMANAGER.cmdInput.ClearTextOnFocus = defaultCmdClear or false
						end
						NAStuff.autofillSelecting = false
					end)
				end
				task.delay(0.5, function()
					NAStuff.cmdFocusGuardUntil = 0
				end)
			end)
		end
		local function bind(obj)
			if not obj then
				return
			end
			if obj:IsA("TextButton") or obj:IsA("ImageButton") then
				obj.MouseButton1Click:Connect(applyFill)
			end
			if obj.InputBegan then
				obj.InputBegan:Connect(function(input)
					if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
						applyFill()
					end
				end)
			end
		end
		bind(btn)
		bind(textObj)
	end
	CMDAUTOFILL = {}
	local entries = NAmanage.buildCommandEntries()
	local i = 0
	for _, entry in ipairs(entries) do
		local name = entry.name
		local meta = entry.meta or {}
		local cmdData = cmds.Commands[name]
		local btn = NAUIMANAGER.cmdExample:Clone()
		btn.Parent = NAUIMANAGER.cmdAutofill
		btn.Name = name
		local finalDisplay = meta.displayText or entry.display or name
		local isPatched = meta.patched == true
		local isCmdIntegration = meta.origin == "cmd"
		local pluginType = meta.pluginType
		local isPluginCmd = pluginType ~= nil
		if not isPluginCmd and NAmanage.IsPluginCommand then
			isPluginCmd = NAmanage.IsPluginCommand(name)
		end
		if btn.Input then
			if isPatched then
				btn.Input.TextColor3 = patchedCommandColor
				finalDisplay = addPatchedLabel(finalDisplay)
			elseif isCmdIntegration then
				btn.Input.TextColor3 = cmdIntegrationColor
			elseif isPluginCmd then
				btn.Input.TextColor3 = pluginCommandColor
			elseif defaultInputColor then
				btn.Input.TextColor3 = defaultInputColor
			end
			btn.Input.Text = finalDisplay
		else
			btn.Text = finalDisplay
		end
		if btn.SetAttribute then
			btn:SetAttribute("IsCmdIntegration", isCmdIntegration)
			btn:SetAttribute("IsPluginCommand", isPluginCmd)
			btn:SetAttribute("IsPatchedCommand", isPatched)
		end
		i += 1
		btn.LayoutOrder = i
		wireAutofillClick(btn, btn.Input, name)
		Insert(CMDAUTOFILL, btn)
	end
	cmdNAnum = i
	NAgui.hideFill()
	NAmanage.rebuildIndex()
end

SpawnCall(function() -- plugin tester
	while Wait(2) do
		if NAmanage.totalCommandCount() ~= cmdNAnum then
			NAgui.loadCMDS()
		end
	end
end)

SpawnCall(function()
	NAmanage.Topbar_Init()
end)

SpawnCall(function()
	Wait(0.25)
	NAmanage.SideSwipe_Init()
end)

local cmdDefaultClear = nil
NAgui.ensureCmdFocus = function()
	if not (NAUIMANAGER and NAUIMANAGER.cmdInput) then return end
	local box = NAUIMANAGER.cmdInput
	if cmdDefaultClear == nil then
		cmdDefaultClear = box.ClearTextOnFocus
	end
	box.ClearTextOnFocus = false
	box:CaptureFocus()
	local deadline = os.clock() + 0.35
	task.spawn(function()
		while box and box.Parent and not box:IsFocused() and os.clock() < deadline do
			box:CaptureFocus()
			task.wait(0.03)
		end
		if box then
			box.ClearTextOnFocus = cmdDefaultClear
		end
	end)
end

NAgui.barSelect = function(speed)
	speed = speed or 0.18
	shouldShowDefaultAutofill = true

	local targetSize = UDim2.new(0, 280, 1, 10)
	local startSize = UDim2.new(0, 250, 1, 8)
	NAUIMANAGER.centerBar.Size = startSize
	NAUIMANAGER.centerBar.Visible = true
	if speed > 0 then
		NAgui.tween(NAUIMANAGER.centerBar, "Back", "Out", speed * 0.6, {
			Size = targetSize
		})
	else
		NAUIMANAGER.centerBar.Size = targetSize
	end

	NAUIMANAGER.leftFill.Position = UDim2.new(0.5, 0, 0.5, 0)
	NAUIMANAGER.rightFill.Position = UDim2.new(0.5, 0, 0.5, 0)
	NAUIMANAGER.leftFill.Size = UDim2.new(0, 0, fillSizes.left.Y.Scale, fillSizes.left.Y.Offset)
	NAUIMANAGER.rightFill.Size = UDim2.new(0, 0, fillSizes.right.Y.Scale, fillSizes.right.Y.Offset)

	Wait(speed * 0.05)
	NAgui.tween(NAUIMANAGER.leftFill, "Quart", "Out", math.max(speed * 1.2, 0.05), {
		Position = UDim2.new(0, 0, 0.5, 0),
		Size = fillSizes.left
	})
	NAgui.tween(NAUIMANAGER.rightFill, "Quart", "Out", math.max(speed * 1.2, 0.05), {
		Position = UDim2.new(1, 0, 0.5, 0),
		Size = fillSizes.right
	})
	if not IsOnMobile then
		task.delay(speed * 0.4, NAgui.ensureCmdFocus)
	end
end

NAgui.barDeselect = function(speed)
	if NAStuff.autofillRefocusGuard > 0 and os.clock() < NAStuff.autofillRefocusGuard then
		return
	end
	speed = speed or 0.4

	shouldShowDefaultAutofill = false

	NAgui.tween(NAUIMANAGER.centerBar, "Back", "InOut", speed, {
		Size = UDim2.new(0, 0, 0, 0)
	})

	NAgui.tween(NAUIMANAGER.leftFill, "Quart", "In", speed * 0.9, {
		Position = UDim2.new(-0.5, -125, 0.5, 0),
		Size = UDim2.new(0, 0, fillSizes.left.Y.Scale, fillSizes.left.Y.Offset)
	})
	NAgui.tween(NAUIMANAGER.rightFill, "Quart", "In", speed * 0.9, {
		Position = UDim2.new(1.5, 125, 0.5, 0),
		Size = UDim2.new(0, 0, fillSizes.right.Y.Scale, fillSizes.right.Y.Offset)
	})

	for i, v in ipairs(NAUIMANAGER.cmdAutofill:GetChildren()) do
		if v:IsA("Frame") then
			wrap(function()
				Wait(math.random(50, 120) / 1000)
				NAgui.tween(v, "Exponential", "In", 0.25, {
					Size = UDim2.new(0, 0, 0, 25)
				})
			end)
		end
	end
	if NAUIMANAGER and NAUIMANAGER.cmdInput then
		NAUIMANAGER.cmdInput:ReleaseFocus()
		if cmdDefaultClear ~= nil then
			NAUIMANAGER.cmdInput.ClearTextOnFocus = cmdDefaultClear
		end
	end
end

--[[ AUTOFILL SEARCHER ]]--
function fixStupidSearchGoober(cmdName, command)
	local dInfo = command and command[2] and command[2][1] or ""
	local func = command and command[1]

	local aliasSet = {}
	for alias, data in pairs(cmds.Aliases) do
		if data[1] == func then
			aliasSet[Lower(alias)] = true
		end
	end

	local main = cmdName and Lower(cmdName)
	local existingAliases = {}
	local prefix, aliasBlock = dInfo:match("^(.-)%s*%((.-)%)$")

	if aliasBlock then
		for a in aliasBlock:gmatch("[^,%s]+") do
			aliasSet[Lower(a)] = true
		end
	end

	local final = {}
	for alias in pairs(aliasSet) do
		if alias ~= main then
			Insert(final, alias)
		end
	end
	table.sort(final)

	local updTxt
	if prefix then
		updTxt = prefix.." ("..Concat(final, ", ")..")"
	else
		updTxt = dInfo
		if #final > 0 then
			updTxt = updTxt.." ("..Concat(final, ", ")..")"
		end
	end

	return updTxt, final
end

NAmanage.computeScore=function(entry,term,len,aliasExact,savedExact,aliasPrefix,savedPrefix)
	if not entry or not entry.name or not entry.lowerName then return end
	local cmdEntry = cmds.Commands and cmds.Commands[entry.name] or nil
	local meta = entry.meta or (NAStuff.AutofillMetaByName and NAStuff.AutofillMetaByName[entry.name]) or nil

	if entry.lowerName == term then return 1,entry.name end
	if Sub(entry.lowerName,1,len) == term then return 2,entry.name end

	if cmdEntry then
		local exactAlias = aliasExact[entry.name]
		if exactAlias then
			return 3, exactAlias
		end
	end
	if savedExact[entry.name] then
		return 3, savedExact[entry.name]
	end

	if cmdEntry then
		local prefixAlias = aliasPrefix[entry.name]
		if prefixAlias then
			return 4, prefixAlias
		end
	end
	if savedPrefix[entry.name] then
		return 4, savedPrefix[entry.name]
	end

	if meta and meta.aliases then
		for _, alias in ipairs(meta.aliases) do
			if alias == term then
				return 3, entry.name
			end
			if Sub(alias, 1, len) == term then
				return 4, entry.name
			end
			if len >= 2 and Find(alias, term, 1, true) then
				return 5, entry.name
			end
		end
	end

	local extraAliases = entry.extraAliases or {}
	for _,a in ipairs(extraAliases) do
		if a == term then return 3,entry.name end
		if Sub(a,1,len) == term then return 4,entry.name end
		if Find(a,term,1,true) then return 5,entry.name end
	end
	if len >= 2 then
		if Find(entry.lowerName,term,1,true) then return 6,entry.name end
		if entry.searchable and Find(entry.searchable,term,1,true) then
			local displayName = entry.name
			if meta and meta.displayText then
				displayName = meta.displayText
			elseif cmdEntry and type(cmdEntry[2]) == "table" and cmdEntry[2][1] then
				displayName = cmdEntry[2][1]
			end
			return 7,displayName
		end
	end
end

NAmanage.performSearch = function(term)
	for _, f in ipairs(prevVisible) do f.Visible = false end
	table.clear(prevVisible)
	table.clear(results)
	local function pushTop(candidate)
		local insertAt = #results + 1
		for idx = 1, #results do
			local existing = results[idx]
			if candidate.score < existing.score or (candidate.score == existing.score and candidate.name < existing.name) then
				insertAt = idx
				break
			end
		end
		Insert(results, insertAt, candidate)
		if #results > 5 then
			table.remove(results)
		end
	end

	local function revealFrame(frame, index)
		if not frame then return end
		Insert(prevVisible, frame)
		frame.Visible = true
		local w = math.sqrt(index) * 125
		local y = (index - 1) * 28
		local pos = UDim2.new(0.5, w, 0, y)
		local size = UDim2.new(0.5, w, 0, 25)
		if canTween then
			NAgui.tween(frame, "Quint", "Out", 0.2, {Size = size, Position = pos})
		else
			frame.Size = size
			frame.Position = pos
		end
	end

	if term == "" or Match(term, "^%s*$") then
		predictionInput.Text = ""
		if shouldShowDefaultAutofill then
			shouldShowDefaultAutofill = false
			local displayed = 0
			for _, cmdName in ipairs(defaultBarCommands) do
				if displayed >= 5 then
					break
				end
				local target = Lower(cmdName)
				for _, entry in ipairs(searchIndex) do
					if NAmanage.defaultCommandMatches(entry, target) then
						displayed += 1
						revealFrame(entry.frame, displayed)
						break
					end
				end
			end
		else
			for i = 1, math.min(5, #searchIndex) do
				local entry = searchIndex[i]
				if entry then
					revealFrame(entry.frame, i)
				end
			end
		end
		return
	end

	local lockedTerm
	if Match(term, "%s") then
		local first = term:match("^%s*(%S+)")
		if not first or first == "" then
			predictionInput.Text = ""
			return
		end
		lockedTerm = first
		term = first
	end

	local len = #term
	table.clear(aliasExactCache)
	table.clear(savedExactCache)
	table.clear(aliasPrefixCache)
	table.clear(savedPrefixCache)
	local dataToName = {}
	for cmdName, data in pairs(cmds.Commands or {}) do
		dataToName[data] = cmdName
	end
	for alias, data in pairs(cmds.Aliases or {}) do
		local targetName = dataToName[data]
		if targetName then
			if alias == term then
				aliasExactCache[targetName] = alias
			end
			if Sub(alias,1,len) == term then
				aliasPrefixCache[targetName] = alias
			end
		end
	end
	for alias, original in pairs(cmds.NASAVEDALIASES or {}) do
		if alias == term then
			savedExactCache[original] = alias
		end
		if Sub(alias,1,len) == term then
			savedPrefixCache[original] = alias
		end
	end
	local function matchesLockedEntry(entry)
		if not lockedTerm then
			return true
		end
		if entry.lowerName == lockedTerm then
			return true
		end
		if aliasExactCache[entry.name] or savedExactCache[entry.name] then
			return true
		end
		local meta = entry.meta
		if meta and meta.aliases then
			for _, alias in ipairs(meta.aliases) do
				if alias and Lower(alias) == lockedTerm then
					return true
				end
			end
		end
		if entry.extraAliases then
			for _, alias in ipairs(entry.extraAliases) do
				if alias and Lower(alias) == lockedTerm then
					return true
				end
			end
		end
		return false
	end

	local lockedHasMatch = false
	if lockedTerm then
		for _, entry in ipairs(searchIndex) do
			if matchesLockedEntry(entry) then
				lockedHasMatch = true
				break
			end
		end
	end

	for _, entry in ipairs(searchIndex) do
		if not lockedTerm or not lockedHasMatch or matchesLockedEntry(entry) then
			local sc, txt = NAmanage.computeScore(entry, term, len, aliasExactCache, savedExactCache, aliasPrefixCache, savedPrefixCache)
			if sc then
				pushTop({frame = entry.frame, score = sc, text = txt, name = entry.name})
			end
		end
	end

	local topText = (results[1] and results[1].text) or ""
	predictionInput.Text = NAmanage.stripChar(topText)

	for i = 1, #results do
		local r = results[i]
		revealFrame(r.frame, i)
	end
end

NAgui.searchCommands = function()
	if not NAUIMANAGER.cmdInput then return end
	if searchInputTarget == NAUIMANAGER.cmdInput and NAlib.isConnected("SearchInput") then
		return
	end
	if NAlib.isConnected("SearchInput") then NAlib.disconnect("SearchInput") end
	searchInputTarget = NAUIMANAGER.cmdInput
	NAlib.connect("SearchInput",NAUIMANAGER.cmdInput:GetPropertyChangedSignal("Text"):Connect(function()
		local cleaned = Lower(GSub(NAUIMANAGER.cmdInput.Text,";",""))
		local trimmed = cleaned:gsub("%s+$", "")
		local query = (trimmed ~= "" and trimmed) or cleaned
		shouldShowDefaultAutofill = cleaned == ""
		local isBlank = cleaned == "" or cleaned:match("^%s*$")
		if query == lastSearchText then
			return
		end
		lastSearchText = query
		gen += 1
		local thisGen = gen
		Delay(0.08,function()
			if thisGen ~= gen then return end
			NAmanage.performSearch(query)
		end)
	end))
end

NAgui.loadCMDS()
NAgui.searchCommands()

NAgui.autoFILLLL=function()
	if not NAUIMANAGER.cmdInput then return end
	local current = NAUIMANAGER.cmdInput.Text or ""
	local cleaned = Lower(GSub(current, ";", ""))
	local trimmed = cleaned:gsub("%s+$", "")
	local query = (trimmed ~= "" and trimmed) or cleaned
	lastSearchText = query
	gen += 1
	NAmanage.performSearch(query)
end

if NAUIMANAGER.cmdInput then
	NAUIMANAGER.cmdInput.Focused:Connect(function()
		Delay(0, NAgui.autoFILLLL)
	end)
end

--[[ OPEN THE COMMAND BAR ]]--
--[[mouse.KeyDown:Connect(function(k)
	if k:lower()==opt.prefix then
		Wait();
		NAgui.barSelect()
		cmdInput.Text=''
		cmdInput:CaptureFocus()
	end
end)]]
UserInputService.InputBegan:Connect(function(i, g)
	if g then return end
	local c = tostring(opt.prefix):sub(1,1)
	local k
	for _, v in pairs(Enum.KeyCode:GetEnumItems()) do
		if v.Name:lower() == c:lower() or v.Value == string.byte(c) then
			k = v
			break
		end
	end
	if i.KeyCode == k then
		Wait()
		if NAUIMANAGER.cmdInput then
			NAgui.barSelect()
			NAUIMANAGER.cmdInput.Text = ''

			while true do
				NAUIMANAGER.cmdInput:CaptureFocus()
				Wait(.00005)
				NAUIMANAGER.cmdInput.Text = ''
				if NAUIMANAGER.cmdInput:IsFocused() then break end
			end
		end
	end
end)

--[[ CLOSE THE COMMAND BAR ]]--
NAUIMANAGER.cmdInput.FocusLost:Connect(function(enter)
	if NAStuff.cmdFocusGuardUntil and os.clock() < NAStuff.cmdFocusGuardUntil then
		return
	end
	if NAStuff.autofillRefocusGuard > 0 and os.clock() < NAStuff.autofillRefocusGuard then
		return
	end
	if IsOnMobile and NAStuff.cmdFocusGuardUntil then
		local sinceGuardStart = os.clock() - (NAStuff.cmdFocusGuardUntil - 0.45)
		if sinceGuardStart > 0 and sinceGuardStart < 0.55 then
			return
		end
	end
	if NAStuff.autofillSelecting then
		return
	end
	if enter then
		local txt = NAUIMANAGER.cmdInput.Text
		if txt and #txt > 0 then
			wrap(function()
				NAlib.parseCommand(opt.prefix..txt)
			end)
		end
	end
	if predictionInput then
		predictionInput.Text = ""
	end
	local checkDelay = 0.05
	if NAStuff.autofillRefocusGuard > 0 then
		checkDelay = math.max(0.22, NAStuff.autofillRefocusGuard - os.clock())
	end
	Wait(checkDelay)
	if not NAUIMANAGER.cmdInput:IsFocused() then NAgui.barDeselect() end
end)

NAUIMANAGER.cmdInput:GetPropertyChangedSignal("Text"):Connect(function()
	if not NAUIMANAGER.cmdInput then
		return
	end

	local box = NAUIMANAGER.cmdInput
	local t = box.Text
	local c = NAmanage.stripChar(t, false)
	if c ~= t then
		box.Text = c
		box.CursorPosition = #c + 1
	end
	NAgui.searchCommands()
end)

if NAUIMANAGER.filterBox then
	NAUIMANAGER.filterBox:GetPropertyChangedSignal("Text"):Connect(NAmanage.UpdateWaypointList)
end

UserInputService.InputBegan:Connect(function(input)
	if input.KeyCode == Enum.KeyCode.Tab
		and UserInputService:GetFocusedTextBox() == NAUIMANAGER.cmdInput then

		local predictionText = predictionInput and predictionInput.Text or ""
		if predictionText ~= "" then
			Defer(function()
				local sanitizedText = NAmanage.stripChar(predictionText)
				NAUIMANAGER.cmdInput.Text = sanitizedText
				NAUIMANAGER.cmdInput.CursorPosition = #sanitizedText + 1
				predictionInput.Text = ""
			end)
		end
	end
end)

NAgui.barDeselect(0)
NAUIMANAGER.cmdBar.Visible=true
if NAUIMANAGER.chatLogsFrame then
	NAgui.menuv3(NAUIMANAGER.chatLogsFrame)
end

if NAUIMANAGER.NAconsoleFrame then
	NAgui.menuv2(NAUIMANAGER.NAconsoleFrame)
end

if NAUIMANAGER.commandsFrame then
	NAgui.menu(NAUIMANAGER.commandsFrame)
end

if NAUIMANAGER.SettingsFrame then
	NAgui.menu(NAUIMANAGER.SettingsFrame)
end

if NAUIMANAGER.WaypointFrame then
	NAgui.menu(NAUIMANAGER.WaypointFrame)
end

if NAUIMANAGER.BindersFrame then
	NAgui.menu(NAUIMANAGER.BindersFrame)
end

--[[ GUI RESIZE FUNCTION ]]--

if NAUIMANAGER.chatLogsFrame then NAgui.resizeable(NAUIMANAGER.chatLogsFrame) end
if NAUIMANAGER.NAconsoleFrame then NAgui.resizeable(NAUIMANAGER.NAconsoleFrame) end
if NAUIMANAGER.commandsFrame then NAgui.resizeable(NAUIMANAGER.commandsFrame) end
if NAUIMANAGER.SettingsFrame then NAgui.resizeable(NAUIMANAGER.SettingsFrame) end
if NAUIMANAGER.WaypointFrame then NAgui.resizeable(NAUIMANAGER.WaypointFrame) end
if NAUIMANAGER.BindersFrame then NAgui.resizeable(NAUIMANAGER.BindersFrame) end

--[[ CMDS COMMANDS SEARCH FUNCTION ]]--
NAgui.normalizeCommandFilter=function(text)
	text = text or ""
	return Lower(GSub(text, ";", ""))
end

NAgui.sanitizeCommandInfo=function(info)
	local searchableInfo = Lower(info or "")
	searchableInfo = GSub(searchableInfo, "<[^>]+>", "")
	searchableInfo = GSub(searchableInfo, "%[[^%]]+%]", "")
	searchableInfo = GSub(searchableInfo, "%([^%)]+%)", "")
	searchableInfo = GSub(searchableInfo, "{[^}]+}", "")
	searchableInfo = GSub(searchableInfo, "【[^】]+】", "")
	searchableInfo = GSub(searchableInfo, "〖[^〗]+〗", "")
	searchableInfo = GSub(searchableInfo, "«[^»]+»", "")
	searchableInfo = GSub(searchableInfo, "‹[^›]+›", "")
	searchableInfo = GSub(searchableInfo, "「[^」]+」", "")
	searchableInfo = GSub(searchableInfo, "『[^』]+』", "")
	searchableInfo = GSub(searchableInfo, "（[^）]+）", "")
	searchableInfo = GSub(searchableInfo, "〔[^〕]+〕", "")
	searchableInfo = GSub(searchableInfo, "‖[^‖]+‖", "")
	searchableInfo = GSub(searchableInfo, "%s+", " ")
	searchableInfo = GSub(searchableInfo, "^%s*(.-)%s*$", "%1")
	return searchableInfo
end

NAgui.filterCommandList = function(rawText)
	if not NAUIMANAGER.commandsList then return end
	local templateColor = NAUIMANAGER.commandExample and NAUIMANAGER.commandExample.TextColor3
	local searchText = NAgui.normalizeCommandFilter(rawText)
	local metaByName = NAStuff.AutofillMetaByName or {}
	for _, label in ipairs(NAUIMANAGER.commandsList:GetChildren()) do
		if label:IsA("TextLabel") then
			local originalName = label.Name or ""
			local cmdName = Lower(originalName)
			local meta = metaByName[originalName] or metaByName[cmdName]
			local command = cmds.Commands[cmdName]
			local aliasList = {}
			local displayText
			local searchableInfo

			if command then
				local updatedText, extraAliases = fixStupidSearchGoober(cmdName, command)
				displayText = updatedText
				if not displayText or displayText == "" then
					displayText = (type(command[2]) == "table" and command[2][1]) or cmdName
				end
				if type(command[2]) == "table" then
					command[2][1] = displayText
				end
				extraAliases = extraAliases or {}
				for i = 1, #extraAliases do
					aliasList[#aliasList + 1] = Lower(extraAliases[i])
				end
			end

			if meta then
				displayText = displayText or meta.displayText
				searchableInfo = meta.searchable or searchableInfo
				if type(meta.aliases) == "table" then
					for _, alias in ipairs(meta.aliases) do
						aliasList[#aliasList + 1] = Lower(alias)
					end
				end
			end

			displayText = displayText or originalName
			searchableInfo = searchableInfo or NAgui.sanitizeCommandInfo(displayText)

			local matches
			if searchText == "" then
				matches = true
			else
				if Sub(cmdName, 1, #searchText) == searchText then
					matches = true
				elseif searchableInfo ~= "" and Find(searchableInfo, searchText, 1, true) then
					matches = true
				else
					for _, alias in ipairs(aliasList) do
						if Sub(alias, 1, #searchText) == searchText or Find(alias, searchText, 1, true) then
							matches = true
							break
						end
					end
				end
			end

			label.Visible = matches and true or false
			if matches then
				local isCmdIntegration = meta and meta.origin == "cmd"
				local pluginType = meta and meta.pluginType
				local isPluginCmd = pluginType ~= nil
				if not isPluginCmd and NAmanage.IsPluginCommand then
					isPluginCmd, pluginType = NAmanage.IsPluginCommand(cmdName)
				end

				local isPatched = meta and meta.patched == true

				local finalText = (meta and meta.displayText) or displayText
				if isPatched then
					label.TextColor3 = patchedCommandColor
					if label.SetAttribute then
						label:SetAttribute("IsPatchedCommand", true)
						label:SetAttribute("IsCmdIntegration", false)
						label:SetAttribute("IsPluginCommand", false)
					end
					finalText = addPatchedLabel(finalText)
				elseif isCmdIntegration then
					label.TextColor3 = cmdIntegrationColor
					if label.SetAttribute then
						label:SetAttribute("IsCmdIntegration", true)
						label:SetAttribute("IsPatchedCommand", false)
						label:SetAttribute("IsPluginCommand", false)
					end
				elseif isPluginCmd then
					label.TextColor3 = pluginCommandColor
					if label.SetAttribute then
						label:SetAttribute("IsPluginCommand", true)
						label:SetAttribute("IsPatchedCommand", false)
						label:SetAttribute("IsCmdIntegration", false)
					end
				else
					if templateColor then
						label.TextColor3 = templateColor
					end
					if label.SetAttribute then
						label:SetAttribute("IsPluginCommand", false)
						label:SetAttribute("IsPatchedCommand", false)
						label:SetAttribute("IsCmdIntegration", false)
					end
				end
				label.Text = " "..finalText
			end
		end
	end
end

NAUIMANAGER.commandsFilter:GetPropertyChangedSignal("Text"):Connect(function()
	NAgui.filterCommandList(NAUIMANAGER.commandsFilter.Text)
end)

originalIO.naTransLatooor=function()
	local Http = HttpService
	local translator = NAStuff.ChatTranslator or {}
	NAStuff.ChatTranslator = translator

	translator.messages = translator.messages or {}
	translator.enabled = opt.chatTranslateEnabled ~= false
	opt.chatTranslateEnabled = translator.enabled

	NAmanage.toIso=function(value)
		if not value then return nil end
		return tostring(value):lower()
	end

	local languages = {
		auto="Automatic",morse="Morse Code",af="Afrikaans",sq="Albanian",am="Amharic",ar="Arabic",hy="Armenian",az="Azerbaijani",eu="Basque",be="Belarusian",bn="Bengali",bs="Bosnian",bg="Bulgarian",ca="Catalan",ceb="Cebuano",ny="Chichewa",
		["zh-cn"]="Chinese Simplified",["zh-tw"]="Chinese Traditional",co="Corsican",hr="Croatian",cs="Czech",da="Danish",nl="Dutch",en="English",eo="Esperanto",et="Estonian",tl="Filipino",fi="Finnish",fr="French",fy="Frisian",
		gl="Galician",ka="Georgian",de="German",el="Greek",gu="Gujarati",ht="Haitian Creole",ha="Hausa",haw="Hawaiian",iw="Hebrew",he="Hebrew",hi="Hindi",hmn="Hmong",hu="Hungarian",is="Icelandic",ig="Igbo",id="Indonesian",ga="Irish",it="Italian",
		ja="Japanese",jw="Javanese",kn="Kannada",kk="Kazakh",km="Khmer",ko="Korean",ku="Kurdish (Kurmanji)",ky="Kyrgyz",lo="Lao",la="Latin",lv="Latvian",lt="Lithuanian",lb="Luxembourgish",mk="Macedonian",mg="Malagasy",ms="Malay",
		ml="Malayalam",mt="Maltese",mi="Maori",mr="Marathi",mn="Mongolian",my="Myanmar (Burmese)",ne="Nepali",no="Norwegian",ps="Pashto",fa="Persian",pl="Polish",pt="Portuguese",pa="Punjabi",ro="Romanian",ru="Russian",sm="Samoan",
		gd="Scots Gaelic",sr="Serbian",st="Sesotho",sn="Shona",sd="Sindhi",si="Sinhala",sk="Slovak",sl="Slovenian",so="Somali",es="Spanish",su="Sundanese",sw="Swahili",sv="Swedish",tg="Tajik",ta="Tamil",te="Telugu",th="Thai",tr="Turkish",
		uk="Ukrainian",ur="Urdu",uz="Uzbek",vi="Vietnamese",cy="Welsh",xh="Xhosa",yi="Yiddish",yo="Yoruba",zu="Zulu"
	}

	NAmanage.iso2=function(value)
		local lowered = NAmanage.toIso(value)
		if not lowered then
			return nil
		end
		if languages[lowered] then
			return lowered
		end
		for code, name in pairs(languages) do
			if type(name) == "string" and name:lower() == lowered then
				return code
			end
		end
		return nil
	end

	originalIO.languageName=function(code)
		return languages[code] or code
	end

	local MORSE_MAP = {
		["A"]=".-",["B"]="-...",["C"]="-.-.",["D"]="-..",["E"]=".",["F"]="..-.",["G"]="--.",["H"]="....",
		["I"]="..",["J"]=".---",["K"]="-.-",["L"]=".-..",["M"]="--",["N"]="-.",["O"]="---",["P"]=".--.",
		["Q"]="--.-",["R"]=".-.",["S"]="...",["T"]="-",["U"]="..-",["V"]="...-",["W"]=".--",["X"]="-..-",
		["Y"]="-.--",["Z"]="--..",
		["1"]=".----",["2"]="..---",["3"]="...--",["4"]="....-",["5"]=".....",["6"]="-....",["7"]="--...",["8"]="---..",["9"]="----.",["0"]="-----",
		["."]=".-.-.-",[","]="--..--",["?"]="..--..",["'"]=".----.",["!"]="-.-.--",["/"]="-..-.",["("]="-.--.",[")"]="-.--.-",
		["&"]=".-...",[":"]="---...",[";"]="-.-.-.",["="]="-...-",["+"]=".-.-.",["-"]="-....-",["_"]="..--.-",["\""]=".-..-.",["$"]="...-..-",["@"]=".--.-."
	}
	local MORSE_REVERSE = {}
	for k,v in pairs(MORSE_MAP) do
		MORSE_REVERSE[v] = k
	end

	local function isLikelyMorse(text)
		if not text or text == "" then return false end
		return not not text:match("^[%s%./%-]+$")
	end

	local function encodeMorse(text)
		text = tostring(text or "")
		if text == "" then return text end
		local words = {}
		for word in text:gmatch("%S+") do
			local letters = {}
			for i = 1, #word do
				local c = word:sub(i, i):upper()
				letters[#letters+1] = MORSE_MAP[c] or c
			end
			words[#words+1] = Concat(letters, " ")
		end
		return Concat(words, " / ")
	end

	local function decodeMorse(text)
		text = tostring(text or "")
		if text == "" then return text end
		local words = {}
		for word in text:gmatch("[^/]+") do
			local trimmed = word:match("^%s*(.-)%s*$") or ""
			if trimmed ~= "" then
				local letters = {}
				for token in trimmed:gmatch("%S+") do
					letters[#letters+1] = MORSE_REVERSE[token] or "?"
				end
				words[#words+1] = Concat(letters)
			end
		end
		return Concat(words, " ")
	end

	translator.target = NAmanage.iso2(opt.chatTranslateTarget) or translator.target or "en"
	opt.chatTranslateTarget = translator.target

	translator._state = translator._state or {
		gv = (isfile and isfile("googlev.txt") and readfile("googlev.txt")) or "";
		fsid = nil;
		bl = nil;
		rid = math.random(1000, 9999);
	}

	local state = translator._state
	local root = "https://translate.google.com/"
	local exec = "https://translate.google.com/_/TranslateWebserverUi/data/batchexecute"
	local rpc = "MkEWBc"

	NAmanage.requestAsync=function(optArgs)
		local fn = opt.NAREQUEST
		if fn then
			local ok, res = pcall(fn, optArgs)
			if ok and res then
				return res
			end
		end
		local ok2, res2 = pcall(function()
			return Http:RequestAsync(optArgs)
		end)
		if ok2 and res2 then
			return res2
		end
		return nil
	end

	local function handleConsent(body)
		local tokens = {}
		for tag in body:gmatch('<input type="hidden" name=".-" value=".-">') do
			local k, v = tag:match('<input type="hidden" name="(.-)" value="(.-)">')
			if k and v then
				tokens[k] = v
			end
		end
		state.gv = tokens.v or state.gv or ""
		if writefile then
			pcall(writefile, "googlev.txt", state.gv)
		end
	end

	local function fetch(url, method, body)
		local res = NAmanage.requestAsync({
			Url = url;
			Method = method or "GET";
			Headers = { cookie = "CONSENT=YES+"..(state.gv or "") };
			Body = body;
		})
		if not res then
			return nil
		end
		local b = res.Body or res.body or ""
		if type(b) ~= "string" then
			b = tostring(b)
		end
		if b:find("https://consent.google.com/s") then
			handleConsent(b)
			res = NAmanage.requestAsync({
				Url = url;
				Method = "GET";
				Headers = { cookie = "CONSENT=YES+"..(state.gv or "") };
			})
			if not res then
				return nil
			end
		end
		return res
	end

	local function ensureSession()
		if state.fsid and state.bl then
			return true
		end
		local res = fetch(root)
		if not res then
			return false
		end
		local body = res.Body or res.body or ""
		if type(body) ~= "string" then
			body = tostring(body)
		end
		state.fsid = body:match('"FdrFJe":"(.-)"')
		state.bl = body:match('"cfb2h":"(.-)"')
		return state.fsid ~= nil and state.bl ~= nil
	end

	local function encodeQuery(data)
		local s = ""
		for k, v in pairs(data) do
			if type(v) == "table" then
				for _, vv in pairs(v) do
					s ..= "&"..Http:UrlEncode(k).."="..Http:UrlEncode(vv)
				end
			else
				s ..= "&"..Http:UrlEncode(k).."="..Http:UrlEncode(v)
			end
		end
		return s:sub(2)
	end

	local jsonEncode = function(x) return Http:JSONEncode(x) end
	local jsonDecode = function(x) return Http:JSONDecode(x) end

	local function translateSimple(text, target, source)
		target = NAmanage.iso2(target) or "en"
		source = NAmanage.iso2(source) or "auto"
		local url = ("https://translate.googleapis.com/translate_a/single?client=gtx&sl=%s&tl=%s&dt=t&q=%s")
			:format(Http:UrlEncode(source), Http:UrlEncode(target), Http:UrlEncode(text))
		local res = NAmanage.requestAsync({Url = url, Method = "GET"})
		if not res then return nil end
		local body = res.Body or res.body or ""
		local ok, data = pcall(function()
			return Http:JSONDecode(body)
		end)
		if not ok or type(data) ~= "table" then
			return nil
		end
		local segments = data[1]
		local detected = data[3]
		local parts = {}
		if type(segments) == "table" then
			for _, seg in ipairs(segments) do
				if type(seg) == "table" and type(seg[1]) == "string" then
					Insert(parts, seg[1])
				end
			end
		end
		local translated = Concat(parts, "")
		if translated == "" then
			translated = nil
		end
		return translated, detected
	end

	local function translatePayload(text, target, source)
		if not text or text == "" then
			return nil
		end

		local targetCode = NAmanage.iso2(target) or "en"
		local sourceCode = NAmanage.iso2(source) or "auto"

		if targetCode == "morse" then
			return encodeMorse(text), "morse"
		end

		local isMorseMsg = isLikelyMorse(text)
		if sourceCode == "morse" or isMorseMsg then
			local decoded = decodeMorse(text)
			if not decoded or decoded == "" then
				return nil
			end
			if targetCode == "auto" or targetCode == nil or targetCode == "en" then
				return decoded, "morse"
			end
			text = decoded
			sourceCode = "auto"
		end

		local translated, detected = translateSimple(text, targetCode, sourceCode)
		if translated and translated ~= "" then
			return translated, detected
		end
		if not ensureSession() then
			return translated, detected
		end
		state.rid += 10000
		local data = { { text, sourceCode, targetCode, true }, { nil } }
		local freq = { { { rpc, jsonEncode(data), nil, "generic" } } }
		local url = exec.."?"..encodeQuery({
			rpcids = rpc;
			["f.sid"] = state.fsid;
			bl = state.bl;
			hl = "en";
			_reqid = state.rid - 10000;
			rt = "c";
		})
		local body = encodeQuery({ ["f.req"] = jsonEncode(freq) })
		local res = fetch(url, "POST", body)
		if not res then
			return translated, detected
		end
		local raw = res.Body or res.body or ""
		if type(raw) ~= "string" then
			raw = tostring(raw)
		end
		local ok, parsed = pcall(function()
			local arr = jsonDecode(raw:match("%[.-%]\n"))
			return jsonDecode(arr[1][3])
		end)
		if not ok or type(parsed) ~= "table" then
			return translated, detected
		end
		local fallTranslated = nil
		pcall(function()
			fallTranslated = parsed[2][1][1][6][1][1]
		end)
		if type(fallTranslated) ~= "string" or fallTranslated == "" then
			return translated, detected
		end
		local detectedLang = parsed[3]
		return fallTranslated, detectedLang or detected
	end

	local function resizeLabel(label)
		if not (label and label.Parent and NAgui and NAgui.txtSize) then
			return
		end
		local ok, size = pcall(NAgui.txtSize, label, label.AbsoluteSize.X, 200)
		if ok and size then
			label.Size = UDim2.new(1, -5, 0, size.Y)
		end
	end

	local function normalizeRichTextEntities(text)
		text = tostring(text or "")
		if text == "" then
			return text
		end
		text = text:gsub("&amp;lt;", "&lt;")
		text = text:gsub("&amp;gt;", "&gt;")
		text = text:gsub("&amp;quot;", "&quot;")
		text = text:gsub("&amp;apos;", "&apos;")
		text = text:gsub("&amp;amp;", "&amp;")
		return text
	end

	local function escapeForRichText(text)
		local raw = tostring(text or "")
		local safe = originalIO.escapeRichTextText and originalIO.escapeRichTextText(raw) or raw
		return normalizeRichTextEntities(safe)
	end

	function translator:isEnabled()
		return self.enabled == true
	end

	function translator:updateUI()
		if self.button then
			if self:isEnabled() then
				self.button.Text = "TR: "..string.upper(self.target or "EN")
				self.button.BackgroundColor3 = Color3.fromRGB(68, 108, 68)
				self.button.TextColor3 = Color3.fromRGB(234, 234, 244)
			else
				self.button.Text = "TR: OFF"
				self.button.BackgroundColor3 = Color3.fromRGB(54, 54, 64)
				self.button.TextColor3 = Color3.fromRGB(178, 178, 188)
			end
		end

		local function normalizeRichTextEntities(text)
			text = tostring(text or "")
			if text == "" then
				return text
			end
			text = text:gsub("&amp;lt;", "&lt;")
			text = text:gsub("&amp;gt;", "&gt;")
			text = text:gsub("&amp;quot;", "&quot;")
			text = text:gsub("&amp;apos;", "&apos;")
			text = text:gsub("&amp;amp;", "&amp;")
			return text
		end

		local function escapeForRichText(text)
			local raw = tostring(text or "")
			local safe = originalIO.escapeRichTextText and originalIO.escapeRichTextText(raw) or raw
			return normalizeRichTextEntities(safe)
		end

		local function normalizeRichTextEntities(text)
			text = tostring(text or "")
			if text == "" then
				return text
			end
			text = text:gsub("&amp;lt;", "&lt;")
			text = text:gsub("&amp;gt;", "&gt;")
			text = text:gsub("&amp;quot;", "&quot;")
			text = text:gsub("&amp;apos;", "&apos;")
			text = text:gsub("&amp;amp;", "&amp;")
			return text
		end

		local function escapeForRichText(text)
			local raw = tostring(text or "")
			local safe = originalIO.escapeRichTextText and originalIO.escapeRichTextText(raw) or raw
			return normalizeRichTextEntities(safe)
		end
		if self.input and not self.input:IsFocused() then
			self.input.Text = string.upper(self.target or "EN")
		end
	end

	function translator:updateAllMessages()
		for _, info in pairs(self.messages) do
			if self:isEnabled() then
				self:ensureTranslation(info)
			end
			self:applyDisplay(info)
		end
	end

	function translator:setEnabled(state)
		local newState = state and true or false
		if self.enabled == newState then
			self.enabled = newState
			self:updateUI()
			return
		end
		self.enabled = newState
		opt.chatTranslateEnabled = newState
		pcall(NAmanage.NASettingsSet, "chatTranslate", newState)
		self:updateUI()
		self:updateAllMessages()
	end

	function translator:toggle()
		self:setEnabled(not self:isEnabled())
		return self.enabled
	end

	function translator:applyDisplay(info)
		if not info or not info.label then return end
		local label = info.label
		if not (label and label.Parent) then
			self.messages[label] = nil
			return
		end
		local text = normalizeRichTextEntities(info.base or "")
		if self:isEnabled() and info.translationLine then
			text = text.."\n"..normalizeRichTextEntities(info.translationLine)
		end
		label.Text = text
		resizeLabel(label)
	end

	function translator:ensureTranslation(info)
		if not info or info.translating then
			return
		end
		if info.translationLine and info.target == self.target then
			return
		end
		if not info.message or info.message == "" then
			return
		end
		info.translating = true
		info.target = self.target
		Spawn(function()
			local ok, translated, detected = pcall(translatePayload, info.message, self.target, "auto")
			info.translating = false
			if not ok then
				info.translationLine = nil
				self:applyDisplay(info)
				return
			end
			if not translated or translated == "" then
				info.translationLine = nil
				self:applyDisplay(info)
				return
			end
			local code = NAmanage.iso2(detected) or detected or "AUTO"
			local tag = tostring(code):upper()
			info.translationLine = ("[%s] %s"):format(self.target:upper(), escapeForRichText(translated))
			info.detected = tag
			self:applyDisplay(info)
		end)
	end

	function translator:registerMessage(label, baseText, rawMessage)
		if not label then return end
		local info = self.messages[label]
		if not info then
			info = {
				label = label;
				base = baseText or "";
				message = rawMessage or "";
				translationLine = nil;
				translating = false;
				target = nil;
			}
			self.messages[label] = info
			if label.Destroying then
				label.Destroying:Connect(function()
					self.messages[label] = nil
				end)
			end
			label.AncestryChanged:Connect(function(_, parent)
				if not parent then
					self.messages[label] = nil
				end
			end)
		else
			info.base = baseText or info.base
			info.message = rawMessage or info.message
			info.translationLine = nil
			info.target = nil
		end

		self:applyDisplay(info)
		self:ensureTranslation(info)
	end

	function translator:setTarget(lang)
		local code = NAmanage.iso2(lang)
		if not code then
			return false
		end
		if self.target == code then
			self:updateUI()
			return true, code, originalIO.languageName(code)
		end
		self.target = code
		opt.chatTranslateTarget = code
		pcall(NAmanage.NASettingsSet, "chatTranslateTarget", code)
		for _, info in pairs(self.messages) do
			info.translationLine = nil
			info.target = nil
			info.translating = false
			self:applyDisplay(info)
			self:ensureTranslation(info)
		end
		self:updateUI()
		return true, code, originalIO.languageName(code)
	end

	function translator:attachControls(button, input)
		if button and self.button ~= button then
			self.button = button
			MouseButtonFix(button, function()
				local nowEnabled = self:toggle()
				self:updateUI()
				DebugNotif("Chat translation "..(nowEnabled and "enabled" or "disabled"), 2)
			end)
		end
		if input and self.input ~= input then
			if self._inputConn then
				self._inputConn:Disconnect()
				self._inputConn = nil
			end
			self.input = input
			input.PlaceholderText = "Lang"
			input.ClearTextOnFocus = false
			self._inputConn = input.FocusLost:Connect(function(enterPressed)
				local text = input.Text or ""
				text = text:match("^%s*(.-)%s*$") or ""
				if text == "" then
					self:updateUI()
					return
				end
				local ok, code, name = self:setTarget(text)
				if not ok then
					DoNotif("Invalid language code. Example: en, bg, ja", 1.5)
				else
					DoNotif(("Chat translator target set to %s (%s)"):format(code:upper(), name), 1.5)
				end
				self:updateUI()
				if enterPressed then
					input:ReleaseFocus()
				end
			end)
		end
		self:updateUI()
	end

	function translator:tryAttach()
		local frame = NAUIMANAGER and NAUIMANAGER.chatLogsFrame
		if not frame then return end
		local button = frame:FindFirstChild("Translate", true)
		local input = frame:FindFirstChild("TranslateInput", true)
		if button or input then
			self:attachControls(button, input)
		end
	end

	function translator:showLanguages()
		local entries = {}
		for code, name in pairs(languages) do
			if code ~= "auto" then
				Insert(entries, { code, name })
			end
		end
		table.sort(entries, function(a, b)
			return a[1] < b[1]
		end)
		local lines = {}
		for _, info in ipairs(entries) do
			Insert(lines, info[1]:upper().." - "..info[2])
		end
		local text = Concat(lines, "\n")
		if typeof(DoWindow) == "function" then
			DoWindow("Supported chat translator languages:\n\n"..text)
		else
			print("[ChatTranslator languages]\n"..text)
			DoNotif("Supported languages printed to console output.", 4)
		end
	end

	translator:tryAttach()
	if NAStuff.NASCREENGUI and not translator._hookedWatcher then
		translator._hookedWatcher = true
		NAStuff.NASCREENGUI.DescendantAdded:Connect(function(inst)
			if inst and (inst.Name == "Translate" or inst.Name == "TranslateInput") then
				Defer(function()
					translator:tryAttach()
				end)
			end
		end)
	end
	translator:updateUI()
end
originalIO.naTransLatooor()

NAmanage.CommandKeybindsAdd=function()
	local UIS = UserInputService
	if not UIS then return end
	local listening = true
	local bindConn
	DoNotif("Press a key to bind to a command...", 3)
	NAStuff._capturingCommandKeybind = true
	bindConn = UIS.InputBegan:Connect(function(input, gameProcessed)
		if gameProcessed or not listening then return end
		if input.UserInputType ~= Enum.UserInputType.Keyboard or not input.KeyCode then return end
		listening = false
		if bindConn then bindConn:Disconnect() bindConn = nil end
		Defer(function()
			NAStuff._capturingCommandKeybind = false
		end)
		local keyName = input.KeyCode.Name
		Window({
			Title = "Command Keybind",
			Description = "Enter a command to run when "..keyName.." is pressed.",
			InputField = true,
			Buttons = {{
				Text = "Save",
				Callback = function(text)
					local raw = tostring(text or ""):match("^%s*(.-)%s*$")
					if raw == "" then
						DoNotif("Command cannot be empty.", 2)
						return
					end
					local args = ParseArguments(raw) or {}
					if #args == 0 then
						DoNotif("Command could not be parsed.", 2)
						return
					end
					CommandKeybinds[keyName] = args
					NAmanage.SaveCommandKeybinds()
					NAmanage.ApplyCommandKeybinds()
					DoNotif(("Bound %s to '%s'"):format(keyName, raw), 2)
				end
			}}
		})
	end)
	Spawn(function()
		Wait(5)
		if listening then
			listening = false
			if bindConn then bindConn:Disconnect() bindConn = nil end
			if NAStuff._capturingCommandKeybind then
				NAStuff._capturingCommandKeybind = false
				DoNotif("Command keybind capture timed out.", 2)
			end
		end
	end)
end

NAmanage.CommandKeybindsRemove=function()
	if type(CommandKeybinds) ~= "table" or not next(CommandKeybinds) then
		DoNotif("No command keybinds to remove.", 2)
		return
	end
	local buttons = {}
	for keyName, args in pairs(CommandKeybinds) do
		local label = (type(args) == "table" and #args > 0) and Concat(args, " ") or ""
		local opt = CommandKeybindOptions[keyName]
		if opt and opt.toggle then
			local toggleTag = opt.hold and "[hold]" or "[toggle]"
			local mainCmd = (type(args) == "table" and tostring(args[1] or "")) or ""
			local secondCmd = ""
			if opt.args2 and type(opt.args2) == "table" and opt.args2[1] then
				secondCmd = tostring(opt.args2[1])
			end
			if mainCmd ~= "" and secondCmd ~= "" then
				label = ("%s %s / %s"):format(toggleTag, mainCmd, secondCmd)
			else
				label = toggleTag.." "..label
			end
		end
		if opt and opt.disabled then
			if label == "" then
				label = "[disabled]"
			else
				label = label.." [disabled]"
			end
		end
		Insert(buttons, {
			Text = keyName.." -> "..label,
			Callback = function()
				CommandKeybinds[keyName] = nil
				CommandKeybindOptions[keyName] = nil
				NAmanage.SaveCommandKeybinds()
				NAmanage.ApplyCommandKeybinds()
				DoNotif("Removed keybind for "..keyName, 2)
			end
		})
	end
	Window({
		Title = "Remove Command Keybind",
		Description = "Select a keybind to remove:",
		Buttons = buttons,
	})
end

NAmanage.CommandKeybindsList=function()
	if type(CommandKeybinds) ~= "table" or not next(CommandKeybinds) then
		DoNotif("No command keybinds set.", 2)
		return
	end
	local lines = {}
	for keyName, args in pairs(CommandKeybinds) do
		local label = (type(args) == "table" and #args > 0) and Concat(args, " ") or ""
		local opt = CommandKeybindOptions[keyName]
		if opt and opt.toggle then
			local toggleTag = opt.hold and "[hold]" or "[toggle]"
			local mainCmd = (type(args) == "table" and tostring(args[1] or "")) or ""
			local secondCmd = ""
			if opt.args2 and type(opt.args2) == "table" and opt.args2[1] then
				secondCmd = tostring(opt.args2[1])
			end
			if mainCmd ~= "" and secondCmd ~= "" then
				label = ("%s %s / %s"):format(toggleTag, mainCmd, secondCmd)
			else
				label = toggleTag.." "..label
			end
		end
		if opt and opt.disabled then
			if label == "" then
				label = "[disabled]"
			else
				label = label.." [disabled]"
			end
		end
		Insert(lines, keyName.." > "..label)
	end
	local text = Concat(lines, "\n")
	if type(DoWindow) == "function" then
		DoWindow(text, "Command Keybinds")
	else
		print("[Command Keybinds]\n"..text)
		DoNotif("Command keybinds printed to console output.", 3)
	end
end

NAmanage.CommandKeybindsUIInit=function()
	local list = NAUIMANAGER and NAUIMANAGER.SettingsList
	if not list then
		return false
	end

	NAStuff._commandKeybindUI = NAStuff._commandKeybindUI or {}
	local ui = NAStuff._commandKeybindUI

	if ui.root and ui.root.Parent then
		return true
	end

	local function cloneSearchBox(parent, placeholder)
		local template = NAUIMANAGER and NAUIMANAGER.SettingsSearchBox
		local box
		if template and template.Parent then
			box = template:Clone()
		else
			box = InstanceNew("TextBox")
			box.BorderSizePixel = 0
			box.BackgroundColor3 = Color3.fromRGB(54, 54, 64)
			box.BackgroundTransparency = 0.2
			box.TextColor3 = Color3.fromRGB(234, 234, 244)
			box.FontFace = Font.new("rbxasset://fonts/families/Roboto.json", Enum.FontWeight.Regular, Enum.FontStyle.Normal)
			box.TextSize = 16
			box.ClearTextOnFocus = false
			local corner = InstanceNew("UICorner", box)
			corner.CornerRadius = UDim.new(0, 8)
			local stroke = InstanceNew("UIStroke", box)
			stroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
			stroke.Thickness = 1.5
			stroke.Color = NAUISTROKER or DEFAULT_UI_STROKE_COLOR or Color3.fromRGB(154, 99, 255)
			NAgui.RegisterColoredStroke(stroke)
		end
		box.Parent = parent
		box.Text = ""
		box.PlaceholderText = placeholder or ""
		box.ClearTextOnFocus = false
		NAgui.RegisterStrokesFrom(box)
		return box
	end

	local root = InstanceNew("Frame", list)
	root.Name = "CommandKeybindsPanel"
	root.BackgroundTransparency = 1
	root.BorderSizePixel = 0
	root.Size = UDim2.new(1, -10, 1, 0)
	root.LayoutOrder = NAgui._nextLayoutOrder()
	root.ClipsDescendants = false

	local keyBox = cloneSearchBox(root, "Key")
	keyBox.Name = "KeyBox"
	keyBox.TextEditable = false
	keyBox.Size = UDim2.new(0.28, -10, 0, 30)
	keyBox.Position = UDim2.new(0, 10, 0, 8)

	local cmdBox = cloneSearchBox(root, "Command")
	cmdBox.Name = "CmdBox"
	cmdBox.Size = UDim2.new(0.34, -10, 0, 30)
	cmdBox.Position = UDim2.new(0.28, 10, 0, 8)

	local argsBox = cloneSearchBox(root, "Args (space separated)")
	argsBox.Name = "ArgsBox"
	argsBox.Size = UDim2.new(0.38, -10, 0, 30)
	argsBox.Position = UDim2.new(0.62, 10, 0, 8)

	local toggleCmdBox = cloneSearchBox(root, "Toggle Command")
	toggleCmdBox.Name = "ToggleCmdBox"
	toggleCmdBox.Size = UDim2.new(0.34, -10, 0, 30)
	toggleCmdBox.Position = UDim2.new(0.28, 10, 0, 46)
	toggleCmdBox.Visible = false

	local toggleArgsBox = cloneSearchBox(root, "Toggle Args (space separated)")
	toggleArgsBox.Name = "ToggleArgsBox"
	toggleArgsBox.Size = UDim2.new(0.38, -10, 0, 30)
	toggleArgsBox.Position = UDim2.new(0.62, 10, 0, 46)
	toggleArgsBox.Visible = false

	local function makeActionButton(parent, text, pos, size, color)
		local btn = InstanceNew("TextButton", parent)
		btn.BorderSizePixel = 0
		btn.BackgroundTransparency = 0.2
		btn.BackgroundColor3 = color or Color3.fromRGB(54, 54, 64)
		btn.TextColor3 = Color3.fromRGB(234, 234, 244)
		btn.FontFace = Font.new("rbxasset://fonts/families/Roboto.json", Enum.FontWeight.SemiBold, Enum.FontStyle.Normal)
		btn.TextSize = 14
		btn.Text = text
		btn.Position = pos
		btn.Size = size
		local c = InstanceNew("UICorner", btn)
		c.CornerRadius = UDim.new(0, 8)
		local s = InstanceNew("UIStroke", btn)
		s.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
		s.Thickness = 1.5
		s.Color = NAUISTROKER or DEFAULT_UI_STROKE_COLOR or Color3.fromRGB(154, 99, 255)
		NAgui.RegisterColoredStroke(s)
		NAgui.RegisterStrokesFrom(btn)
		return btn
	end

	local setKeyBtn = makeActionButton(root, "Set Key (click)", UDim2.new(0, 10, 0, 46), UDim2.new(0.22, -10, 0, 30), Color3.fromRGB(54, 54, 64))
	local newBtn = makeActionButton(root, "New", UDim2.new(0.22, 10, 0, 46), UDim2.new(0.14, -10, 0, 30), Color3.fromRGB(54, 54, 64))
	local saveBtn = makeActionButton(root, "Save", UDim2.new(0.36, 10, 0, 46), UDim2.new(0.16, -10, 0, 30), Color3.fromRGB(80, 120, 80))
	local toggleBtn = makeActionButton(root, "Toggle: Off", UDim2.new(0.52, 10, 0, 46), UDim2.new(0.16, -10, 0, 30), Color3.fromRGB(54, 54, 64))
	local holdBtn = makeActionButton(root, "Hold: Off", UDim2.new(0.68, 10, 0, 46), UDim2.new(0.14, -10, 0, 30), Color3.fromRGB(54, 54, 64))
	local delBtn = makeActionButton(root, "Delete", UDim2.new(0.82, 10, 0, 46), UDim2.new(0.18, -10, 0, 30), Color3.fromRGB(184, 54, 54))

	local searchBox = cloneSearchBox(root, "Search keybinds...")
	searchBox.Name = "Search"
	searchBox.Size = UDim2.new(1, -20, 0, 30)
	searchBox.Position = UDim2.new(0, 10, 0, 122)

	local listFrame = InstanceNew("ScrollingFrame", root)
	listFrame.Name = "List"
	listFrame.BackgroundTransparency = 1
	listFrame.BorderSizePixel = 0
	listFrame.Size = UDim2.new(1, -10, 1, 0)
	listFrame.Position = UDim2.new(0, 5, 0, 160)
	listFrame.ScrollBarThickness = 3
	listFrame.ScrollBarImageColor3 = Color3.fromRGB(104, 104, 114)
	listFrame.CanvasSize = UDim2.new(0, 0, 0, 0)
	local layout = InstanceNew("UIListLayout", listFrame)
	layout.SortOrder = Enum.SortOrder.LayoutOrder
	layout.Padding = UDim.new(0, 6)
	layout.HorizontalAlignment = Enum.HorizontalAlignment.Center

	ui.root = root
	ui.searchBox = searchBox
	ui.listFrame = listFrame
	ui.keyBox = keyBox
	ui.cmdBox = cmdBox
	ui.argsBox = argsBox
	ui.toggleCmdBox = toggleCmdBox
	ui.toggleArgsBox = toggleArgsBox
	ui.setKeyBtn = setKeyBtn
	ui.newBtn = newBtn
	ui.saveBtn = saveBtn
	ui.toggleBtn = toggleBtn
	ui.holdBtn = holdBtn
	ui.delBtn = delBtn
	ui.selectedKey = nil
	ui.toggleState = false
	ui.holdState = false
	ui.disabledState = false

	NAmanage.registerElementForCurrentTab(root)
	NAgui.RegisterStrokesFrom(root)
	SpawnCall(function() RunService.RenderStepped:Connect(function() if root.Parent.ClassName:lower()=="scrollingframe" then updateCanvasSize(root.Parent) end updateCanvasSize(listFrame) end) end)

	return true
end

NAmanage.CommandKeybindsUpdateToggleLayout=function(ui)
	if not ui then return end
	local show = ui.toggleState and ui.toggleCmdBox and ui.toggleArgsBox
	if ui.toggleCmdBox then ui.toggleCmdBox.Visible = show and true or false end
	if ui.toggleArgsBox then ui.toggleArgsBox.Visible = show and true or false end

	local rowY = show and 84 or 46

	local function place(btn, pos, size)
		if not btn then return end
		btn.Position = UDim2.new(pos, 10, 0, rowY)
		btn.Size = UDim2.new(size, -10, 0, 30)
	end

	if show then
		if ui.toggleCmdBox then
			ui.toggleCmdBox.Position = UDim2.new(0.28, 10, 0, 46)
		end
		if ui.toggleArgsBox then
			ui.toggleArgsBox.Position = UDim2.new(0.62, 10, 0, 46)
		end
	end

	place(ui.setKeyBtn, 0, 0.22)
	place(ui.newBtn, 0.22, 0.14)
	place(ui.saveBtn, 0.36, 0.16)
	place(ui.toggleBtn, 0.52, 0.16)
	place(ui.holdBtn, 0.68, 0.14)
	place(ui.delBtn, 0.82, 0.18)

	if ui.holdBtn then
		ui.holdBtn.AutoButtonColor = ui.toggleState and true or false
		ui.holdBtn.BackgroundTransparency = ui.toggleState and 0.2 or 0.5
		ui.holdBtn.TextColor3 = ui.toggleState and Color3.fromRGB(234, 234, 244) or Color3.fromRGB(180, 180, 190)
		ui.holdBtn.Text = ui.holdState and "Hold: On" or "Hold: Off"
	end
end

NAmanage.CommandKeybindsUIRefresh=function()
	local ui = NAStuff._commandKeybindUI
	if not (ui and ui.listFrame and ui.listFrame.Parent) then
		return
	end

	local filter = ""
	if ui.searchBox then
		filter = Lower(tostring(ui.searchBox.Text or "")):match("^%s*(.-)%s*$") or ""
	end

	for _, child in ipairs(ui.listFrame:GetChildren()) do
		if child:IsA("Frame") then
			child:Destroy()
		end
	end

	local keys = {}
	for keyName in pairs(CommandKeybinds) do
		Insert(keys, keyName)
	end
	table.sort(keys, function(a, b)
		return tostring(a) < tostring(b)
	end)

	local function isDisabled(keyName)
		local opt = CommandKeybindOptions[keyName]
		return opt and opt.disabled == true
	end

	local function normalizeLabel(args)
		if type(args) ~= "table" or #args == 0 then
			return ""
		end
		return Concat(args, " ")
	end

	local function buildDisplayLabel(keyName, args)
		local baseLabel = normalizeLabel(args)
		local opt = CommandKeybindOptions[keyName]
		if not (opt and opt.toggle) then
			local label = baseLabel ~= "" and baseLabel or "(empty)"
			if isDisabled(keyName) then
				return label.." (disabled)"
			end
			return label
		end

		local mainCmd = (type(args) == "table" and tostring(args[1] or "")) or ""
		local secondCmd = ""
		if opt.args2 and type(opt.args2) == "table" and opt.args2[1] then
			secondCmd = tostring(opt.args2[1])
		end

		local tag = (opt and opt.hold) and "[hold]" or "[toggle]"

		if mainCmd ~= "" and secondCmd ~= "" then
			local label = ("%s %s / %s"):format(tag, mainCmd, secondCmd)
			if isDisabled(keyName) then
				return label.." (disabled)"
			end
			return label
		end

		local label = tag.." "..(baseLabel ~= "" and baseLabel or "(empty)")
		if isDisabled(keyName) then
			return label.." (disabled)"
		end
		return label
	end

	local idx = 0
	for _, keyName in ipairs(keys) do
		local args = CommandKeybinds[keyName]
		local label = normalizeLabel(args)
		local hay = Lower(keyName.." "..label)
		if filter ~= "" and not Find(hay, filter, 1, true) then
			continue
		end

		local disabled = isDisabled(keyName)

		idx += 1
		local row = InstanceNew("Frame", ui.listFrame)
		row.Name = "Row_"..tostring(keyName)
		row.BorderSizePixel = 0
		row.BackgroundColor3 = Color3.fromRGB(49, 49, 54)
		row.BackgroundTransparency = disabled and 0.35 or 0.25
		row.Size = UDim2.new(0.98, 0, 0, 32)
		row.LayoutOrder = idx
		local rc = InstanceNew("UICorner", row)
		rc.CornerRadius = UDim.new(0, 8)
		local rs = InstanceNew("UIStroke", row)
		rs.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
		rs.Thickness = 1
		NAgui.RegisterColoredStroke(rs)

		local keyLbl = InstanceNew("TextLabel", row)
		keyLbl.BackgroundTransparency = 1
		keyLbl.Size = UDim2.new(0, 60, 1, 0)
		keyLbl.Position = UDim2.new(0, 10, 0, 0)
		keyLbl.FontFace = Font.new("rbxasset://fonts/families/Roboto.json", Enum.FontWeight.SemiBold, Enum.FontStyle.Normal)
		keyLbl.TextSize = 14
		keyLbl.TextWrapped = true
		keyLbl.TextXAlignment = Enum.TextXAlignment.Left
		keyLbl.TextColor3 = disabled and Color3.fromRGB(184, 184, 194) or Color3.fromRGB(234, 234, 244)
		keyLbl.Text = tostring(keyName)

		local cmdLbl = InstanceNew("TextLabel", row)
		cmdLbl.BackgroundTransparency = 1
		cmdLbl.Size = UDim2.new(1, -240, 1, 0)
		cmdLbl.Position = UDim2.new(0, 70, 0, 0)
		cmdLbl.FontFace = Font.new("rbxasset://fonts/families/Roboto.json", Enum.FontWeight.Regular, Enum.FontStyle.Normal)
		cmdLbl.TextSize = 14
		cmdLbl.TextWrapped = true
		cmdLbl.TextXAlignment = Enum.TextXAlignment.Left
		cmdLbl.TextColor3 = disabled and Color3.fromRGB(170, 170, 182) or Color3.fromRGB(214, 214, 224)
		cmdLbl.Text = buildDisplayLabel(keyName, args)

		local editBtn = InstanceNew("TextButton", row)
		editBtn.BorderSizePixel = 0
		editBtn.BackgroundColor3 = Color3.fromRGB(54, 54, 64)
		editBtn.BackgroundTransparency = 0.2
		editBtn.Size = UDim2.new(0, 50, 0, 24)
		editBtn.Position = UDim2.new(1, -190, 0.5, -12)
		editBtn.Text = "Edit"
		editBtn.TextColor3 = Color3.fromRGB(234, 234, 244)
		editBtn.FontFace = Font.new("rbxasset://fonts/families/Roboto.json", Enum.FontWeight.SemiBold, Enum.FontStyle.Normal)
		editBtn.TextSize = 13
		local ec = InstanceNew("UICorner", editBtn)
		ec.CornerRadius = UDim.new(0, 8)
		NAgui.RegisterStrokesFrom(editBtn)

		local disableBtn = InstanceNew("TextButton", row)
		disableBtn.BorderSizePixel = 0
		disableBtn.BackgroundColor3 = disabled and Color3.fromRGB(80, 120, 80) or Color3.fromRGB(184, 124, 54)
		disableBtn.BackgroundTransparency = 0.2
		disableBtn.Size = UDim2.new(0, 60, 0, 24)
		disableBtn.Position = UDim2.new(1, -130, 0.5, -12)
		disableBtn.Text = disabled and "Enable" or "Disable"
		disableBtn.TextColor3 = Color3.fromRGB(244, 244, 244)
		disableBtn.FontFace = Font.new("rbxasset://fonts/families/Roboto.json", Enum.FontWeight.SemiBold, Enum.FontStyle.Normal)
		disableBtn.TextSize = 13
		local dbc = InstanceNew("UICorner", disableBtn)
		dbc.CornerRadius = UDim.new(0, 8)
		NAgui.RegisterStrokesFrom(disableBtn)

		local remBtn = InstanceNew("TextButton", row)
		remBtn.BorderSizePixel = 0
		remBtn.BackgroundColor3 = Color3.fromRGB(184, 54, 54)
		remBtn.BackgroundTransparency = 0.2
		remBtn.Size = UDim2.new(0, 60, 0, 24)
		remBtn.Position = UDim2.new(1, -60, 0.5, -12)
		remBtn.Text = "Delete"
		remBtn.TextColor3 = Color3.fromRGB(244, 244, 244)
		remBtn.FontFace = Font.new("rbxasset://fonts/families/Roboto.json", Enum.FontWeight.SemiBold, Enum.FontStyle.Normal)
		remBtn.TextSize = 13
		local dc = InstanceNew("UICorner", remBtn)
		dc.CornerRadius = UDim.new(0, 8)
		NAgui.RegisterStrokesFrom(remBtn)

		MouseButtonFix(editBtn, function()
			ui.selectedKey = tostring(keyName)
			if ui.keyBox then ui.keyBox.Text = tostring(keyName) end
			if ui.cmdBox then ui.cmdBox.Text = (type(args) == "table" and tostring(args[1] or "")) or "" end
			if ui.argsBox then
				if type(args) == "table" and #args > 1 then
					local parts = {}
					for i = 2, #args do
						Insert(parts, tostring(args[i]))
					end
					ui.argsBox.Text = Concat(parts, " ")
				else
					ui.argsBox.Text = ""
				end
			end

			local opt = CommandKeybindOptions[tostring(keyName)]
			local isToggle = opt and opt.toggle or false
			ui.disabledState = (opt and opt.disabled == true) or false

			if ui.toggleBtn then
				ui.toggleState = isToggle
				ui.toggleBtn.Text = ui.toggleState and "Toggle: On" or "Toggle: Off"
			end
			ui.holdState = (opt and opt.hold == true) or false
			if not ui.toggleState then
				ui.holdState = false
			end
			if ui.holdBtn then
				ui.holdBtn.Text = ui.holdState and "Hold: On" or "Hold: Off"
			end

			local args2 = (opt and type(opt.args2) == "table") and opt.args2 or nil
			if ui.toggleCmdBox then
				ui.toggleCmdBox.Text = args2 and tostring(args2[1] or "") or ""
			end
			if ui.toggleArgsBox then
				if args2 and #args2 > 1 then
					local tparts = {}
					for i = 2, #args2 do
						Insert(tparts, tostring(args2[i]))
					end
					ui.toggleArgsBox.Text = Concat(tparts, " ")
				else
					ui.toggleArgsBox.Text = ""
				end
			end

			NAmanage.CommandKeybindsUpdateToggleLayout(ui)
		end)

		MouseButtonFix(disableBtn, function()
			local k = tostring(keyName)
			local opt = CommandKeybindOptions[k] or {}
			opt.disabled = not (opt.disabled == true)
			if not opt.toggle and not opt.disabled then
				CommandKeybindOptions[k] = nil
			else
				CommandKeybindOptions[k] = opt
			end
			if ui.selectedKey == k then
				ui.disabledState = opt and opt.disabled == true or false
			end
			NAmanage.SaveCommandKeybinds()
			NAmanage.ApplyCommandKeybinds()
			NAmanage.CommandKeybindsUIRefresh()
			DoNotif(opt.disabled and ("Disabled keybind "..k) or ("Enabled keybind "..k), 2)
		end)

		MouseButtonFix(remBtn, function()
			CommandKeybinds[tostring(keyName)] = nil
			CommandKeybindOptions[tostring(keyName)] = nil
			NAmanage.SaveCommandKeybinds()
			NAmanage.ApplyCommandKeybinds()
			if ui.selectedKey == tostring(keyName) then
				ui.selectedKey = nil
				if ui.keyBox then ui.keyBox.Text = "" end
				if ui.cmdBox then ui.cmdBox.Text = "" end
				if ui.argsBox then ui.argsBox.Text = "" end
				if ui.toggleCmdBox then ui.toggleCmdBox.Text = "" end
				if ui.toggleArgsBox then ui.toggleArgsBox.Text = "" end
				ui.disabledState = false
				ui.toggleState = false
				ui.holdState = false
				if ui.toggleBtn then ui.toggleBtn.Text = "Toggle: Off" end
				if ui.holdBtn then ui.holdBtn.Text = "Hold: Off" end
				NAmanage.CommandKeybindsUpdateToggleLayout(ui)
			end
			NAmanage.CommandKeybindsUIRefresh()
		end)
	end
end

NAmanage.CommandKeybindsUIWire=function()
	local ui = NAStuff._commandKeybindUI
	if not (ui and ui.root and ui.root.Parent) then
		return
	end
	if ui._wired then
		return
	end
	ui._wired = true

	if ui.searchBox then
		ui.searchBox:GetPropertyChangedSignal("Text"):Connect(function()
			NAmanage.CommandKeybindsUIRefresh()
		end)
	end

	local function clearEditor()
		ui.selectedKey = nil
		if ui.keyBox then ui.keyBox.Text = "" end
		if ui.cmdBox then ui.cmdBox.Text = "" end
		if ui.argsBox then ui.argsBox.Text = "" end
		if ui.toggleCmdBox then ui.toggleCmdBox.Text = "" end
		if ui.toggleArgsBox then ui.toggleArgsBox.Text = "" end
		ui.disabledState = false
		if ui.toggleBtn then
			ui.toggleState = false
			ui.toggleBtn.Text = "Toggle: Off"
		end
		ui.holdState = false
		if ui.holdBtn then
			ui.holdBtn.Text = "Hold: Off"
		end
		NAmanage.CommandKeybindsUpdateToggleLayout(ui)
	end

	if ui.newBtn then
		MouseButtonFix(ui.newBtn, function()
			clearEditor()
		end)
	end

	if ui.toggleBtn then
		MouseButtonFix(ui.toggleBtn, function()
			ui.toggleState = not ui.toggleState
			if not ui.toggleState then
				ui.holdState = false
			end
			ui.toggleBtn.Text = ui.toggleState and "Toggle: On" or "Toggle: Off"
			if ui.holdBtn then
				ui.holdBtn.Text = ui.holdState and "Hold: On" or "Hold: Off"
			end
			NAmanage.CommandKeybindsUpdateToggleLayout(ui)
		end)
	end

	if ui.holdBtn then
		MouseButtonFix(ui.holdBtn, function()
			if not ui.toggleState then
				DoNotif("Enable Toggle before using Hold mode.", 1.5)
				return
			end
			ui.holdState = not ui.holdState
			ui.holdBtn.Text = ui.holdState and "Hold: On" or "Hold: Off"
			NAmanage.CommandKeybindsUpdateToggleLayout(ui)
		end)
	end

	-- ensure initial layout matches default toggle state
	NAmanage.CommandKeybindsUpdateToggleLayout(ui)

	if ui.setKeyBtn then
		MouseButtonFix(ui.setKeyBtn, function()
			if ui._cap then
				ui._cap = false
				NAStuff._capturingCommandKeybind = false
				ui.setKeyBtn.Text = "Set Key"
				DoNotif("Cancelled", 1.5)
				return
			end

			ui._cap = true
			ui._capTok = (ui._capTok or 0) + 1
			local tok = ui._capTok

			NAStuff._capturingCommandKeybind = true
			ui.setKeyBtn.Text = "Cancel"
			DoNotif("Press a key to set...", 2)

			local conn
			local function stop(msg)
				if tok ~= ui._capTok then return end
				ui._capTok = (ui._capTok or 0) + 1
				ui._cap = false
				ui.setKeyBtn.Text = "Set Key"
				if conn then conn:Disconnect() conn = nil end
				Defer(function()
					NAStuff._capturingCommandKeybind = false
				end)
				if msg then DoNotif(msg, 1.5) end
			end

			conn = UserInputService.InputBegan:Connect(function(input, gp)
				if tok ~= ui._capTok then return end
				if gp then return end
				if input.UserInputType ~= Enum.UserInputType.Keyboard or not input.KeyCode then return end

				local keyName = input.KeyCode.Name
				if ui.keyBox then ui.keyBox.Text = keyName end
				stop()
			end)

			Spawn(function()
				Wait(5)
				if tok ~= ui._capTok then return end
				stop("Key capture timed out.")
			end)
		end)
	end

	if ui.saveBtn then
		MouseButtonFix(ui.saveBtn, function()
			local keyName = ui.keyBox and tostring(ui.keyBox.Text or ""):match("^%s*(.-)%s*$") or ""
			local cmdName = ui.cmdBox and tostring(ui.cmdBox.Text or ""):match("^%s*(.-)%s*$") or ""
			local argsRaw = ui.argsBox and tostring(ui.argsBox.Text or "") or ""
			local toggleCmdName = ui.toggleCmdBox and tostring(ui.toggleCmdBox.Text or ""):match("^%s*(.-)%s*$") or ""
			local toggleArgsRaw = ui.toggleArgsBox and tostring(ui.toggleArgsBox.Text or "") or ""

			if keyName == "" then
				DoNotif("Pick a key first.", 2)
				return
			end
			if cmdName == "" then
				DoNotif("Command cannot be empty.", 2)
				return
			end
			local args = { cmdName }
			local extra = ParseArguments(argsRaw)
			if extra then
				for _, v in ipairs(extra) do
					Insert(args, v)
				end
			end

			local prevKey = ui.selectedKey
			if prevKey and prevKey ~= "" and prevKey ~= keyName then
				CommandKeybinds[prevKey] = nil
				CommandKeybindOptions[prevKey] = nil
			end
			CommandKeybinds[keyName] = args
			local opt = CommandKeybindOptions[keyName] or {}
			if ui.toggleState then
				opt.toggle = true
				opt.state = false
				opt.hold = ui.holdState and true or nil
				-- build second layer: either from explicit toggle fields or just reuse the first command
				local args2 = nil
				if toggleCmdName ~= "" then
					args2 = { toggleCmdName }
					local extra2 = ParseArguments(toggleArgsRaw)
					if extra2 then
						for _, v in ipairs(extra2) do
							Insert(args2, v)
						end
					end
				else
					args2 = {}
					for i, v in ipairs(args) do
						args2[i] = v
					end
				end
				opt.args2 = args2
			else
				opt.toggle = nil
				opt.state = nil
				opt.args2 = nil
				opt.hold = nil
				ui.holdState = false
			end
			opt.disabled = ui.disabledState and true or nil
			if not opt.toggle and not opt.disabled then
				CommandKeybindOptions[keyName] = nil
			else
				CommandKeybindOptions[keyName] = opt
			end
			ui.selectedKey = keyName
			ui.disabledState = opt and opt.disabled == true or false

			NAmanage.SaveCommandKeybinds()
			NAmanage.ApplyCommandKeybinds()
			NAmanage.CommandKeybindsUIRefresh()
			DoNotif(("Saved %s > %s"):format(keyName, Concat(args, " ")), 2)
		end)
	end

	if ui.delBtn then
		MouseButtonFix(ui.delBtn, function()
			local keyName = ui.keyBox and tostring(ui.keyBox.Text or ""):match("^%s*(.-)%s*$") or ""
			if keyName == "" then
				DoNotif("No key selected.", 2)
				return
			end
			CommandKeybinds[keyName] = nil
			CommandKeybindOptions[keyName] = nil
			NAmanage.SaveCommandKeybinds()
			NAmanage.ApplyCommandKeybinds()
			clearEditor()
			NAmanage.CommandKeybindsUIRefresh()
			DoNotif("Deleted keybind "..keyName, 2)
		end)
	end
end

--[[ CHAT TO USE COMMANDS ]]--
function bindToChat(plr, msg)
	local shouldDisplay = NAmanage.jlCfg.ChatLog ~= false
	local shouldSave = NAmanage.jlCfg.SaveChatLog == true

	if not shouldDisplay and not shouldSave then
		return
	end

	local displayName = plr.DisplayName or "Unknown"
	local userName = plr.Name or "Unknown"
	local currentTime = os.date("%Y-%m-%d %H:%M:%S")
	local baseText
	if displayName == userName then
		baseText = ("@%s: %s"):format(userName, msg)
	else
		baseText = ("%s [@%s]: %s"):format(displayName, userName, msg)
	end

	local chatMsg = nil
	if shouldDisplay then
		chatMsg = NAUIMANAGER.chatExample:Clone()

		for _, v in pairs(NAUIMANAGER.chatLogs:GetChildren()) do
			if v:IsA("TextLabel") then
				v.LayoutOrder = v.LayoutOrder + 1
			end
		end

		chatMsg.Name = '\0'
		chatMsg.Parent = NAUIMANAGER.chatLogs
		chatMsg.Text = baseText

		if NAmanage.AttachMessageCopy then
			NAmanage.AttachMessageCopy(chatMsg, tostring(msg or ""))
		end

		local isNAadmin = false
		if _G.NAadminsLol then
			for _, id in ipairs(_G.NAadminsLol) do
				if plr.UserId == id then
					isNAadmin = true
					break
				end
			end
		end

		if isNAadmin then
			local function rainbowColor(now)
				local r = math.sin(now * 0.5) * 127 + 128
				local g = math.sin(now * 0.5 + 2 * math.pi / 3) * 127 + 128
				local b = math.sin(now * 0.5 + 4 * math.pi / 3) * 127 + 128
				return Color3.fromRGB(r, g, b)
			end

			NAStuff.AdminChatRainbowMessages = NAStuff.AdminChatRainbowMessages or {}
			Insert(NAStuff.AdminChatRainbowMessages, chatMsg)

			if not NAStuff.AdminChatRainbowConnection then
				local lastUpdate = 0
				NAStuff.AdminChatRainbowConnection = RunService.Heartbeat:Connect(function()
					local now = tick()
					if now - lastUpdate < 0.12 then
						return
					end
					lastUpdate = now

					local list = NAStuff.AdminChatRainbowMessages
					if not list then
						return
					end
					for i = #list, 1, -1 do
						local label = list[i]
						if not label or not label.Parent then
							table.remove(list, i)
						else
							label.TextColor3 = rainbowColor(now)
						end
					end
					if #list == 0 and NAStuff.AdminChatRainbowConnection then
						NAStuff.AdminChatRainbowConnection:Disconnect()
						NAStuff.AdminChatRainbowConnection = nil
					end
				end)
			end
		else
			if plr == LocalPlayer then
				chatMsg.TextColor3 = Color3.fromRGB(0, 155, 255)
			elseif LocalPlayer:IsFriendsWith(plr.UserId) then
				chatMsg.TextColor3 = Color3.fromRGB(255, 255, 0)
			end
		end

		local translator = NAStuff.ChatTranslator
		if translator then
			translator:registerMessage(chatMsg, baseText, msg)
		end
	end

	pcall(function()
		if shouldSave and FileSupport and appendfile then
			local cEntry = Format(
				"[%s] %s | Game: %s | PlaceId: %s | GameId: %s | JobId: %s\n",
				currentTime,
				baseText,
				placeName() or "unknown",
				tostring(PlaceId),
				tostring(GameId),
				tostring(JobId)
			)
			if isfile(NAfiles.NACHATLOGS) then
				appendfile(NAfiles.NACHATLOGS, cEntry)
			else
				writefile(NAfiles.NACHATLOGS, cEntry)
			end
		end
	end)

	if shouldDisplay and chatMsg then
		local txtSize = NAgui.txtSize(chatMsg, chatMsg.AbsoluteSize.X, 200)
		chatMsg.Size = UDim2.new(1, -5, 0, txtSize.Y)

		local MAX_MESSAGES = 200
		local chatFrames = {}
		for _, v in pairs(NAUIMANAGER.chatLogs:GetChildren()) do
			if v:IsA("TextLabel") then
				Insert(chatFrames, v)
			end
		end

		table.sort(chatFrames, function(a, b)
			return a.LayoutOrder < b.LayoutOrder
		end)

		if #chatFrames > MAX_MESSAGES then
			for i = MAX_MESSAGES + 1, #chatFrames do
				chatFrames[i]:Destroy()
			end
		end
	end
end

NAmanage.bindToDevConsole = function()
	if not NAUIMANAGER.NAconsoleLogs or not NAUIMANAGER.NAconsoleExample then return end

	local activeLogs, pool, pending = {}, {}, {}
	local buttonTypes = { "Output", "Info", "Warn", "Error" }
	local savedFilters
	if NAmanage and NAmanage.NASettingsGet then
		local ok, result = pcall(function()
			return NAmanage.NASettingsGet("devConsoleFilters")
		end)
		if ok and type(result) == "table" then
			savedFilters = result
		end
	end
	local toggles = {}
	for _, logType in ipairs(buttonTypes) do
		local savedValue = savedFilters and savedFilters[logType]
		if type(savedValue) == "boolean" then
			toggles[logType] = savedValue
		else
			toggles[logType] = true
		end
	end

	local SELECTED_COLOR = Color3.fromRGB(0, 255, 0)
	local DESELECTED_COLOR = Color3.fromRGB(255, 255, 255)

	local FilterButtons = InstanceNew("Frame")
	FilterButtons.Name = "FilterButtons"
	FilterButtons.Size = UDim2.new(1, -10, 0, 22)
	FilterButtons.Position = UDim2.new(0.5, 0, 0, 30)
	FilterButtons.AnchorPoint = Vector2.new(0.5, 0)
	FilterButtons.BackgroundTransparency = 1
	FilterButtons.Parent = NAUIMANAGER.NAconsoleLogs.Parent

	local layout = InstanceNew("UIListLayout")
	layout.FillDirection = Enum.FillDirection.Horizontal
	layout.HorizontalAlignment = Enum.HorizontalAlignment.Center
	layout.SortOrder = Enum.SortOrder.LayoutOrder
	layout.Padding = UDim.new(0, 6)
	layout.Parent = FilterButtons

	for _, logType in ipairs(buttonTypes) do
		local btnContainer = InstanceNew("Frame")
		btnContainer.Name = logType
		btnContainer.Size = UDim2.new(0, 90, 1, 0)
		btnContainer.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
		btnContainer.Parent = FilterButtons

		local corner = InstanceNew("UICorner")
		corner.CornerRadius = UDim.new(1, 0)
		corner.Parent = btnContainer

		local checkbox = InstanceNew("Frame")
		checkbox.Name = "Checkbox"
		checkbox.Size = UDim2.new(0, 18, 0, 18)
		checkbox.Position = UDim2.new(0, 5, 0.5, 0)
		checkbox.AnchorPoint = Vector2.new(0, 0.5)
		checkbox.BackgroundColor3 = toggles[logType] and SELECTED_COLOR or DESELECTED_COLOR
		checkbox.BorderSizePixel = 0
		checkbox.Parent = btnContainer

		local boxCorner = InstanceNew("UICorner")
		boxCorner.CornerRadius = UDim.new(0, 4)
		boxCorner.Parent = checkbox

		local label = InstanceNew("TextLabel")
		label.Name = "Label"
		label.Text = logType
		label.Position = UDim2.new(0, 28, 0, 0)
		label.Size = UDim2.new(1, -28, 1, 0)
		label.BackgroundTransparency = 1
		label.Font = Enum.Font.Gotham
		label.TextSize = 14
		label.TextColor3 = Color3.fromRGB(255, 255, 255)
		label.TextXAlignment = Enum.TextXAlignment.Center
		label.Parent = btnContainer

		local clickZone = InstanceNew("TextButton")
		clickZone.Name = "ClickArea"
		clickZone.Size = UDim2.new(1, 0, 1, 0)
		clickZone.BackgroundTransparency = 1
		clickZone.Text = ""
		clickZone.Parent = btnContainer

		MouseButtonFix(clickZone, function()
			toggles[logType] = not toggles[logType]

			if NAmanage and NAmanage.NASettingsSet then
				local ok, saved = pcall(function()
					return NAmanage.NASettingsSet("devConsoleFilters", toggles)
				end)
				if ok and type(saved) == "table" then
					for _, key in ipairs(buttonTypes) do
						local savedValue = saved[key]
						if type(savedValue) == "boolean" then
							toggles[key] = savedValue
						end
					end
				end
			end

			local targetColor = toggles[logType] and SELECTED_COLOR or DESELECTED_COLOR
			local tweenInfo = TweenInfo.new(0.3, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut)
			TweenService:Create(checkbox, tweenInfo, {BackgroundColor3 = targetColor}):Play()

			local query = NAUIMANAGER.NAfilter.Text:lower()
			for i = 1, #activeLogs do
				local lbl = activeLogs[i]
				if lbl and lbl.Parent then
					local tag = lbl:GetAttribute("Tag")
					local matchesSearch = query == "" or Find(lbl.Text:lower(), query)
					lbl.Visible = toggles[tag] and matchesSearch
				end
			end
		end)
	end

	NAUIMANAGER.NAfilter:GetPropertyChangedSignal("Text"):Connect(function()
		local query = NAUIMANAGER.NAfilter.Text:lower()
		for i = 1, #activeLogs do
			local lbl = activeLogs[i]
			if lbl and lbl.Parent then
				local tag = lbl:GetAttribute("Tag")
				local matches = query == "" or Find(lbl.Text:lower(), query)
				lbl.Visible = toggles[tag] and matches
			end
		end
	end)

	local function acquireLabel()
		if not NAUIMANAGER.NAconsoleLogs or not NAUIMANAGER.NAconsoleLogs.Parent then return nil end
		local lbl = table.remove(pool)
		if not lbl then
			lbl = NAUIMANAGER.NAconsoleExample:Clone()
			lbl.RichText = true
			lbl.AutoLocalize = false
			pcall(function() lbl.Active = true end)
			lbl.TextWrapped = true
			lbl.TextScaled = true
		end
		if not pcall(function() lbl.Parent = NAUIMANAGER.NAconsoleLogs end) then return nil end
		return lbl
	end

	local function recycleOldest()
		local oldest = table.remove(activeLogs, 1)
		if oldest then
			oldest.Visible = false
			oldest.Parent = nil
			Insert(pool, oldest)
		end
	end

	local function escape(s)
		return s:gsub("&","&amp;"):gsub("<","&lt;"):gsub(">","&gt;")
	end

	local function measureHeight(lbl, width)
		local plain = lbl.Text:gsub("<.->","")
		local baseSize = NAUIMANAGER.NAconsoleExample.TextSize or 14
		local vec = TextService:GetTextSize(plain, baseSize, lbl.Font, Vector2.new(width, 1e6))
		local h = vec.Y
		if h < 18 then h = 18 end
		return math.floor(h + 0.5)
	end

	local messageCounter = 0
	local MAX_MESSAGES = 200

	RunService.Heartbeat:Connect(function()
		if not NAUIMANAGER.NAconsoleLogs or not NAUIMANAGER.NAconsoleLogs.Parent then return end
		local perStep = 30
		local processed = 0
		while processed < perStep and #pending > 0 do
			local item = table.remove(pending, 1)
			if toggles[item.t] then
				local logLabel = acquireLabel()
				if not logLabel then break end
				messageCounter += 1
				logLabel.Name = "Log_"..tostring(messageCounter)
				logLabel.LayoutOrder = messageCounter
				logLabel.Text = '<font color="'..item.c..'">['..item.t..']</font>: <font color="#ffffff">'..item.m..'</font>'
				logLabel:SetAttribute("Tag", item.t)

				local width = NAUIMANAGER.NAconsoleLogs.AbsoluteSize.X
				local h = measureHeight(logLabel, width)
				logLabel.Size = UDim2.new(1, 0, 0, h)

				activeLogs[#activeLogs + 1] = logLabel
				if #activeLogs > MAX_MESSAGES then
					recycleOldest()
				end

				local query = NAUIMANAGER.NAfilter.Text:lower()
				local matchesSearch = query == "" or Find(logLabel.Text:lower(), query)
				logLabel.Visible = toggles[item.t] and matchesSearch
				processed += 1
			end
		end
	end)

	SafeGetService("LogService").MessageOut:Connect(function(msg, msgTYPE)
		local tagColor = "#cccccc"
		local tagText = "Output"
		if msgTYPE == Enum.MessageType.MessageError then
			tagColor = "#ff6464"
			tagText = "Error"
		elseif msgTYPE == Enum.MessageType.MessageWarning then
			tagColor = "#ffcc00"
			tagText = "Warn"
		elseif msgTYPE == Enum.MessageType.MessageInfo then
			tagColor = "#66ccff"
			tagText = "Info"
		end
		if not toggles[tagText] then return end
		Insert(pending, { m = escape(msg), t = tagText, c = tagColor })
	end)
end

--[[function NAUISCALEUPD()
	if not workspace.CurrentCamera then return end

	local screenHeight = workspace.CurrentCamera.ViewportSize.Y
	local baseHeight = 720
	AUTOSCALER.Scale = math.clamp(screenHeight / baseHeight, 0.75, 1.25)
end]]

logClrs={
	GREEN   = "#00FF00";
	WHITE   = "#FFFFFF";
	RED     = "#FF0000";
}

binderKillerTags = {
	"creator",
	"Creator",
	"creatorPlayer",
	"creatorTag",
	"killer",
	"Killer",
	"attacker",
	"Attacker",
	"DamageOwner",
	"DamageTag",
	"LastDamager",
	"lastDamager",
}

originalIO.binderResolvePlayerFromValue=function(value)
	if typeof(value) == "Instance" then
		if value:IsA("Player") then
			return value
		end
		return Players:GetPlayerFromCharacter(value)
	end
	if type(value) == "number" then
		local ok, plr = pcall(function()
			return Players:GetPlayerByUserId(value)
		end)
		if ok and plr then
			return plr
		end
	elseif type(value) == "string" then
		return Players:FindFirstChild(value)
	end
	return nil
end

originalIO.binderFindPlayerInTag=function(tag)
	if not tag then
		return nil
	end
	if tag:IsA("ObjectValue") then
		return originalIO.binderResolvePlayerFromValue(tag.Value)
	end
	if tag:IsA("StringValue") then
		return Players:FindFirstChild(tag.Value)
	end
	if tag:IsA("IntValue") or tag:IsA("NumberValue") then
		local ok, plr = pcall(function()
			return Players:GetPlayerByUserId(tag.Value)
		end)
		if ok and plr then
			return plr
		end
	end
	if tag:IsA("ValueBase") then
		return originalIO.binderResolvePlayerFromValue(tag.Value)
	end
	if tag:IsA("Folder") or tag:IsA("Model") then
		for _, child in ipairs(tag:GetChildren()) do
			local result = originalIO.binderFindPlayerInTag(child)
			if result then
				return result
			end
		end
	end
	return originalIO.binderResolvePlayerFromValue(tag)
end

originalIO.binderFindKiller=function(humanoid)
	if not humanoid then
		return nil
	end
	for _, name in ipairs(binderKillerTags) do
		local tag = humanoid:FindFirstChild(name)
		local killer = originalIO.binderFindPlayerInTag(tag)
		if killer then
			return killer
		end
	end
	for _, child in ipairs(humanoid:GetChildren()) do
		local killer = originalIO.binderFindPlayerInTag(child)
		if killer then
			return killer
		end
	end
	return nil
end

originalIO.binderAttachHumanoidListeners=function(plr, hum)
	if not (plr and hum) then
		return
	end
	local lastHP = hum.Health
	hum.Died:Connect(function()
		NAmanage.ExecuteBindings("OnDeath", plr)
		local killer = originalIO.binderFindKiller(hum)
		if killer then
			NAmanage.ExecuteBindings("OnKill", killer, plr)
		end
	end)
	hum.HealthChanged:Connect(function(newHP)
		if newHP < lastHP then
			NAmanage.ExecuteBindings("OnDamage", plr, lastHP, newHP)
		end
		lastHP = newHP
	end)
	hum.StateChanged:Connect(function(_, newState)
		if newState == Enum.HumanoidStateType.Jumping then
			NAmanage.ExecuteBindings("OnJump", plr, hum)
		end
	end)
end

originalIO.binderAttachToolListeners=function(plr, char)
	if not (plr and char) then
		return
	end
	char.ChildAdded:Connect(function(child)
		if child:IsA("Tool") then
			NAmanage.ExecuteBindings("OnEquipItem", plr, child)
		end
	end)
	char.ChildRemoved:Connect(function(child)
		if child:IsA("Tool") then
			NAmanage.ExecuteBindings("OnUnequipItem", plr, child)
		end
	end)
end

originalIO.binderSetupCharacter=function(plr, char)
	if not char then
		return
	end
	originalIO.binderAttachToolListeners(plr, char)
	local hum = getHum(char)
	if hum then
		originalIO.binderAttachHumanoidListeners(plr, hum)
	end
end

originalIO.waitForCharacterReady=function(plr)
	if not plr then
		return nil
	end
	while plr.Parent do
		local char = plr.Character
		if char and NAmanage.IsValidESPModel(char, false) then
			return char
		end
		Wait(0.25)
	end
	return nil
end

function setupPlayer(plr,bruh)
	NAmanage.ExecuteBindings("OnJoin", plr)

	plr.Chatted:Connect(function(msg)
		bindToChat(plr, msg)
		NAmanage.ExecuteBindings("OnChatted", plr, msg)
		if NAmanage.WebhookChat then
			NAmanage.WebhookChat(plr, msg)
		end
	end)

	if plr ~= LocalPlayer then
		SpawnCall(function() CheckPermissions(plr) end)
	end

	if ESPPlayersEnabled and ESPAutoTrackAll then
		SpawnCall(function()
			local char = originalIO.waitForCharacterReady(plr)
			if char then
				NAmanage.ESP_Add(plr,true)
			end
		end)
	end

	plr.CharacterAdded:Connect(function(char)
		NAmanage.ExecuteBindings("OnSpawn", plr, char)
		originalIO.binderSetupCharacter(plr, char)
	end)

	if not bruh and plr.Character then
		originalIO.binderSetupCharacter(plr, plr.Character)
	end

	if NAmanage.jlCfg.JoinLog and not bruh then
		local joinMsg = nameChecker(plr).." has joined the game."
		local categoryRT = ('<font color="%s">Join</font>/'..'<font color="%s">Leave</font>'):format(logClrs.GREEN, logClrs.WHITE)
		DoNotif(joinMsg, 1, categoryRT)
		NAmanage.LogJoinLeave(joinMsg)
	end
	if NAmanage.WebhookJoinLeave then
		NAmanage.WebhookJoinLeave(plr, "join")
	end
end

for _, plr in pairs(Players:GetPlayers()) do
	setupPlayer(plr, true)
	if plr.Character then
		originalIO.binderSetupCharacter(plr, plr.Character)
	end
end

Players.PlayerAdded:Connect(setupPlayer)

Players.PlayerRemoving:Connect(function(plr)
	NAmanage.ExecuteBindings("OnLeave", plr)
	NAmanage.ESP_Disconnect(plr)
	if NAmanage.jlCfg.LeaveLog then
		local leaveMsg = nameChecker(plr).." has left the game."
		local categoryRT = ('<font color="%s">Join</font>/'..'<font color="%s">Leave</font>'):format(logClrs.WHITE, logClrs.RED)
		DoNotif(leaveMsg, 1, categoryRT)
		NAmanage.LogJoinLeave(leaveMsg)
	end
	if NAmanage.WebhookJoinLeave then
		NAmanage.WebhookJoinLeave(plr, "leave")
	end
end)

SpawnCall(function()
	local HUI = (typeof(gethui) == "function" and gethui()) or nil

	local function hookFriendLabel(o)
		if not o or typeof(o) ~= "Instance" then return end
		if HUI and o:IsDescendantOf(HUI) then return end
		if not (o:IsA("TextLabel") or o:IsA("TextButton") or o:IsA("TextBox")) then return end
		if o:GetAttribute("NAFriendHooked") then return end
		o:SetAttribute("NAFriendHooked", true)

		local applying = false
		local function apply()
			if applying then return end
			applying = true
			local ok, t = pcall(function()
				return o.Text
			end)
			if ok and type(t) == "string" and t ~= "" and t:find("Connection") then
				local new = t:gsub("Connections", "Friends"):gsub("Connection", "Friend")
				if new ~= t then
					pcall(function()
						o.Text = new
					end)
				end
			end
			applying = false
		end

		Defer(apply)
		o:GetPropertyChangedSignal("Text"):Connect(function()
			Defer(apply)
		end)
	end

	local function registerInteract(inst)
		if HUI and inst:IsDescendantOf(HUI) then return end
		if inst:IsA("ClickDetector") then
			Insert(interactTbl.click, inst)
		elseif inst:IsA("ProximityPrompt") then
			Insert(interactTbl.proxy, inst)
		elseif inst:IsA("TouchTransmitter") then
			Insert(interactTbl.touch, inst)
		end
	end

	local function batchedScan(root, fn, batchSize, timeBudget)
		if not root then return end
		batchSize = batchSize or 125
		timeBudget = timeBudget or 0.006
		local n, start = 0, os.clock()
		for _, inst in ipairs(root:GetDescendants()) do
			fn(inst)
			n += 1
			if n % batchSize == 0 and (os.clock() - start) >= timeBudget then
				start = os.clock()
				Wait()
			end
		end
	end

	if CoreGui then
		Spawn(function()
			batchedScan(CoreGui, hookFriendLabel, 100, 0.004)
		end)
		CoreGui.DescendantAdded:Connect(function(o)
			if HUI and o:IsDescendantOf(HUI) then return end
			Defer(function()
				hookFriendLabel(o)
				for _, c in ipairs(o:GetDescendants()) do
					hookFriendLabel(c)
				end
			end)
		end)
	end

	if PlrGui then
		Spawn(function()
			batchedScan(PlrGui, hookFriendLabel, 100, 0.004)
		end)
		PlrGui.DescendantAdded:Connect(function(o)
			if HUI and o:IsDescendantOf(HUI) then return end
			Defer(function()
				hookFriendLabel(o)
			end)
		end)
	end

	Spawn(function()
		batchedScan(workspace, registerInteract, 200, 0.006)
	end)

	workspace.DescendantAdded:Connect(function(inst)
		Defer(function()
			registerInteract(inst)
		end)
	end)

	workspace.DescendantRemoving:Connect(function(inst)
		Defer(function()
			if inst:IsA("ClickDetector") then
				local i = Discover(interactTbl.click, inst)
				if i then
					table.remove(interactTbl.click, i)
				end
			elseif inst:IsA("ProximityPrompt") then
				local i = Discover(interactTbl.proxy, inst)
				if i then
					table.remove(interactTbl.proxy, i)
				end
			elseif inst:IsA("TouchTransmitter") then
				local i = Discover(interactTbl.touch, inst)
				if i then
					table.remove(interactTbl.touch, i)
				end
			end
		end)
	end)
end)

SpawnCall(function()
	local function setupFLASHBACK(c)
		if not c then return end
		local hum=getHum()
		while not hum do Wait(.1) hum=getHum() end
		hum.Died:Connect(function()
			local root=getRoot(c)
			if root then
				deathCFrame=root.CFrame
			end
			NAmanage._persist.lastMode=NAmanage._state and NAmanage._state.mode or "none"
			NAmanage._persist.wasFlying=(FLYING==true)
			if FLYING then
				NAmanage.pauseCurrent()
			end
			NAmanage._clearPhysics(true)
			NAmanage._persist.resumeAfterSpawn=false
		end)
	end

	setupFLASHBACK(LocalPlayer.Character)

	LocalPlayer.CharacterAdded:Connect(function(c)
		setupFLASHBACK(c)
		NAmanage.ExecuteBindings("OnSpawn", LocalPlayer, c)
		Wait(.5)
		local humanoid=getHum()
		if humanoid then
			local lastHP=humanoid.Health
			humanoid.Died:Connect(function() NAmanage.ExecuteBindings("OnDeath") end)
			humanoid.HealthChanged:Connect(function(newHP)
				if newHP<lastHP then
					NAmanage.ExecuteBindings("OnDamage", lastHP, newHP)
				end
				lastHP=newHP
			end)
		end
		NAmanage.connectFlyKey()
		NAmanage.connectVFlyKey()
		NAmanage.connectCFlyKey()
		NAmanage.connectTFlyKey()
		NAmanage.startWatcher()

		SpawnCall(function()
			if not NAmanage._persist or NAmanage._persist.resumeAfterSpawn then
				return
			end
			if not NAmanage._persist.wasFlying then
				return
			end
			local desired=NAmanage._persist.lastMode
			if not desired or desired=="none" then
				NAmanage._persist.wasFlying=false
				return
			end
			if not NAmanage._modeEnabled(desired) then
				NAmanage._persist.wasFlying=false
				return
			end
			local elapsed=0
			while elapsed<5 and (not getChar() or not getRoot(getChar()) or not getHum()) do
				elapsed+=(Wait() or 0.03)
			end
			if not getChar() or not getRoot(getChar()) or not getHum() then
				return
			end
			NAmanage._clearPhysics(true)
			NAmanage._applyMode(desired,true)
			NAmanage._persist.wasFlying=false
		end)
	end)

	if LocalPlayer.Character then
		local humanoid=getHum()
		if humanoid then
			local lastHP=humanoid.Health
			humanoid.Died:Connect(function() NAmanage.ExecuteBindings("OnDeath") end)
			humanoid.HealthChanged:Connect(function(newHP)
				if newHP<lastHP then
					NAmanage.ExecuteBindings("OnDamage", lastHP, newHP)
				end
				lastHP=newHP
			end)
		end
	end

	NAmanage.startWatcher()
end)

SpawnCall(function()
	if flyVariables._watchConn then pcall(function() flyVariables._watchConn:Disconnect() end) end
	NAmanage.startWatcher()
end)

mouse.Move:Connect(function()
	local viewportSize = workspace.CurrentCamera and workspace.CurrentCamera.ViewportSize or Vector2.new(1920, 1080)

	local xScale = mouse.X / viewportSize.X
	local yScale = mouse.Y / viewportSize.Y

	NAUIMANAGER.description.Position = UDim2.new(xScale, 0, yScale, 0)

	local newSize = NAgui.txtSize(NAUIMANAGER.description, 200, 100)
	NAUIMANAGER.description.Size = UDim2.new(0, newSize.X, 0, newSize.Y)
end)

RunService.RenderStepped:Connect(function()
	if NAUIMANAGER.chatLogs then
		updateCanvasSize(NAUIMANAGER.chatLogs, NAUIMANAGER.AUTOSCALER.Scale);
	end;
	if NAUIMANAGER.NAconsoleLogs then
		updateCanvasSize(NAUIMANAGER.NAconsoleLogs, NAUIMANAGER.AUTOSCALER.Scale);
	end;
	if NAUIMANAGER.commandsList then
		updateCanvasSize(NAUIMANAGER.commandsList, NAUIMANAGER.AUTOSCALER.Scale);
	end;
	if NAUIMANAGER.SettingsList then
		updateCanvasSize(NAUIMANAGER.SettingsList, NAUIMANAGER.AUTOSCALER.Scale);
	end;
	if NAUIMANAGER.WaypointList then
		updateCanvasSize(NAUIMANAGER.WaypointList, NAUIMANAGER.AUTOSCALER.Scale);
	end;
	if NAUIMANAGER.BindersList then
		updateCanvasSize(NAUIMANAGER.BindersList, NAUIMANAGER.AUTOSCALER.Scale);
	end;
end);

RunService.RenderStepped:Connect(function()
	local p = opt.prefix;
	local function isInvalid(prefix)
		return not prefix or utf8.len(prefix) ~= 1 or prefix:match("[%w]") or prefix:match("[%[%]%(%)%*%^%$%%{}<>]") or prefix:match("&amp;") or prefix:match("&lt;") or prefix:match("&gt;") or prefix:match("&quot;") or prefix:match("&#x27;") or prefix:match("&#x60;");
	end;
	if isInvalid(p) then
		if opt.prefix ~= ";" then
			opt.prefix = ";";
			DoNotif("Invalid prefix detected. Resetting to default ';'");
			lastPrefix = ";";
			if NAmanage.SyncPrefixUI then
				NAmanage.SyncPrefixUI();
			end;
			local storedPrefix = NAmanage.NASettingsGet("prefix");
			if isInvalid(storedPrefix) then
				NAmanage.NASettingsSet("prefix", ";");
			end;
		end;
	else
		lastPrefix = p;
	end;
end);

--RunService.RenderStepped:Connect(NAUISCALEUPD)

NACaller(function()
	if NAStuff.NAjson and NAStuff.NAjson.annc and NAStuff.NAjson.annc ~= "" then
		DoPopup(NAStuff.NAjson.annc, adminName .. " Announcement");
	end;
end);

--[[ COMMAND BAR BUTTON ]]--
TextLabel = InstanceNew("TextLabel")
UICorner = InstanceNew("UICorner")
UIStroke = InstanceNew("UIStroke")
TextButton = nil
IconFallbackText = nil
UICorner2 = InstanceNew("UICorner")

NAICONASSET = nil

pcall(function() NAICONASSET=(getcustomasset and (isAprilFools() and getcustomasset(NAfiles.NAASSETSFILEPATH.."/"..NAImageAssets.nilsongamer99) or getcustomasset(NAfiles.NAASSETSFILEPATH.."/"..NAImageAssets.Icon))) or nil end)

TextButton = InstanceNew("ImageButton")
TextButton.Image = NAICONASSET or ""

if NAICONASSET then
	TextButton.Image = NAICONASSET;
else
	IconFallbackText = InstanceNew("TextLabel");
	IconFallbackText.Name = "NAFallbackIconText";
	IconFallbackText.BackgroundTransparency = 1;
	IconFallbackText.AnchorPoint = Vector2.new(0.5, 0.5);
	IconFallbackText.Position = UDim2.new(0.5, 0, 0.5, 0);
	IconFallbackText.Size = UDim2.new(1, 0, 1, 0);
	IconFallbackText.Font = Enum.Font.SourceSansBold;
	IconFallbackText.TextColor3 = Color3.fromRGB(241, 241, 241);
	IconFallbackText.TextSize = 22;
	if isAprilFools() then
		cringyahhnamesidk = {
			"IY",
			"FE",
			"F3X",
			"HD",
			"CMD",
			"Ω",
			"R6",
			"Ø",
			"NA",
			"CMDX"
		};
		IconFallbackText.Text = cringyahhnamesidk[math.random(1, #cringyahhnamesidk)];
	else
		IconFallbackText.Text = "NA";
	end;
	IconFallbackText.TextStrokeTransparency = 0.7;
	IconFallbackText.Parent = TextButton;
end;

NAStuff.NAICONMAIN = TextButton
NAStuff.IconFallbackLabel = IconFallbackText

NAmanage.btUpdate()

TextLabel.Parent = NAStuff.NASCREENGUI
TextLabel.BackgroundColor3 = Color3.fromRGB(25, 26, 30)
TextLabel.BackgroundTransparency = 0.1
TextLabel.AnchorPoint = Vector2.new(0.5, 0.5)
TextLabel.Position = UDim2.new(0.5, 0, 0.5, 0)
TextLabel.Size = UDim2.new(0, 0, 0, 0)
TextLabel.Font = Enum.Font.FredokaOne
TextLabel.Text = getSeasonEmoji().." "..adminName..curVer.." "..getSeasonEmoji()
TextLabel.TextColor3 = Color3.fromRGB(241, 241, 241)
TextLabel.TextSize = 22
TextLabel.TextWrapped = true
TextLabel.TextStrokeTransparency = 0.7
TextLabel.TextTransparency = 1
TextLabel.ZIndex = 9999
TextLabel.Active = true
TextLabel.Selectable = false

UICorner2.CornerRadius = UDim.new(0.25, 0)
UICorner2.Parent = TextLabel

UIStroke.Parent = TextLabel
UIStroke.Thickness = 2
UIStroke.Color = NAUISTROKER
UIStroke.Transparency = 0.4
UIStroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border

TextButton.Parent = NAStuff.NASCREENGUI
TextButton.BackgroundTransparency = 0
TextButton.AnchorPoint = Vector2.new(0.5, 0)
TextButton.BorderSizePixel = 0
TextButton.BackgroundColor3 = Color3.fromRGB(25, 26, 30)
TextButton.Position = UDim2.new(0.5, 0, -1, 0)
TextButton.Size = UDim2.new(0, 32 * NAScale, 0, 32 * NAScale)
TextButton.ZIndex = 9999
if IconFallbackText then
	IconFallbackText.ZIndex = TextButton.ZIndex + 1
end

UICorner.CornerRadius = UDim.new(1, 0)
UICorner.Parent = TextButton

TextButton.MouseEnter:Connect(function()
	TweenService:Create(TextButton, TweenInfo.new(0.25, Enum.EasingStyle.Sine, Enum.EasingDirection.Out), {
		Size = UDim2.new(0, 35 * NAScale, 0, 35 * NAScale)
	}):Play()
end)

TextButton.MouseLeave:Connect(function()
	TweenService:Create(TextButton, TweenInfo.new(0.25, Enum.EasingStyle.Sine, Enum.EasingDirection.Out), {
		Size = UDim2.new(0, 32 * NAScale, 0, 32 * NAScale)
	}):Play()
end)

NAStuff.iconAppearance = NAStuff.iconAppearance or  {
	background = TextButton.BackgroundTransparency;
	text = (IconFallbackText and IconFallbackText.TextTransparency) or (TextButton:IsA("TextButton") and TextButton.TextTransparency) or nil;
	stroke = (IconFallbackText and IconFallbackText.TextStrokeTransparency) or (TextButton:IsA("TextButton") and TextButton.TextStrokeTransparency) or nil;
	image = TextButton:IsA("ImageButton") and TextButton.ImageTransparency or nil;
}

do
	local prefs = NAStuff.iconAppearancePrefs or {}
	local function clamp01(v)
		local n = tonumber(v)
		if not n then return nil end
		if n < 0 then n = 0 elseif n > 1 then n = 1 end
		return n
	end
	local bg = clamp01(prefs.background)
	local img = clamp01(prefs.image)
	local txt = clamp01(prefs.text)
	local stroke = clamp01(prefs.stroke)
	if bg then
		NAStuff.iconAppearance.background = bg
		TextButton.BackgroundTransparency = bg
	end
	if img and TextButton:IsA("ImageButton") then
		NAStuff.iconAppearance.image = img
		TextButton.ImageTransparency = img
	end
	if txt and IconFallbackText then
		NAStuff.iconAppearance.text = txt
		IconFallbackText.TextTransparency = txt
	end
	if stroke and IconFallbackText then
		NAStuff.iconAppearance.stroke = stroke
		IconFallbackText.TextStrokeTransparency = stroke
	end
end

NAStuff.CustomIcon = NAStuff.CustomIcon or {}

if NAmanage and type(NAmanage.NASettingsGet) == "function" then
	local storedAsset = NAmanage.NASettingsGet("customIconAssetId")
	if typeof(storedAsset) == "string" and storedAsset ~= "" then
		NAStuff.CustomIcon.assetId = storedAsset
	end
	local storedEnabled = NAmanage.NASettingsGet("customIconEnabled")
	if typeof(storedEnabled) == "boolean" then
		NAStuff.CustomIcon.enabled = storedEnabled
	end
end

function NAgui.iconSupported()
	return TextButton and TextButton:IsA("ImageButton")
end

if not NAgui.iconSupported() then
	NAStuff.CustomIcon.enabled = false
else
	if typeof(TextButton.Image) == "string" and TextButton.Image ~= "" then
		NAStuff.CustomIcon.defaultImage = NAStuff.CustomIcon.defaultImage or TextButton.Image
	end
	if typeof(NAStuff.CustomIcon.assetId) ~= "string" or NAStuff.CustomIcon.assetId == "" then
		NAStuff.CustomIcon.assetId = nil
		NAStuff.CustomIcon.enabled = false
	end
end

if typeof(NAStuff.CustomIcon.enabled) ~= "boolean" then
	NAStuff.CustomIcon.enabled = false
end

function NAgui._saveIconSettings()
	if not (NAmanage and type(NAmanage.NASettingsSet) == "function") then
		return
	end
	local assetValue = NAStuff.CustomIcon.assetId
	if typeof(assetValue) ~= "string" or assetValue == "" then
		assetValue = ""
	end
	pcall(NAmanage.NASettingsSet, "customIconAssetId", assetValue)
	pcall(NAmanage.NASettingsSet, "customIconEnabled", NAStuff.CustomIcon.enabled == true)
end

function NAgui.getIconDigits()
	if typeof(NAStuff.CustomIcon.assetId) == "string" then
		return NAStuff.CustomIcon.assetId:match("(%d+)$") or ""
	end
	return ""
end

function NAgui._applyIconState()
	if not NAgui.iconSupported() then
		return false
	end
	local state = NAStuff.CustomIcon
	local targetImage
	if state.enabled and typeof(state.assetId) == "string" and state.assetId ~= "" then
		targetImage = state.assetId
	elseif typeof(state.defaultImage) == "string" and state.defaultImage ~= "" then
		targetImage = state.defaultImage
	end
	local applied = false
	if targetImage and targetImage ~= "" then
		TextButton.Image = targetImage
		applied = true
	else
		TextButton.Image = ""
	end
	if NAStuff.IconFallbackLabel then
		NAStuff.IconFallbackLabel.Visible = not applied
	end
	return applied
end

function NAgui.setIconEnabled(enabled, opts)
	opts = opts or {}
	if not NAgui.iconSupported() then
		return false, "Custom icon requires \"getcustomasset\" support for the NA icon."
	end
	enabled = enabled and true or false
	if enabled and not NAStuff.CustomIcon.assetId then
		if not opts.skipToggle and NAgui.setToggleState then
			NAgui.setToggleState("Use Custom NA Icon", false, { force = true, fire = false })
		end
		return false, "Add an asset id before enabling the custom icon."
	end
	if NAStuff.CustomIcon.enabled == enabled and not opts.force then
		return true
	end
	NAStuff.CustomIcon.enabled = enabled
	NAgui._applyIconState()
	if not opts.skipToggle and NAgui.setToggleState then
		NAgui.setToggleState("Use Custom NA Icon", enabled, { force = true, fire = false })
	end
	NAgui._saveIconSettings()
	return true
end

function NAgui.setIconAsset(inputValue, opts)
	opts = opts or {}
	if not NAgui.iconSupported() then
		return false, "Custom icon requires \"getcustomasset\" support for the NA icon."
	end
	local raw = typeof(inputValue) == "string" and inputValue or tostring(inputValue)
	if typeof(raw) ~= "string" then
		return false, "Enter a valid numeric asset id."
	end
	raw = raw:match("^%s*(.-)%s*$")
	if raw == "" then
		return false, "Enter a valid numeric asset id."
	end
	local digits = raw:match("^rbxassetid://(%d+)$") or raw:match("id=(%d+)") or raw:match("(%d+)$")
	if not digits then
		return false, "Enter a valid numeric asset id."
	end
	local newAsset = "rbxassetid://"..digits
	NAStuff.CustomIcon.assetId = newAsset
	if opts.autoEnable ~= false then
		NAStuff.CustomIcon.enabled = true
	end
	NAgui._applyIconState()
	if opts.autoEnable ~= false and not opts.skipToggle and NAgui.setToggleState then
		NAgui.setToggleState("Use Custom NA Icon", true, { force = true, fire = false })
	end
	NAgui._saveIconSettings()
	return true, digits
end

if NAStuff.CustomIcon.enabled and NAStuff.CustomIcon.assetId and NAgui.iconSupported() then
	NAgui._applyIconState()
end

NAgui.clampIconPositionUDim=function(pos)
	if typeof(pos) ~= "UDim2" then
		return pos
	end
	if not TextButton or not TextButton.Parent then
		return UDim2.new(math.clamp(pos.X.Scale, 0, 1), 0, math.clamp(pos.Y.Scale, 0, 1), 0)
	end
	local container = TextButton.Parent
	local parentSize = container.AbsoluteSize
	if parentSize.X <= 0 or parentSize.Y <= 0 then
		local cam = workspace and workspace.CurrentCamera
		if cam then
			parentSize = cam.ViewportSize
		end
	end
	if parentSize.X <= 0 or parentSize.Y <= 0 then
		return UDim2.new(math.clamp(pos.X.Scale, 0, 1), 0, math.clamp(pos.Y.Scale, 0, 1), 0)
	end
	local anchor = TextButton.AnchorPoint or Vector2.new(0, 0)
	local buttonSizeX = TextButton.AbsoluteSize.X
	local buttonSizeY = TextButton.AbsoluteSize.Y
	if buttonSizeX <= 0 then buttonSizeX = 32 * NAScale end
	if buttonSizeY <= 0 then buttonSizeY = 32 * NAScale end
	local absX = pos.X.Scale * parentSize.X + pos.X.Offset
	local absY = pos.Y.Scale * parentSize.Y + pos.Y.Offset
	local minX = anchor.X * buttonSizeX
	local maxX = parentSize.X - (1 - anchor.X) * buttonSizeX
	local minY = anchor.Y * buttonSizeY
	local maxY = parentSize.Y - (1 - anchor.Y) * buttonSizeY
	if maxX < minX then maxX = minX end
	if maxY < minY then maxY = minY end
	local clampedX = math.clamp(absX, minX, maxX)
	local clampedY = math.clamp(absY, minY, maxY)
	return UDim2.new(clampedX / parentSize.X, 0, clampedY / parentSize.Y, 0)
end

NAgui.getClampedIconPosition=function()
	if not TextButton then return nil end
	local clamped = NAgui.clampIconPositionUDim(TextButton.Position)
	if clamped and clamped ~= TextButton.Position then
		TextButton.Position = clamped
	end
	return clamped or TextButton.Position
end

NAgui.applyIconVisibility=function(hidden)
	if not TextButton then return end
	local fallbackText = NAStuff.IconFallbackLabel
	local function setFallbackTrans()
		if not fallbackText then return end
		local defaultText = NAStuff.iconAppearance.text
		local defaultStroke = NAStuff.iconAppearance.stroke
		fallbackText.TextTransparency = hidden and 1 or (defaultText ~= nil and defaultText or 0)
		if defaultStroke ~= nil then
			fallbackText.TextStrokeTransparency = hidden and 1 or defaultStroke
		end
	end
	if IsOnMobile and not IsOnPC then
		TextButton.Visible = true
		TextButton.BackgroundTransparency = hidden and 1 or NAStuff.iconAppearance.background
		if TextButton:IsA("ImageButton") then
			if hidden then
				TextButton.ImageTransparency = 1
			elseif NAStuff.iconAppearance.image ~= nil then
				TextButton.ImageTransparency = NAStuff.iconAppearance.image
			end
		else
			TextButton.TextTransparency = hidden and 1 or (NAStuff.iconAppearance.text or 0)
			if NAStuff.iconAppearance.stroke ~= nil then
				TextButton.TextStrokeTransparency = hidden and 1 or NAStuff.iconAppearance.stroke
			end
		end
	else
		TextButton.Visible = not hidden
		TextButton.BackgroundTransparency = NAStuff.iconAppearance.background
		if TextButton:IsA("ImageButton") then
			if NAStuff.iconAppearance.image ~= nil then
				TextButton.ImageTransparency = NAStuff.iconAppearance.image
			end
		else
			if NAStuff.iconAppearance.text ~= nil then
				TextButton.TextTransparency = NAStuff.iconAppearance.text
			end
			if NAStuff.iconAppearance.stroke ~= nil then
				TextButton.TextStrokeTransparency = NAStuff.iconAppearance.stroke
			end
		end
	end
	setFallbackTrans()
end

NAgui.setIconHidden=function(hidden, opts)
	opts = opts or {}
	hidden = hidden and true or false
	if NAStuff.IconInvisible == hidden and not opts.force then
		return
	end
	NAStuff.IconInvisible = hidden
	NAgui.applyIconVisibility(hidden)
	if FileSupport then
		pcall(NAmanage.NASettingsSet, "iconInvisible", hidden)
	end
	if not opts.skipToggle and NAgui.setToggleState then
		NAgui.setToggleState("Hide NA Icon", hidden, { force = true, fire = false })
	end
end

NAmanage.IconSetInvisible = NAgui.setIconHidden

NAgui.setIconHidden(NAStuff.IconInvisible, { force = true, skipToggle = true })

NAStuff.IconLocked = NAStuff.IconLocked or false

NAgui._NAIconConnName=function()
	return TextButton and "DraggerV2_"..TextButton:GetDebugId() or "DraggerV2_ICON"
end

NAgui.applyIconLock=function(locked)
	if not TextButton then return end
	if locked then
		NAlib.disconnect(NAgui._NAIconConnName())
	else
		NAgui.draggerV2(TextButton)
	end
end

NAgui.setIconLocked=function(locked, opts)
	opts = opts or {}
	locked = locked and true or false
	if NAStuff.IconLocked == locked and not opts.force then return end
	NAStuff.IconLocked = locked
	NAgui.applyIconLock(locked)
	if FileSupport then
		NAmanage.NASettingsSet("iconLocked", locked)
	end
	if not opts.skipToggle and NAgui.setToggleState then
		NAgui.setToggleState("Lock NA Icon", locked, { force = true, fire = false })
	end
end

NAmanage.IconSetLocked = NAgui.setIconLocked

swooshySWOOSH = false

function Swoosh()
	TweenService:Create(TextButton, TweenInfo.new(1.5, Enum.EasingStyle.Elastic, Enum.EasingDirection.Out), {Rotation = 720}):Play()
	if not NAStuff.IconLocked then
		NAgui.draggerV2(TextButton)
	end
	if swooshySWOOSH then return end
	swooshySWOOSH = true
	TextButton.InputBegan:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
			input.Changed:Connect(function()
				if input.UserInputState == Enum.UserInputState.End then
					if FileSupport and NAiconSaveEnabled then
						local pos = NAgui.getClampedIconPosition() or TextButton.Position
						pcall(NAmanage.NASettingsSet, "iconPosition", {
							X = pos.X.Scale;
							Y = pos.Y.Scale;
						})
						pcall(NAmanage.NASettingsSet, "iconKeepPosition", true)
					end
				end
			end)
		end
	end)
end

function mainNameless()
	local txtLabel = TextLabel
	local showIntroLabel = not (NAmanage.jlCfg and NAmanage.jlCfg.IconLabel == false)
	if txtLabel and not showIntroLabel then
		txtLabel.Visible = false
	end
	local fadeOutStarted = false

	local function fadeOut()
		if fadeOutStarted or not showIntroLabel or not txtLabel then return end
		fadeOutStarted = true
		local fadeOutTween = TweenService:Create(txtLabel, TweenInfo.new(0.6, Enum.EasingStyle.Elastic, Enum.EasingDirection.InOut), {
			TextTransparency = 1,
			BackgroundTransparency = 1,
			Position = UDim2.new(0.5, 0, 0.52, 20),
			Size = UDim2.new(0, 0, 0, 0)
		})
		fadeOutTween:Play()
		fadeOutTween.Completed:Once(function()
			txtLabel:Destroy()
		end)
	end

	if showIntroLabel and txtLabel then
		txtLabel.InputBegan:Connect(function(input)
			if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
				fadeOut()
			end
		end)

		local textWidth = TextService:GetTextSize(txtLabel.Text, txtLabel.TextSize, txtLabel.Font, Vector2.new(math.huge, math.huge)).X
		local finalSize = UDim2.new(0, textWidth + 80, 0, 40)

		local appearTween = TweenService:Create(txtLabel, TweenInfo.new(0.8, Enum.EasingStyle.Elastic, Enum.EasingDirection.Out), {
			Size = finalSize,
			BackgroundTransparency = 0.1,
			TextTransparency = 0,
		})

		local riseTween = TweenService:Create(txtLabel, TweenInfo.new(0.4, Enum.EasingStyle.Elastic, Enum.EasingDirection.Out), {
			Position = UDim2.new(0.5, 0, 0.48, 0)
		})

		appearTween:Play()
		riseTween:Play()
	end

	TextButton.Size = UDim2.new(0, 0, 0, 0)
	if TextButton:IsA("TextButton") then
		TextButton.TextTransparency = 1
	end

	local targetPos = UDim2.new(0.5, 0, 0.1, 0)

	if NAmanage and type(NAmanage.NASettingsGet) == "function" then
		local data = NAmanage.NASettingsGet("iconPosition")
		if type(data) == "table" then
			local x = math.clamp(tonumber(data.X) or 0.5, 0, 1)
			local y = math.clamp(tonumber(data.Y) or 0.1, 0, 1)
			targetPos = UDim2.new(x, 0, y, 0)
		end
	end

	targetPos = NAgui.clampIconPositionUDim(targetPos)
	if FileSupport and NAiconSaveEnabled then
		pcall(NAmanage.NASettingsSet, "iconPosition", {
			X = targetPos.X.Scale;
			Y = targetPos.Y.Scale;
		})
		pcall(NAmanage.NASettingsSet, "iconKeepPosition", true)
	end
	local introPos = NAgui.clampIconPositionUDim(UDim2.new(targetPos.X.Scale, 0, targetPos.Y.Scale - 0.15, -20)) or targetPos
	TextButton.Position = introPos

	local tweenProps = {
		Size = UDim2.new(0, 32 * NAScale, 0, 32 * NAScale),
		Position = targetPos
	}

	if TextButton:IsA("TextButton") then
		tweenProps.TextTransparency = 0
	end

	local appearBtnTween = TweenService:Create(TextButton, TweenInfo.new(1, Enum.EasingStyle.Elastic, Enum.EasingDirection.Out), tweenProps)
	appearBtnTween:Play()

	Swoosh()

	if showIntroLabel and txtLabel then
		Wait(2.5)
		fadeOut()
	end
end

coroutine.wrap(mainNameless)()

NAgui.setIconLocked(NAStuff.IconLocked, { force = true, skipToggle = true })

MouseButtonFix(TextButton,function()
	NAgui.barSelect()
	NAUIMANAGER.cmdInput.Text=''
	NAUIMANAGER.cmdInput:CaptureFocus()
	Wait(.00005)
	NAUIMANAGER.cmdInput.Text=''
end)

--@ltseverydayyou (Aervanix)
--@Cosmella (Viper)

--original by @qipu | loadstring(game:HttpGet("https://raw.githubusercontent.com/FilteringEnabled/NamelessAdmin/main/Source"))();

SpawnCall(function()
	local NAresult = tick() - NAbegin
	local nameCheck = nameChecker(Player)

	Delay(0.3, function()
		local executorName = identifyexecutor and identifyexecutor() or "Unknown"
		local welcomeMessage = "Welcome to "..adminName..curVer

		executorName = maybeMock(executorName)
		welcomeMessage = maybeMock(welcomeMessage)

		local notifBody = welcomeMessage..
			(identifyexecutor and ("\nExecutor: "..executorName) or "")..
			"\nUpdated on: "..opt.NAupdDate..
			"\nTime Taken To Load: "..loadedResults(NAresult)

		if NAmanage.jlCfg.WelcomeNotif ~= false then
			DoNotif(notifBody, 6, rngMsg().." "..nameCheck)
		end

		if not FileSupport then
			--warn("NAWWW NO FILE SUPPORT???????")
			Window({
				Title = maybeMock("Would you like to enable QueueOnTeleport?"),
				Description = maybeMock("With QueueOnTeleport, "..adminName.." will automatically execute itself upon teleporting to a game or place."),
				Buttons = {
					{Text = "Yes", Callback = function()
						opt.queueteleport(opt.loader)
					end},
					{Text = "No", Callback = function() end}
				}
			})
		elseif not opt.queueteleport then
			warn('your executor is dog shit')
		end

		Wait(1)

		if IsOnPC and NAmanage.jlCfg.KeybindNotif ~= false then
			local keybindMessage = maybeMock("Your Keybind Prefix: "..opt.prefix)
			DoNotif(keybindMessage, 10, adminName.." Keybind Prefix")
		end

		local coreGuiOk = pcall(function()
			loadstring(game:HttpGet("https://raw.githubusercontent.com/ltseverydayyou/uuuuuuu/refs/heads/main/CoreGuiManipulation.luau"))()
		end) -- manipulates coregui checks

		if coreGuiOk then
			pcall(function()
				loadstring(game:HttpGet("https://raw.githubusercontent.com/ltseverydayyou/uuuuuuu/refs/heads/main/lxteCmdSupport.luau"))()
			end) -- collab soon?????
		end

		-- just ignore this section (personal stuff)
		--[[Window({
			Title = adminName.." (Archived)",
			Description = 'This version is no longer maintained.\nCheck the README on GitHub for legacy details.',
			Buttons = {
				{
					Text = "Copy GitHub Repo",
					Callback = function()
						setclipboard("https://github.com/ltseverydayyou/Nameless-Admin")
					end
				},
				{
					Text = "Discord Server",
					Callback = function()
						setclipboard("https://discord.gg/zzjYhtMGFD")
					end
				},
				{
					Text = "Close",
					Callback = function() end
				}
			}
		})]]
	end)
	SpawnCall(function()
		Wait(.5)

		if NAmanage.loadAutoExec then
			pcall(NAmanage.loadAutoExec)
		end

		if NAStuff.AutoExecEnabled == false then
			DebugNotif("AutoExec is disabled, skipping stored commands.")
			return
		end

		local data = NAEXECDATA or {commands = {}, args = {}}
		local commands = data.commands
		local argsMap = data.args or {}

		if type(commands) ~= "table" or #commands == 0 then
			return
		end

		for _, commandName in ipairs(commands) do
			local fullRun = {commandName}
			local argsString = argsMap[commandName]
			if type(argsString) == "string" and argsString ~= "" then
				local extraArgs = ParseArguments(argsString)
				if extraArgs then
					for _, v in ipairs(extraArgs) do
						Insert(fullRun, v)
					end
				end
			end
			cmd.run(fullRun)
		end
	end)
	NAUIMANAGER.cmdInput.ZIndex = 10
	NAUIMANAGER.cmdInput.PlaceholderText = isAprilFools() and '🤡 '..adminName..curVer..' 🤡' or getSeasonEmoji()..' '..adminName..curVer..' '..getSeasonEmoji()
	NAmanage.startAprilPranks()
end)

NAmanage.hsv2rgb=function(h, s, v)
	local c = v * s
	local x = c * (1 - math.abs((h / 60) % 2 - 1))
	local m = v - c
	local r1, g1, b1
	if h < 60 then
		r1, g1, b1 = c, x, 0
	elseif h < 120 then
		r1, g1, b1 = x, c, 0
	elseif h < 180 then
		r1, g1, b1 = 0, c, x
	elseif h < 240 then
		r1, g1, b1 = 0, x, c
	elseif h < 300 then
		r1, g1, b1 = x, 0, c
	else
		r1, g1, b1 = c, 0, x
	end
	return (r1 + m), (g1 + m), (b1 + m)
end

NAmanage.gradientify=function(text)
	local len = #text
	if len == 0 then return "" end
	local out = {}
	for i = 1, len do
		local frac = (i - 1) / (len - 1)
		local hue = frac * 360
		local r, g, b = NAmanage.hsv2rgb(hue, 1, 1)
		local hex = Format("#%02X%02X%02X", r * 255, g * 255, b * 255)
		local ch = text:sub(i, i)
		out[i] = Format('<font color="%s">%s</font>', hex, ch)
	end
	return Concat(out)
end

NAmanage.grayGradient=function(text)
	local startGray = 0
	local endGray   = 100
	local len = #text
	if len == 0 then return "" end
	local out = {}
	for i = 1, len do
		local frac = (i - 1) / (len - 1)
		local v = startGray + (endGray - startGray) * frac
		local g = math.floor(v)
		local hex = Format("#%02X%02X%02X", g, g, g)
		local ch = text:sub(i, i)
		out[i] = Format('<font color="%s">%s</font>', hex, ch)
	end
	return Concat(out)
end
-- temp disabled for fixing
--[[TextChatService.OnIncomingMessage = function(message)
	local ts = message.TextSource
	if not ts then return end
	local pl = Players:GetPlayerByUserId(ts.UserId)
	if not pl then return end

	local tagText = pl:GetAttribute("CustomNAtaggerText")
	local tagCol = pl:GetAttribute("CustomNAtaggerColor")
	local useRainbow = pl:GetAttribute("CustomNAtaggerRainbow")

	local basePrefix = message.PrefixText
	if not basePrefix or basePrefix == "" then
		local nm = nameChecker(pl)
		basePrefix = Format("%s: ", nm)
	end

	local rainbowApplied = false
	if useRainbow then
		local nmA = ts.Name or ""
		local nmB = pl.DisplayName or ""
		local nmC = pl.Name or ""
		local nmD = nameChecker(pl) or ""
		local gradSrc = nmD ~= "" and nmD or (nmB ~= "" and nmB or nmC)
		local grad = NAmanage.gradientify(gradSrc)
		local seen = {}
		local cands = {}
		local function add(s) if s and s ~= "" and not seen[s] then seen[s] = true; Insert(cands, s) end end
		add(nmA); add(nmB); add(nmC); add(nmD)
		local function esc(s) return (s:gsub("([^%w])","%%%1")) end
		for _, c in ipairs(cands) do
			local rep, n = basePrefix:gsub(esc(c), grad, 1)
			if n > 0 then
				basePrefix = rep
				rainbowApplied = true
				break
			end
		end
		if not rainbowApplied then
			basePrefix = Format("%s: ", grad)
			rainbowApplied = true
		end
	end

	for _, id in ipairs(_G.NAadminsLol or {}) do
		if pl.UserId == id then
			local props = InstanceNew("TextChatMessageProperties")
			local tag = NAmanage.grayGradient("[NA ADMIN]")
			local finalPrefix = basePrefix
			if NAStuff.ForceAdminRainbow then
				local nm = nameChecker(pl)
				local grad = NAmanage.gradientify(nm)
				local esc = nm:gsub("([^%w])","%%%1")
				local rep, n = finalPrefix:gsub(esc, grad, 1)
				finalPrefix = n > 0 and rep or Format("%s: ", grad)
			end
			props.PrefixText = Format("%s %s", tag, finalPrefix)
			props.Text = message.Text
			return props
		end
	end

	if tagText and tagCol then
		local r, g, b = tagCol.R * 255, tagCol.G * 255, tagCol.B * 255
		local hex = Format("#%02X%02X%02X", r, g, b)
		local props = InstanceNew("TextChatMessageProperties")
		props.PrefixText = Format('<font color="%s">[%s]</font> %s', hex, tagText, basePrefix)
		props.Text = message.Text
		return props
	end

	if rainbowApplied then
		local props = InstanceNew("TextChatMessageProperties")
		props.PrefixText = basePrefix
		props.Text = message.Text
		return props
	end
end]]
math.randomseed(os.time())

NAmanage.injectNAConsole = function()
	if NAmanage._naConsoleInitialized then
		return true
	end

	local baseMainViewSize = nil
	local lastWindowSize = nil

	local function ensureCommandHelpers()
		if not NAmanage._naConsoleDispatch then
			local function splitArgs(line)
				local out, buf, quote = {}, "", nil
				for i = 1, #line do
					local ch = Sub(line, i, i)
					if quote then
						if ch == quote then
							quote = nil
						else
							buf = buf..ch
						end
					else
						if ch == "'" or ch == '"' then
							quote = ch
						elseif ch == " " or ch == "\t" then
							if #buf > 0 then
								out[#out+1] = buf
								buf = ""
							end
						else
							buf = buf..ch
						end
					end
				end
				if #buf > 0 then
					out[#out+1] = buf
				end
				return out
			end

			local function dispatchRun(...)
				local runner = cmd and (cmd.run or cmd.Run)
				if not runner then
					return nil, "cmd.run not available"
				end

				local n = select("#", ...)
				local argv
				if n == 1 then
					local a = ...
					if type(a) == "table" then
						argv = a
					elseif type(a) == "string" then
						argv = splitArgs(a)
					else
						return nil, "invalid input to cmdRun"
					end
				else
					argv = {}
					for i = 1, n do
						local v = select(i, ...)
						argv[#argv+1] = type(v) == "string" and v or tostring(v)
					end
				end

				if #argv == 0 then
					return nil, "no command provided"
				end

				local ok1, res1 = NACaller(runner, argv)
				if ok1 then
					return res1
				end

				local ok2, res2 = NACaller(runner, Concat(argv, " "))
				if ok2 then
					return res2
				end

				return nil, res2
			end

			NAmanage._naConsoleDispatch = dispatchRun
		end

		local dispatch = NAmanage._naConsoleDispatch
		local targetEnv = (getgenv and getgenv()) or _G or {}
		targetEnv.cmdRun = dispatch
		targetEnv.RunCommand = dispatch
		targetEnv.runCommand = dispatch
	end

	local commandLine = InstanceNew("Frame")
	commandLine.Name = "NAConsole"
	commandLine.BackgroundColor3 = Color3.fromRGB(45, 45, 45)
	commandLine.BorderColor3 = Color3.fromRGB(184, 184, 184)
	commandLine.AnchorPoint = Vector2.new(0, 1)
	commandLine.Position = UDim2.new(0, 0, 1, 0)
	commandLine.Size = UDim2.new(1, 0, 0, 30)
	commandLine.ZIndex = 1
	commandLine.AutoLocalize = false

	local inputField = InstanceNew("Frame", commandLine)
	inputField.Name = "InputField"
	inputField.BackgroundTransparency = 1
	inputField.ClipsDescendants = true
	inputField.Position = UDim2.new(0, 30, 0, 0)
	inputField.Size = UDim2.new(1, -30, 0, 30)
	inputField.AutoLocalize = false
	inputField.ZIndex = 1

	local textbox = InstanceNew("TextBox", inputField)
	textbox.Name = "TextBox"
	textbox.BackgroundTransparency = 1
	textbox.ClearTextOnFocus = false
	textbox.Font = Enum.Font.Code
	textbox.PlaceholderText = "NA Console Master"
	textbox.Size = UDim2.new(1, 0, 1, 0)
	textbox.Text = ""
	textbox.TextColor3 = Color3.fromRGB(255, 255, 255)
	textbox.TextSize = 15
	textbox.TextXAlignment = Enum.TextXAlignment.Left
	textbox.AutoLocalize = false
	textbox.ZIndex = 2

	local arrow = InstanceNew("TextLabel", commandLine)
	arrow.Name = "Arrow"
	arrow.BackgroundTransparency = 1
	arrow.Font = Enum.Font.Code
	arrow.Size = UDim2.new(0, 30, 1, 0)
	arrow.Text = "> "
	arrow.TextColor3 = Color3.fromRGB(255, 255, 255)
	arrow.TextSize = 15
	arrow.TextXAlignment = Enum.TextXAlignment.Right
	arrow.AutoLocalize = false
	arrow.ZIndex = 2

	local function resetCommandLine()
		if commandLine.Parent then
			commandLine.Parent = nil
		end
		if textbox.Text ~= "" then
			textbox.Text = ""
		end
	end

	resetCommandLine()

	local testService = SafeGetService("TestService")

	local function getUIScaleFactor(inst)
		local scale = 1
		local current = inst
		while current do
			local uiScale = current:FindFirstChildOfClass("UIScale")
			if uiScale and uiScale.Scale then
				scale *= uiScale.Scale
			end
			current = current.Parent
		end
		return scale
	end

	local function resolveLineHeight(window)
		local size = commandLine.Size
		local height = (size and size.Y and size.Y.Offset) or 0
		if height == 0 and size and size.Y and size.Y.Scale ~= 0 and window then
			height = window.AbsoluteSize.Y * size.Y.Scale
		end

		if height == 0 and commandLine.AbsoluteSize.Y > 0 then
			local scale = getUIScaleFactor(commandLine)
			if scale > 0 then
				height = commandLine.AbsoluteSize.Y / scale
			end
		end

		if height <= 0 then
			height = 30
		end

		return math.max(0, math.floor(height + 0.5))
	end

	local function adjustDevConsoleLayout(window)
		if not window then
			return
		end

		local consoleUI = window:FindFirstChild("DevConsoleUI") or window
		if commandLine.Parent ~= window then
			commandLine.Parent = window
		end

		local mainView = consoleUI and consoleUI:FindFirstChild("MainView")
		if not mainView then
			return
		end

		local lineHeight = resolveLineHeight(window)

		local targetPosition = UDim2.new(0, 0, 1, 0)
		if commandLine.Position ~= targetPosition then
			commandLine.Position = targetPosition
		end

		local windowAbs = window.AbsoluteSize
		if not baseMainViewSize then
			baseMainViewSize = mainView.Size
		elseif not lastWindowSize or windowAbs.X ~= lastWindowSize.X or windowAbs.Y ~= lastWindowSize.Y then
			baseMainViewSize = UDim2.new(
				mainView.Size.X.Scale,
				mainView.Size.X.Offset,
				mainView.Size.Y.Scale,
				mainView.Size.Y.Offset + lineHeight
			)
		end
		lastWindowSize = windowAbs

		local baseSize = baseMainViewSize
		local targetSize = UDim2.new(baseSize.X.Scale, baseSize.X.Offset, baseSize.Y.Scale, baseSize.Y.Offset - lineHeight)
		if mainView.Size ~= targetSize then
			mainView.Size = targetSize
		end
	end

	local function reportError(message)
		local filtered = tostring(message or "error")
		filtered = filtered:gsub("%[string \"console\"%]:", "console:")
		if testService then
			pcall(function()
				testService:Error(filtered)
			end)
		else
			warn(filtered)
		end
	end

	textbox.FocusLost:Connect(function(enterPressed)
		if not enterPressed then
			return
		end
		local commandText = textbox.Text
		if commandText == "" or commandText:match("^%s*$") then
			textbox.Text = ""
			return
		end
		textbox.Text = ""
		print("> "..commandText)

		local trimmed = commandText:match("^%s*(.-)%s*$")
		local commandLiteral = nil
		if trimmed and trimmed ~= "" then
			local firstChar = trimmed:sub(1, 1)
			if (firstChar == '"' or firstChar == "'") and trimmed:sub(-1) == firstChar then
				local literalChunk = loadstring("return "..trimmed, "console_literal")
				if literalChunk then
					local okLiteral, literalValue = pcall(literalChunk)
					if okLiteral and type(literalValue) == "string" then
						commandLiteral = literalValue
					end
				end
			end
		end

		if commandLiteral then
			ensureCommandHelpers()
			local dispatch = NAmanage._naConsoleDispatch
			if dispatch then
				local okDispatch, dispatchErr = NACaller(dispatch, commandLiteral)
				if not okDispatch then
					reportError(dispatchErr or "command execution failed")
				end
			else
				reportError("Command dispatcher unavailable")
			end
			return
		end

		local chunk, compileErr = loadstring(commandText, "console")
		if not chunk then
			reportError(compileErr or "compile error")
			return
		end

		ensureCommandHelpers()

		local ok, execErr = pcall(function()
			if not cmd or not cmd.run then
				error("cmd.run unavailable")
			end
			cmd.run({"loadstring", commandText})
		end)
		if not ok then
			reportError(execErr or "execution error")
		end
	end)

	local function ensureInjection()
		local coreGui = COREGUI
		if not coreGui then
			resetCommandLine()
			return
		end

		local master = coreGui:FindFirstChild("DevConsoleMaster")
		if not master then
			resetCommandLine()
			return
		end

		local window = master:FindFirstChild("DevConsoleWindow")
		if not window or window.Visible == false then
			resetCommandLine()
			return
		end

		adjustDevConsoleLayout(window)
	end

	NAlib.disconnect("naconsole_loop")
	NAlib.connect("naconsole_loop", RunService.Heartbeat:Connect(ensureInjection))
	ensureInjection()

	NAmanage._naConsoleInitialized = true
	NAmanage._naConsoleFrame = commandLine
	NAmanage._naConsoleTextBox = textbox
	NAmanage._naConsoleArrow = arrow
	return true
end

SpawnCall(function()
	SpawnCall(function() Lighting.LightingStyle=Enum.LightingStyle.Soft end)
	while Wait(0.25) and getChar() do
		local hum = getHum()
		if hum and hum.AutoJumpEnabled then
			hum.AutoJumpEnabled = false
		end
	end
end)


SpawnCall(function() -- init
	if NAUIMANAGER.cmdBar then NAProtection(NAUIMANAGER.cmdBar) end
	if NAUIMANAGER.chatLogsFrame then NAProtection(NAUIMANAGER.chatLogsFrame) end
	--if NAUIMANAGER.NAchatFrame then NAProtection(NAUIMANAGER.NAchatFrame) end
	if NAUIMANAGER.NAconsoleFrame then NAProtection(NAUIMANAGER.NAconsoleFrame) end
	if NAUIMANAGER.commandsFrame then NAProtection(NAUIMANAGER.commandsFrame) end
	if NAUIMANAGER.resizeFrame then NAProtection(NAUIMANAGER.resizeFrame) end
	if NAUIMANAGER.description then NAProtection(NAUIMANAGER.description) end
	if NAUIMANAGER.ModalFixer then NAProtection(NAUIMANAGER.ModalFixer) end
	if NAUIMANAGER.AUTOSCALER then NAProtection(NAUIMANAGER.AUTOSCALER) NAUIMANAGER.AUTOSCALER.Scale = NAUIScale end
	if NAUIMANAGER.SettingsFrame then NAProtection(NAUIMANAGER.SettingsFrame) end
	if NAUIMANAGER.WaypointFrame then NAProtection(NAUIMANAGER.WaypointFrame) end
	if NAUIMANAGER.BindersFrame then NAProtection(NAUIMANAGER.BindersFrame) end
	if not PlrGui then PlrGui=Player:WaitForChild("PlayerGui",math.huge) end
end)

SpawnCall(function()
	if NADisableLastInput then
		task.spawn(originalIO.ApplyLastInputPatch)
	end
end)

NAmanage.scheduleLoader('BindDevConsole', NAmanage.bindToDevConsole)
NAmanage.scheduleLoader('NAConsole', NAmanage.injectNAConsole)
NAmanage.scheduleLoader('Aliases', NAmanage.loadAliases)
NAmanage.scheduleLoader('UserButtons', function()
	if NAStuff.UserButtonsAutoLoad == false then
		return true
	end
	NAmanage.loadButtonIDS()
	return NAmanage.RenderUserButtons()
end, { requiresGui = true, retries = 5, delay = 0.4, retryOnFalse = true })
NAmanage.scheduleLoader('AutoExec', NAmanage.loadAutoExec, { retries = 4, delay = 0.4, retryOnFalse = true })
NAmanage.scheduleLoader('CmdIntegrationAutoRun', function()
	if NAStuff.CmdIntegrationAutoRun == true and NAmanage.loadCmdIntegration then
		local ok, err = NAmanage.loadCmdIntegration({ silent = true })
		if not ok then
			local msg = Format("Cmd auto-load failed: %s", tostring(err))
			if type(DebugNotif) == "function" then
				DebugNotif(msg, 3)
			else
				warn(msg)
			end
			return false
		end
	end
	return true
end, { retries = 2, delay = 0.6, retryOnFalse = true })
NAmanage.scheduleLoader('CmdBar2AutoRun', function()
	if NAStuff.CmdBar2AutoRun == true and cmd and cmd.run then
		cmd.run({"cmdbar2"})
	end
	return true
end, { requiresGui = true, retries = 3, delay = 0.4 })
NAmanage.scheduleLoader('Plugins', function()
	NAmanage.InitPlugs()
	local silent = (NAmanage.jlCfg and NAmanage.jlCfg.PluginNotif == false) or false
	return NAmanage.LoadPlugins({ silent = silent })
end, { retries = 4, delay = 0.5, retryOnFalse = true })
NAmanage.scheduleLoader('Waypoints', NAmanage.UpdateWaypointList)
NAmanage.LoadESPSettings()
NAmanage.scheduleLoader('ESPSettings', NAmanage.LoadESPSettings)

OrgDestroyHeight=NAlib.isProperty(workspace, "FallenPartsDestroyHeight") or math.huge

NAStuff.bindersList      = NAUIMANAGER.BindersList
SpawnCall(function()
	local layoutOrder = 1
	for _, evName in ipairs(events) do
		local ev = evName
		local HEADER_H = 30

		local binderFrame = InstanceNew("Frame")
		binderFrame.Name             = ev.."Binder"
		binderFrame.Parent           = NAStuff.bindersList
		binderFrame.Size             = UDim2.new(1,0,0, HEADER_H)
		binderFrame.LayoutOrder      = layoutOrder
		binderFrame.ClipsDescendants = true
		binderFrame.BackgroundColor3 = Color3.fromRGB(20,20,20)
		local binderCorner = InstanceNew("UICorner", binderFrame)
		binderCorner.CornerRadius    = UDim.new(0,8)
		local binderStroke = InstanceNew("UIStroke", binderFrame)
		binderStroke.Color           = Color3.fromRGB(60,60,60)
		binderStroke.Thickness       = 1

		local header = InstanceNew("TextButton")
		header.Name                   = "Header"
		header.Parent                 = binderFrame
		header.Size                   = UDim2.new(1,-30,0, HEADER_H)
		header.Position               = UDim2.new(0,0,0,0)
		header.BackgroundColor3       = Color3.fromRGB(30,30,30)
		header.AutoButtonColor        = false
		header.Font                   = Enum.Font.SourceSansSemibold
		header.TextSize               = 14
		header.TextColor3             = Color3.fromRGB(255,255,255)
		header.Text                   = ev
		local headerCorner = InstanceNew("UICorner", header)
		headerCorner.CornerRadius     = UDim.new(0,6)
		header.MouseEnter:Connect(function() header.BackgroundColor3 = Color3.fromRGB(50,50,50) end)
		header.MouseLeave:Connect(function() header.BackgroundColor3 = Color3.fromRGB(30,30,30) end)

		local addBtn = InstanceNew("TextButton")
		addBtn.Name                    = "AddBtn"
		addBtn.Parent                  = binderFrame
		addBtn.Size                    = UDim2.new(0,30,0, HEADER_H)
		addBtn.Position                = UDim2.new(1,-30,0,0)
		addBtn.BackgroundColor3        = Color3.fromRGB(30,30,30)
		addBtn.AutoButtonColor         = false
		addBtn.Font                    = Enum.Font.SourceSansBold
		addBtn.TextSize                = 18
		addBtn.TextColor3              = Color3.fromRGB(255,255,255)
		addBtn.Text                    = "+"
		local addCorner = InstanceNew("UICorner", addBtn)
		addCorner.CornerRadius         = UDim.new(0,6)
		addBtn.MouseEnter:Connect(function() addBtn.BackgroundColor3 = Color3.fromRGB(50,50,50) end)
		addBtn.MouseLeave:Connect(function() addBtn.BackgroundColor3 = Color3.fromRGB(30,30,30) end)

		local itemsFrame = InstanceNew("Frame")
		itemsFrame.Name                 = "Items"
		itemsFrame.Parent               = binderFrame
		itemsFrame.Position             = UDim2.new(0,0,0, HEADER_H)
		itemsFrame.Size                 = UDim2.new(1,0,0, 0)
		itemsFrame.BackgroundColor3     = Color3.fromRGB(25,25,25)
		local itemsCorner = InstanceNew("UICorner", itemsFrame)
		itemsCorner.CornerRadius        = UDim.new(0,6)

		local uiLayout = InstanceNew("UIListLayout")
		uiLayout.SortOrder              = Enum.SortOrder.LayoutOrder
		uiLayout.Padding                = UDim.new(0,4)
		uiLayout.Parent                 = itemsFrame
		uiLayout:GetPropertyChangedSignal("AbsoluteContentSize"):Connect(function()
			if binderFrame:GetAttribute("Expanded") then
				local h = uiLayout.AbsoluteContentSize.Y + 8
				itemsFrame:TweenSize(UDim2.new(1,0,0,h), "Out", "Quint", 0.25, true)
				binderFrame:TweenSize(UDim2.new(1,0,0, HEADER_H + h), "Out", "Quint", 0.25, true)
			end
		end)

		MouseButtonFix(header, function()
			local exp = binderFrame:GetAttribute("Expanded")
			binderFrame:SetAttribute("Expanded", not exp)
			if exp then
				itemsFrame:TweenSize(UDim2.new(1,0,0,0), "Out", "Quint", 0.25, true)
				binderFrame:TweenSize(UDim2.new(1,0,0, HEADER_H), "Out", "Quint", 0.25, true)
			else
				local h = uiLayout.AbsoluteContentSize.Y + 8
				itemsFrame:TweenSize(UDim2.new(1,0,0,h), "Out", "Quint", 0.25, true)
				binderFrame:TweenSize(UDim2.new(1,0,0, HEADER_H + h), "Out", "Quint", 0.25, true)
			end
		end)

		local function refreshItems()
			for _, child in ipairs(itemsFrame:GetChildren()) do
				if child.Name == "BinderItem" then
					child:Destroy()
				end
			end
			local list = Bindings[ev] or {}
			header.Text = ev.." ("..#list..")"
			if #list > 0 then
				binderFrame:SetAttribute("Expanded", true)
				local h = uiLayout.AbsoluteContentSize.Y + 8
				itemsFrame:TweenSize(UDim2.new(1,0,0,h), "Out", "Quint", 0.25, true)
				binderFrame:TweenSize(UDim2.new(1,0,0, HEADER_H + h), "Out", "Quint", 0.25, true)
			else
				binderFrame:SetAttribute("Expanded", false)
				itemsFrame:TweenSize(UDim2.new(1,0,0,0), "Out", "Quint", 0.25, true)
				binderFrame:TweenSize(UDim2.new(1,0,0, HEADER_H), "Out", "Quint", 0.25, true)
			end
			for i, cmdStr in ipairs(list) do
				local item = InstanceNew("Frame")
				item.Name               = "BinderItem"
				item.Parent             = itemsFrame
				item.Size               = UDim2.new(1,0,0,24)
				item.LayoutOrder        = i
				item.BackgroundColor3   = Color3.fromRGB(35,35,35)
				local itemCorner = InstanceNew("UICorner", item)
				itemCorner.CornerRadius  = UDim.new(0,4)

				local lbl = InstanceNew("TextLabel")
				lbl.Parent               = item
				lbl.Size                 = UDim2.new(1,-24,1,0)
				lbl.Position             = UDim2.new(0,8,0,0)
				lbl.BackgroundTransparency = 1
				lbl.Text                 = cmdStr
				lbl.Font                 = Enum.Font.SourceSans
				lbl.TextSize             = 14
				lbl.TextColor3           = Color3.fromRGB(255,255,255)
				lbl.TextXAlignment       = Enum.TextXAlignment.Left

				local rem = InstanceNew("TextButton")
				rem.Parent               = item
				rem.Size                 = UDim2.new(0,20,0,20)
				rem.Position             = UDim2.new(1,-24,0,2)
				rem.BackgroundTransparency = 1
				rem.Text                 = "×"
				rem.Font                 = Enum.Font.SourceSansBold
				rem.TextSize             = 18
				rem.TextColor3           = Color3.fromRGB(255,100,100)
				MouseButtonFix(rem, function()
					table.remove(list, i)
					NAmanage.SaveBinders()
					refreshItems()
				end)
			end
		end

		MouseButtonFix(addBtn, function()
			Bindings[ev] = Bindings[ev] or {}
			local allowMe = (ev ~= "OnJoin" and ev ~= "OnLeave")

			Window({
				Title       = ev.." Target",
				Description = "Pick who this binder applies to.",
				Buttons     = (function()
					local B = {}

					Insert(B, {
						Text = "No Selector",
						Callback = function()
							Window({
								Title = ev.." Binders",
								Description = "Enter command",
								InputField = true,
								Buttons = {{
									Text = "Submit",
									Callback = function(input)
										local cmdName = input and input:match("^(%S+)")
										if not (cmdName and (cmds.Commands[Lower(cmdName)] or cmds.Aliases[Lower(cmdName)])) then
											DoNotif("Command '"..tostring(cmdName).."' not found."); return
										end
										Insert(Bindings[ev], input)
										NAmanage.SaveBinders()
										refreshItems()
									end
								}}
							})
						end
					})

					if allowMe then
						Insert(B, {
							Text = "Me",
							Callback = function()
								Window({
									Title = ev.." Binders",
									Description = "Enter command (target: <me>)",
									InputField = true,
									Buttons = {{
										Text = "Submit",
										Callback = function(input)
											local cmdName = input and input:match("^(%S+)")
											if not (cmdName and (cmds.Commands[Lower(cmdName)] or cmds.Aliases[Lower(cmdName)])) then
												DoNotif("Command '"..tostring(cmdName).."' not found."); return
											end
											Insert(Bindings[ev], "<me> "..input)
											NAmanage.SaveBinders()
											refreshItems()
										end
									}}
								})
							end
						})
					end

					Insert(B, {
						Text = "Others",
						Callback = function()
							Window({
								Title = ev.." Binders",
								Description = "Enter command (target: <others>)",
								InputField = true,
								Buttons = {{
									Text = "Submit",
									Callback = function(input)
										local cmdName = input and input:match("^(%S+)")
										if not (cmdName and (cmds.Commands[Lower(cmdName)] or cmds.Aliases[Lower(cmdName)])) then
											DoNotif("Command '"..tostring(cmdName).."' not found."); return
										end
										Insert(Bindings[ev], "<others> "..input)
										NAmanage.SaveBinders()
										refreshItems()
									end
								}}
							})
						end
					})

					Insert(B, {
						Text = "All",
						Callback = function()
							Window({
								Title = ev.." Binders",
								Description = "Enter command (target: <all>)",
								InputField = true,
								Buttons = {{
									Text = "Submit",
									Callback = function(input)
										local cmdName = input and input:match("^(%S+)")
										if not (cmdName and (cmds.Commands[Lower(cmdName)] or cmds.Aliases[Lower(cmdName)])) then
											DoNotif("Command '"..tostring(cmdName).."' not found."); return
										end
										Insert(Bindings[ev], "<all> "..input)
										NAmanage.SaveBinders()
										refreshItems()
									end
								}}
							})
						end
					})

					Insert(B, {
						Text = "Friends",
						Callback = function()
							Window({
								Title = ev.." Binders",
								Description = "Enter command (target: <friends>)",
								InputField = true,
								Buttons = {{
									Text = "Submit",
									Callback = function(input)
										local cmdName = input and input:match("^(%S+)")
										if not (cmdName and (cmds.Commands[Lower(cmdName)] or cmds.Aliases[Lower(cmdName)])) then
											DoNotif("Command '"..tostring(cmdName).."' not found."); return
										end
										Insert(Bindings[ev], "<friends> "..input)
										NAmanage.SaveBinders()
										refreshItems()
									end
								}}
							})
						end
					})

					Insert(B, {
						Text = "NonFriends",
						Callback = function()
							Window({
								Title = ev.." Binders",
								Description = "Enter command (target: <nonfriends>)",
								InputField = true,
								Buttons = {{
									Text = "Submit",
									Callback = function(input)
										local cmdName = input and input:match("^(%S+)")
										if not (cmdName and (cmds.Commands[Lower(cmdName)] or cmds.Aliases[Lower(cmdName)])) then
											DoNotif("Command '"..tostring(cmdName).."' not found."); return
										end
										Insert(Bindings[ev], "<nonfriends> "..input)
										NAmanage.SaveBinders()
										refreshItems()
									end
								}}
							})
						end
					})

					Insert(B, {
						Text = "Team",
						Callback = function()
							Window({
								Title = ev.." Binders",
								Description = "Enter command (target: <team>)",
								InputField = true,
								Buttons = {{
									Text = "Submit",
									Callback = function(input)
										local cmdName = input and input:match("^(%S+)")
										if not (cmdName and (cmds.Commands[Lower(cmdName)] or cmds.Aliases[Lower(cmdName)])) then
											DoNotif("Command '"..tostring(cmdName).."' not found."); return
										end
										Insert(Bindings[ev], "<team> "..input)
										NAmanage.SaveBinders()
										refreshItems()
									end
								}}
							})
						end
					})

					Insert(B, {
						Text = "Nearest",
						Callback = function()
							Window({
								Title = ev.." Binders",
								Description = "Enter command (target: <nearest>)",
								InputField = true,
								Buttons = {{
									Text = "Submit",
									Callback = function(input)
										local cmdName = input and input:match("^(%S+)")
										if not (cmdName and (cmds.Commands[Lower(cmdName)] or cmds.Aliases[Lower(cmdName)])) then
											DoNotif("Command '"..tostring(cmdName).."' not found."); return
										end
										Insert(Bindings[ev], "<nearest> "..input)
										NAmanage.SaveBinders()
										refreshItems()
									end
								}}
							})
						end
					})

					Insert(B, {
						Text = "Farthest",
						Callback = function()
							Window({
								Title = ev.." Binders",
								Description = "Enter command (target: <farthest>)",
								InputField = true,
								Buttons = {{
									Text = "Submit",
									Callback = function(input)
										local cmdName = input and input:match("^(%S+)")
										if not (cmdName and (cmds.Commands[Lower(cmdName)] or cmds.Aliases[Lower(cmdName)])) then
											DoNotif("Command '"..tostring(cmdName).."' not found."); return
										end
										Insert(Bindings[ev], "<farthest> "..input)
										NAmanage.SaveBinders()
										refreshItems()
									end
								}}
							})
						end
					})

					Insert(B, {
						Text = "Random…",
						Callback = function()
							Window({
								Title = "Random Count",
								Description = "How many random players? (e.g. 1, 3, 5)",
								InputField = true,
								Buttons = {{
									Text = "Next",
									Callback = function(n)
										n = tonumber(n) or 1
										n = math.max(1, math.floor(n))
										local prefix = "<#"..tostring(n).."> "
										Window({
											Title = ev.." Binders",
											Description = "Enter command (target: "..prefix..")",
											InputField = true,
											Buttons = {{
												Text = "Submit",
												Callback = function(input)
													local cmdName = input and input:match("^(%S+)")
													if not (cmdName and (cmds.Commands[Lower(cmdName)] or cmds.Aliases[Lower(cmdName)])) then
														DoNotif("Command '"..tostring(cmdName).."' not found."); return
													end
													Insert(Bindings[ev], prefix..input)
													NAmanage.SaveBinders()
													refreshItems()
												end
											}}
										})
									end
								}}
							})
						end
					})

					Insert(B, {
						Text = "Radius…",
						Callback = function()
							Window({
								Title = "Radius (studs)",
								Description = "Players within this radius of you (e.g. 25)",
								InputField = true,
								Buttons = {{
									Text = "Next",
									Callback = function(r)
										r = tonumber(r) or 25
										r = math.max(1, math.floor(r))
										local prefix = "<rad"..tostring(r).."> "
										Window({
											Title = ev.." Binders",
											Description = "Enter command (target: "..prefix..")",
											InputField = true,
											Buttons = {{
												Text = "Submit",
												Callback = function(input)
													local cmdName = input and input:match("^(%S+)")
													if not (cmdName and (cmds.Commands[Lower(cmdName)] or cmds.Aliases[Lower(cmdName)])) then
														DoNotif("Command '"..tostring(cmdName).."' not found."); return
													end
													Insert(Bindings[ev], prefix..input)
													NAmanage.SaveBinders()
													refreshItems()
												end
											}}
										})
									end
								}}
							})
						end
					})

					Insert(B, {
						Text = "Team prefix…",
						Callback = function()
							Window({
								Title = "Team Prefix",
								Description = "e.g. red / blu / gua",
								InputField = true,
								Buttons = {{
									Text = "Next",
									Callback = function(prefix)
										prefix = tostring(prefix or ""):gsub("%s+","")
										if prefix == "" then DoNotif("Team prefix cannot be empty."); return end
										local sel = "<%"..prefix.."> "
										Window({
											Title = ev.." Binders",
											Description = "Enter command (target: "..sel..")",
											InputField = true,
											Buttons = {{
												Text = "Submit",
												Callback = function(input)
													local cmdName = input and input:match("^(%S+)")
													if not (cmdName and (cmds.Commands[Lower(cmdName)] or cmds.Aliases[Lower(cmdName)])) then
														DoNotif("Command '"..tostring(cmdName).."' not found."); return
													end
													Insert(Bindings[ev], sel..input)
													NAmanage.SaveBinders()
													refreshItems()
												end
											}}
										})
									end
								}}
							})
						end
					})

					Insert(B, {
						Text = "Specific player…",
						Callback = function()
							Window({
								Title = "Player Name (prefix ok)",
								Description = "Example: coolguy / coo",
								InputField = true,
								Buttons = {{
									Text = "Next",
									Callback = function(name)
										name = tostring(name or ""):gsub("^%s+",""):gsub("%s+$","")
										if name == "" then DoNotif("Name cannot be empty."); return end
										local sel = "<player:"..name.."> "
										Window({
											Title = ev.." Binders",
											Description = "Enter command (target: "..sel..")",
											InputField = true,
											Buttons = {{
												Text = "Submit",
												Callback = function(input)
													local cmdName = input and input:match("^(%S+)")
													if not (cmdName and (cmds.Commands[Lower(cmdName)] or cmds.Aliases[Lower(cmdName)])) then
														DoNotif("Command '"..tostring(cmdName).."' not found."); return
													end
													Insert(Bindings[ev], sel..input)
													NAmanage.SaveBinders()
													refreshItems()
												end
											}}
										})
									end
								}}
							})
						end
					})

					Insert(B, {
						Text = "UserId…",
						Callback = function()
							Window({
								Title = "UserId",
								Description = "Numbers only",
								InputField = true,
								Buttons = {{
									Text = "Next",
									Callback = function(id)
										id = tonumber(id)
										if not id then DoNotif("Invalid UserId."); return end
										local sel = "<id:"..tostring(id).."> "
										Window({
											Title = ev.." Binders",
											Description = "Enter command (target: "..sel..")",
											InputField = true,
											Buttons = {{
												Text = "Submit",
												Callback = function(input)
													local cmdName = input and input:match("^(%S+)")
													if not (cmdName and (cmds.Commands[Lower(cmdName)] or cmds.Aliases[Lower(cmdName)])) then
														DoNotif("Command '"..tostring(cmdName).."' not found."); return
													end
													Insert(Bindings[ev], sel..input)
													NAmanage.SaveBinders()
													refreshItems()
												end
											}}
										})
									end
								}}
							})
						end
					})

					Insert(B, {
						Text = "Custom term(s)…",
						Callback = function()
							Window({
								Title = "Custom PlayerArgs terms",
								Description = "Comma-separated: nearest,%blu,#3,group123,rad25",
								InputField = true,
								Buttons = {{
									Text = "Next",
									Callback = function(term)
										term = tostring(term or ""):gsub("%s+", "")
										if term == "" then DoNotif("Enter at least one term."); return end
										local sel = "<"..term.."> "
										Window({
											Title = ev.." Binders",
											Description = "Enter command (target: "..sel..")",
											InputField = true,
											Buttons = {{
												Text = "Submit",
												Callback = function(input)
													local cmdName = input and input:match("^(%S+)")
													if not (cmdName and (cmds.Commands[Lower(cmdName)] or cmds.Aliases[Lower(cmdName)])) then
														DoNotif("Command '"..tostring(cmdName).."' not found."); return
													end
													Insert(Bindings[ev], sel..input)
													NAmanage.SaveBinders()
													refreshItems()
												end
											}}
										})
									end
								}}
							})
						end
					})

					return B
				end)()
			})
		end)

		refreshItems()
		layoutOrder = layoutOrder + 1
	end
end)

-- [[ GUI ELEMENTS ]] --

--[[

NAgui.addToggle("Toggle Button", true, function(state)
	print("State:", state)
end)

NAgui.addColorPicker("Color Picker", Color3.fromRGB(200, 50, 100), function(color)
	print("Selected Color:", color)
end)

NAgui.addButton("button", function()
	print'pressed button'
end)

NAgui.addSection("Section Label")

NAgui.addInput("Input Label", "Placeholder", "", function(text)
	print("Input:", text)
end)

NAgui.addKeybind("Toggle Key", "F", function(key)
	print("key triggered:", key)
end)

NAgui.addSlider("Slider", 0, 100, 50, 5, "%", function(val) -- min, max, default, add, suffix
	print("Slider Value:", val)
end)

]]

--[[if Discover(_G.NAadminsLol or {}, LocalPlayer.UserId) then
	if NAgui.addSection then
		NAgui.addSection("NA Admin")
	end
	NAgui.addToggle("Admin RGB Username", NAStuff.ForceAdminRainbow, function(state)
		NAStuff.ForceAdminRainbow = state
	end)
end]]

NAgui.addTab(TAB_ALL, { default = true, order = 0, textIcon = "grid" })
NAgui.addTab(TAB_GENERAL, { order = 1, textIcon = "gear" })
NAgui.setTab(TAB_GENERAL)

NAgui.addSection("Prefix Settings")

NAgui.addInput("Prefix", "Enter a Prefix", opt.prefix, function(text)
	local newPrefix = text
	if not newPrefix or newPrefix == "" then
		DoNotif("Please enter a valid prefix")
	elseif utf8.len(newPrefix) > 1 then
		DoNotif("Prefix must be a single character (e.g. ; . !)")
	elseif newPrefix:match("[%w]") then
		DoNotif("Prefix cannot contain letters or numbers")
	elseif newPrefix:match("[%[%]%(%)%*%^%$%%{}<>]") then
		DoNotif("That symbol is not allowed as a prefix")
	elseif newPrefix:match("&amp;") or newPrefix:match("&lt;") or newPrefix:match("&gt;")
		or newPrefix:match("&quot;") or newPrefix:match("&#x27;") or newPrefix:match("&#x60;") then
		DoNotif("Encoded/HTML characters are not allowed as a prefix")
	else
		opt.prefix = newPrefix
		DoNotif("Prefix set to: "..newPrefix)
		if NAmanage.SyncPrefixUI then
			NAmanage.SyncPrefixUI()
		end
	end
end)

if FileSupport then
	NAgui.addButton("Save Prefix", function()
		NAmanage.NASettingsSet("prefix", opt.prefix)
		DoNotif("Prefix saved to settings file: "..NAfiles.NAMAINSETTINGSPATH)
	end)
end

NAgui.addSection("Admin Utility")

NAgui.addToggle("Keep "..adminName, NAQoTEnabled, function(val)
	NAQoTEnabled = val
	NAmanage.NASettingsSet("queueOnTeleport", val)
	if NAQoTEnabled then
		DoNotif(adminName.." will now auto-load after teleport (QueueOnTeleport enabled)", 3)
	else
		DoNotif("QueueOnTeleport has been disabled. "..adminName.." will no longer auto-run after teleport", 3)
	end
end)
NAmanage.RegisterToggleAutoSync("Keep "..adminName, function()
	return NAQoTEnabled == true
end)

NAgui.addToggle("Hide NA Icon", NAStuff.IconInvisible, function(v)
	NAmanage.IconSetInvisible(v, { skipToggle = true, force = true })
	DoNotif("Icon Visibility is "..(v and "Off" or "On"), 2)
end)
NAmanage.RegisterToggleAutoSync("Hide NA Icon", function()
	return NAStuff.IconInvisible == true
end)

NAgui.addToggle("Lock NA Icon", NAStuff.IconLocked, function(v)
	NAgui.setIconLocked(v, { force = true, skipToggle = true })
	DoNotif("Icon Position is "..(v and "Locked" or "Unlocked"), 2)
end)
NAmanage.RegisterToggleAutoSync("Lock NA Icon", function()
	return NAStuff.IconLocked == true
end)

NAgui.addToggle("Command Predictions Prompt", doPREDICTION, function(v)
	doPREDICTION = v
	DoNotif("Command Predictions "..(v and "Enabled" or "Disabled"), 2)
	NAmanage.NASettingsSet("prediction", v)
end)
NAmanage.RegisterToggleAutoSync("Command Predictions Prompt", function()
	return doPREDICTION == true
end)

NAgui.addToggle("Disable Purchase Prompts", NAStuff.PurchasePromptsDisabled == true, function(v)
	NAStuff.PurchasePromptsDisabled = v == true
	pcall(NAmanage.NASettingsSet, "purchasePromptsDisabled", NAStuff.PurchasePromptsDisabled)
	NAmanage.nuhuhprompt(not NAStuff.PurchasePromptsDisabled)
	DoNotif("Purchase prompts "..(NAStuff.PurchasePromptsDisabled and "blocked" or "allowed"), 2)
end)
NAmanage.RegisterToggleAutoSync("Disable Purchase Prompts", function()
	return NAStuff.PurchasePromptsDisabled == true
end)

NAgui.addToggle("Disable Network Pause", NAStuff.NetworkPauseDisabled == true, function(v)
	NAStuff.NetworkPauseDisabled = v == true
	pcall(NAmanage.NASettingsSet, "networkPauseDisabled", NAStuff.NetworkPauseDisabled)
	NAmanage.setNetworkPauseBlocked(NAStuff.NetworkPauseDisabled)
	DoNotif("Network pause UI "..(NAStuff.NetworkPauseDisabled and "blocked" or "allowed"), 2)
end)
NAmanage.RegisterToggleAutoSync("Disable Network Pause", function()
	return NAStuff.NetworkPauseDisabled == true
end)

tweenDurationDefault = math.clamp(tonumber(NAStuff.tweenSpeed) or 1, 0.05, 5)
NAgui.addSlider("Teleport Tween Duration", 0.05, 5, tweenDurationDefault, 0.05, " s", function(val)
	local clamped = math.clamp(tonumber(val) or tweenDurationDefault, 0.05, 5)
	NAStuff.tweenSpeed = clamped
	NAmanage.NASettingsSet("tweenSpeed", clamped)
end)

if IsOnPC then
	NAgui.addToggle("Freecam Shift+P Keybind", _G.NAFreecamKeybindEnabled == true, function(v)
		_G.NAFreecamKeybindEnabled = v and true or false
		NAmanage.NASettingsSet("freecamKeybind", _G.NAFreecamKeybindEnabled)
		DoNotif("Freecam Shift+P keybind "..(v and "enabled" or "disabled"), 2)
	end)
	NAmanage.RegisterToggleAutoSync("Freecam Shift+P Keybind", function()
		return _G.NAFreecamKeybindEnabled == true
	end)
end

freecamSpeedDefault = math.clamp(tonumber(NAStuff.FreecamSpeed) or 5, 0.05, 20)
NAgui.addInput("Freecam Speed", "Enter speed (e.g. 10)", tostring(freecamSpeedDefault), function(text)
	local value = tonumber(text)
	if not value then
		DoNotif("Please enter a numeric freecam speed", 2)
		return
	end
	local clamped = math.clamp(value, 0.05, 20)
	NAStuff.FreecamSpeed = clamped
	pcall(NAmanage.NASettingsSet, "freecamSpeed", clamped)
	if NAFreecam and NAFreecam.SetSpeed then
		NAFreecam.SetSpeed(math.clamp(clamped / 5, 0.01, 4))
	end
	DoNotif("Freecam speed set to "..Format("%.2f", clamped), 2)
end)

NAgui.addToggle("Debug Notifications", NAStuff.nuhuhNotifs, function(v)
	NAStuff.nuhuhNotifs = v
	DoNotif("Debug Notifications "..(v and "Enabled" or "Disabled"), 2)
	NAmanage.NASettingsSet("notifsToggle", v)
end)
NAmanage.RegisterToggleAutoSync("Debug Notifications", function()
	return NAStuff.nuhuhNotifs == true
end)

NAgui.addToggle("Run AutoExec on Start", NAStuff.AutoExecEnabled ~= false, function(v)
	NAStuff.AutoExecEnabled = v
	NAmanage.NASettingsSet("autoExecEnabled", v)
	DoNotif("AutoExec "..(v and "will run on start" or "is disabled"), 2)
end)
NAmanage.RegisterToggleAutoSync("Run AutoExec on Start", function()
	return NAStuff.AutoExecEnabled ~= false
end)

NAgui.addToggle("Run UserButtons on Start", NAStuff.UserButtonsAutoLoad ~= false, function(v)
	NAStuff.UserButtonsAutoLoad = v
	NAmanage.NASettingsSet("userButtonsAutoLoad", v)
	DoNotif("User buttons "..(v and "will load on start" or "will not auto-load on start"), 2)
end)
NAmanage.RegisterToggleAutoSync("Run UserButtons on Start", function()
	return NAStuff.UserButtonsAutoLoad ~= false
end)

NAgui.addButton("cmdbar2", function()
	if cmd and cmd.run then
		cmd.run({"cmdbar2"})
	end
end)

NAgui.addToggle("Run cmdbar2 on Start", NAStuff.CmdBar2AutoRun == true, function(v)
	NAStuff.CmdBar2AutoRun = v and true or false
	NAmanage.NASettingsSet("cmdbar2AutoRun", v)
	DoNotif("cmdbar2 "..(v and "will open on start" or "will not auto-open on start"), 2)
end)
NAmanage.RegisterToggleAutoSync("Run cmdbar2 on Start", function()
	return NAStuff.CmdBar2AutoRun == true
end)

NAgui.addSlider("cmdbar2 Width", NAStuff.CmdBar2.minWidth, NAStuff.CmdBar2.maxWidth, NAmanage.CmdBar2ClampValue(NAStuff.CmdBar2Width, NAStuff.CmdBar2.minWidth, NAStuff.CmdBar2.maxWidth, NAStuff.CmdBar2.defaultWidth), 2, " px", function(val)
	NAmanage.CmdBar2ApplySize({
		width = val,
		height = NAStuff.CmdBar2Height,
	})
end)

NAgui.addSlider("cmdbar2 Height", NAStuff.CmdBar2.minHeight, NAStuff.CmdBar2.maxHeight, NAmanage.CmdBar2ClampValue(NAStuff.CmdBar2Height, NAStuff.CmdBar2.minHeight, NAStuff.CmdBar2.maxHeight, NAStuff.CmdBar2.defaultHeight), 1, " px", function(val)
	NAmanage.CmdBar2ApplySize({
		width = NAStuff.CmdBar2Width,
		height = val,
	})
end)

NAgui.addToggle("Auto Skip Loading Screen", NAmanage.getAutoSkipPreference(), function(v)
	NAmanage.setAutoSkipPreference(v)
	DoNotif("Auto skip loading screen "..(v and "enabled" or "disabled"), 2)
end)
NAmanage.RegisterToggleAutoSync("Auto Skip Loading Screen", function()
	return NAmanage.getAutoSkipPreference() == true
end)

if type(NAmanage.isDeltaExecutor) == "function" and NAmanage.isDeltaExecutor(true) then
	NAgui.addToggle("Delta Reminder", NAStuff.deltaPrompted ~= true, function(state)
		if state then
			if NAStuff.deltaPrompted ~= true then
				DoNotif("Delta customization reminder is already enabled. The popup will appear soon.", 3)
				Defer(function()
					Wait(0.1)
					NAmanage.deltaPopup()
				end)
				return
			end
			NAStuff.deltaPrompted = false
			pcall(NAmanage.NASettingsSet, "deltaPrompted", false)
			DoNotif("Delta customization reminder re-enabled. It will show again shortly and this toggle will switch off afterwards.", 4)
			Defer(function()
				Wait(0.1)
				NAmanage.deltaPopup()
			end)
		else
			NAStuff.deltaPrompted = true
			pcall(NAmanage.NASettingsSet, "deltaPrompted", true)
			DoNotif("Delta customization reminder disabled.", 3)
		end
	end)
	NAmanage.RegisterToggleAutoSync("Delta Reminder", function()
		return NAStuff.deltaPrompted ~= true
	end)
end

NAgui.addToggle("Loading Mode (Tray)", NALoadingStartMinimized, function(v)
	NALoadingStartMinimized = v and true or false
	NAmanage.NASettingsSet("loadingStartMinimized", NALoadingStartMinimized)
	NAAssetsLoading.applyMinimizedPreference()
	DoNotif("Loading screen will start "..(NALoadingStartMinimized and "in tray" or "expanded"), 2)
end)
NAmanage.RegisterToggleAutoSync("Loading Mode (Tray)", function()
	return NALoadingStartMinimized == true
end)

NAgui.addToggle("Keep Icon Position", NAiconSaveEnabled, function(v)
	local pos = NAgui.getClampedIconPosition() or TextButton.Position
	if v then
		TextButton.Position = pos
	else
		pos = NAgui.clampIconPositionUDim(UDim2.new(0.5, 0, 0.1, 0))
	end
	pcall(NAmanage.NASettingsSet, "iconPosition", {
		X = pos.X.Scale;
		Y = pos.Y.Scale;
	})
	pcall(NAmanage.NASettingsSet, "iconKeepPosition", v == true)
	NAiconSaveEnabled = v == true
	DoNotif("Icon position "..(v and "will be saved" or "won't be saved").." on exit", 2)
end)
NAmanage.RegisterToggleAutoSync("Keep Icon Position", function()
	return NAiconSaveEnabled == true
end)

NAStuff.PRELOAD_ASSET_CLASS_PROPS = NAStuff.PRELOAD_ASSET_CLASS_PROPS or {
	Animation = { "AnimationId" };
	AnimationClip = { "AnimationId" };
	AnimationTrack = { "Animation" };
	Beam = { "Texture" };
	Decal = { "Texture", "TextureId" };
	Fire = { "Texture" };
	ImageButton = { "Image" };
	ImageLabel = { "Image" };
	MeshPart = { "MeshId", "TextureId" };
	ParticleEmitter = { "Texture" };
	Pants = { "PantsTemplate" };
	PantsGraphic = { "Graphic" };
	Shirt = { "ShirtTemplate" };
	ShirtGraphic = { "Graphic" };
	Sky = { "SkyboxBk", "SkyboxDn", "SkyboxFt", "SkyboxLf", "SkyboxRt", "SkyboxUp" };
	Smoke = { "Texture" };
	Sound = { "SoundId" };
	SpecialMesh = { "MeshId", "TextureId" };
	SurfaceAppearance = { "AlbedoTexture", "MetalnessTexture", "RoughnessTexture", "NormalId" };
	SurfaceTexture = { "Texture" };
	Trail = { "Texture" };
	Texture = { "Texture", "TextureId" };
	Sparkles = { "Texture" };
	VideoFrame = { "Video" };
	CharacterMesh = { "BaseTextureId", "OverlayTextureId" };
};
NAStuff.PRELOAD_INSTANCE_CLASSES = NAStuff.PRELOAD_INSTANCE_CLASSES or {
	Animation = true;
	AnimationClip = true;
	AnimationTrack = true;
	Beam = true;
	Decal = true;
	Fire = true;
	MeshPart = true;
	ParticleEmitter = true;
	Pants = true;
	PantsGraphic = true;
	Shirt = true;
	ShirtGraphic = true;
	Sky = true;
	Smoke = true;
	Sound = true;
	SpecialMesh = true;
	SurfaceAppearance = true;
	SurfaceTexture = true;
	Trail = true;
	Texture = true;
	Sparkles = true;
	VideoFrame = true;
	CharacterMesh = true;
};

NAStuff.ASSET_LOAD_MODE_DEFS = NAStuff.ASSET_LOAD_MODE_DEFS or {
	Batch = { chunk = 96, delay = 0.03 };
	Medium = { chunk = 256, delay = 0.02 };
	Fast = { chunk = 512, delay = 0.01 };
	Aggressive = { chunk = 768, delay = 0.005 };
}
NAStuff.ASSET_LOAD_MODE_ORDER = NAStuff.ASSET_LOAD_MODE_ORDER or { "Batch", "Medium", "Fast", "Aggressive" }
NAStuff.AssetLoadMode = NAStuff.AssetLoadMode or "Fast"

NAmanage.ClampNumber = NAmanage.ClampNumber or function(value, minValue, maxValue)
	if type(value) ~= "number" then
		return value
	end
	minValue = minValue or value
	maxValue = maxValue or value
	if value < minValue then
		value = minValue
	end
	if value > maxValue then
		value = maxValue
	end
	return value
end

NAmanage.GetAssetLoadModeData = NAmanage.GetAssetLoadModeData or function()
	local mode = NAStuff.AssetLoadMode or "Fast"
	local def = NAStuff.ASSET_LOAD_MODE_DEFS[mode]
	if not def then
		mode = "Fast"
		def = NAStuff.ASSET_LOAD_MODE_DEFS.Fast
		NAStuff.AssetLoadMode = mode
	end
	return mode, def
end

NAmanage.SetAssetLoadMode = NAmanage.SetAssetLoadMode or function(mode)
	if type(mode) ~= "string" then
		return
	end
	local def = NAStuff.ASSET_LOAD_MODE_DEFS[mode]
	if not def then
		return
	end
	NAStuff.AssetLoadMode = mode
	if NAmanage.NASettingsSet then
		pcall(NAmanage.NASettingsSet, "assetLoadMode", mode)
	end
	local box = NAStuff.AssetLoadModeBox
	if box then
		pcall(function()
			box.Text = Format("%s Mode | %d chunk, %.3fs delay", mode, def.chunk, def.delay)
		end)
	end
end

NAmanage.GetAggressivePreloadChunk = NAmanage.GetAggressivePreloadChunk or function()
	local _, def = NAmanage.GetAssetLoadModeData()
	return def.chunk
end

NAmanage.GetAggressiveChunkYield = NAmanage.GetAggressiveChunkYield or function()
	local _, def = NAmanage.GetAssetLoadModeData()
	return def.delay
end

NAmanage.FormatAssetProgress = NAmanage.FormatAssetProgress or function(done, total)
	local loaded = tonumber(done) or 0
	local totalAssets = tonumber(total) or 0
	if totalAssets <= 0 then
		return "0/0 (0/0%)"
	end
	local percent = NAmanage.ClampNumber(loaded / totalAssets, 0, 1) * 100
	return Format("%d/%d (%.0f%%)", loaded, totalAssets, percent)
end

NAmanage.UpdateAssetLoadStatus = NAmanage.UpdateAssetLoadStatus or function(done, total)
	local box = NAStuff.AssetLoadStatusBox
	if not box then
		return
	end
	local text = NAmanage.FormatAssetProgress(done, total)
	pcall(function()
		box.Text = text
	end)
end

originalIO.AssetsPreloadNA = function()
	local entries = {}
	local seenString = {}
	local seenInstance = {}
	local scanChunk = math.max(100, NAmanage.GetAggressivePreloadChunk())
	local scanYield = math.max(0, NAmanage.GetAggressiveChunkYield())
	local scanned = 0

	local function addResource(value)
		local t = typeof(value)
		if t == "Instance" then
			if not seenInstance[value] then
				seenInstance[value] = true
				entries[#entries + 1] = value
			end
		elseif t == "string" and value ~= "" and not value:match("^rbxassetid://0+$") then
			if not seenString[value] then
				seenString[value] = true
				entries[#entries + 1] = value
			end
		end
	end

	local roots = {
		game:GetService("Workspace"),
		game:GetService("ReplicatedStorage"),
		game:GetService("ReplicatedFirst"),
		game:GetService("Lighting"),
		game:GetService("StarterGui"),
		game:GetService("StarterPack"),
		game:GetService("StarterPlayer"),
		game:GetService("SoundService"),
		game:GetService("Chat"),
		game:GetService("TextChatService"),
	}

	for i = 1, #roots do
		local root = roots[i]
		local ok, descendants = pcall(function()
			return root:GetDescendants()
		end)
		if ok and descendants then
			for _, inst in ipairs(descendants) do
				if NAStuff.PRELOAD_INSTANCE_CLASSES[inst.ClassName] then
					addResource(inst)
				end
				local props = NAStuff.PRELOAD_ASSET_CLASS_PROPS[inst.ClassName]
				if props then
					for j = 1, #props do
						local prop = props[j]
						local okProp, value = pcall(function()
							return inst[prop]
						end)
						if okProp and value then
							addResource(value)
						end
					end
				end
				scanned += 1
				if scanned % scanChunk == 0 then
					if scanYield > 0 then
						Wait(scanYield)
					else
						Wait()
					end
				end
			end
		end
		if scanYield > 0 then
			Wait(scanYield)
		else
			Wait()
		end
	end

	return entries
end

NAgui.addSection("Asset Loading")
NAStuff.AssetLoadModeBox = NAgui.addInfo("Asset Load Mode", "")
NAStuff.AssetLoadStatusBox = NAgui.addInfo("Asset Load Progress", "0/0 (0/0%)")

NAgui.addToggle("Preload Assets On Load", NAStuff.AutoPreloadAssets == true, function(v)
	NAStuff.AutoPreloadAssets = v and true or false
	pcall(NAmanage.NASettingsSet, "autoPreloadAssets", NAStuff.AutoPreloadAssets)
end)
NAmanage.RegisterToggleAutoSync("Preload Assets On Load", function()
	return NAStuff.AutoPreloadAssets == true
end)

for _, modeName in ipairs(NAStuff.ASSET_LOAD_MODE_ORDER) do
	NAgui.addButton("Mode: "..modeName, function()
		if NAStuff.AssetLoadRunning then
			DoNotif("Finish the current load before changing modes.", 2)
			return
		end
		NAmanage.SetAssetLoadMode(modeName)
		DoNotif("Asset load mode set to "..modeName, 2)
	end)
end

NAmanage.setAssetLoadButtonState = function(isRunning)
	NAStuff.AssetLoadRunning = isRunning and true or false
	local button = NAStuff.AssetLoadButton
	if not button then
		return
	end
	local interact = button:FindFirstChild("Interact")
	if interact then
		interact.Active = not isRunning
		interact.AutoButtonColor = not isRunning
	end
	pcall(function()
		button.Title.Text = isRunning and "Loading Game Assets..." or "Load Game Assets"
	end)
end

NAmanage.finishAssetLoad = function(session, success, total, startTime, err)
	if session.finished then
		return
	end
	session.finished = true
	NAmanage.setAssetLoadButtonState(false)
	if success and total and total > 0 and startTime then
		local elapsed = tick() - startTime
		DoNotif(Format("Preloaded %d assets in %.2fs.", total, elapsed), 3)
	elseif not success then
		DoNotif("Asset preloading failed: "..tostring(err or "unknown"), 4)
	end
end

NAmanage.StartAssetPreload = NAmanage.StartAssetPreload or function(opts)
	local silent = opts and opts.silent
	if NAStuff.AssetLoadRunning then
		if not silent then
			DoNotif("Asset loader is already running.", 2)
		end
		return
	end
	if not ContentProvider or not ContentProvider.PreloadAsync then
		if not silent then
			DoNotif("ContentProvider preloading is unavailable on this platform.", 3)
		end
		return
	end

	NAmanage.setAssetLoadButtonState(true)
	NAmanage.UpdateAssetLoadStatus(0, 0)
	if not silent then
		DoNotif("Scanning for assets to preload...", 2)
	end

	Spawn(function()
		local startTime = tick()
		local totalAssets = 0
		local session = { finished = false }
		local lastProgressTick = startTime
		local ok, err = pcall(function()
			local assets = originalIO.AssetsPreloadNA()
			local total = #assets
			totalAssets = total
			if total == 0 then
				NAmanage.UpdateAssetLoadStatus(0, 0)
				if not silent then
					DoNotif("Could not find any assets to preload.", 3)
				end
				return
			end

			NAmanage.UpdateAssetLoadStatus(0, total)
			lastProgressTick = tick()
			local chunkSize = math.max(1, NAmanage.GetAggressivePreloadChunk())
			local chunkYield = math.max(0, NAmanage.GetAggressiveChunkYield())
			local watchdog = Spawn(function()
				while not session.finished do
					Wait(2)
					if not NAStuff.AssetLoadRunning then
						break
					end
					if tick() - lastProgressTick > 20 then
						NAmanage.finishAssetLoad(session, false, total, startTime, "watchdog timeout")
						break
					end
				end
			end)

			for index = 1, total, chunkSize do
				if session.finished then
					break
				end
				local chunk = {}
				for j = index, math.min(total, index + chunkSize - 1) do
					chunk[#chunk + 1] = assets[j]
				end

				pcall(function()
					ContentProvider:PreloadAsync(chunk)
				end)
				local doneCount = math.min(total, index + #chunk - 1)
				NAmanage.UpdateAssetLoadStatus(doneCount, total)
				lastProgressTick = tick()
				Wait(chunkYield)
			end

			if not session.finished then
				NAmanage.UpdateAssetLoadStatus(total, total)
			end
		end)
		NAmanage.finishAssetLoad(session, ok, totalAssets, startTime, err)
		if not ok then
			warn("Asset loader failed:", err)
		end
	end)
end

NAStuff.loadGameAssetsButton = NAStuff.loadGameAssetsButton or NAgui.addButton("Load Game Assets", function()
	NAmanage.StartAssetPreload()
end)
NAStuff.AssetLoadButton = NAStuff.loadGameAssetsButton
NAmanage.setAssetLoadButtonState(false)
NAmanage.SetAssetLoadMode(NAStuff.AssetLoadMode)

NAgui.addSection("Roblox Input Settings")

NAgui.addToggle("Disable LastInputTypeChanged", NADisableLastInput, function(v)
	NADisableLastInput = v
	NAmanage.NASettingsSet("disableLastInput", v)

	if v then
		originalIO.ApplyLastInputPatch()
		DoNotif("LastInputTypeChanged Disabled\nPrevents forcing your input to change to Keyboard when using VirtualInputManager on mobile", 3)
	else
		originalIO.RevertLastInputPatch()
		DoNotif("LastInputTypeChanged Enabled", 2)
	end
end)

NAgui.addSection("Support")
NAgui.addButton("Join Discord", function()
	if setclipboard then
		setclipboard(inviteLink)
		DoNotif("Discord link copied to clipboard!")
	else
		DoNotif("Unable to copy automatically. Invite: "..inviteLink, 3)
	end
end)

if FileSupport then
	NAgui.addSection("Saved Data")
	NAgui.addButton("Delete Saved Settings...", function()
		NAmanage.openSettingsCleanupPopup()
	end)
end

NAgui.addTab(TAB_FFLAGS, { order = 4, textIcon = "flag" })
NAgui.setTab(TAB_FFLAGS)

local NAFFlags = NAmanage.NAFFlags or {}
NAmanage.NAFFlags = NAFFlags

NAFFlags.whitelist = NAFFlags.whitelist or {
	{ name = "PhysicsReceiveNumParallelTasks", default = 16, valueType = "number" };
	{ name = "RuntimeConcurrency", default = 15, valueType = "number" };
	{ name = "SimWorldTaskQueueParallelTasks", default = 16, valueType = "number" };
	{ name = "ReplicationDataCacheNumParallelTasks", default = 16, valueType = "number" };
	{ name = "NetworkClusterPacketCacheNumParallelTasks", default = 16, valueType = "number" };
	{ name = "FixParticleEmissionBias2", default = true, valueType = "boolean" };
	{ name = "InterpolationNumParallelTasks", default = 16, valueType = "number" };
	{ name = "MegaReplicatorNumParallelTasks", default = 16, valueType = "number" };
	{ name = "LuaGcParallelMinMultiTasks", default = 16, valueType = "number" };
	{ name = "FixParticleAttachmentCulling", default = true, valueType = "boolean" };
	{ name = "DebugRenderingSetDeterministic", default = true, valueType = "boolean" };
	{ name = "TaskSchedulerAutoThreadLimit", default = 15, valueType = "number" };
	{ name = "TaskSchedulerAsyncTasksMinimumThreadCount", default = 15, valueType = "number" };
	{ name = "SmoothClusterTaskQueueMaxParallelTasks", default = 16, valueType = "number" };
	{ name = "TeleportReconnect", default = true, valueType = "boolean" };
	{ name = "TeleportReconnect3", default = true, valueType = "boolean" };
	{ name = "AddJoinAttemptId", default = true, valueType = "boolean" };
	{ name = "ChatTranslationSettingEnabled3", default = true, valueType = "boolean" };
	{ name = "EnableQuickGameLaunch", default = false, valueType = "boolean" };
	{ name = "LCCageDeformLimit", default = -1, valueType = "number" };
	{ name = "FullscreenTitleBarTriggerDelayMillis", default = 3600000, valueType = "number" };
	{ name = "DebugPauseVoxelizer", default = false, valueType = "boolean" };
	{ name = "RobloxGuiBlurIntensity", default = 0, valueType = "number" };
	{ name = "DebugDisplayFPS", default = true, valueType = "boolean" };
	{ name = "RenderShadowmapBias", default = -1, valueType = "number" };
	{ name = "MaxFrameBufferSize", default = 4, valueType = "number" };
	{ name = "DebugPerfMode", default = true, valueType = "boolean" };
	{ name = "Order66", default = true, valueType = "boolean" };
	{ name = "AdServiceEnabled", default = false, valueType = "boolean" };
	{ name = "HandleAltEnterFullscreenManually", default = false, valueType = "boolean" };
	{ name = "DebugGraphicsPreferD3D11", default = false, valueType = "boolean" };
	{ name = "DebugGraphicsPreferD3D11FL10", default = false, valueType = "boolean" };
	{ name = "DebugGraphicsPreferVulkan", default = true, valueType = "boolean" };
	{ name = "DebugGraphicsPreferOpenGL", default = false, valueType = "boolean" };
	{ name = "DebugGraphicsDisableDirect3D11", default = true, valueType = "boolean" };
	{ name = "TaskSchedulerTargetFps", default = 2147483647, valueType = "number" };
	{ name = "TaskSchedulerLimitTargetFpsTo2402", default = false, valueType = "boolean" };
	{ name = "DebugForceMSAASamples", default = 0, valueType = "number" };
	{ name = "TextureQualityOverrideEnabled", default = true, valueType = "boolean" };
	{ name = "TextureQualityOverride", default = 0, valueType = "number" };
	{ name = "TextureCompositorLowResFactor", default = 1, valueType = "number" };
	{ name = "PerformanceControlTextureQualityBestUtility", default = -1, valueType = "number" };
	{ name = "EnableRequestAsyncCompression", default = false, valueType = "boolean" };
	{ name = "DisablePostFx", default = true, valueType = "boolean" };
	{ name = "DebugRenderForceTechnologyVoxel", default = true, valueType = "boolean" };
	{ name = "CSGLevelOfDetailSwitchingDistance", default = 0, valueType = "number" };
	{ name = "CSGLevelOfDetailSwitchingDistanceL12", default = 0, valueType = "number" };
	{ name = "CSGLevelOfDetailSwitchingDistanceL23", default = 0, valueType = "number" };
	{ name = "CSGLevelOfDetailSwitchingDistanceL34", default = 0, valueType = "number" };
	{ name = "CSGv2LodsToGenerate", default = 0, valueType = "number" };
	{ name = "CSGv2LodMinTriangleCount", default = 0, valueType = "number" };
	{ name = "NewLightAttenuation", default = false, valueType = "boolean" };
	{ name = "RenderShadowIntensity", default = 0, valueType = "number" };
	{ name = "CSGVoxelizerFadeRadius", default = 0, valueType = "number" };
	{ name = "TerrainArraySliceSize", default = 0, valueType = "number" };
	{ name = "RomarkStartWithGraphicQualityLevel", default = 1, valueType = "number" };
	{ name = "DebugFRMQualityLevelOverride", default = 0, valueType = "number" };
	{ name = "DebugRestrictGCDistance", default = 36000, valueType = "number" };
	{ name = "MSRefactor5", default = false, valueType = "boolean" };
	{ name = "DebugTextureManagerSkipMips", default = -1, valueType = "number" };
	{ name = "GlobalWindActivated", default = false, valueType = "boolean" };
	{ name = "GlobalWindRendering", default = false, valueType = "boolean" };
	{ name = "DebugDontRenderScreenGui", default = false, valueType = "boolean" };
	{ name = "DebugSSAOForce", default = false, valueType = "boolean" };
	{ name = "SSAOMipLevels", default = 0, valueType = "number" };
	{ name = "EnableCommandAutocomplete", default = false, valueType = "boolean" };
	{ name = "AnimationLodFacsDistanceMin", default = 0, valueType = "number" };
	{ name = "AnimationLodFacsDistanceMax", default = 0, valueType = "number" };
	{ name = "AnimationLodFacsVisibilityDenominator", default = 0, valueType = "number" };
	{ name = "TextureCompositorActiveJobs", default = 1, valueType = "number" };
	{ name = "ViewportFrameMaxSize", default = 9999999, valueType = "number" };
	{ name = "FRMMaxGrassDistance", default = 0, valueType = "number" };
	{ name = "FRMMinGrassDistance", default = 0, valueType = "number" };
	{ name = "RenderGrassDetailStrands", default = 0, valueType = "number" };
	{ name = "GrassMovementReducedMotionFactor", default = 100, valueType = "number" };
	{ name = "DebugSkyGray", default = false, valueType = "boolean" };
	{ name = "CoreGuiTypeSelfViewPresent", default = false, valueType = "boolean" };
	{ name = "RenderCheckThreading", default = true, valueType = "boolean" };
	{ name = "OptimizeNetworkTransport", default = true, valueType = "boolean" };
	{ name = "OptimizeNetworkRouting", default = true, valueType = "boolean" };
	{ name = "RakNetResendBufferArrayLength", default = 128, valueType = "number" };
	{ name = "WaitOnRecvFromLoopEndedMS", default = 100, valueType = "number" };
	{ name = "DebugDisableTelemetryEphemeralCounter", default = true, valueType = "boolean" };
	{ name = "DebugDisableTelemetryEphemeralStat", default = true, valueType = "boolean" };
	{ name = "DebugDisableTelemetryEventIngest", default = true, valueType = "boolean" };
	{ name = "DebugDisableTelemetryPoint", default = true, valueType = "boolean" };
	{ name = "DebugDisableTelemetryV2Counter", default = true, valueType = "boolean" };
	{ name = "DebugDisableTelemetryV2Event", default = true, valueType = "boolean" };
	{ name = "DebugDisableTelemetryV2Stat", default = true, valueType = "boolean" };
	{ name = "DisableDPIScale", default = true, valueType = "boolean" };
}

NAFFlags.info = NAFFlags.info or {
	PhysicsReceiveNumParallelTasks = "Splits incoming physics work across more threads. Higher can help multi-core CPUs.";
	RuntimeConcurrency = "Global concurrency limit for internal worker threads.";
	SimWorldTaskQueueParallelTasks = "Parallelism for world simulation task queue.";
	ReplicationDataCacheNumParallelTasks = "Parallelism for replication data cache processing.";
	NetworkClusterPacketCacheNumParallelTasks = "Parallelism for network packet cache handling.";
	FixParticleEmissionBias2 = "Fixes uneven particle emission behavior.";
	InterpolationNumParallelTasks = "Parallel interpolation jobs used for smoothing replicated motion.";
	MegaReplicatorNumParallelTasks = "Parallel jobs for large-scale replication operations.";
	LuaGcParallelMinMultiTasks = "Minimum parallel tasks used by the Luau garbage collector.";
	FixParticleAttachmentCulling = "Fixes particle attachment culling glitches.";
	DebugRenderingSetDeterministic = "Makes some rendering behavior more deterministic and stable.";

	TaskSchedulerAutoThreadLimit = "Upper bound for automatically created scheduler worker threads.";
	TaskSchedulerAsyncTasksMinimumThreadCount = "Minimum thread count for async tasks.";
	SmoothClusterTaskQueueMaxParallelTasks = "Max parallel tasks for smooth-cluster network queue.";

	TeleportReconnect = "Enables reconnect logic on failed teleports.";
	TeleportReconnect3 = "Newer reconnect path for teleports.";
	AddJoinAttemptId = "Tags join attempts with IDs to improve robustness.";
	ChatTranslationSettingEnabled3 = "Enables current chat translation behavior.";
	EnableQuickGameLaunch = "Faster game launch flow; may spike CPU at load.";

	LCCageDeformLimit = "Limit for cage-based mesh deformation. -1 removes the limit.";
	FullscreenTitleBarTriggerDelayMillis = "Delay before fullscreen title bar appears when hitting screen top.";
	DebugPauseVoxelizer = "Pauses voxelizer (lighting voxel updates). Keep false.";
	RobloxGuiBlurIntensity = "Blur intensity for core UI. 0 disables blur.";
	DebugDisplayFPS = "Shows a debug FPS counter overlay.";
	RenderShadowmapBias = "Overrides shadowmap bias. -1 uses engine default.";
	MaxFrameBufferSize = "Max number of buffered frames. Lower = less latency, higher = smoother.";
	DebugPerfMode = "Enables performance-focused debug behaviors.";
	Order66 = "Internal debug/perf flag. Leave enabled.";
	AdServiceEnabled = "Enables AdService (video ads). Off removes ad overhead.";
	HandleAltEnterFullscreenManually = "Changes how Alt+Enter fullscreen is handled.";

	DebugGraphicsPreferD3D11 = "Prefer D3D11 graphics backend.";
	DebugGraphicsPreferD3D11FL10 = "Prefer D3D11 FL10 for older GPUs.";
	DebugGraphicsPreferVulkan = "Prefer Vulkan graphics backend.";
	DebugGraphicsPreferOpenGL = "Prefer OpenGL graphics backend.";
	DebugGraphicsDisableDirect3D11 = "Disables D3D11 backend when true.";

	TaskSchedulerTargetFps = "Target FPS used by internal scheduler.";
	TaskSchedulerLimitTargetFpsTo2402 = "Clamp target FPS to 240 when true.";

	DebugForceMSAASamples = "Forces MSAA sample count. 0 disables forced MSAA.";

	TextureQualityOverrideEnabled = "Allows manual override of texture quality.";
	TextureQualityOverride = "Texture quality level (0 = lowest, higher = better).";
	TextureCompositorLowResFactor = "Base resolution factor for composited avatar textures.";
	PerformanceControlTextureQualityBestUtility = "Weight for automatic texture quality choice. -1 lets engine decide.";
	EnableRequestAsyncCompression = "Compresses some assets asynchronously when loading.";
	DisablePostFx = "Disables most post-processing effects (bloom, AO, etc.).";
	DebugRenderForceTechnologyVoxel = "Forces voxel lighting pipeline.";

	CSGLevelOfDetailSwitchingDistance = "Base distance where CSG LOD switching starts.";
	CSGLevelOfDetailSwitchingDistanceL12 = "LOD switch distance between CSG L1 and L2.";
	CSGLevelOfDetailSwitchingDistanceL23 = "LOD switch distance between CSG L2 and L3.";
	CSGLevelOfDetailSwitchingDistanceL34 = "LOD switch distance between CSG L3 and L4.";
	CSGv2LodsToGenerate = "How many CSGv2 LOD levels to generate.";
	CSGv2LodMinTriangleCount = "Minimum triangle count for generating CSGv2 LODs.";

	NewLightAttenuation = "Enables new light attenuation model.";
	RenderShadowIntensity = "Global multiplier for shadow intensity.";
	CSGVoxelizerFadeRadius = "Fade radius used by CSG voxelizer.";

	TerrainArraySliceSize = "Internal slice size for terrain storage.";

	RomarkStartWithGraphicQualityLevel = "Initial graphics quality level at launch.";
	DebugFRMQualityLevelOverride = "Forces a fixed FRM (render) quality level.";
	DebugRestrictGCDistance = "Restriction on GC distance in FRM; lower = more aggressive culling.";

	MSRefactor5 = "Enables a refactored rendering path. Experimental.";
	DebugTextureManagerSkipMips = "If >= 0, skips top texture mips (lower-res textures).";

	GlobalWindActivated = "Turns on global wind simulation.";
	GlobalWindRendering = "Renders wind on foliage/parts when global wind is active.";

	DebugDontRenderScreenGui = "Stops ScreenGui from rendering when true.";
	DebugSSAOForce = "Forces SSAO debug behavior.";
	SSAOMipLevels = "Number of SSAO mip levels (AO quality).";

	EnableCommandAutocomplete = "Enables autocomplete in developer command bar.";

	AnimationLodFacsDistanceMin = "Minimum distance for animation LOD falloff.";
	AnimationLodFacsDistanceMax = "Maximum distance for animation LOD falloff.";
	AnimationLodFacsVisibilityDenominator = "Visibility scale factor for animation LOD.";

	TextureCompositorActiveJobs = "Number of active avatar texture compositor jobs. Very low values can cause gray avatars.";

	ViewportFrameMaxSize = "Max resolution for ViewportFrame rendering. 0 uses default.";

	FRMMaxGrassDistance = "Maximum distance grass is rendered.";
	FRMMinGrassDistance = "Minimum distance grass starts rendering.";
	RenderGrassDetailStrands = "Amount of detailed grass strands rendered.";
	GrassMovementReducedMotionFactor = "Scales grass movement; higher = less waving.";

	DebugSkyGray = "Replaces skybox with simple gray debug sky.";
	CoreGuiTypeSelfViewPresent = "Marks that self-view CoreGui is present.";
	RenderCheckThreading = "Enables threaded render checks.";

	OptimizeNetworkTransport = "Enables optimized network transport implementation.";
	OptimizeNetworkRouting = "Enables optimized network routing.";
	RakNetResendBufferArrayLength = "Size of RakNet resend buffer array.";
	WaitOnRecvFromLoopEndedMS = "Wait time after receive loop ends before shutdown.";

	DebugDisableTelemetryEphemeralCounter = "Disable ephemeral counter telemetry.";
	DebugDisableTelemetryEphemeralStat = "Disable ephemeral stat telemetry.";
	DebugDisableTelemetryEventIngest = "Disable telemetry event ingest.";
	DebugDisableTelemetryPoint = "Disable telemetry points.";
	DebugDisableTelemetryV2Counter = "Disable v2 telemetry counters.";
	DebugDisableTelemetryV2Event = "Disable v2 telemetry events.";
	DebugDisableTelemetryV2Stat = "Disable v2 telemetry stats.";

	DisableDPIScale = "Disables OS DPI scaling for the Roblox window.";
}

for _, entry in ipairs(NAFFlags.whitelist) do
	entry.valueType = entry.valueType or type(entry.default)
end

NAFFlags.filePath = NAfiles.NAFFLAGSPATH or (NAfiles.NAFILEPATH.."/NAFFlags.json")
NAFFlags.config = NAFFlags.config or { useFFlags = false, autoApply = false, flags = {}, custom = {} }
NAFFlags.config.custom = NAFFlags.config.custom or {}
NAFFlags.values = NAFFlags.values or {}
NAFFlags.renderingPreferFlags = NAFFlags.renderingPreferFlags or {
	"FFlagDebugGraphicsPreferD3D11",
	"FFlagDebugGraphicsPreferD3D11FL10",
	"FFlagDebugGraphicsPreferVulkan",
	"FFlagDebugGraphicsPreferOpenGL",
}
NAFFlags.renderingDisableFlag = "FFlagDebugGraphicsDisableDirect3D11"

NAFFlags.normalizeValue = function(entry, rawValue, opts)
	opts = opts or {}
	if entry.valueType == "number" then
		local numValue = tonumber(rawValue)
		if numValue == nil then
			if not opts.silent then
				DoNotif(Format("%s expects a number", tostring(entry.name)), 3)
			end
			return nil
		end
		return numValue
	elseif entry.valueType == "boolean" then
		return rawValue and true or false
	end
	return rawValue
end

NAFFlags.parseCustomValue = function(rawValue)
	local str = tostring(rawValue or "")
	local trimmed = str:match("^%s*(.-)%s*$") or str
	local lower = trimmed:lower()
	if lower == "true" then
		return true
	elseif lower == "false" then
		return false
	end
	local num = tonumber(trimmed)
	if num ~= nil then
		return num
	end
	return trimmed
end

NAFFlags.isWhitelistedFlag = function(name)
	for _, entry in ipairs(NAFFlags.whitelist) do
		if entry.name == name then
			return true
		end
	end
	return false
end

NAFFlags.getDefault = function(entry)
	if entry.valueType == "boolean" then
		return false
	end
	return entry.default
end

NAFFlags.normalizeRenderingPrefs = function(changedFlag)
	if not NAFFlags.config or not NAFFlags.config.flags then
		return
	end
	local preferFlags = NAFFlags.renderingPreferFlags or {}
	local disableFlag = NAFFlags.renderingDisableFlag
	local active = nil
	if changedFlag and NAFFlags.values[changedFlag] == true then
		active = changedFlag
	end
	if not active then
		for _, name in ipairs(preferFlags) do
			if NAFFlags.values[name] == true then
				active = name
				break
			end
		end
	end
	for _, name in ipairs(preferFlags) do
		local shouldBe = name == active
		NAFFlags.values[name] = shouldBe
		NAFFlags.config.flags[name] = shouldBe
	end
	if disableFlag then
		if active == "FFlagDebugGraphicsPreferVulkan" or active == "FFlagDebugGraphicsPreferOpenGL" then
			NAFFlags.values[disableFlag] = true
			NAFFlags.config.flags[disableFlag] = true
		elseif active then
			NAFFlags.values[disableFlag] = false
			NAFFlags.config.flags[disableFlag] = false
		end
	end
end

NAFFlags.isRenderingPreferFlag = function(name)
	for _, flagName in ipairs(NAFFlags.renderingPreferFlags) do
		if flagName == name then
			return true
		end
	end
	return false
end

NAFFlags.applyDefaults = function()
	NAFFlags.config.useFFlags = false
	NAFFlags.config.autoApply = false
	NAFFlags.config.flags = {}
	NAFFlags.config.custom = {}
	for _, entry in ipairs(NAFFlags.whitelist) do
		NAFFlags.config.flags[entry.name] = NAFFlags.getDefault(entry)
	end
end

NAFFlags.save = function()
	if not FileSupport then
		return
	end
	local okEncode, encoded = pcall(HttpService.JSONEncode, HttpService, NAFFlags.config)
	if okEncode and encoded then
		pcall(writefile, NAFFlags.filePath, encoded)
	end
end

NAFFlags.load = function()
	NAFFlags.applyDefaults()
	if not FileSupport then
		return
	end
	local needsSave = false
	local okRead, raw = pcall(readfile, NAFFlags.filePath)
	if okRead and type(raw) == "string" and raw ~= "" then
		local okDecode, decoded = pcall(HttpService.JSONDecode, HttpService, raw)
		if okDecode and type(decoded) == "table" then
			if type(decoded.useFFlags) == "boolean" then
				NAFFlags.config.useFFlags = decoded.useFFlags
			else
				needsSave = true
			end
			if type(decoded.autoApply) == "boolean" then
				NAFFlags.config.autoApply = decoded.autoApply
			else
				needsSave = true
			end
			if type(decoded.flags) == "table" then
				for _, entry in ipairs(NAFFlags.whitelist) do
					local normalized = NAFFlags.normalizeValue(entry, decoded.flags[entry.name], { silent = true })
					if normalized ~= nil then
						NAFFlags.config.flags[entry.name] = normalized
					else
						needsSave = true
					end
				end
			end
			if type(decoded.custom) == "table" then
				NAFFlags.config.custom = {}
				for customName, customValue in pairs(decoded.custom) do
					if type(customName) == "string" then
						NAFFlags.config.custom[customName] = customValue
					end
				end
			else
				needsSave = true
			end
		else
			needsSave = true
		end
	else
		needsSave = true
	end
	if needsSave then
		NAFFlags.save()
	end
end

NAFFlags.load()
for _, entry in ipairs(NAFFlags.whitelist) do
	NAFFlags.values[entry.name] = NAFFlags.config.flags[entry.name]
end
for name, value in pairs(NAFFlags.config.custom or {}) do
	NAFFlags.values[name] = value
end
NAFFlags.normalizeRenderingPrefs()

NAFFlags.hasSupport = function()
	if type(setfflag) == "function" then
		return true
	end
	local ok, define = pcall(function()
		return game and game.DefineFastFlag
	end)
	return ok and type(define) == "function"
end

NAFFlags.enabled = function()
	return NAFFlags.config.useFFlags == true
end

NAFFlags.apply = function(flagName, flagValue, opts)
	opts = opts or {}
	local requireEnabled = opts.allowDisabled ~= true
	if requireEnabled and not NAFFlags.enabled() then
		if not opts.silent then
			DoNotif("FastFlags are disabled. Enable \"Use FastFlags\" first.", 3)
		end
		return false, "disabled"
	end
	if not NAFFlags.hasSupport() then
		if not opts.silent then
			DoNotif("setfflag / DefineFastFlag is unavailable on this executor.", 3)
		end
		return false, "unsupported"
	end
	local setter = type(setfflag) == "function" and setfflag or function(name, value)
		return game:DefineFastFlag(name, value)
	end
	local ok, err = pcall(setter, flagName, tostring(flagValue))
	if not ok then
		if not opts.silent then
			DoNotif(Format("Failed to set %s: %s", tostring(flagName), tostring(err)), 4)
		end
		-- disabled due to spam if the default ones fail
		--warn("[NA] FastFlag apply failed for "..tostring(flagName)..": "..tostring(err))
		return false, err
	end
	if not opts.silent then
		DoNotif(Format("%s set to %s", tostring(flagName), tostring(flagValue)), 2)
	end
	return true
end

NAFFlags.applyAll = function(opts)
	opts = opts or {}
	local shouldNotify = opts.notify ~= false
	NAFFlags.normalizeRenderingPrefs()
	if not NAFFlags.enabled() then
		if shouldNotify then
			DoNotif("FastFlags are disabled. Enable \"Use FastFlags\" first.", 3)
		end
		return 0, false
	end
	if not NAFFlags.hasSupport() then
		if shouldNotify then
			DoNotif("FastFlag functions not available on this executor.", 3)
		end
		return 0, false
	end
	local targets = {}
	local seen = {}
	for _, entry in ipairs(NAFFlags.whitelist) do
		targets[#targets + 1] = { name = entry.name, value = NAFFlags.values[entry.name] }
		seen[entry.name] = true
	end
	for customName, customValue in pairs(NAFFlags.config.custom or {}) do
		if not seen[customName] and customValue ~= nil then
			targets[#targets + 1] = { name = customName, value = customValue }
		end
	end
	local applied = 0
	for _, target in ipairs(targets) do
		if NAFFlags.apply(target.name, target.value, { silent = true }) then
			applied = applied + 1
		end
	end
	if shouldNotify then
		DoNotif(Format("Applied %d/%d fast flags", applied, #targets), 3)
	end
	return applied, true
end

NAFFlags.getSortedCustomNames = function()
	local names = {}
	for customName, customValue in pairs(NAFFlags.config.custom or {}) do
		if customValue ~= nil then
			Insert(names, customName)
		end
	end
	table.sort(names, function(a, b)
		return tostring(a):lower() < tostring(b):lower()
	end)
	return names
end

NAFFlags.updateSelectedDisplay = function()
	local selectedInfo = NAStuff and NAStuff.customFlagSelectedInfo
	if not selectedInfo then
		return
	end
	local names = (NAStuff and NAStuff.customFlagNames) or NAFFlags.getSortedCustomNames()
	local count = #names
	local idx = tonumber(NAStuff and NAStuff.customFlagIndex) or 0
	if count == 0 then
		selectedInfo.Text = "Selected Custom Flag: None"
		return
	end
	if idx < 1 or idx > count then
		idx = 1
		if NAStuff then
			NAStuff.customFlagIndex = idx
		end
	end
	local name = names[idx]
	selectedInfo.Text = Format("Selected Custom Flag: %s (%d/%d)", tostring(name), idx, count)
	selectedInfo.TextScaled = true
end

NAFFlags.refreshCustomListDisplay = function()
	local countInfo = NAStuff and NAStuff.customFlagCountInfo
	local names = NAFFlags.getSortedCustomNames()
	local count = #names
	if NAStuff then
		NAStuff.customFlagNames = names
		if count == 0 then
			NAStuff.customFlagIndex = nil
		else
			local idx = tonumber(NAStuff.customFlagIndex) or 1
			if idx > count then
				idx = 1
			end
			if idx < 1 then
				idx = 1
			end
			NAStuff.customFlagIndex = idx
		end
	end
	if countInfo then
		countInfo.Text = Format("Saved Custom Flags (%d)", count)
	end
	NAFFlags.updateSelectedDisplay()
end

NAFFlags.setCustomFlag = function(name, value)
	local trimmedName = (tostring(name or ""):match("^%s*(.-)%s*$")) or ""
	if trimmedName == "" then
		return false, "Missing flag name"
	end
	if value == nil then
		return false, "Missing flag value"
	end
	name = trimmedName
	if NAFFlags.isWhitelistedFlag and NAFFlags.isWhitelistedFlag(name) then
		return false, "Flag is already managed in the default list"
	end
	NAFFlags.config.custom = NAFFlags.config.custom or {}
	NAFFlags.config.custom[name] = value
	NAFFlags.values[name] = value
	NAFFlags.save()
	NAFFlags.refreshCustomListDisplay()
	return true
end

NAFFlags.removeCustomFlag = function(name)
	local trimmedName = (tostring(name or ""):match("^%s*(.-)%s*$")) or ""
	if trimmedName == "" then
		return false, "Missing flag name"
	end
	name = trimmedName
	if NAFFlags.config.custom then
		NAFFlags.config.custom[name] = nil
	end
	NAFFlags.values[name] = nil
	NAFFlags.save()
	NAFFlags.refreshCustomListDisplay()
	return true
end

NAFFlags.setCustomInputFields = function(name)
	NAStuff.customFFlagName = name or ""
	local value = NAFFlags.config.custom and NAFFlags.config.custom[name] or nil
	local valueText = value ~= nil and tostring(value) or ""
	NAStuff.customFFlagValue = valueText
	if NAgui and NAgui.setInputValue then
		NAgui.setInputValue("Custom Flag Name", NAStuff.customFFlagName, { force = true, fire = true })
		NAgui.setInputValue("Custom Flag Value", valueText, { force = true, fire = true })
	end
	NAFFlags.updateSelectedDisplay()
end

NAFFlags.cycleCustomFlag = function(direction)
	direction = direction or 1
	local names = NAFFlags.getSortedCustomNames()
	local count = #names
	if count == 0 then
		DoNotif("No custom fast flags saved yet.", 3)
		return
	end
	local idx = tonumber(NAStuff.customFlagIndex) or 1
	if direction < 0 then
		idx = idx - 1
	else
		idx = idx + 1
	end
	if idx < 1 then
		idx = count
	elseif idx > count then
		idx = 1
	end
	NAStuff.customFlagIndex = idx
	NAStuff.customFlagNames = names
	local name = names[idx]
	NAFFlags.setCustomInputFields(name)
	NAFFlags.updateSelectedDisplay()
	--DoNotif(Format("Viewing custom fast flag %d/%d: %s", idx, count, tostring(name)), 2)
end

NAFFlags.ensureMaintainLoop = function()
	if NAFFlags._maintainLoopRunning then
		return
	end
	if not (NAFFlags.config.autoApply and NAFFlags.enabled() and NAFFlags.hasSupport()) then
		return
	end
	NAFFlags._maintainLoopRunning = true
	if NAFFlags._maintainConn then
		NAFFlags._maintainConn:Disconnect()
		NAFFlags._maintainConn = nil
	end
	NAFFlags._maintainConn = RunService.Heartbeat:Connect(function()
		if not (NAFFlags.config.autoApply and NAFFlags.enabled() and NAFFlags.hasSupport()) then
			if NAFFlags._maintainConn then
				NAFFlags._maintainConn:Disconnect()
				NAFFlags._maintainConn = nil
			end
			NAFFlags._maintainLoopRunning = false
			return
		end
		NAFFlags.applyAll({ notify = false })
	end)
end

NAFFlags.autoApplyWithRetry = function(opts)
	opts = opts or {}
	local initialDelays = opts.delays or { 0, 0.5, 1.5 }
	local postLoadDelays = opts.postLoadDelays or { 0, 1 }

	local function runAttempts(delayList)
		for _, delay in ipairs(delayList) do
			if delay > 0 then
				Wait(delay)
			end
			if not (NAFFlags.config.autoApply and NAFFlags.enabled()) then
				return true
			end
			if NAFFlags.hasSupport() then
				local _, success = NAFFlags.applyAll({ notify = false })
				if success then
					return true
				end
			end
		end
		return false
	end

	SpawnCall(function()
		local success = runAttempts(initialDelays)
		if not success then
			local okLoaded, loaded = pcall(function()
				return game:IsLoaded()
			end)
			if not (okLoaded and loaded) then
				pcall(function()
					game.Loaded:Wait()
				end)
			end

			success = runAttempts(postLoadDelays) or success
		end

		if NAFFlags.config.autoApply and NAFFlags.enabled() then
			NAFFlags.ensureMaintainLoop()
		end
	end)
end

NAFFlags.buildSetfflagScript = function()
	NAFFlags.normalizeRenderingPrefs()
	local lines = { "if not setfflag then return warn(\"setfflag unavailable\") end" }
	local seen = {}
	for _, entry in ipairs(NAFFlags.whitelist) do
		local value = NAFFlags.values[entry.name]
		if value == nil then
			value = NAFFlags.getDefault(entry)
		end
		lines[#lines + 1] = Format("setfflag(%q, %q)", entry.name, tostring(value))
		seen[entry.name] = true
	end
	for customName, customValue in pairs(NAFFlags.config.custom or {}) do
		if not seen[customName] and customValue ~= nil then
			lines[#lines + 1] = Format("setfflag(%q, %q)", customName, tostring(customValue))
		end
	end
	return Concat(lines, "\n")
end

if NAFFlags.config.autoApply then
	NAFFlags.autoApplyWithRetry()
end

NAgui.addSection("Whitelisted FastFlags")

NAStuff.supportText = NAStuff.supportText or NAFFlags.hasSupport() and "Available" or "Unavailable (setfflag missing)"

NAgui.addInfo("FastFlag Support", NAStuff.supportText)
NAgui.addInfo("Session Warning", "FastFlags reset after you close Roblox")

NAgui.addToggle("Use FastFlags", NAFFlags.config.useFFlags == true, function(state)
	NAFFlags.config.useFFlags = state == true
	NAFFlags.save()
	if NAFFlags.config.autoApply and state == true then
		NAFFlags.autoApplyWithRetry()
	end
end)

NAgui.addToggle("Auto-apply FastFlags", NAFFlags.config.autoApply == true, function(state)
	NAFFlags.config.autoApply = state == true
	NAFFlags.save()
	if state then
		NAFFlags.autoApplyWithRetry()
	end
end)
NAmanage.RegisterToggleAutoSync("Auto-apply FastFlags", function()
	return NAFFlags.config.autoApply == true
end)

NAgui.addButton("Apply All FFlags (including custom)", function()
	NAFFlags.applyAll()
end)

NAgui.addButton("Copy standalone setfflag script", function()
	if not setclipboard then
		DoNotif("Your executor does not support setclipboard", 3)
		return
	end
	local scriptText = NAFFlags.buildSetfflagScript()
	local ok, err = pcall(setclipboard, scriptText)
	if not ok then
		DoNotif("Failed to copy setfflag script: "..tostring(err), 3)
		return
	end
	DoNotif("setfflag script copied to clipboard.", 2)
end)

NAgui.addSection("Custom FastFlags")
NAmanage.trimCustomFlagText=function(text)
	local str = tostring(text or "")
	return str:match("^%s*(.-)%s*$") or ""
end
NAStuff.customFFlagName = NAStuff.customFFlagName or ""
NAStuff.customFFlagValue = NAStuff.customFFlagValue or ""
NAgui.addInput("Custom Flag Name", "Enter fast flag name", NAStuff.customFFlagName, function(inputText)
	NAStuff.customFFlagName = inputText
end)
NAgui.addInput("Custom Flag Value", "Enter fast flag value", NAStuff.customFFlagValue, function(inputText)
	NAStuff.customFFlagValue = inputText
end)
NAStuff.customFlagCountInfo = NAStuff.customFlagCountInfo or NAgui.addInfo("Saved Custom Flags", "Saved Custom Flags (0)")
NAStuff.customFlagSelectedInfo = NAStuff.customFlagSelectedInfo or NAgui.addInfo("Selected Custom Flag", "Selected Custom Flag: None")
NAFFlags.refreshCustomListDisplay()

NAgui.addButton("Add / Update Custom Flag", function()
	local name = NAmanage.trimCustomFlagText(NAStuff.customFFlagName)
	local valueRaw = NAStuff.customFFlagValue
	if name == "" then
		DoNotif("Enter a fast flag name first.", 3)
		return
	end
	if valueRaw == nil or valueRaw == "" then
		DoNotif("Enter a fast flag value first.", 3)
		return
	end
	if NAFFlags.isWhitelistedFlag and NAFFlags.isWhitelistedFlag(name) then
		DoNotif("That flag already exists in the built-in list above.", 3)
		return
	end
	local parsedValue = NAFFlags.parseCustomValue and NAFFlags.parseCustomValue(valueRaw) or valueRaw
	local ok, err = NAFFlags.setCustomFlag(name, parsedValue)
	if ok then
		DoNotif(Format("Saved custom fast flag %s = %s", name, tostring(parsedValue)), 2)
	else
		DoNotif(tostring(err or "Failed to save custom fast flag"), 3)
	end
end)

NAgui.addButton("Test Custom Flag", function()
	local name = NAmanage.trimCustomFlagText(NAStuff.customFFlagName)
	local valueRaw = NAStuff.customFFlagValue
	if name == "" then
		DoNotif("Enter a fast flag name to test.", 3)
		return
	end
	if valueRaw == nil or valueRaw == "" then
		DoNotif("Enter a fast flag value to test.", 3)
		return
	end
	local parsedValue = NAFFlags.parseCustomValue and NAFFlags.parseCustomValue(valueRaw) or valueRaw
	local ok, err = NAFFlags.apply(name, parsedValue, { allowDisabled = true, silent = true })
	if ok then
		DoNotif(Format("Successfully set %s = %s", name, tostring(parsedValue)), 2)
	else
		DoNotif(Format("Failed to set %s: %s", name, tostring(err or "Unknown error")), 4)
	end
end)

NAgui.addButton("Remove Custom Flag", function()
	local name = NAmanage.trimCustomFlagText(NAStuff.customFFlagName)
	if name == "" then
		DoNotif("Enter the custom flag name you want to remove.", 3)
		return
	end
	if not (NAFFlags.config.custom and NAFFlags.config.custom[name]) then
		DoNotif("No saved custom flag with that name.", 3)
		return
	end
	local ok, err = NAFFlags.removeCustomFlag(name)
	if ok then
		DoNotif("Removed custom fast flag "..name, 2)
	else
		DoNotif(tostring(err or "Failed to remove custom fast flag"), 3)
	end
end)

NAgui.addButton("Previous Custom Flag", function()
	NAFFlags.cycleCustomFlag(-1)
end)

NAgui.addButton("Next Custom Flag", function()
	NAFFlags.cycleCustomFlag(1)
end)

NAgui.addSection("Individual Flags")

for _, entry in ipairs(NAFFlags.whitelist) do
	local entryName = entry.name
	local desc = NAFFlags.info and NAFFlags.info[entryName] or nil

	if entry.valueType == "boolean" then
		NAgui.addToggle(entryName, NAFFlags.values[entryName] == true, function(state)
			local normalized = NAFFlags.normalizeValue(entry, state)
			if normalized == nil then
				return
			end
			NAFFlags.values[entryName] = normalized
			NAFFlags.config.flags[entryName] = normalized
			local isRenderingPrefer = NAFFlags.isRenderingPreferFlag and NAFFlags.isRenderingPreferFlag(entryName)
			local isRenderingDisable = entryName == NAFFlags.renderingDisableFlag
			if NAFFlags.normalizeRenderingPrefs and (isRenderingPrefer or isRenderingDisable) then
				NAFFlags.normalizeRenderingPrefs(entryName)
			end
			NAFFlags.save()
			if isRenderingPrefer or isRenderingDisable then
				NAFFlags.applyAll({ notify = false })
			else
				NAFFlags.apply(entryName, normalized)
			end
		end)
	else
		local defaultText = NAFFlags.values[entryName]
		if defaultText == nil then
			defaultText = entry.default
		end
		if defaultText ~= nil then
			defaultText = tostring(defaultText)
		else
			defaultText = ""
		end

		local function applyEntryValue(rawValue)
			local normalized = NAFFlags.normalizeValue(entry, rawValue)
			if normalized == nil then
				return false
			end
			NAFFlags.values[entryName] = normalized
			NAFFlags.config.flags[entryName] = normalized
			NAFFlags.save()
			return true
		end

		NAgui.addInput(entryName, "Enter value", defaultText, function(inputValue)
			if applyEntryValue(inputValue) then
				NAFFlags.apply(entryName, NAFFlags.values[entryName])
			end
		end)
	end

	if desc then
		NAgui.addSection(entryName.." – "..desc)
	end
end

NAgui.addTab(TAB_INTEGRATIONS, { order = 2, textIcon = "chain-link" })
NAgui.setTab(TAB_INTEGRATIONS)

NAgui.addSection("Integrations")

NAgui.addButton("Load Cmd (lxte)", function()
	local ok, err = NAmanage.loadCmdIntegration()
	if not ok then
		local msg = "Cmd failed to load: "..tostring(err)
		if type(DoNotif) == "function" then
			DoNotif(msg, 4)
		else
			warn(msg)
		end
	end
end)

NAgui.addToggle("Auto-load Cmd (lxte)", NAStuff.CmdIntegrationAutoRun == true, function(v)
	NAStuff.CmdIntegrationAutoRun = v and true or false
	pcall(NAmanage.NASettingsSet, "cmdIntegrationAutoRun", NAStuff.CmdIntegrationAutoRun)
	if v then
		local ok, err = NAmanage.loadCmdIntegration()
		if not ok then
			local msg = "Cmd failed to load: "..tostring(err)
			if type(DoNotif) == "function" then
				DoNotif(msg, 4)
			else
				warn(msg)
			end
		end
	end
end)
NAmanage.RegisterToggleAutoSync("Auto-load Cmd (lxte)", function()
	return NAStuff.CmdIntegrationAutoRun == true
end)

NAgui.addToggle("Bloxtrap RPC Presence", NAmanage.btEnabled(), function(v)
	NAmanage.btSetEnabled(v)
	if v then
		NAmanage.btGetExecutorInfo(true)
		NAmanage.btUpdate()
	end
end)
NAmanage.RegisterToggleAutoSync("Bloxtrap RPC Presence", function()
	return NAmanage.btEnabled()
end)

NAgui.addSection("Discord Webhook")
NAStuff.Integrations = NAStuff.Integrations or {}
local webhookCfg = NAStuff.Integrations.webhook or {}
NAStuff.Integrations.webhook = webhookCfg
webhookCfg.urls = webhookCfg.urls or {}
webhookCfg.urls.main = webhookCfg.urls.main or webhookCfg.url or webhookCfg.urls.all or ""
webhookCfg.urls.all = webhookCfg.urls.all or webhookCfg.url or ""
webhookCfg.urls.joinleave = webhookCfg.urls.joinleave or ""
webhookCfg.urls.chat = webhookCfg.urls.chat or ""
webhookCfg.urls.commands = webhookCfg.urls.commands or ""
webhookCfg.mainMessage = webhookCfg.mainMessage or ""

NAgui.addInput("All Events Webhook", "https://discord.com/api/webhooks/...", webhookCfg.urls.all, function(text)
	webhookCfg.urls.all = text or ""
	webhookCfg.url = webhookCfg.urls.all
	if NAmanage.NASettingsSet then
		NAmanage.NASettingsSet("integrationWebhookUrlAll", webhookCfg.urls.all)
		NAmanage.NASettingsSet("integrationWebhookUrl", webhookCfg.urls.all)
	end
end)
NAgui.addInput("Join/Leave Webhook", "https://discord.com/api/webhooks/...", webhookCfg.urls.joinleave, function(text)
	webhookCfg.urls.joinleave = text or ""
	if NAmanage.NASettingsSet then
		NAmanage.NASettingsSet("integrationWebhookUrlJoinLeave", webhookCfg.urls.joinleave)
	end
end)
NAgui.addInput("Chat Webhook", "https://discord.com/api/webhooks/...", webhookCfg.urls.chat, function(text)
	webhookCfg.urls.chat = text or ""
	if NAmanage.NASettingsSet then
		NAmanage.NASettingsSet("integrationWebhookUrlChat", webhookCfg.urls.chat)
	end
end)
NAgui.addInput("Command Webhook", "https://discord.com/api/webhooks/...", webhookCfg.urls.commands, function(text)
	webhookCfg.urls.commands = text or ""
	if NAmanage.NASettingsSet then
		NAmanage.NASettingsSet("integrationWebhookUrlCommands", webhookCfg.urls.commands)
	end
end)
NAgui.addToggle("Send To All Webhooks", webhookCfg.useAll == true, function(v)
	webhookCfg.useAll = v and true or false
	if NAmanage.NASettingsSet then
		NAmanage.NASettingsSet("integrationWebhookUseAll", webhookCfg.useAll)
	end
end)
NAgui.addSlider("Min Interval (sec)", 0, 30, NAmanage.clampNumber(webhookCfg.minInterval, 0, 30, 2), 1, " s", function(v)
	webhookCfg.minInterval = NAmanage.clampNumber(v, 0, 30, 2)
	if NAmanage.NASettingsSet then
		NAmanage.NASettingsSet("integrationWebhookInterval", webhookCfg.minInterval)
	end
end)
NAgui.addToggle("Send Join/Leave", webhookCfg.enableJoinLeave, function(v)
	webhookCfg.enableJoinLeave = v and true or false
	if NAmanage.NASettingsSet then
		NAmanage.NASettingsSet("integrationWebhookJoinLeave", webhookCfg.enableJoinLeave)
	end
end)
NAgui.addToggle("Send Chat Messages", webhookCfg.enableChat, function(v)
	webhookCfg.enableChat = v and true or false
	if NAmanage.NASettingsSet then
		NAmanage.NASettingsSet("integrationWebhookChat", webhookCfg.enableChat)
	end
end)
NAgui.addToggle("Send Command Logs", webhookCfg.enableCommands, function(v)
	webhookCfg.enableCommands = v and true or false
	if NAmanage.NASettingsSet then
		NAmanage.NASettingsSet("integrationWebhookCommands", webhookCfg.enableCommands)
	end
end)
NAgui.addButton("Test Webhook Ping", function()
	local ok, err = NAmanage.SendIntegrationWebhook("test", Format("[Test] %s ping", adminName or "NA"))
	if ok then
		DoNotif("Webhook ping sent.", 2)
	else
		DoNotif("Webhook failed: "..tostring(err), 3)
	end
end)

NAgui.addSection("Main Webhook Sender")
NAgui.addInput("Main Webhook", "https://discord.com/api/webhooks/...", webhookCfg.urls.main, function(text)
	webhookCfg.urls.main = text or ""
	if NAmanage.NASettingsSet then
		NAmanage.NASettingsSet("integrationWebhookUrlMain", webhookCfg.urls.main)
	end
end)
NAgui.addInput("Message", "Enter message to send", webhookCfg.mainMessage, function(text)
	webhookCfg.mainMessage = text or ""
end)
NAgui.addButton("Send Main Webhook Message", function()
	local msg = webhookCfg.mainMessage or ""
	if msg == "" then
		DoNotif("Please enter a message to send.", 3)
		return
	end
	local ok, err = NAmanage.SendIntegrationWebhook("main", msg)
	if ok then
		DoNotif("Main webhook message sent.", 2)
	else
		DoNotif("Main webhook failed: "..tostring(err), 3)
	end
end)

NAgui.addSection("API Health Checks")
local function setHealthEndpoint(i, val)
	NAStuff.Integrations.health.endpoints[i] = val or ""
	if NAmanage.NASettingsSet then
		NAmanage.NASettingsSet("integrationHealthEndpoints", NAStuff.Integrations.health.endpoints)
	end
end
local healthDefaults = NAStuff.Integrations.health.endpoints
for i = 1, 3 do
	NAgui.addInput("Endpoint #"..i, "https://example.com/health", healthDefaults[i] or "", function(text)
		setHealthEndpoint(i, text)
	end)
end
NAgui.addButton("Ping Endpoints", function()
	local results = NAmanage.HealthPingAll()
	if #results == 0 then
		DoNotif("No endpoints configured.", 3)
	else
		DoNotif(Concat(results, " | "), 4)
	end
end)

NAgui.addSection("Notes / Clipboard")
NAgui.addInput("Note Text", "Optional note to save/copy", NAStuff.Integrations.notes.last, function(text)
	NAStuff.Integrations.notes.last = text or ""
	if NAmanage.NASettingsSet then
		NAmanage.NASettingsSet("integrationNotesLast", NAStuff.Integrations.notes.last)
	end
end)
NAgui.addButton("Copy Server Info + Note", function()
	local note = NAStuff.Integrations.notes.last or ""
	local payload = NAmanage.ComposeServerNote(note)
	if setclipboard then
		setclipboard(payload)
		DoNotif("Server info copied to clipboard.", 2)
	else
		DoNotif(payload, 3)
	end
end)

NAgui.addSection("Bloxstrap RPC Settings")
NAgui.addToggle("Custom RPC Text", NAStuff.Integrations.rpc.useCustom, function(v)
	NAStuff.Integrations.rpc.useCustom = v and true or false
	if NAmanage.NASettingsSet then
		NAmanage.NASettingsSet("integrationRpcUseCustom", NAStuff.Integrations.rpc.useCustom)
	end
	if NAmanage.btEnabled() then
		NAmanage.btUpdate()
	end
end)
NAgui.addInput("RPC Details Text", "Supports {cmds} {game}", NAStuff.Integrations.rpc.details, function(text)
	NAStuff.Integrations.rpc.details = text or ""
	if NAmanage.NASettingsSet then
		NAmanage.NASettingsSet("integrationRpcDetails", NAStuff.Integrations.rpc.details)
	end
	if NAmanage.btEnabled() and NAStuff.Integrations.rpc.useCustom then
		NAmanage.btUpdate()
	end
end)
NAgui.addInput("RPC State Text", "Supports {cmds} {game}", NAStuff.Integrations.rpc.state, function(text)
	NAStuff.Integrations.rpc.state = text or ""
	if NAmanage.NASettingsSet then
		NAmanage.NASettingsSet("integrationRpcState", NAStuff.Integrations.rpc.state)
	end
	if NAmanage.btEnabled() and NAStuff.Integrations.rpc.useCustom then
		NAmanage.btUpdate()
	end
end)
NAgui.addButton("Refresh RPC Presence", function()
	NAmanage.btUpdate()
	DoNotif("Bloxstrap RPC refreshed.", 2)
end)

NAgui.addTab(TAB_INTERFACE, { order = 3, textIcon = "two-makeup-brushes" })
NAgui.setTab(TAB_INTERFACE)

NAgui.clamp01 = NAgui.clamp01 or function(v, fallback)
	local n = tonumber(v)
	if n == nil then
		return fallback or 0
	end
	if n < 0 then n = 0 elseif n > 1 then n = 1 end
	return n
end

NAStuff.IconDefaultTrans = NAStuff.IconDefaultTrans or {
	background = NAStuff.iconAppearance and NAStuff.iconAppearance.background or 0,
	image = NAStuff.iconAppearance and NAStuff.iconAppearance.image or 0,
	text = NAStuff.iconAppearance and NAStuff.iconAppearance.text or 0,
	stroke = NAStuff.iconAppearance and NAStuff.iconAppearance.stroke or 0.7,
}

NAmanage.applyIconAppearance = function()
	if not TextButton then return end
	local clamp01 = NAgui.clamp01
	local label = IconFallbackText
	local bg = clamp01(NAStuff.iconAppearance and NAStuff.iconAppearance.background or 0, 0)
	if NAStuff.iconAppearance then NAStuff.iconAppearance.background = bg end
	TextButton.BackgroundTransparency = bg
	if TextButton:IsA("ImageButton") then
		local imgT = clamp01(NAStuff.iconAppearance and NAStuff.iconAppearance.image or 0, 0)
		if NAStuff.iconAppearance then NAStuff.iconAppearance.image = imgT end
		TextButton.ImageTransparency = imgT
	else
		local txtT = clamp01(NAStuff.iconAppearance and NAStuff.iconAppearance.text or 0, 0)
		if NAStuff.iconAppearance then NAStuff.iconAppearance.text = txtT end
		TextButton.TextTransparency = txtT
		local strokeT = clamp01(NAStuff.iconAppearance and NAStuff.iconAppearance.stroke or 0.7, 0.7)
		if NAStuff.iconAppearance then NAStuff.iconAppearance.stroke = strokeT end
		TextButton.TextStrokeTransparency = strokeT
	end
	if label then
		if NAStuff.iconAppearance and NAStuff.iconAppearance.text ~= nil then
			label.TextTransparency = clamp01(NAStuff.iconAppearance.text, 0)
		end
		if NAStuff.iconAppearance and NAStuff.iconAppearance.stroke ~= nil then
			label.TextStrokeTransparency = clamp01(NAStuff.iconAppearance.stroke, 0.7)
		end
	end
end

NAmanage.applyTopbarStyle = function()
	local clamp01 = NAgui.clamp01
	local glass = TopBarApp and TopBarApp.tGlass
	if glass then
		glass.BackgroundTransparency = clamp01(NAStuff.TopbarGlassTransparency or 0.12, 0.12)
	end
	local stroke = TopBarApp and TopBarApp.tStroke
	if stroke then
		stroke.Transparency = clamp01(NAStuff.TopbarStrokeTransparency or 0.15, 0.15)
	end
	if TopBarApp and TopBarApp.isOpen ~= nil and NAmanage.Topbar_UpdateToggleVisual then
		NAmanage.Topbar_UpdateToggleVisual(TopBarApp.isOpen)
	end
end

NAmanage.applySideSwipeStyle = function(opts)
	local clamp01 = NAgui.clamp01
	if NAmanage.SideSwipe_Init then
		NAmanage.SideSwipe_Init()
	end
	if SideSwipeApp then
		if SideSwipeApp.underlay then
			SideSwipeApp.underlay.BackgroundTransparency = 0.35
		end
		if SideSwipeApp.handles then
			local ht = clamp01(NAStuff.SideSwipeHandleTransparency or 0.72, 0.72)
			if SideSwipeApp.handles.left then
				SideSwipeApp.handles.left.BackgroundTransparency = ht
			end
			if SideSwipeApp.handles.right then
				SideSwipeApp.handles.right.BackgroundTransparency = ht
			end
		end
		local scroll = SideSwipeApp.scroll
		if scroll then
			scroll.ScrollBarThickness = 4
		end
		if SideSwipeApp.scroll then
			for _, btn in ipairs(SideSwipeApp.scroll:GetChildren()) do
				if btn:IsA("TextButton") then
					local bg = btn:FindFirstChildOfClass("Frame")
					if bg then
						bg.BackgroundTransparency = 0.16
					end
				end
			end
		end
		local layout = SideSwipeApp.layout
		if layout and layout.Parent then
			local pad = layout.Parent:FindFirstChildOfClass("UIPadding")
			if pad then
				-- force a layout refresh by toggling padding
				local old = pad.PaddingTop
				pad.PaddingTop = old + UDim.new(0, 0)
				pad.PaddingTop = old
			end
		end
		if SideSwipeApp.scroll and SideSwipeApp.scroll:FindFirstChildWhichIsA("UIListLayout", true) then
			local list = SideSwipeApp.scroll:FindFirstChildWhichIsA("UIListLayout", true)
			if list then
				-- triggers AbsoluteContentSize recompute
				list.Padding = list.Padding
			end
		end
		if opts and opts.rebuild and NAmanage.SideSwipe_Rebuild then
			NAmanage.SideSwipe_Rebuild()
		end
		if NAmanage.SideSwipe_UpdateCanvas then
			NAmanage.SideSwipe_UpdateCanvas()
		end
		if NAmanage.SideSwipe_PositionHandles then
			NAmanage.SideSwipe_PositionHandles()
		end
	end
end

NAmanage.applyIconAppearance()
NAmanage.applyTopbarStyle()
NAmanage.applySideSwipeStyle({ rebuild = false })

NAgui.addSection("UI Customization")

NAgui.addSlider("NA Icon Size", 0.5, 3, NAScale, 0.01, "", function(val)
	NAScale = val
	TextButton.Size = UDim2.new(0, 32 * val, 0, 33 * val)
	NAmanage.NASettingsSet("buttonSize", val)
end)

local mainColorDefault = (NAStuff and NAStuff.AprilFoolsData and NAStuff.AprilFoolsData.originalColor) or NAUISTROKER

NAgui.addColorPicker("Main Color", mainColorDefault, function(color, meta)
	if typeof(color) == "Color3" then
		NAUISTROKER = color
		for _, element in ipairs(NACOLOREDELEMENTS) do
			if typeof(element) == "Instance" and element:IsA("UIStroke") then
				element.Color = color
			end
		end
		if TabManager and TabManager.tabs then
			for name, info in pairs(TabManager.tabs) do
				local btn = info and info.button
				if btn then
					local stroke = btn:FindFirstChildWhichIsA("UIStroke", true)
					if stroke then
						local computeColor = NAmanage.getTabStrokeColor
						if typeof(computeColor) == "function" then
							stroke.Color = computeColor(TabManager.current == name)
						else
							stroke.Color = color
						end
					end
					if originalIO.applyTabDisplayText then
						originalIO.applyTabDisplayText(info, {
							isActive = info._isActive,
							defaultColor = color,
						})
					end
				end
			end
		end
		NAmanage.SideSwipe_UpdateHandleColors(color)
	end
	if not (meta and meta.context == "init") then
		SaveUIStroke(color)
	end
end, {
	fireOnInit = true,
})

NAgui.addSection("Icon Appearance")

NAgui.addSlider("Icon Background Transparency", 0, 1, NAgui.clamp01(NAStuff.iconAppearance and NAStuff.iconAppearance.background or 0, 0), 0.05, "", function(val)
	local v = NAgui.clamp01(val, 0)
	NAStuff.iconAppearance.background = v
	NAmanage.applyIconAppearance()
	NAmanage.NASettingsSet("iconBgTransparency", v)
end)

if TextButton and TextButton:IsA("ImageButton") then
	NAgui.addSlider("Icon Image Transparency", 0, 1, NAgui.clamp01(NAStuff.iconAppearance and NAStuff.iconAppearance.image or 0, 0), 0.05, "", function(val)
		local v = NAgui.clamp01(val, 0)
		NAStuff.iconAppearance.image = v
		NAmanage.applyIconAppearance()
		NAmanage.NASettingsSet("iconImageTransparency", v)
	end)
end

NAgui.addSlider("Icon Text Transparency", 0, 1, NAgui.clamp01(NAStuff.iconAppearance and NAStuff.iconAppearance.text or 0, 0), 0.05, "", function(val)
	local v = NAgui.clamp01(val, 0)
	NAStuff.iconAppearance.text = v
	NAmanage.applyIconAppearance()
	NAmanage.NASettingsSet("iconTextTransparency", v)
end)

NAgui.addSlider("Icon Stroke Transparency", 0, 1, NAgui.clamp01(NAStuff.iconAppearance and NAStuff.iconAppearance.stroke or 0.7, 0.7), 0.05, "", function(val)
	local v = NAgui.clamp01(val, 0.7)
	NAStuff.iconAppearance.stroke = v
	NAmanage.applyIconAppearance()
	NAmanage.NASettingsSet("iconStrokeTransparency", v)
end)

NAgui.addButton("Reset Icon Transparency", function()
	NAStuff.iconAppearance.background = NAStuff.IconDefaultTrans.background
	NAStuff.iconAppearance.image = NAStuff.IconDefaultTrans.image
	NAStuff.iconAppearance.text = NAStuff.IconDefaultTrans.text
	NAStuff.iconAppearance.stroke = NAStuff.IconDefaultTrans.stroke
	NAmanage.applyIconAppearance()
	if NAgui.setSliderValue then
		NAgui.setSliderValue("Icon Background Transparency", NAStuff.IconDefaultTrans.background or 0, { force = true, fire = false })
		NAgui.setSliderValue("Icon Text Transparency", NAStuff.IconDefaultTrans.text or 0, { force = true, fire = false })
		NAgui.setSliderValue("Icon Stroke Transparency", NAStuff.IconDefaultTrans.stroke or 0.7, { force = true, fire = false })
		if TextButton and TextButton:IsA("ImageButton") then
			NAgui.setSliderValue("Icon Image Transparency", NAStuff.IconDefaultTrans.image or 0, { force = true, fire = false })
		end
	end
	NAmanage.NASettingsSet("iconBgTransparency", NAStuff.IconDefaultTrans.background or 0)
	NAmanage.NASettingsSet("iconImageTransparency", NAStuff.IconDefaultTrans.image or 0)
	NAmanage.NASettingsSet("iconTextTransparency", NAStuff.IconDefaultTrans.text or 0)
	NAmanage.NASettingsSet("iconStrokeTransparency", NAStuff.IconDefaultTrans.stroke or 0.7)
end)

NAgui.addSection("Topbar")

NAgui.addToggle("Dropdown Under Toggle", TopBarApp.mode == "bottom", function(state)
	NAmanage.Topbar_SetMode(state and "bottom" or "side")
end)

NATopbarDock = NAmanage.topbar_readDock()
NAgui.addToggle("Topbar on Bottom", NATopbarDock == "bottom", function(state)
	NAmanage.Topbar_SetDock(state and "bottom" or "top")
end)
NAmanage.RegisterToggleAutoSync("Topbar on Bottom", function()
	return NATopbarDock == "bottom"
end)

NAgui.addToggle("TopBar Visibility", NATOPBARVISIBLE, function(v)
	NATOPBARVISIBLE = v and true or false
	if TopBarApp and TopBarApp.top then
		TopBarApp.top.Enabled = NATOPBARVISIBLE
	end
	NAmanage.NASettingsSet("topbarVisible", NATOPBARVISIBLE)
end)
NAmanage.RegisterToggleAutoSync("TopBar Visibility", function()
	return NATOPBARVISIBLE == true
end)

NAgui.addToggle("Keep Topbar Position", NATopbarKeepPosition, function(v)
	NATopbarKeepPosition = v and true or false
	NAmanage.NASettingsSet("topbarKeepPosition", NATopbarKeepPosition)
	if NATopbarKeepPosition then
		NAmanage.Topbar_SavePositionPreference({ force = true })
		DoNotif("Topbar position will be saved on exit", 2)
	else
		NAmanage.Topbar_ResetPositionPreference()
		DoNotif("Topbar position reset to center", 2)
	end
	NAmanage.Topbar_ClampToggle()
end)
NAmanage.RegisterToggleAutoSync("Keep Topbar Position", function()
	return NATopbarKeepPosition == true
end)

NAgui.addSlider("Topbar Glass Transparency", 0, 1, NAgui.clamp01(NAStuff.TopbarGlassTransparency or 0.12, 0.12), 0.05, "", function(v)
	NAStuff.TopbarGlassTransparency = NAgui.clamp01(v, 0.12)
	NAmanage.applyTopbarStyle()
	NAmanage.NASettingsSet("topbarGlassTransparency", NAStuff.TopbarGlassTransparency)
end)

NAgui.addSlider("Topbar Stroke Transparency", 0, 1, NAgui.clamp01(NAStuff.TopbarStrokeTransparency or 0.15, 0.15), 0.05, "", function(v)
	NAStuff.TopbarStrokeTransparency = NAgui.clamp01(v, 0.15)
	NAmanage.applyTopbarStyle()
	NAmanage.NASettingsSet("topbarStrokeTransparency", NAStuff.TopbarStrokeTransparency)
end)

NAgui.addSection("Side Swipe")

NAgui.addToggle("Side Swipe On Left", NASideSwipeSide ~= "right", function(v)
	NAmanage.SideSwipe_SetSide(v and "left" or "right")
end)
NAmanage.RegisterToggleAutoSync("Side Swipe On Left", function()
	return NASideSwipeSide ~= "right"
end)

NAgui.addToggle("Side Swipe Enabled", NASideSwipeEnabled, function(v)
	NASideSwipeEnabled = v and true or false
	if SideSwipeApp and SideSwipeApp.gui then
		SideSwipeApp.gui.Enabled = NASideSwipeEnabled
	end
	NAmanage.NASettingsSet("sideSwipeEnabled", NASideSwipeEnabled)
end)
NAmanage.RegisterToggleAutoSync("Side Swipe Enabled", function()
	return NASideSwipeEnabled == true
end)

NAgui.addSection("Side Swipe Styling")

NAgui.addSlider("Side Swipe Width", 60, 200, math.clamp(tonumber(NAStuff.SideSwipeWidth) or 80, 60, 200), 1, " px", function(v)
	NAStuff.SideSwipeWidth = math.clamp(math.floor(tonumber(v) or 80 + 0.5), 60, 200)
	NAmanage.NASettingsSet("sideSwipeWidth", NAStuff.SideSwipeWidth)
	NAmanage.applySideSwipeStyle({ rebuild = true })
end)

NAgui.addSlider("Side Swipe Handle Transparency", 0, 1, NAgui.clamp01(NAStuff.SideSwipeHandleTransparency or 0.72, 0.72), 0.05, "", function(v)
	NAStuff.SideSwipeHandleTransparency = NAgui.clamp01(v, 0.72)
	NAmanage.NASettingsSet("sideSwipeHandleTransparency", NAStuff.SideSwipeHandleTransparency)
	NAmanage.applySideSwipeStyle({ rebuild = false })
end)

if CoreGui then
	local PT = {
		path      = NAfiles.NAFILEPATH.."/plexity_theme.json",
		default   = { enabled = false, start = { h = 0.8, s = 1, v = 1 }, finish = { h = 0, s = 1, v = 1 } },
		cg        = CoreGui,
		images    = {},
		queue     = {},
		queueSet  = {},
		processing = false,
		applying   = false,
	}

	local data = PT.default
	if FileSupport then
		if not isfile(PT.path) then
			writefile(PT.path, HttpService:JSONEncode(PT.default))
		end

		local okRead, raw = pcall(readfile, PT.path)
		if okRead and type(raw) == "string" then
			local okDecode, decoded = pcall(HttpService.JSONDecode, HttpService, raw)
			if okDecode and type(decoded) == "table" then
				data = decoded
			end
		end
	end

	PT.data = data

	local HUI = (typeof(gethui) == "function" and gethui()) or nil

	local function isPlexTarget(o)
		if HUI and o:IsDescendantOf(HUI) then
			return false
		end
		return o:IsA("ImageLabel")
			or o:IsA("ImageButton")
			or o:IsA("TextLabel")
			or o:IsA("TextButton")
	end

	local function getImageId(o)
		local value = NAlib.isProperty(o, "Image")
		if type(value) == "string" and value ~= "" then
			return value
		end
		value = NAlib.isProperty(o, "Texture")
		if type(value) == "string" and value ~= "" then
			return value
		end
		value = NAlib.isProperty(o, "TextureId")
		if type(value) == "string" and value ~= "" then
			return value
		end
		return nil
	end

	local function applyIfReady(o)
		if not (o and o.Parent) then
			return false
		end

		if HUI and o:IsDescendantOf(HUI) then
			return false
		end

		if PT.images[o] then
			NAmanage.plex_apply(o)
			return true
		end

		if not isPlexTarget(o) then
			return false
		end

		local imgId = getImageId(o)
		if type(imgId) == "string" and imgId:match("img_set_%dx_%d+%.png$") then
			PT.images[o] = true
			NAmanage.plex_apply(o)
			return true
		end

		if o:IsA("TextLabel") or o:IsA("TextButton") then
			local ff = NAlib.isProperty(o, "FontFace")
			local ffType = ff and typeof(ff) or nil
			local fam = ff and ff.Family or nil

			if (ffType == "Font" or ffType == "FontFace")
				and type(fam) == "string"
				and fam:find("BuilderIcons/BuilderIcons.json", 1, true)
			then
				PT.images[o] = true
				NAmanage.plex_apply(o)
				return true
			end
		end

		return false
	end

	NAmanage.plex_remove = function(o)
		local g = o and o:FindFirstChildOfClass("UIGradient")
		if g then g:Destroy() end
	end

	NAmanage.plex_apply = function(o)
		if not (o and o.Parent) then
			return
		end
		if HUI and o:IsDescendantOf(HUI) then
			return
		end
		NAmanage.plex_remove(o)
		if PT.data.enabled then
			local seq = ColorSequence.new{
				ColorSequenceKeypoint.new(0, Color3.fromHSV(PT.data.start.h, PT.data.start.s, PT.data.start.v)),
				ColorSequenceKeypoint.new(1, Color3.fromHSV(PT.data.finish.h, PT.data.finish.s, PT.data.finish.v)),
			}
			local ug = InstanceNew("UIGradient", o)
			ug.Color, ug.Rotation = seq, 45
			ug.Transparency = NumberSequence.new{
				NumberSequenceKeypoint.new(0,   0, 0),
				NumberSequenceKeypoint.new(0.5, 0, 0),
				NumberSequenceKeypoint.new(1,   0, 0),
			}
		end
	end

	local function enqueue(o)
		if not o then
			return
		end
		if PT.queueSet[o] then
			return
		end
		if HUI and o:IsDescendantOf(HUI) then
			return
		end
		PT.queueSet[o] = true
		Insert(PT.queue, o)
	end

	local function processQueue()
		if PT.processing then
			return
		end
		PT.processing = true
		coroutine.wrap(function()
			while #PT.queue > 0 do
				local stepCount = math.min(#PT.queue, 50)
				for i = 1, stepCount do
					local o = table.remove(PT.queue, 1)
					if o then
						PT.queueSet[o] = nil
						if o.Parent then
							applyIfReady(o)
						end
					end
				end
				Wait()
			end
			PT.processing = false
		end)()
	end

	NAmanage.plex_add = function(o)
		enqueue(o)
		processQueue()
	end

	NAmanage.plex_applyAll = function()
		if PT.applying then
			return
		end
		PT.applying = true
		coroutine.wrap(function()
			local n = 0
			for o in pairs(PT.images) do
				if o and o.Parent then
					NAmanage.plex_apply(o)
				else
					PT.images[o] = nil
				end
				n += 1
				if n % 50 == 0 then
					Wait()
				end
			end
			PT.applying = false
		end)()
	end

	local function rescanAll()
		coroutine.wrap(function()
			local cg = PT.cg
			if cg then
				local desc = cg:GetDescendants()
				for i = 1, #desc do
					enqueue(desc[i])
					if i % 200 == 0 then
						Wait()
					end
				end
				processQueue()
			end
		end)()
	end

	rescanAll()

	local function onDescendantAdded(o)
		coroutine.wrap(function()
			enqueue(o)
			processQueue()
		end)()
	end

	NAlib.disconnect("PlexyDesc")
	NAlib.connect("PlexyDesc", PT.cg.DescendantAdded:Connect(onDescendantAdded))

	NAgui.addSection("Plexity Theme")
	NAgui.addToggle("Enable Theme", PT.data.enabled, function(v)
		PT.data.enabled = v
		if v then
			NAmanage.plex_applyAll()
		else
			for o in pairs(PT.images) do
				NAmanage.plex_remove(o)
			end
		end
		if FileSupport then
			writefile(PT.path, HttpService:JSONEncode(PT.data))
		end
	end)

	NAgui.addColorPicker("Gradient Start Color", Color3.fromHSV(PT.data.start.h, PT.data.start.s, PT.data.start.v), function(c)
		local h, s, v = c:ToHSV()
		PT.data.start.h, PT.data.start.s, PT.data.start.v = h, s, v
		NAmanage.plex_applyAll()
		if FileSupport then
			writefile(PT.path, HttpService:JSONEncode(PT.data))
		end
	end)

	NAgui.addColorPicker("Gradient End Color", Color3.fromHSV(PT.data.finish.h, PT.data.finish.s, PT.data.finish.v), function(c)
		local h, s, v = c:ToHSV()
		PT.data.finish.h, PT.data.finish.s, PT.data.finish.v = h, s, v
		NAmanage.plex_applyAll()
		if FileSupport then
			writefile(PT.path, HttpService:JSONEncode(PT.data))
		end
	end)

	NAmanage.initCornerEditor(CoreGui, HUI)

	if previousTab and previousTab ~= TAB_INTERFACE then
		if NAgui.getActiveTab() == TAB_INTERFACE then
			NAgui.setTab(previousTab)
		end
	end
end

NAgui.addTab(TAB_USER_BUTTONS, { order = 10, textIcon = "circle-plus" })
NAgui.setTab(TAB_USER_BUTTONS)

originalIO.UserBtnEditor=function()
	local editorState = {
		editAll = false,
		currentIndex = 1,
		currentId = nil,
		width = 60,
		height = 60,
		corner = 0.25,
		bgColor = Color3.fromRGB(0, 0, 0),
		textColor = Color3.fromRGB(255, 255, 255),
		lbl = "",
		hidden = false,
		locked = false,
		interactable = true,
		childIdx = 1,
		childLbl = "",
		childBg = Color3.fromRGB(0,0,0),
		childTc = Color3.fromRGB(255,255,255),
	}

	NAgui.addSection("User Buttons Loader")

	NAgui.addButton("Load User Buttons", function()
		if type(NAmanage.loadButtonIDS) == "function" then
			NAmanage.loadButtonIDS()
		end
		if type(NAmanage.RenderUserButtons) == "function" then
			NAmanage.RenderUserButtons()
		end
		DoNotif("User buttons loaded", 2)
	end)

	local function collectAllIds()
		local ids = {}
		for id, data in pairs(NAUserButtons) do
			if type(id) == "number" and type(data) == "table" then
				Insert(ids, id)
			end
		end
		table.sort(ids)
		return ids
	end

	local function getTargetIds()
		if editorState.editAll then
			return collectAllIds()
		end
		if type(editorState.currentId) == "number" then
			return { editorState.currentId }
		end
		return {}
	end

	local function applyToTargets(mutator, description)
		if not next(NAUserButtons) then
			return
		end

		local targets = getTargetIds()
		if #targets == 0 then
			return
		end

		local applied = 0
		for _, id in ipairs(targets) do
			local data = NAUserButtons[id]
			if type(data) == "table" then
				mutator(data, id)
				applied = applied + 1
			end
		end

		if applied == 0 then
			return
		end

		NAmanage.UserButtonsSave("editor apply")
		if type(NAmanage.RenderUserButtons) == "function" then
			NAmanage.RenderUserButtons()
		end

		if description then
			local suffix = (applied == 1) and " button" or " buttons"
			--DoNotif(description.." applied to "..tostring(applied)..suffix, 2)
		end
	end

	local function lblPr(def, cb)
		local sg = NAmanage.waitForScreenGui and NAmanage.waitForScreenGui(5)
		if not sg then
			return
		end

		local gui = InstanceNew("ScreenGui")
		gui.IgnoreGuiInset = true
		gui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
		gui.Parent = sg

		local f = InstanceNew("Frame")
		f.Size = UDim2.new(0, 280, 0, 150)
		f.Position = UDim2.new(0.5, -140, 0.5, -75)
		f.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
		f.BorderSizePixel = 0
		f.Parent = gui

		local u = InstanceNew("UICorner")
		u.CornerRadius = UDim.new(0.1, 0)
		u.Parent = f

		local t = InstanceNew("TextLabel")
		t.Size = UDim2.new(1, -20, 0, 30)
		t.Position = UDim2.new(0, 10, 0, 10)
		t.BackgroundTransparency = 1
		t.Text = "Rename UserButton Label"
		t.TextColor3 = Color3.fromRGB(255, 255, 255)
		t.Font = Enum.Font.GothamBold
		t.TextSize = 16
		t.TextWrapped = true
		t.Parent = f

		local tb = InstanceNew("TextBox")
		tb.Size = UDim2.new(1, -20, 0, 32)
		tb.Position = UDim2.new(0, 10, 0, 55)
		tb.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
		tb.TextColor3 = Color3.fromRGB(255, 255, 255)
		tb.PlaceholderText = "Type new label"
		tb.Text = type(def) == "string" and def or ""
		tb.TextSize = 16
		tb.Font = Enum.Font.Gotham
		tb.ClearTextOnFocus = false
		tb.Parent = f

		local s = InstanceNew("TextButton")
		s.Size = UDim2.new(0.5, -15, 0, 30)
		s.Position = UDim2.new(0, 10, 1, -40)
		s.BackgroundColor3 = Color3.fromRGB(0, 170, 255)
		s.Text = "Save"
		s.TextColor3 = Color3.fromRGB(255, 255, 255)
		s.Font = Enum.Font.GothamBold
		s.TextSize = 14
		s.Parent = f

		local c = InstanceNew("TextButton")
		c.Size = UDim2.new(0.5, -15, 0, 30)
		c.Position = UDim2.new(0.5, 5, 1, -40)
		c.BackgroundColor3 = Color3.fromRGB(255, 0, 0)
		c.Text = "Cancel"
		c.TextColor3 = Color3.fromRGB(255, 255, 255)
		c.Font = Enum.Font.GothamBold
		c.TextSize = 14
		c.Parent = f

		MouseButtonFix(s, function()
			local txt = tostring(tb.Text or "")
			txt = GSub(txt, "^%s+", "")
			txt = GSub(txt, "%s+$", "")
			if txt == "" then
				gui:Destroy()
				return
			end
			gui:Destroy()
			cb(txt)
		end)

		MouseButtonFix(c, function()
			gui:Destroy()
		end)

		NAgui.draggerV2(f)
	end

	NAgui.addSection("Label")

	NAgui.addInput("UserButton Label", "Type label", "", function(txt)
		editorState.lbl = tostring(txt or "")
	end)

	NAgui.addButton("Apply Label", function()
		local txt = tostring(editorState.lbl or "")
		txt = GSub(txt, "^%s+", "")
		txt = GSub(txt, "%s+$", "")
		if txt == "" then
			DoNotif("Type a label first", 2)
			return
		end
		applyToTargets(function(data)
			data.Label = txt
		end, "Label")
		updateSelectionLabel()
	end)

	local selectionInfo

	local function cData()
		if type(editorState.currentId) ~= "number" then
			return
		end
		local g = NAUserButtons[editorState.currentId]
		if not (type(g) == "table" and g.Type == "group" and type(g.Children) == "table" and #g.Children > 0) then
			return
		end
		local idx = tonumber(editorState.childIdx) or 1
		if idx < 1 or idx > #g.Children then
			idx = 1
		end
		editorState.childIdx = idx
		return g, g.Children, idx, g.Children[idx]
	end

	local function cSync()
		local g, list, idx, ch = cData()
		if not ch then
			editorState.childLbl = ""
			editorState.childBg = Color3.fromRGB(0,0,0)
			editorState.childTc = Color3.fromRGB(255,255,255)
			if NAgui and NAgui.setInputValue then
				NAgui.setInputValue("Child Index", "", { force = true, fire = false })
				NAgui.setInputValue("Child Label", "", { force = true, fire = false })
			end
			if NAgui and NAgui.setColorPickerValue then
				NAgui.setColorPickerValue("Child Background", Color3.fromRGB(0,0,0), { fire = false })
				NAgui.setColorPickerValue("Child Text", Color3.fromRGB(255,255,255), { fire = false })
			end
			return
		end
		local bg = NAmanage.UserButtonColorFromTable(ch.BgColor, Color3.fromRGB(0,0,0))
		local tc = NAmanage.UserButtonColorFromTable(ch.TextColor, Color3.fromRGB(255,255,255))
		editorState.childLbl = ch.Label or ""
		editorState.childBg = bg
		editorState.childTc = tc
		if NAgui and NAgui.setInputValue then
			NAgui.setInputValue("Child Index", tostring(idx), { force = true, fire = false })
			NAgui.setInputValue("Child Label", editorState.childLbl, { force = true, fire = false })
		end
		if NAgui and NAgui.setColorPickerValue then
			NAgui.setColorPickerValue("Child Background", bg, { fire = false })
			NAgui.setColorPickerValue("Child Text", tc, { fire = false })
		end
	end

	local function updateSelectionLabel()
		if not selectionInfo then
			return
		end
		if type(editorState.currentId) ~= "number" then
			selectionInfo.Text = "Selected: None"
			editorState.lbl = ""
			editorState.childIdx = 1
			editorState.childLbl = ""
			if NAgui and NAgui.setInputValue then
				NAgui.setInputValue("UserButton Label", "", { force = true, fire = false })
			end
			cSync()
			return
		end

		local id = editorState.currentId
		local data = NAUserButtons[id]

		local hidden = (type(data) == "table" and data.Hidden) and true or false
		local locked = (type(data) == "table" and data.Locked) and true or false
		local interactable = not (type(data) == "table" and data.Interactable == false)

		local raw = (type(data) == "table" and type(data.Label) == "string") and data.Label or ""
		local label = raw
		if label == "" then
			label = "Button "..tostring(id)
		end

		local groupSuffix = ""
		if data.Type == "group" then
			local count = (type(data.Children) == "table") and #data.Children or 0
			groupSuffix = (" (group: %d)"):format(count)
		end

		selectionInfo.Text = ("Selected: [%d] %s%s"):format(id, label, groupSuffix)

		if editorState.editAll then
			if NAgui and NAgui.setInputValue then
				NAgui.setInputValue("UserButton Label", editorState.lbl or "", { force = true, fire = false })
			end
			return
		end

		editorState.lbl = raw
		if NAgui and NAgui.setInputValue then
			NAgui.setInputValue("UserButton Label", raw, { force = true, fire = false })
		end

		editorState.hidden = hidden
		editorState.locked = locked
		editorState.interactable = interactable
		if NAgui and NAgui.setToggleState then
			NAgui.setToggleState("Hide Button", hidden, { force = true, fire = false })
			NAgui.setToggleState("Lock Button", locked, { force = true, fire = false })
			NAgui.setToggleState("Toggle Interactable", interactable, { force = true, fire = false })
			NAgui.setToggleState("Side Toggle Layout", data.Type == "group" and data.GroupMode == "side" or false, { force = true, fire = false })
		end

		local w = tonumber(data and data.Width) or 60
		local h = tonumber(data and data.Height) or 60
		local cr = tonumber(data and data.CornerRadius) or 0.25
		if cr < 0 then cr = 0 end
		if cr > 1 then cr = 1 end

		local bg = NAmanage.UserButtonColorFromTable(data and data.BgColor, Color3.fromRGB(0, 0, 0))
		local tc = NAmanage.UserButtonColorFromTable(data and data.TextColor, Color3.fromRGB(255, 255, 255))

		editorState.width = w
		editorState.height = h
		editorState.corner = cr
		editorState.bgColor = bg
		editorState.textColor = tc

		if NAgui and NAgui.setSliderValue then
			NAgui.setSliderValue("Button Width", w, { fire = false })
			NAgui.setSliderValue("Button Height", h, { fire = false })
			NAgui.setSliderValue("Corner Radius", cr, { fire = false })
		end

		if NAgui and NAgui.setColorPickerValue then
			NAgui.setColorPickerValue("Background Color", bg, { fire = false })
			NAgui.setColorPickerValue("Text Color", tc, { fire = false })
		end
		cSync()
	end

	local function selectByDelta(delta)
		local ids = collectAllIds()
		if #ids == 0 then
			editorState.currentId = nil
			editorState.currentIndex = 0
			updateSelectionLabel()
			return
		end
		local idx = editorState.currentIndex
		if idx < 1 or idx > #ids then
			idx = 1
		end
		if delta ~= 0 then
			idx = ((idx - 1 + delta) % #ids) + 1
		end
		editorState.currentIndex = idx
		editorState.currentId = ids[idx]
		updateSelectionLabel()
	end

	local function selectChildByDelta(delta)
		local g, list, idx = cData()
		if not (g and list) then
			DoNotif("Select a group with children", 2)
			return
		end
		idx = ((idx - 1 + delta) % #list) + 1
		editorState.childIdx = idx
		cSync()
	end

	local function getChildPickerColor(label, fallback)
		local reg = NAgui and NAgui._colorPickerRegistry
		local entry = reg and reg[label]
		if entry and entry.get then
			local ok, col = pcall(entry.get)
			if ok and typeof(col) == "Color3" then
				return col
			end
		end
		return fallback
	end

	local function currentChildColors()
		local bg = getChildPickerColor("Child Background", editorState.childBg or Color3.fromRGB(0,0,0))
		local tc = getChildPickerColor("Child Text", editorState.childTc or Color3.fromRGB(255,255,255))
		editorState.childBg = bg
		editorState.childTc = tc
		return bg, tc
	end

	local function applyChildUpdates()
		local g, list, idx, ch = cData()
		if not ch then
			return
		end
		local label = tostring(editorState.childLbl or "")
		label = GSub(label, "^%s+", "")
		label = GSub(label, "%s+$", "")
		if label == "" then
			label = ch.Label or ("Action "..idx)
		end
		local bg, tc = currentChildColors()
		list[idx].Label = label
		list[idx].BgColor = NAmanage.UserButtonColorToTable(bg)
		list[idx].TextColor = NAmanage.UserButtonColorToTable(tc)
		NAmanage.UserButtonsSave("edit group child")
		if type(NAmanage.RenderUserButtons) == "function" then
			NAmanage.RenderUserButtons()
		end
		cSync()
		return true
	end

	NAgui.addSection("Selection")

	NAgui.addToggle("Edit All User Buttons", false, function(value)
		editorState.editAll = value and true or false
	end)

	selectionInfo = NAgui.addInfo("Selected Button", "Selected: None")
	selectByDelta(0)

	NAgui.addButton("Previous Button", function()
		selectByDelta(-1)
	end)

	NAgui.addButton("Next Button", function()
		selectByDelta(1)
	end)

	NAgui.addButton("Delete Button", function()
		if not next(NAUserButtons) then
			DoNotif("No user buttons to delete", 2)
			return
		end

		local targets = getTargetIds()
		if #targets == 0 then
			DoNotif("No selected button to delete", 2)
			return
		end

		local deleted = 0
		for _, id in ipairs(targets) do
			if NAUserButtons[id] ~= nil then
				NAUserButtons[id] = nil
				originalIO.clearUserButtonState(id)
				deleted = deleted + 1
			end
		end

		if deleted == 0 then
			DoNotif("No user buttons were deleted", 2)
			return
		end

		NAmanage.UserButtonsSave("editor delete")
		if type(NAmanage.RenderUserButtons) == "function" then
			NAmanage.RenderUserButtons()
		end

		editorState.currentId = nil
		editorState.currentIndex = 0
		updateSelectionLabel()

		local suffix = (deleted == 1) and " button" or " buttons"
		DoNotif("Deleted "..tostring(deleted)..suffix, 2)
	end)

	NAgui.addSection("Grouping")

	NAgui.addToggle("Side Toggle Layout", false, function(state)
		local mode = state and "side" or "dropdown"
		applyToTargets(function(data)
			if data.Type == "group" then
				data.GroupMode = mode
			end
		end, "Group mode")
	end)

	NAgui.addButton("Ungroup Selected", function()
		if type(editorState.currentId) ~= "number" then
			DoNotif("Select a group to ungroup", 2)
			return
		end
		local data = NAUserButtons[editorState.currentId]
		if not (type(data) == "table" and data.Type == "group") then
			DoNotif("Selected item is not a group", 2)
			return
		end
		local ok, msg = NAmanage.UserButtons_Ungroup(editorState.currentId)
		if ok then
			editorState.currentId = nil
			editorState.currentIndex = 0
			if type(NAmanage.RenderUserButtons) == "function" then
				NAmanage.RenderUserButtons()
			end
			updateSelectionLabel()
			DoNotif(msg or "Ungrouped", 2)
		else
			DoNotif(msg or "Failed to ungroup", 3)
		end
	end)

	NAgui.addSection("Button State")

	NAgui.addToggle("Hide Button", false, function(state)
		editorState.hidden = state and true or false
		applyToTargets(function(data)
			data.Hidden = editorState.hidden or nil
		end, "Visibility")
	end)

	NAgui.addSection("Group Children")

	NAgui.addButton("Previous Child", function()
		selectChildByDelta(-1)
	end)

	NAgui.addButton("Next Child", function()
		selectChildByDelta(1)
	end)

	NAgui.addInput("Child Index", "Number in group", "", function(txt)
		editorState.childIdx = tonumber(txt) or editorState.childIdx or 1
		cSync()
	end)

	NAgui.addInput("Child Label", "Type child label", "", function(txt)
		editorState.childLbl = tostring(txt or "")
		applyChildUpdates()
	end)

	NAgui.addColorPicker("Child Background", editorState.childBg, function(color)
		if typeof(color) ~= "Color3" then
			return
		end
		editorState.childBg = color
		applyChildUpdates()
	end)

	NAgui.addColorPicker("Child Text", editorState.childTc, function(color)
		if typeof(color) ~= "Color3" then
			return
		end
		editorState.childTc = color
		applyChildUpdates()
	end)

	NAgui.addToggle("Lock Button", false, function(state)
		editorState.locked = state and true or false
		applyToTargets(function(data)
			data.Locked = editorState.locked or nil
		end, "Lock")
	end)

	NAgui.addToggle("Toggle Interactable", true, function(state)
		editorState.interactable = state and true or false
		applyToTargets(function(data)
			if editorState.interactable then
				data.Interactable = nil
			else
				data.Interactable = false
			end
		end, "Interactable")
	end)

	NAgui.addSection("Appearance")

	NAgui.addSlider("Button Width", 20, 500, editorState.width, 2, " px", function(value)
		editorState.width = value
		applyToTargets(function(data)
			data.Width = math.floor(value + 0.5)
		end)
	end)

	NAgui.addSlider("Button Height", 20, 500, editorState.height, 2, " px", function(value)
		editorState.height = value
		applyToTargets(function(data)
			data.Height = math.floor(value + 0.5)
		end)
	end)

	NAgui.addSlider("Corner Radius", 0, 1, editorState.corner, 0.05, "", function(value)
		editorState.corner = value
		applyToTargets(function(data)
			data.CornerRadius = value
		end)
	end)

	NAgui.addColorPicker("Background Color", editorState.bgColor, function(color)
		if typeof(color) ~= "Color3" then
			return
		end
		editorState.bgColor = color
		local stored = NAmanage.UserButtonColorToTable(color)
		applyToTargets(function(data)
			data.BgColor = stored
		end)
	end)

	NAgui.addColorPicker("Text Color", editorState.textColor, function(color)
		if typeof(color) ~= "Color3" then
			return
		end
		editorState.textColor = color
		local stored = NAmanage.UserButtonColorToTable(color)
		applyToTargets(function(data)
			data.TextColor = stored
		end)
	end)

	NAgui.addButton("Reset Appearance Overrides", function()
		applyToTargets(function(data)
			data.Width = nil
			data.Height = nil
			data.BgColor = nil
			data.TextColor = nil
			data.CornerRadius = nil
		end, "Appearance reset")
	end)
	updateSelectionLabel()
end
originalIO.UserBtnEditor()

NAStuff.joinLeaveWarned = false
function NAmanage.jlSave()
	NAmanage.jlCfg = NAmanage.jlNorm(NAmanage.jlCfg)
	NAmanage.logApply()
	if FileSupport then
		writefile(NAfiles.NAJOINLEAVE, HttpService:JSONEncode(NAmanage.jlCfg))
	elseif not NAStuff.joinLeaveWarned then
		NAStuff.joinLeaveWarned = true
		DebugNotif("Logging settings will reset after this session (no file support detected).")
	end
end

NAgui.addTab(TAB_LOGGING, { order = 11, textIcon = "list-bulleted" })
NAgui.setTab(TAB_LOGGING)

NAgui.addSection("Join/Leave Logging")

NAgui.addToggle("Log Player Joins", NAmanage.jlCfg.JoinLog, function(v)
	NAmanage.jlCfg.JoinLog = v
	NAmanage.jlSave()
	DoNotif("Join logging "..(v and "enabled" or "disabled"), 2)
end)

NAgui.addToggle("Log Player Leaves", NAmanage.jlCfg.LeaveLog, function(v)
	NAmanage.jlCfg.LeaveLog = v
	NAmanage.jlSave()
	DoNotif("Leave logging "..(v and "enabled" or "disabled"), 2)
end)

NAgui.addToggle("Save Join/Leave Logs", NAmanage.jlCfg.SaveLog, function(v)
	NAmanage.jlCfg.SaveLog = v
	NAmanage.jlSave()
	DoNotif("Join/Leave log saving has been "..(v and "enabled" or "disabled"), 2)
end)

NAgui.addSection("Chat Logging")

NAgui.addToggle("Log Chat Messages", NAmanage.jlCfg.ChatLog, function(v)
	NAmanage.jlCfg.ChatLog = v
	NAmanage.jlSave()
	DoNotif("Chat logging "..(v and "enabled" or "disabled"), 2)
end)

NAgui.addToggle("Save Chat Logs", NAmanage.jlCfg.SaveChatLog, function(v)
	NAmanage.jlCfg.SaveChatLog = v
	NAmanage.jlSave()
	DoNotif("Chat log saving has been "..(v and "enabled" or "disabled"), 2)
end)

NAgui.addSection("Notification Preferences")

NAgui.addToggle("Show Welcome Notification", NAmanage.jlCfg.WelcomeNotif ~= false, function(v)
	NAmanage.jlCfg.WelcomeNotif = v and true or false
	NAmanage.jlSave()
	DoNotif("Welcome notification "..(v and "enabled" or "disabled"), 2)
end)

NAgui.addToggle("Show Keybind Prefix Reminder", NAmanage.jlCfg.KeybindNotif ~= false, function(v)
	NAmanage.jlCfg.KeybindNotif = v and true or false
	NAmanage.jlSave()
	DoNotif("Keybind prefix reminder "..(v and "enabled" or "disabled"), 2)
end)

NAgui.addToggle("Show Plugin Load Summary", NAmanage.jlCfg.PluginNotif ~= false, function(v)
	NAmanage.jlCfg.PluginNotif = v and true or false
	NAmanage.jlSave()
	DoNotif("Plugin load summary "..(v and "enabled" or "disabled"), 2)
end)

NAgui.addToggle("Show Intro Text Label", NAmanage.jlCfg.IconLabel ~= false, function(v)
	NAmanage.jlCfg.IconLabel = v and true or false
	NAmanage.jlSave()
	DoNotif("Intro text label "..(v and "enabled" or "disabled"), 2)
end)

NAgui.addSection("Other Logging")

NAgui.addToggle("Log Physics Errors", NAmanage.jlCfg.PhysicsLog, function(v)
	NAmanage.jlCfg.PhysicsLog = v
	NAmanage.jlSave()
	DoNotif("Physics error logging "..(v and "enabled" or "disabled"), 2)
end)

NAgui.addSection("Log Maintenance")

NAgui.addButton("Clear Join/Leave Log File", function()
	if not FileSupport then
		DoNotif("File operations not supported by this executor.", 2)
		return
	end
	local ok, msg = originalIO.safeDeleteFile(NAfiles.NAJOINLEAVELOG)
	DoNotif(ok and "Join/Leave log cleared." or ("Failed to clear: "..tostring(msg)), 2.5)
end)

NAgui.addButton("Clear Chat Log File", function()
	if not FileSupport then
		DoNotif("File operations not supported by this executor.", 2)
		return
	end
	local ok, msg = originalIO.safeDeleteFile(NAfiles.NACHATLOGS)
	DoNotif(ok and "Chat log cleared." or ("Failed to clear: "..tostring(msg)), 2.5)
end)

NAgui.addTab(TAB_ESP, { order = 5, textIcon = "crosshairs" })
NAgui.setTab(TAB_ESP)

NAgui.isListActive=function(list)
	return type(list) == "table" and next(list) ~= nil
end

NAgui.trimText=function(str)
	return (str or ""):match("^%s*(.-)%s*$")
end

NAgui.addSection("Visuals & Color")

NAgui.addToggle("Use Highlight Rendering (Highlight)", NAgui.espUsesHighlight(), function(state)
	NAStuff.ESP_RenderMode = state and "Highlight" or "BoxHandleAdornment"
	NAmanage.SaveESPSettings()
	NAmanage.ESP_RebuildVisuals()
end)

NAgui.addToggle("Use Custom ESP Color", NAStuff.ESP_UseCustomColor == true, function(state)
	NAStuff.ESP_UseCustomColor = state
	NAmanage.SaveESPSettings()
	NAmanage.ESP_RebuildVisuals()
end)

NAgui.addColorPicker("Custom ESP Color", NAStuff.ESP_CustomColor or Color3.new(1, 1, 1), function(color)
	if typeof(color) ~= "Color3" then
		return
	end
	NAStuff.ESP_CustomColor = color
	NAmanage.SaveESPSettings()
	NAmanage.ESP_RebuildVisuals()
end)

NAgui.addToggle("ESP Color By Team", (NAStuff.ESP_ColorByTeam ~= false), function(state)
	NAStuff.ESP_ColorByTeam = state
	NAmanage.SaveESPSettings()
end)

NAgui.addSlider("ESP Transparency", 0, 1, NAgui.sanitizeTransparency(NAStuff.ESP_Transparency or 0.7), 0.05, "", function(v)
	local alpha = NAgui.sanitizeTransparency(v)
	NAStuff.ESP_Transparency = alpha
	for _, data in pairs(espCONS) do
		if data.highlight then
			data.highlight.FillTransparency = alpha
		end
		for _, box in pairs(data.boxTable) do
			if box then box.Transparency = alpha end
		end
	end
	NAmanage.PartESP_UpdateTexts(true)
	NAmanage.SaveESPSettings()
end)

NAgui.addSlider("Highlight Outline Transparency", 0, 1, NAgui.sanitizeTransparency(NAStuff.ESP_OutlineTransparency or 0), 0.05, "", function(v)
	local outline = NAgui.sanitizeTransparency(v)
	NAStuff.ESP_OutlineTransparency = outline
	for _, data in pairs(espCONS) do
		if data and data.highlight then
			data.highlight.OutlineTransparency = outline
		end
	end
	NAmanage.SaveESPSettings()
	NAmanage.PartESP_UpdateTexts(true)
end)

NAgui.addSection("Visibility & Performance")

NAgui.addSlider("ESP Box Distance", 0, 2000, NAStuff.ESP_BoxMaxDistance or 120, 5, " studs", function(v)
	NAStuff.ESP_BoxMaxDistance = v
	NAmanage.SaveESPSettings()
end)

NAgui.addSlider("ESP Label Distance", 0, 5000, NAStuff.ESP_LabelMaxDistance or 1000, 25, " studs", function(v)
	NAStuff.ESP_LabelMaxDistance = v
	NAmanage.SaveESPSettings()
end)

NAgui.addSlider("ESP Update Batch Size", 1, 256, math.clamp(math.floor(tonumber(NAStuff.ESP_MaxPerStep) or 32), 1, 256), 1, " models", function(v)
	NAStuff.ESP_MaxPerStep = math.clamp(math.floor(tonumber(v) or 32), 1, 256)
	NAmanage.SaveESPSettings()
end)

NAgui.addSection("Label Content")

NAgui.addToggle("Show Name In Label", (NAStuff.ESP_ShowName ~= false), function(state)
	NAStuff.ESP_ShowName = state
	NAmanage.SaveESPSettings()
end)

NAgui.addToggle("Show Health In Label", (NAStuff.ESP_ShowHealth ~= false), function(state)
	NAStuff.ESP_ShowHealth = state
	NAmanage.SaveESPSettings()
end)

NAgui.addToggle("Show Team In Label", (NAStuff.ESP_ShowTeamText ~= false), function(state)
	NAStuff.ESP_ShowTeamText = state
	NAmanage.SaveESPSettings()
end)

NAgui.addToggle("Show Distance In Label", (NAStuff.ESP_ShowDistance ~= false), function(state)
	NAStuff.ESP_ShowDistance = state
	NAmanage.SaveESPSettings()
end)

NAgui.addSection("Label Appearance")

NAgui.addSlider("Label Text Size", 8, 72, NAgui.sanitizeLabelSize(NAStuff.ESP_LabelTextSize), 1, " px", function(v)
	local size = NAgui.sanitizeLabelSize(v)
	NAStuff.ESP_LabelTextSize = size
	NAmanage.SaveESPSettings()
	NAmanage.ESP_ApplyLabelStyles()
end)

NAgui.addToggle("Label Text Scaled", NAStuff.ESP_LabelTextScaled, function(state)
	NAStuff.ESP_LabelTextScaled = state
	NAmanage.SaveESPSettings()
	NAmanage.ESP_ApplyLabelStyles()
end)

NAgui.addSlider("Label Stroke Transparency", 0, 1, math.clamp(tonumber(NAStuff.ESP_LabelStrokeTransparency) or 0.5, 0, 1), 0.05, "", function(v)
	NAStuff.ESP_LabelStrokeTransparency = math.clamp(tonumber(v) or 0.5, 0, 1)
	NAmanage.SaveESPSettings()
	NAmanage.ESP_ApplyLabelStyles()
	NAmanage.PartESP_UpdateTexts(true)
end)

NAgui.addSection("Part ESP")

NAgui.addToggle("Show Part Distance", (NAStuff.ESP_ShowPartDistance == true), function(state)
	NAStuff.ESP_ShowPartDistance = state
	NAmanage.SaveESPSettings()
	NAmanage.PartESP_UpdateTexts(true)
end)

NAgui.addSection("Folder ESP")

NAgui.addToggle("Highlight Folder ESP By Models", (NAStuff.ESP_FolderMode == "models"), function(state)
	NAStuff.ESP_FolderMode = state and "models" or "parts"
	NAmanage.SaveESPSettings()
	DoNotif("Folder ESP will highlight by "..(state and "models" or "parts")..".", 2)
	if NAmanage.FolderESP_RefreshActive then
		NAmanage.FolderESP_RefreshActive()
	end
end)

NAgui.addSection("Locator Arrows")

NAgui.addToggle("ESP Locator Arrows", NAStuff.ESP_LocatorEnabled == true, function(state)
	NAmanage.ESP_SetLocatorEnabled(state)
end)

NAgui.addSlider("Locator Size", 12, 128, math.clamp(tonumber(NAStuff.ESP_LocatorSize) or 26, 12, 128), 1, " px", function(v)
	NAStuff.ESP_LocatorSize = math.clamp(tonumber(v) or 26, 12, 128)
	NAmanage.ESP_LocatorApplyFlags()
	NAmanage.SaveESPSettings()
end)

NAgui.addToggle("Locator Show Text", NAStuff.ESP_LocatorShowText == true, function(state)
	NAmanage.ESP_SetLocatorShowText(state)
end)

NAgui.addSlider("Locator Text Size", 10, 48, math.clamp(tonumber(NAStuff.ESP_LocatorTextSize) or 14, 10, 48), 1, " px", function(v)
	NAStuff.ESP_LocatorTextSize = math.clamp(tonumber(v) or 14, 10, 48)
	NAmanage.ESP_LocatorApplyFlags()
	NAmanage.SaveESPSettings()
end)

NAgui.addSection("Interactable ESP (touchesp/proximityesp/clickesp)")

NAgui.addToggle("Touch ESP", NAgui.isListActive(NAStuff.touchESPList), function(state)
	SpawnCall(function()
		if state then
			cmd.run({"touchesp"})
		else
			cmd.run({"untouchesp"})
		end
	end)
end)

NAgui.addToggle("Proximity Prompt ESP", NAgui.isListActive(NAStuff.proximityESPList), function(state)
	SpawnCall(function()
		if state then
			cmd.run({"proximityesp"})
		else
			cmd.run({"unproximityesp"})
		end
	end)
end)

NAgui.addToggle("Click Detector ESP", NAgui.isListActive(NAStuff.clickESPList), function(state)
	SpawnCall(function()
		if state then
			cmd.run({"clickesp"})
		else
			cmd.run({"unclickesp"})
		end
	end)
end)

NAgui.addSection("Seat ESP")

NAgui.addToggle("Seat ESP", NAgui.isListActive(NAStuff.siteESPList), function(state)
	SpawnCall(function()
		if state then
			cmd.run({"sitesp"})
		else
			cmd.run({"unsitesp"})
		end
	end)
end)

NAgui.addToggle("Vehicle Seat ESP", NAgui.isListActive(NAStuff.vehicleSiteESPList), function(state)
	SpawnCall(function()
		if state then
			cmd.run({"vehiclesitesp"})
		else
			cmd.run({"unvehiclesitesp"})
		end
	end)
end)

NAgui.addSection("Physics ESP | AKA: lag section")

NAgui.addToggle("Unanchored Parts ESP", NAgui.isListActive(NAStuff.unanchoredESPList), function(state)
	SpawnCall(function()
		if state then
			cmd.run({"unanchored"})
		else
			cmd.run({"ununanchored"})
		end
	end)
end)

NAgui.addToggle("Collidable Parts ESP", NAgui.isListActive(NAStuff.collisiontrueESPList), function(state)
	SpawnCall(function()
		if state then
			cmd.run({"collisionesp"})
		else
			cmd.run({"uncollisionesp"})
		end
	end)
end)

NAgui.addToggle("Non-Collidable Parts ESP", NAgui.isListActive(NAStuff.collisionfalseESPList), function(state)
	SpawnCall(function()
		if state then
			cmd.run({"nocollisionesp"})
		else
			cmd.run({"unnocollisionesp"})
		end
	end)
end)

NAgui.addSection("Part ESP")

NAgui.addInput("Exact Part Name", "Exact part name (partesp)", NAStuff.ESP_LastExactPart, function(text)
	NAStuff.ESP_LastExactPart = text
end)

NAgui.addButton("Apply Exact Part ESP", function()
	local name = NAgui.trimText(NAStuff.ESP_LastExactPart)
	if name == "" then
		DoNotif("Enter an exact part name before using partesp.", 2)
		return
	end
	SpawnCall(function() cmd.run({"pesp", name}) end)
end)

NAgui.addButton("Clear Exact Part ESP", function()
	SpawnCall(function() cmd.run({"unpesp"}) end)
end)

NAgui.addInput("Partial Part Name", "Partial part name (pespfind)", NAStuff.ESP_LastPartialPart, function(text)
	NAStuff.ESP_LastPartialPart = text
end)

NAgui.addButton("Apply Partial Part ESP", function()
	local name = NAgui.trimText(NAStuff.ESP_LastPartialPart)
	if name == "" then
		DoNotif("Enter a partial part name before using pespfind.", 2)
		return
	end
	SpawnCall(function() cmd.run({"pespfind", name}) end)
end)

NAgui.addButton("Clear Partial Part ESP", function()
	SpawnCall(function() cmd.run({"unpespfind"}) end)
end)

NAgui.addSection("Folder ESP")

NAgui.addInput("Folder Name", "Folder name to highlight", NAStuff.ESP_LastFolderName, function(text)
	NAStuff.ESP_LastFolderName = text
end)

NAgui.addButton("Apply Folder ESP", function()
	local name = NAgui.trimText(NAStuff.ESP_LastFolderName)
	if name == "" then
		DoNotif("Enter a folder name before using folderesp.", 2)
		return
	end
	SpawnCall(function() cmd.run({"folderesp", name}) end)
end)

NAgui.addButton("Clear Folder ESP", function()
	local name = NAgui.trimText(NAStuff.ESP_LastFolderName)
	SpawnCall(function()
		if name ~= "" then
			cmd.run({"unfolderesp", name})
		else
			cmd.run({"unfolderesp"})
		end
	end)
end)

NAgui.addTab(TAB_CHAT, { order = 7, textIcon = "speech-bubble-align-center" })
NAgui.setTab(TAB_CHAT)

do
	local function tblToC3(t)
		if typeof(t) == "Color3" then return t end
		local r = (t and (t.R or t[1])) or 255
		local g = (t and (t.G or t[2])) or 255
		local b = (t and (t.B or t[3])) or 255
		return Color3.fromRGB(r, g, b)
	end
	local function c3ToTbl(c)
		return { math.floor(c.R * 255 + 0.5), math.floor(c.G * 255 + 0.5), math.floor(c.B * 255 + 0.5) }
	end

	NAgui.addSection("Text Chat")
	NAgui.addToggle("Enable Custom Chat Styling", NAStuff.ChatSettings.customEnabled, function(v)
		local wasEnabled = NAStuff.ChatSettings.customEnabled == true
		NAStuff.ChatSettings.customEnabled = v

		if wasEnabled and not v then
			originalIO.backupChatSection("bubbles")
			if not originalIO.assignChatSectionFromTemplate("bubbles") then
				originalIO.restoreChatSectionFromBackup("bubbles")
			end
		elseif v and not wasEnabled then
			if not originalIO.restoreChatSectionFromBackup("bubbles") and type(NAStuff.ChatSettings.bubbles) ~= "table" then
				originalIO.assignChatSectionFromTemplate("bubbles")
			end
		end

		NAmanage.SaveTextChatSettings()
		NAmanage.ApplyTextChatSettings()
	end)
	NAgui.addButton("Reset Custom Chat Settings", function()
		local ok, err = pcall(function()
			local template = NAStuff.ChatSettingsTemplate
			if type(template) ~= "table" then
				error("Chat default settings unavailable.")
			end

			local current = NAStuff.ChatSettings
			local preserveCustom = (current and current.customEnabled) or false
			local preserveCoreChat = (current and current.coreGuiChat ~= nil) and current.coreGuiChat or true
			local templateCopy = originalIO.deepCopyTable(template)

			if type(current) ~= "table" then
				current = {}
				NAStuff.ChatSettings = current
			end

			for key in pairs(current) do
				current[key] = nil
			end
			for key, value in pairs(templateCopy) do
				current[key] = value
			end

			NAStuff.ChatSettingsCustomBackup = nil
			current.customEnabled = preserveCustom
			current.coreGuiChat = preserveCoreChat

			NAStuff.ChatCustomizationActive = nil
			NAmanage.SaveTextChatSettings()
			NAmanage.ApplyTextChatSettings()
		end)

		if ok then
			DoNotif("Chat style options reset to defaults.", 2)
		else
			warn("[NA] Reset Custom Chat Settings failed:", err)
			DoNotif("Failed to reset chat settings. Check console for details.", 3)
		end
	end)

	NAgui.addToggle("Enable Chat (CoreGui)", NAStuff.ChatSettings.coreGuiChat, function(v)
		NAStuff.ChatSettings.coreGuiChat = v; NAmanage.SaveTextChatSettings(); NAmanage.ApplyTextChatSettings()
	end)

	NAgui.addSection("Chat Window")
	NAgui.addToggle("Window Enabled", NAStuff.ChatSettings.window.enabled, function(v)
		NAStuff.ChatSettings.window.enabled = v; NAmanage.SaveTextChatSettings(); NAmanage.ApplyTextChatSettings()
	end)
	NAgui.addSlider("Text Size (Window)", 5, 50, NAStuff.ChatSettings.window.textSize, 1, " px", function(v)
		NAStuff.ChatSettings.window.textSize = v; NAmanage.SaveTextChatSettings(); NAmanage.ApplyTextChatSettings()
	end)
	NAgui.addColorPicker("Text Color", tblToC3(NAStuff.ChatSettings.window.textColor), function(c)
		NAStuff.ChatSettings.window.textColor = c3ToTbl(c); NAmanage.SaveTextChatSettings(); NAmanage.ApplyTextChatSettings()
	end)
	NAgui.addSlider("Text Transparency (Window)", 0, 1, NAStuff.ChatSettings.window.textTransparency, 0.05, "", function(v)
		NAStuff.ChatSettings.window.textTransparency = v; NAmanage.SaveTextChatSettings(); NAmanage.ApplyTextChatSettings()
	end)
	NAgui.addColorPicker("Text Stroke Color", tblToC3(NAStuff.ChatSettings.window.strokeColor), function(c)
		NAStuff.ChatSettings.window.strokeColor = c3ToTbl(c); NAmanage.SaveTextChatSettings(); NAmanage.ApplyTextChatSettings()
	end)
	NAgui.addSlider("Text Stroke Transparency", 0, 1, NAStuff.ChatSettings.window.strokeTransparency, 0.05, "", function(v)
		NAStuff.ChatSettings.window.strokeTransparency = v; NAmanage.SaveTextChatSettings(); NAmanage.ApplyTextChatSettings()
	end)
	NAgui.addColorPicker("Window Background", tblToC3(NAStuff.ChatSettings.window.backgroundColor), function(c)
		NAStuff.ChatSettings.window.backgroundColor = c3ToTbl(c); NAmanage.SaveTextChatSettings(); NAmanage.ApplyTextChatSettings()
	end)
	NAgui.addSlider("Window Background Transparency", 0, 1, NAStuff.ChatSettings.window.backgroundTransparency, 0.05, "", function(v)
		NAStuff.ChatSettings.window.backgroundTransparency = v; NAmanage.SaveTextChatSettings(); NAmanage.ApplyTextChatSettings()
	end)

	NAgui.addSection("Channel Tabs")
	NAgui.addToggle("Tabs Enabled", NAStuff.ChatSettings.tabs.enabled, function(v)
		NAStuff.ChatSettings.tabs.enabled = v; NAmanage.SaveTextChatSettings(); NAmanage.ApplyTextChatSettings()
	end)
	NAgui.addSlider("Text Size (Tabs)", 5, 50, NAStuff.ChatSettings.tabs.textSize, 1, " px", function(v)
		NAStuff.ChatSettings.tabs.textSize = v; NAmanage.SaveTextChatSettings(); NAmanage.ApplyTextChatSettings()
	end)
	NAgui.addColorPicker("Tab Background", tblToC3(NAStuff.ChatSettings.tabs.backgroundColor), function(c)
		NAStuff.ChatSettings.tabs.backgroundColor = c3ToTbl(c); NAmanage.SaveTextChatSettings(); NAmanage.ApplyTextChatSettings()
	end)
	NAgui.addSlider("Background Transparency (Tabs)", 0, 1, NAStuff.ChatSettings.tabs.backgroundTransparency, 0.05, "", function(v)
		NAStuff.ChatSettings.tabs.backgroundTransparency = v; NAmanage.SaveTextChatSettings(); NAmanage.ApplyTextChatSettings()
	end)
	NAgui.addSlider("Text Transparency (Tabs)", 0, 1, NAStuff.ChatSettings.tabs.textTransparency, 0.05, "", function(v)
		NAStuff.ChatSettings.tabs.textTransparency = v; NAmanage.SaveTextChatSettings(); NAmanage.ApplyTextChatSettings()
	end)
	NAgui.addColorPicker("Text Color (Tabs)", tblToC3(NAStuff.ChatSettings.tabs.textColor), function(c)
		NAStuff.ChatSettings.tabs.textColor = c3ToTbl(c); NAmanage.SaveTextChatSettings(); NAmanage.ApplyTextChatSettings()
	end)
	NAgui.addColorPicker("Selected Text Color", tblToC3(NAStuff.ChatSettings.tabs.selectedTextColor), function(c)
		NAStuff.ChatSettings.tabs.selectedTextColor = c3ToTbl(c); NAmanage.SaveTextChatSettings(); NAmanage.ApplyTextChatSettings()
	end)
	NAgui.addColorPicker("Unselected Text Color", tblToC3(NAStuff.ChatSettings.tabs.unselectedTextColor), function(c)
		NAStuff.ChatSettings.tabs.unselectedTextColor = c3ToTbl(c); NAmanage.SaveTextChatSettings(); NAmanage.ApplyTextChatSettings()
	end)

	NAgui.addSection("Chat Input")
	NAgui.addToggle("Input Enabled", NAStuff.ChatSettings.input.enabled, function(v)
		NAStuff.ChatSettings.input.enabled = v; NAmanage.SaveTextChatSettings(); NAmanage.ApplyTextChatSettings()
	end)
	NAgui.addToggle("Autocomplete", NAStuff.ChatSettings.input.autocomplete, function(v)
		NAStuff.ChatSettings.input.autocomplete = v; NAmanage.SaveTextChatSettings(); NAmanage.ApplyTextChatSettings()
	end)
	NAgui.addToggle("Target #RBXGeneral", NAStuff.ChatSettings.input.targetGeneral, function(v)
		NAStuff.ChatSettings.input.targetGeneral = v; NAmanage.SaveTextChatSettings(); NAmanage.ApplyTextChatSettings()
	end)
	NAgui.addSlider("Text Size (Input)", 5, 25, NAStuff.ChatSettings.input.textSize, 1, " px", function(v)
		NAStuff.ChatSettings.input.textSize = v; NAmanage.SaveTextChatSettings(); NAmanage.ApplyTextChatSettings()
	end)
	NAgui.addColorPicker("Text Color (Input)", tblToC3(NAStuff.ChatSettings.input.textColor), function(c)
		NAStuff.ChatSettings.input.textColor = c3ToTbl(c); NAmanage.SaveTextChatSettings(); NAmanage.ApplyTextChatSettings()
	end)
	NAgui.addColorPicker("Input Stroke Color", tblToC3(NAStuff.ChatSettings.input.strokeColor), function(c)
		NAStuff.ChatSettings.input.strokeColor = c3ToTbl(c); NAmanage.SaveTextChatSettings(); NAmanage.ApplyTextChatSettings()
	end)
	NAgui.addSlider("Text Stroke Transparency (Input)", 0, 1, NAStuff.ChatSettings.input.strokeTransparency, 0.05, "", function(v)
		NAStuff.ChatSettings.input.strokeTransparency = v; NAmanage.SaveTextChatSettings(); NAmanage.ApplyTextChatSettings()
	end)
	NAgui.addColorPicker("Input Background", tblToC3(NAStuff.ChatSettings.input.backgroundColor), function(c)
		NAStuff.ChatSettings.input.backgroundColor = c3ToTbl(c); NAmanage.SaveTextChatSettings(); NAmanage.ApplyTextChatSettings()
	end)
	NAgui.addSlider("Background Transparency (Input)", 0, 1, NAStuff.ChatSettings.input.backgroundTransparency, 0.05, "", function(v)
		NAStuff.ChatSettings.input.backgroundTransparency = v; NAmanage.SaveTextChatSettings(); NAmanage.ApplyTextChatSettings()
	end)
	if not IsOnMobile then
		NAgui.addKeybind("Chat Key", NAStuff.ChatSettings.input.keyCode or "Slash", function(keyName)
			NAStuff.ChatSettings.input.keyCode = tostring(keyName or "Slash"); NAmanage.SaveTextChatSettings(); NAmanage.ApplyTextChatSettings()
		end)
	end

	NAgui.addSection("Bubble Chat")
	NAgui.addToggle("Bubbles Enabled", NAStuff.ChatSettings.bubbles.enabled, function(v)
		NAStuff.ChatSettings.bubbles.enabled = v; NAmanage.SaveTextChatSettings(); NAmanage.ApplyTextChatSettings()
	end)
	NAgui.addSlider("Max Distance", 10, 500, NAStuff.ChatSettings.bubbles.maxDistance, 5, " u", function(v)
		NAStuff.ChatSettings.bubbles.maxDistance = v; NAmanage.SaveTextChatSettings(); NAmanage.ApplyTextChatSettings()
	end)
	NAgui.addSlider("Minimize Distance", 0, 350, NAStuff.ChatSettings.bubbles.minimizeDistance, 2, " u", function(v)
		NAStuff.ChatSettings.bubbles.minimizeDistance = v; NAmanage.SaveTextChatSettings(); NAmanage.ApplyTextChatSettings()
	end)
	NAgui.addSlider("Text Size (Bubble)", 5, 30, NAStuff.ChatSettings.bubbles.textSize, 1, " px", function(v)
		NAStuff.ChatSettings.bubbles.textSize = v; NAmanage.SaveTextChatSettings(); NAmanage.ApplyTextChatSettings()
	end)
	NAgui.addColorPicker("Bubble Text Color", tblToC3(NAStuff.ChatSettings.bubbles.textColor), function(c)
		NAStuff.ChatSettings.bubbles.textColor = c3ToTbl(c); NAmanage.SaveTextChatSettings(); NAmanage.ApplyTextChatSettings()
	end)
	NAgui.addSlider("Text Transparency (Bubble)", 0, 1, NAStuff.ChatSettings.bubbles.textTransparency, 0.05, "", function(v)
		NAStuff.ChatSettings.bubbles.textTransparency = v; NAmanage.SaveTextChatSettings(); NAmanage.ApplyTextChatSettings()
	end)
	NAgui.addSlider("Bubble Spacing", 0, 12, NAStuff.ChatSettings.bubbles.spacing, 1, " px", function(v)
		NAStuff.ChatSettings.bubbles.spacing = v; NAmanage.SaveTextChatSettings(); NAmanage.ApplyTextChatSettings()
	end)
	NAgui.addColorPicker("Bubble Background", tblToC3(NAStuff.ChatSettings.bubbles.backgroundColor), function(c)
		NAStuff.ChatSettings.bubbles.backgroundColor = c3ToTbl(c); NAmanage.SaveTextChatSettings(); NAmanage.ApplyTextChatSettings()
	end)
	NAgui.addSlider("Background Transparency (Bubble)", 0, 1, NAStuff.ChatSettings.bubbles.backgroundTransparency, 0.05, "", function(v)
		NAStuff.ChatSettings.bubbles.backgroundTransparency = v; NAmanage.SaveTextChatSettings(); NAmanage.ApplyTextChatSettings()
	end)
	NAgui.addSlider("Bubble Duration", 3, 30, NAStuff.ChatSettings.bubbles.bubbleDuration, 1, " s", function(v)
		NAStuff.ChatSettings.bubbles.bubbleDuration = v; NAmanage.SaveTextChatSettings(); NAmanage.ApplyTextChatSettings()
	end)
	NAgui.addSlider("Max Bubbles", 1, 5, math.min(5, NAStuff.ChatSettings.bubbles.maxBubbles or 1), 1, "", function(v)
		NAStuff.ChatSettings.bubbles.maxBubbles = math.min(5, v); NAmanage.SaveTextChatSettings(); NAmanage.ApplyTextChatSettings()
	end)
	NAgui.addToggle("Tail Visible", NAStuff.ChatSettings.bubbles.tailVisible, function(v)
		NAStuff.ChatSettings.bubbles.tailVisible = v; NAmanage.SaveTextChatSettings(); NAmanage.ApplyTextChatSettings()
	end)
end

if not IsOnMobile then
	NAgui.addTab(TAB_KEYBINDS, { order = 8, textIcon = "xbox-a" })
	NAgui.setTab(TAB_KEYBINDS)

	if IsOnPC then
		NAgui.addSection("Control Lock")
		NAgui.addKeybind("Add Shiftlock Key","LeftShift",function(k)
			if k then NAmanage.ControlLock_AddKey(k) end
		end)
		NAgui.addKeybind("Remove Shiftlock Key","RightShift",function(k)
			if k then NAmanage.ControlLock_RemoveKey(k) end
		end)
		NAgui.addButton("Apply Saved Keys",function()
			NAmanage.ControlLock_Apply(NAStuff._ctrlLockKeys)
		end)
		NAgui.addButton("Reset To Default (Shift)",function()
			NAmanage.ControlLock_ClearToDefault()
		end)
		NAgui.addToggle("Reapply On Respawn",NAStuff._ctrlLockPersist,function(state)
			NAStuff._ctrlLockPersist = state and true or false
			NAmanage.ControlLock_Bind()
		end)

		NAgui.addSection("Fly Keybinds")
		local function createFlyKeybindHandler(varField, connField, connectFunc, successTemplate, emptyMessage)
			emptyMessage = emptyMessage or "Please provide a keybind."
			return function(keyName)
				if keyName == nil then
					return
				end
				local newKey = tostring(keyName or ""):lower()
				if newKey == "" then
					DoNotif(emptyMessage)
					return
				end
				flyVariables[varField] = newKey
				local existingConn = flyVariables[connField]
				if existingConn then
					existingConn:Disconnect()
					flyVariables[connField] = nil
				end
				connectFunc()
				DebugNotif(Format(successTemplate, newKey:upper()))
			end
		end

		NAgui.addKeybind("Fly Keybind", string.upper(flyVariables.toggleKey or "F"), createFlyKeybindHandler(
			"toggleKey",
			"keybindConn",
			NAmanage.connectFlyKey,
			"Fly keybind set to '%s'"
			))

		NAgui.addKeybind("vFly Keybind", string.upper(flyVariables.vToggleKey or "V"), createFlyKeybindHandler(
			"vToggleKey",
			"vKeybindConn",
			NAmanage.connectVFlyKey,
			"vFly keybind set to '%s'"
			))

		NAgui.addKeybind("cFly Keybind", string.upper(flyVariables.cToggleKey or "C"), createFlyKeybindHandler(
			"cToggleKey",
			"cKeybindConn",
			NAmanage.connectCFlyKey,
			"CFrame fly keybind set to '%s'"
			))

		NAgui.addKeybind("tFly Keybind", string.upper(flyVariables.tflyToggleKey or "T"), createFlyKeybindHandler(
			"tflyToggleKey",
			"tflyKeyConn",
			NAmanage.connectTFlyKey,
			"TFly keybind set to '%s'",
			"Please provide a key."
			))

		NAgui.addSection("Command Keybinds")
		NAgui.addButton("Open Command Keybinds", function()
			NAgui.setTab(TAB_COMMAND_KEYBINDS)
			Defer(function()
				NAmanage.CommandKeybindsUIRefresh()
			end)
		end)

		local prevTab = NAgui.getActiveTab()
		NAgui.addTab(TAB_COMMAND_KEYBINDS, { order = 9, textIcon = "xbox-a" })
		NAgui.setTab(TAB_COMMAND_KEYBINDS)
		NAmanage.CommandKeybindsUIInit()
		NAmanage.CommandKeybindsUIWire()
		NAmanage.CommandKeybindsUIRefresh()
		NAgui.setTab(prevTab)
	end
end

NAgui.addTab(TAB_CHARACTER, { order = 6, textIcon = "circle-person" })
NAgui.setTab(TAB_CHARACTER)

NAmanage.ApplyWalkSpeed = function(val)
	local hum = getHum(getChar())
	if hum then
		hum.WalkSpeed = val
	end
end

NAmanage.ApplyJump = function(val)
	local hum = getHum(getChar())
	if hum then
		if hum.UseJumpPower ~= false then
			hum.JumpPower = val
		elseif hum.ChangeState then
			hum:ChangeState(Enum.HumanoidStateType.Jumping)
		end
	end
end

NAgui.addSection("Character Morph")
NAgui.addInput("Target User", "UserId or Username", "", function(val)
	morphTarget = val
end)
NAgui.addButton("Morph Character", function()
	if morphTarget ~= "" then
		cmd.run({"char", morphTarget})
	end
end)
NAgui.addButton("Revert Character", function()
	cmd.run({"unchar"})
end)
NAgui.addToggle("Auto Morph", false, function(state)
	if state then
		NAlib.disconnect("autochartoggle")
		NAlib.connect("autochartoggle", Players.LocalPlayer.CharacterAdded:Connect(function()
			if morphTarget ~= "" then
				cmd.run({"char", morphTarget})
			end
		end))
		if morphTarget ~= "" then
			cmd.run({"char", morphTarget})
		end
	else
		NAlib.disconnect("autochartoggle")
	end
end)

NAgui.addButton("Re-select Character (BETA)", function()
	if NA_GRAB_BODY and NA_GRAB_BODY.pickOverride then
		Spawn(function()
			NA_GRAB_BODY.pickOverride()
		end)
	end
end)

NAgui.addSection("Character Light")
NAgui.addSlider("Range",      0,  120, settingsLight.range,      0.1,   "", function(val) settingsLight.range      = val end)
NAgui.addSlider("Brightness", 0,   100, settingsLight.brightness, 0.5,   "", function(val) settingsLight.brightness = val end)
NAgui.addColorPicker("Color",  settingsLight.color, function(col) settingsLight.color = col end)
NAgui.addButton("Apply Light", function()
	local root = getRoot(Player.Character)
	if not root then return end
	local light = settingsLight.LIGHTER
	if not light or not light.Parent then
		light = InstanceNew("PointLight")
		settingsLight.LIGHTER = light
	end
	light.Parent     = root
	light.Range      = settingsLight.range
	light.Brightness = settingsLight.brightness
	light.Color      = settingsLight.color
end)
NAgui.addButton("Remove Light", function()
	if settingsLight.LIGHTER then
		settingsLight.LIGHTER:Destroy()
		settingsLight.LIGHTER = nil
	end
end)

NAgui.addSection("Movement Tweaks")
local currentHum = getHum(getChar())
local wsDefault = (currentHum and currentHum.WalkSpeed) or 16
local jpDefault = (currentHum and currentHum.JumpPower) or 50
NAgui.addSlider("WalkSpeed", 0, 150, wsDefault, 1, " u/s", function(v)
	NAmanage.ApplyWalkSpeed(v)
end)
NAgui.addSlider("JumpPower", 0, 150, jpDefault, 1, "", function(v)
	NAmanage.ApplyJump(v)
end)
NAgui.addButton("Reset Speed/Jump", function()
	NAmanage.ApplyWalkSpeed(16)
	NAmanage.ApplyJump(50)
	DoNotif("WalkSpeed/Jump reset to defaults", 2)
end)
NAgui.addToggle("Noclip", NAStuff.CharacterNoclip == true, function(state)
	NAStuff.CharacterNoclip = state and true or false
	if state then
		cmd.run({"noclip"})
	else
		cmd.run({"clip"})
	end
end)

NAgui.addSection("Character Cleanup")
NAgui.addButton("Remove Accessories", function()
	local hum = getHum(getChar())
	local char = hum and hum.Parent
	if not char then
		DoNotif("Character not found.", 2)
		return
	end
	local removed = 0
	for _, child in ipairs(char:GetChildren()) do
		if child:IsA("Accessory") then
			removed += 1
			child:Destroy()
		end
	end
	DoNotif(removed > 0 and ("Removed "..removed.." accessory(ies).") or "No accessories to remove.", 2)
end)

NAmanage.SetupBasicInfoTab = function()
	local previousTab = NAgui.getActiveTab()
	NAgui.addTab(TAB_BASIC_INFO, { order = 12, textIcon = "circle-i" })
	NAgui.setTab(TAB_BASIC_INFO)

	local basicInfoConfig = {
		{
			title = "Player";
			fields = {
				{ id = "playerDisplayName", label = "Display Name", path = {"player","displayName"} };
				{ id = "playerUsername", label = "Username", path = {"player","username"} };
				{ id = "playerUserId", label = "UserId", path = {"player","userId"} };
				{ id = "playerAccountAge", label = "Account Age", path = {"player","accountAge"} };
				{ id = "playerMembership", label = "Membership", path = {"player","membership"} };
				{ id = "playerTeam", label = "Team", path = {"player","team"} };
			};
		},
		{
			title = "Platform";
			fields = {
				{ id = "platformName", label = "Platform", path = {"platform","platform"} };
				{ id = "executorName", label = "Executor", path = {"platform","executor"} };
				{ id = "platformDevice", label = "Device", path = {"platform","device"} };
			};
		},
		{
			title = "Game";
			fields = {
				{ id = "gameName", label = "Game Name", path = {"game","name"} };
				{ id = "gameCreator", label = "Creator", path = {"game","creator"} };
				{ id = "gameGenre", label = "Genre", path = {"game","genre"} };
				{ id = "placeVersion", label = "Place Version", path = {"game","placeVersion"} };
			};
		},
		{
			title = "Identifiers";
			fields = {
				{ id = "placeId", label = "Place ID", path = {"ids","placeId"} };
				{ id = "gameId", label = "Game ID", path = {"ids","gameId"} };
				{ id = "jobId", label = "Job ID", path = {"ids","jobId"} };
			};
		},
		{
			title = "Server";
			fields = {
				{ id = "serverPlayers", label = "Players", path = {"server","playerCount"} };
				{ id = "serverPing", label = "Ping", path = {"server","ping"} };
			};
		},
		{
			title = "System";
			fields = {
				{ id = "robloxLocale", label = "Roblox Locale", path = {"system","robloxLocale"} };
				{ id = "systemLocale", label = "System Locale", path = {"system","systemLocale"} };
				{ id = "qualitySetting", label = "Graphics Quality", path = {"system","quality"} };
				{ id = "voiceStatus", label = "Voice Chat", path = {"system","voice"} };
				{ id = "screenResolution", label = "Resolution", path = {"system","resolution"} };
			};
		},
		{
			title = "Session";
			fields = {
				{ id = "sessionUptime", label = "Session Uptime", path = {"session","uptime"} };
			};
		},
		{
			title = "Flags";
			fields = {
				{ id = "naVersion", label = "NA Version", path = {"flags","version"} };
				{ id = "aprilMode", label = "April Fools Mode", path = {"flags","aprilFools"} };
				{ id = "timestamp", label = "Timestamp", path = "timestamp" };
			};
		},
	}

	local basicInfoBoxes = {}

	local function resolveValue(snapshot, path)
		local current = snapshot
		if type(path) == "table" then
			for _, key in ipairs(path) do
				if current == nil then
					break
				end
				current = current[key]
			end
		elseif path ~= nil then
			current = current and current[path] or nil
		end
		if current == nil or current == "" then
			return "Unknown"
		end
		return tostring(current)
	end

	for _, section in ipairs(basicInfoConfig) do
		if NAgui.addSection then
			NAgui.addSection(section.title)
		end
		for _, field in ipairs(section.fields) do
			local box = NAgui.addInfo(field.label, "")
			if box then
				box.TextXAlignment = Enum.TextXAlignment.Left
				box.TextYAlignment = Enum.TextYAlignment.Center
				box.TextWrapped = false
				box.TextScaled = false
				box.Selectable = true
				box.Active = true
				local frame = box.Parent
			end
			basicInfoBoxes[field.id] = box
		end
	end

	local function refreshBasicInfo()
		local snapshot = NAmanage.GetBasicInfoSnapshot()
		for _, section in ipairs(basicInfoConfig) do
			for _, field in ipairs(section.fields) do
				local box = basicInfoBoxes[field.id]
				if box then
					local value = resolveValue(snapshot, field.path)
					box.Text = value
				end
			end
		end
	end

	NAgui.RefreshBasicInfo = refreshBasicInfo
	refreshBasicInfo()
	NAgui.addButton("Refresh Basic Info", refreshBasicInfo)

	local updateInterval = 1
	if not NAgui.BasicInfoUpdate then
		NAgui.BasicInfoUpdate = { interval = updateInterval, last = 0 }
		NAgui.BasicInfoUpdate.conn = RunService.Heartbeat:Connect(function()
			local data = NAgui.BasicInfoUpdate
			if not data then
				return
			end
			if not TabManager or TabManager.current ~= TAB_BASIC_INFO then
				return
			end
			local now = tick()
			if now - data.last >= data.interval then
				data.last = now
				refreshBasicInfo()
			end
		end)
	else
		NAgui.BasicInfoUpdate.interval = updateInterval
	end

	if previousTab and previousTab ~= TAB_BASIC_INFO then
		NAgui.setTab(previousTab)
	end
end
NAmanage.SetupBasicInfoTab()

NAgui.addTab(TAB_ROBLOX_DATA, { order = 13, textIcon = "tilt" })
NAgui.setTab(TAB_ROBLOX_DATA)

NAStuff.GitHubLoadingText = "Loading..."
NAStuff.GitHubFailureText = "Failed to load commits"
NAStuff.GitHubEmptyText = "No commits found"
NAStuff.GitHubEndpointField = nil
NAStuff.GitHubCommits = nil
NAStuff.GitHubCommitMessageField = nil
NAStuff.GitHubCommitAuthorField = nil
NAStuff.GitHubCommitDateField = nil
NAStuff.GitHubCommitsLastFetch = 0
NAStuff.GitHubTabInitialized = false
NAStuff.GitHubCommitHeaders = {
	["Accept"] = "application/vnd.github+json";
	["X-GitHub-Api-Version"] = "2022-11-28";
}

if getgenv and rawget(getgenv(), "GITHUB_TOKEN") then
	local token = tostring(getgenv().GITHUB_TOKEN)
	if token ~= "" then
		NAStuff.GitHubCommitHeaders["Authorization"] = "Bearer "..token
	end
elseif getgenv and rawget(getgenv(), "GITHUB_AUTH") then
	local auth = tostring(getgenv().GITHUB_AUTH)
	if auth ~= "" then
		NAStuff.GitHubCommitHeaders["Authorization"] = auth
	end
end

NAStuff.RobloxVersionEndpoints = {
	"https://weao.xyz/api/versions/current";
	"http://weao.xyz/api/versions/current";
}

if getgenv and rawget(getgenv(), "WEAO_PROXY") and getgenv().WEAO_PROXY ~= "" then
	Insert(NAStuff.RobloxVersionEndpoints, tostring(getgenv().WEAO_PROXY))
end
Insert(NAStuff.RobloxVersionEndpoints, "https://r.jina.ai/http://weao.xyz/api/versions/current")
Insert(NAStuff.RobloxVersionEndpoints, "https://r.jina.ai/http://weao.xyz/api/versions/current?format=json")

NAStuff.RobloxVersionHeaders = {
	["User-Agent"] = "WEAO-3PService";
	["Accept"] = "application/json";
	["Origin"] = "https://weao.xyz";
	["Referer"] = "https://weao.xyz/";
}

if getgenv and rawget(getgenv(), "WEAO_COOKIE") and getgenv().WEAO_COOKIE ~= "" then
	NAStuff.RobloxVersionHeaders["Cookie"] = getgenv().WEAO_COOKIE
end

originalIO.parseRobloxVersionBody=function(body)
	if type(body) ~= "string" then return nil end
	if body:sub(1,3) == "\239\187\191" then body = body:sub(4) end
	local ok, decoded = pcall(HttpService.JSONDecode, HttpService, body)
	if ok and type(decoded) == "table" then return decoded end
	local a,depth,inStr,esc=nil,0,false,false
	for i=1,#body do
		local c=body:sub(i,i)
		if inStr then
			if esc then esc=false elseif c=="\\" then esc=true elseif c=='"' then inStr=false end
		else
			if c=='"' then inStr=true
			elseif c=='{' then depth=depth+1 a=a or i
			elseif c=='}' and depth>0 then
				depth=depth-1
				if depth==0 and a then
					local ok2, j = pcall(HttpService.JSONDecode, HttpService, body:sub(a,i))
					if ok2 and type(j)=="table" then return j end
				end
			end
		end
	end
	return nil
end

originalIO.fetchGitHubCommits = function(forceRefresh)
	local cached = NAStuff.GitHubCommits
	local lastFetch = NAStuff.GitHubCommitsLastFetch or 0
	if cached and not forceRefresh and (tick() - lastFetch) < 300 then
		return true, cached
	end

	local requestFunc = opt and opt.NAREQUEST
	if type(requestFunc) ~= "function" then
		return false, "HTTP request function is unavailable"
	end

	local baseUrl = opt and opt.githubUrl
	if type(baseUrl) ~= "string" or baseUrl == "" then
		return false, "GitHub URL is not configured"
	end

	local endpoints = {}
	local function appendEndpoint(url)
		if url and url ~= "" then
			Insert(endpoints, url)
		end
	end

	appendEndpoint(baseUrl)

	if not baseUrl:lower():find("^https?://r%.jina%.ai/") then
		appendEndpoint("https://r.jina.ai/"..baseUrl)
	end

	if getgenv and rawget(getgenv(), "GITHUB_PROXY") then
		local proxy = tostring(getgenv().GITHUB_PROXY)
		if proxy ~= "" then
			appendEndpoint(proxy)
		end
	end

	local headers = {}
	for key, value in pairs(NAStuff.GitHubCommitHeaders or {}) do
		headers[key] = value
	end

	local lastError
	for _, endpoint in ipairs(endpoints) do
		local sep = endpoint:find("?", 1, true) and "&" or "?"
		local cacheBuster = "_="..tostring(os.time())..tostring(math.random(1, 1e6))
		local url = endpoint..sep..cacheBuster
		local okRequest, response = pcall(requestFunc, {
			Url = url;
			Method = "GET";
			Headers = headers;
			Timeout = 8;
			FollowRedirects = true;
			SslVerify = false;
		})
		if okRequest and response then
			local status = tonumber(response.StatusCode) or tonumber(response.Status)
			local body = response.Body or response.body
			if status == 200 and type(body) == "string" then
				local decodeOk, decoded = pcall(HttpService.JSONDecode, HttpService, body)
				if decodeOk and type(decoded) == "table" then
					NAStuff.GitHubCommits = decoded
					NAStuff.GitHubCommitsLastFetch = tick()
					return true, decoded
				else
					lastError = "Invalid JSON response"
				end
			elseif status == 304 and cached then
				NAStuff.GitHubCommitsLastFetch = tick()
				return true, cached
			else
				local statusText = status and tostring(status) or "unknown"
				lastError = Format("GitHub request failed (HTTP %s)", statusText)
			end
		else
			local err = okRequest and "Unknown response error" or tostring(response)
			lastError = err
		end
	end

	if type(baseUrl) == "string" and baseUrl ~= "" then
		local sep = baseUrl:find("?", 1, true) and "&" or "?"
		local cacheBuster = "_="..tostring(os.time())..tostring(math.random(1, 1e6))
		local directUrl = baseUrl..sep..cacheBuster
		local okDirect, bodyDirect = pcall(function()
			return HttpService:GetAsync(directUrl)
		end)
		if okDirect and type(bodyDirect) == "string" then
			local decodeOk, decoded = pcall(HttpService.JSONDecode, HttpService, bodyDirect)
			if decodeOk and type(decoded) == "table" then
				NAStuff.GitHubCommits = decoded
				NAStuff.GitHubCommitsLastFetch = tick()
				return true, decoded
			end
		end
	end

	return false, lastError or NAStuff.GitHubFailureText
end

originalIO.sanitizeCommitMessage = function(message)
	message = tostring(message or "(no message)")
	message = message:gsub("[%c]", " ")
	message = message:gsub("%s+", " ")
	if #message > 70 then
		message = message:sub(1, 67).."..."
	end
	return message
end

originalIO.formatCommitAuthor = function(commit)
	if type(commit) ~= "table" then
		return "Unknown author"
	end
	local commitInfo = commit.commit or {}
	local authorInfo = commitInfo.author or {}
	local fallbackAuthor = commit.author or {}
	local nickname = authorInfo.name
	local username = fallbackAuthor.login
	if nickname and username then
		if nickname == username then
			return nickname
		else
			return Format("%s (%s)", nickname, username)
		end
	elseif nickname then
		return nickname
	elseif username then
		return username
	end
	return "Unknown author"
end

originalIO.formatCommitDate = function(isoDate)
	if type(isoDate) ~= "string" then
		return "Unknown date", nil
	end
	local year, month, day, hour, minute = isoDate:match("^(%d+)%-(%d+)%-(%d+)T(%d+):(%d+)")
	if year and month and day and hour and minute then
		local display = Format("%02d/%02d/%s %s:%s UTC", tonumber(month), tonumber(day), year, hour, minute)
		local shortDate = Format("%02d/%02d/%s", tonumber(month), tonumber(day), year)
		return display, shortDate
	end
	return isoDate, nil
end

NAmanage.FormatGitHubCommitSummary = function(commit)
	if type(commit) ~= "table" then
		return NAStuff.GitHubFailureText
	end
	local sha = commit.sha and tostring(commit.sha):sub(1, 7) or "unknown"
	local commitInfo = commit.commit or {}
	local message = originalIO.sanitizeCommitMessage(commitInfo.message)
	return Format("%s (%s)", message, sha)
end

NAmanage.UpdateGitHubCommitUI = function(commits, statusMessage)
	commits = commits or NAStuff.GitHubCommits
	local commit = (type(commits) == "table" and commits[1]) or nil
	local messageField = NAStuff.GitHubCommitMessageField
	local authorField = NAStuff.GitHubCommitAuthorField
	local dateField = NAStuff.GitHubCommitDateField

	local endpointField = NAStuff.GitHubEndpointField
	if endpointField then
		endpointField.Text = (type(opt.githubUrl) == "string" and opt.githubUrl ~= "" and opt.githubUrl) or "Unavailable"
	end

	if commit then
		local message = NAmanage.FormatGitHubCommitSummary(commit)
		local authorDisplay = originalIO.formatCommitAuthor(commit)
		local commitInfo = commit.commit or {}
		local authorInfo = commitInfo.author or commitInfo.committer or {}
		local dateDisplay, shortDate = originalIO.formatCommitDate(authorInfo.date)

		if messageField then
			messageField.Text = message or NAStuff.GitHubEmptyText
		end
		if authorField then
			authorField.Text = authorDisplay or NAStuff.GitHubEmptyText
		end
		if dateField then
			dateField.Text = dateDisplay or NAStuff.GitHubEmptyText
		end

		if shortDate then
			opt.NAupdDate = shortDate
		end
	else
		local fallback = statusMessage or NAStuff.GitHubEmptyText
		if messageField then
			messageField.Text = fallback
		end
		if authorField then
			authorField.Text = fallback
		end
		if dateField then
			dateField.Text = fallback
		end
	end
end

NAmanage.RefreshGitHubCommits = function(forceRefresh)
	local ok, result = originalIO.fetchGitHubCommits(forceRefresh)
	if ok then
		NAmanage.UpdateGitHubCommitUI(result)
	else
		local message = result or NAStuff.GitHubFailureText
		if type(message) == "string" and #message > 128 then
			message = message:sub(1, 125).."..."
		end
		warn("[NA] GitHub commit fetch failed:", message)
		NAmanage.UpdateGitHubCommitUI(nil, "Error: "..message)
	end
	return ok
end

NAmanage.UpdateAdminInfoTabDisplayName = function()
	if not TabManager or not TabManager.tabs then return end
	local info = TabManager.tabs[TAB_ADMIN_INFO]
	if not info then return end
	local displayText = (adminName or "Admin").." Info"
	info.displayName = displayText
	if originalIO.applyTabDisplayText then
		originalIO.applyTabDisplayText(info, { isActive = info._isActive })
	elseif info.button then
		local title = info.button:FindFirstChild("Title")
		if title then
			title.Text = displayText
		end
	end
end

originalIO.fetchRobloxVersionData=function(forceRefresh)
	local cached = NAStuff.RobloxVersionData
	local lastFetch = NAStuff.RobloxVersionLastFetch or 0
	if cached and not forceRefresh and (tick() - lastFetch) < 300 then
		return true, cached
	end

	local requestFunc = opt and opt.NAREQUEST
	for _, baseUrl in ipairs(NAStuff.RobloxVersionEndpoints) do
		if baseUrl and baseUrl ~= "" then
			local url = baseUrl..((Find(baseUrl, "?", 1, true) and "&" or "?").."_="..tostring(os.time())..tostring(math.random(1,1e6)))
			if requestFunc then
				local ok1, response = pcall(requestFunc, { Url = url; Method = "GET"; Headers = NAStuff.RobloxVersionHeaders; Timeout = 6; FollowRedirects = true; SslVerify = false; })
				if ok1 and response then
					local body = response.Body or response.body or response.Data or response.data or response.Text or response.text or response.Content or response.content or response[1]
					body = tostring(body or "")
					local decoded = originalIO.parseRobloxVersionBody(body)
					if decoded then
						NAStuff.RobloxVersionData = decoded
						NAStuff.RobloxVersionLastFetch = tick()
						return true, decoded
					end
				end
				local ok2, response2 = pcall(requestFunc, { Url = url; Method = "GET"; Headers = {["Accept"]="application/json"}; Timeout = 6; FollowRedirects = true; SslVerify = false; })
				if ok2 and response2 then
					local body2 = response2.Body or response2.body or response2.Data or response2.data or response2.Text or response2.text or response2.Content or response2.content or response2[1]
					body2 = tostring(body2 or "")
					local decoded2 = originalIO.parseRobloxVersionBody(body2)
					if decoded2 then
						NAStuff.RobloxVersionData = decoded2
						NAStuff.RobloxVersionLastFetch = tick()
						return true, decoded2
					end
				end
			end
			local ok3, body3 = pcall(function() return game and game.HttpGet and game:HttpGet(url) end)
			if ok3 and type(body3) == "string" then
				local decoded3 = originalIO.parseRobloxVersionBody(body3)
				if decoded3 then
					NAStuff.RobloxVersionData = decoded3
					NAStuff.RobloxVersionLastFetch = tick()
					return true, decoded3
				end
			end
		end
	end

	return false, cached
end

NAStuff.RobloxVersionLoadingText = "Loading..."
NAStuff.RobloxVersionMissingText = "Unavailable"
NAStuff.RobloxVersionFailureText = "Failed to load"

NAStuff.RobloxVersionRows = {}
originalIO.addRobloxVersionSection=function(sectionTitle, versionKey, dateKey)
	NAgui.addSection(sectionTitle)
	local versionField = NAgui.addInfo("Version", NAStuff.RobloxVersionLoadingText)
	local updatedField = NAgui.addInfo("Last Updated", NAStuff.RobloxVersionLoadingText)
	Insert(NAStuff.RobloxVersionRows, {
		versionKey = versionKey;
		dateKey = dateKey;
		versionField = versionField;
		dateField = updatedField;
	})
end

NAgui.addSection("Powered by weao.xyz API")
originalIO.addRobloxVersionSection("Windows", "Windows", "WindowsDate")
originalIO.addRobloxVersionSection("Mac", "Mac", "MacDate")
originalIO.addRobloxVersionSection("Android", "Android", "AndroidDate")
originalIO.addRobloxVersionSection("iOS", "iOS", "iOSDate")

SpawnCall(function()
	local ok, data = originalIO.fetchRobloxVersionData()
	local fallbackText = ok and NAStuff.RobloxVersionMissingText or NAStuff.RobloxVersionFailureText
	for _, entry in ipairs(NAStuff.RobloxVersionRows) do
		if entry.versionField then
			local v = (type(data) == "table" and data[entry.versionKey]) or fallbackText
			entry.versionField.Text = v and tostring(v) or fallbackText
		end
		if entry.dateField then
			local d = (type(data) == "table" and data[entry.dateKey]) or fallbackText
			entry.dateField.Text = d and tostring(d) or fallbackText
		end
	end
end)

NAgui.addTab(TAB_ADMIN_INFO, { order = 14, displayText = adminInfoDisplay })
NAgui.setTab(TAB_ADMIN_INFO)

if NAmanage.UpdateAdminInfoTabDisplayName then
	NAmanage.UpdateAdminInfoTabDisplayName()
end

if not NAStuff.GitHubTabInitialized then
	NAgui.addSection("Latest Commit")
	NAStuff.GitHubCommitMessageField = NAgui.addInfo("Commit", NAStuff.GitHubLoadingText)
	NAStuff.GitHubCommitAuthorField = NAgui.addInfo("Author", NAStuff.GitHubLoadingText)
	NAStuff.GitHubCommitDateField = NAgui.addInfo("Updated", NAStuff.GitHubLoadingText)

	NAgui.addButton("Refresh Commits", function()
		NAmanage.UpdateGitHubCommitUI(nil, NAStuff.GitHubLoadingText)
		SpawnCall(function()
			local ok, result = originalIO.fetchGitHubCommits(true)
			if ok then
				NAmanage.UpdateGitHubCommitUI(result)
				if DoNotif then
					DoNotif("GitHub commits updated.", 2)
				end
			else
				local message = result or NAStuff.GitHubFailureText
				if type(message) == "string" and #message > 128 then
					message = message:sub(1, 125).."..."
				end
				warn("[NA] GitHub commit refresh failed:", message)
				NAmanage.UpdateGitHubCommitUI(nil, "Error: "..tostring(message))
				if DoNotif then
					DoNotif("Failed to refresh GitHub commits.", 3)
				end
			end
		end)
	end)

	NAStuff.GitHubTabInitialized = true
end

NAmanage.UpdateGitHubCommitUI(nil, NAStuff.GitHubLoadingText)

SpawnCall(function()
	NAmanage.RefreshGitHubCommits(false)
end)

NAgui.setTab(NAgui.getActiveTab())

NAgui.setTab(TAB_CHAT)


NAgui.addSection("Chat Tag Customization | disabled for fixing")

--[[NAgui.addInput("Tag Text", "Enter your tag", opt.currentTagText, function(inputText)
	opt.currentTagText = inputText
end)

NAgui.addColorPicker("Tag Color", opt.currentTagColor, function(color)
	opt.currentTagColor = color
end)

NAgui.addToggle("Rainbow Name", opt.currentTagRGB, function(state)
	opt.currentTagRGB = state
end)

NAgui.addButton("Apply Chat Tag", function()
	if opt.currentTagText == "" or not opt.currentTagText then
		DoNotif("Please enter a tag name before applying",2)
		return
	end

	LocalPlayer:SetAttribute("CustomNAtaggerText", opt.currentTagText)
	LocalPlayer:SetAttribute("CustomNAtaggerColor", opt.currentTagColor)
	LocalPlayer:SetAttribute("CustomNAtaggerRainbow", opt.currentTagRGB)

	if FileSupport then
		writefile(NAfiles.NACHATTAG, HttpService:JSONEncode({
			Text = opt.currentTagText;
			Color = {
				R = opt.currentTagColor.R;
				G = opt.currentTagColor.G;
				B = opt.currentTagColor.B;
			};
			RGB = opt.currentTagRGB;
			Save = true;
		}))
	end

	DebugNotif("Custom chat tag applied and saved!",2.5)
end)

NAgui.addButton("Remove Chat Tag", function()
	LocalPlayer:SetAttribute("CustomNAtaggerText", nil)
	LocalPlayer:SetAttribute("CustomNAtaggerColor", nil)
	LocalPlayer:SetAttribute("CustomNAtaggerRainbow", nil)

	if FileSupport and isfile(NAfiles.NACHATTAG) then
		writefile(NAfiles.NACHATTAG, HttpService:JSONEncode({
			Text = opt.currentTagText;
			Color = { R = opt.currentTagColor.R, G = opt.currentTagColor.G, B = opt.currentTagColor.B };
			RGB = opt.currentTagRGB;
			Save = false;
		}))
	end

	DebugNotif("Custom chat tag removed.",2.5)
end)]]

NAgui.setTab(TAB_ALL)

SpawnCall(function()
	Wait()
	if TabManager and TabManager.current ~= TAB_ALL then
		NAgui.setTab(TAB_ALL)
	end
end)

pcall(function()
	if NAAssetsLoading and NAAssetsLoading.setStatus and NAAssetsLoading.setPercent and NAAssetsLoading.completed then
		NAAssetsLoading.setStatus("ready")
		NAAssetsLoading.setPercent(1)
		NAAssetsLoading.completed.Value = true
	end
	if NAStuff.AutoPreloadAssets then
		Defer(function()
			Wait(0.1)
			NAmanage.StartAssetPreload({silent = true})
		end)
	end
end)

--[[print(
	
███╗░░██╗░█████╗░███╗░░░███╗███████╗██╗░░░░░███████╗░██████╗░██████╗
████╗░██║██╔══██╗████╗░████║██╔════╝██║░░░░░██╔════╝██╔════╝██╔════╝
██╔██╗██║███████║██╔████╔██║█████╗░░██║░░░░░█████╗░░╚█████╗░╚█████╗░
██║╚████║██╔══██║██║╚██╔╝██║██╔══╝░░██║░░░░░██╔══╝░░░╚═══██╗░╚═══██╗
██║░╚███║██║░░██║██║░╚═╝░██║███████╗███████╗███████╗██████╔╝██████╔╝
╚═╝░░╚══╝╚═╝░░╚═╝╚═╝░░░░░╚═╝╚══════╝╚══════╝╚══════╝╚═════╝░╚═════╝░

░█████╗░██████╗░███╗░░░███╗██╗███╗░░██╗
██╔══██╗██╔══██╗████╗░████║██║████╗░██║
███████║██║░░██║██╔████╔██║██║██╔██╗██║
██╔══██║██║░░██║██║╚██╔╝██║██║██║╚████║
██║░░██║██████╔╝██║░╚═╝░██║██║██║░╚███║
╚═╝░░╚═╝╚═════╝░╚═╝░░░░░╚═╝╚═╝╚═╝░░╚══╝

)]]
