if getgenv().RealNamelessLoaded~=nil then return end
pcall(function() getgenv().RealNamelessLoaded=true; getgenv().NATestingVer=false; end)

NAbegin=tick()
CMDAUTOFILL = {}

local Lower = string.lower;
local Sub = string.sub;
local GSub = string.gsub;
local Find = string.find;
local Match = string.match;
local Format = string.format;
local Unpack = table.unpack;
local Insert = table.insert;
local Spawn = task.spawn;
local Delay = task.delay;
local Wait = task.wait;
local Discover = table.find;
local Concat = table.concat;
local Defer = task.defer;

local Notify = nil
local Window = nil
local Popup  = nil

local TAB_ALL = "All"
local TAB_GENERAL = "General"
local TAB_INTERFACE = "Interface"
local TAB_LOGGING = "Logging"
local TAB_ESP = "ESP"
local TAB_CHAT = "Chat"
local TAB_CHARACTER = "Character"
local TAB_KEYBINDS = "Keybinds"
local TAB_BASIC_INFO = "Basic Info"
local TAB_ROBLOX_DATA = "Roblox Data"
local TAB_ADMIN_INFO = "Admin Info"

local LoadstringCommandAliases = {
	loadstring = true;
	ls = true;
	lstring = true;
	loads = true;
	execute = true;
};

local function SafeGetService(name, timeoutSeconds)
	local Reference = cloneref or function(ref) return ref end
	local startClock = tick()

	local function timedOut()
		return timeoutSeconds and (tick() - startClock) >= timeoutSeconds
	end

	local okImmediate, serviceImmediate = pcall(game.GetService, game, name)
	if okImmediate and serviceImmediate then
		return Reference(serviceImmediate)
	end

	local function waitForGameLoaded()
		while true do
			local okLoaded, isLoaded = pcall(game.IsLoaded, game)
			if not okLoaded or isLoaded then
				return true
			end
			if timedOut() then
				return false
			end

			local loaded = false
			local conn
			local connected = pcall(function()
				conn = game.Loaded:Connect(function()
					loaded = true
				end)
			end)

			if connected and conn then
				while not loaded do
					if timedOut() then
						conn:Disconnect()
						return false
					end
					local dt = Wait(0.05)
					if not dt then dt = 0.05 end
				end
				conn:Disconnect()
				return true
			end

			local dt = Wait(0.05)
			if not dt then dt = 0.05 end
		end
	end

	if not waitForGameLoaded() then
		return nil
	end

	while true do
		local okService, service = pcall(game.GetService, game, name)
		if okService and service then
			return Reference(service)
		end

		if timedOut() then
			return nil
		end

		if not waitForGameLoaded() then
			return nil
		end

		local dt = Wait(0.05)
		if not dt then dt = 0.05 end
	end
end

local SpawnCall=function(pp)Spawn(function() pcall(pp) end)end -- idk why but solara just fucked up when executing scripts (this is a sort of a fix ig)

local mainName = 'Nameless Admin'
local testingName = 'NA Testing'
local adminName = 'NA'
local connections = {}
local HttpService=SafeGetService('HttpService');
local Players=SafeGetService("Players");
local UserInputService=SafeGetService("UserInputService");
local TweenService=SafeGetService("TweenService");
local RunService=SafeGetService("RunService");
local TeleportService=SafeGetService("TeleportService");
local Lighting=SafeGetService("Lighting");
local ReplicatedStorage=SafeGetService("ReplicatedStorage");
local COREGUI=SafeGetService("CoreGui");
local TextChatService = SafeGetService("TextChatService");
local TextService = SafeGetService("TextService");
local StarterGui = SafeGetService("StarterGui");
local LocalizationService = SafeGetService("LocalizationService");
local MarketplaceService = SafeGetService("MarketplaceService");

local CustomFunctionSupport = isfile and isfolder and writefile and readfile and listfiles and appendfile;
local FileSupport = isfile and isfolder and writefile and readfile and makefolder;

local IsOnMobile=(function()
	local platform=UserInputService:GetPlatform()
	if platform==Enum.Platform.IOS or platform==Enum.Platform.Android or platform==Enum.Platform.AndroidTV or platform==Enum.Platform.Chromecast or platform==Enum.Platform.MetaOS then
		return true
	end
	if platform==Enum.Platform.None then
		return UserInputService.TouchEnabled and not (UserInputService.KeyboardEnabled or UserInputService.MouseEnabled)
	end
	return false
end)()
local IsOnPC=(function()
	local platform=UserInputService:GetPlatform()
	if platform==Enum.Platform.Windows or platform==Enum.Platform.OSX or platform==Enum.Platform.Linux or platform==Enum.Platform.SteamOS or platform==Enum.Platform.UWP or platform==Enum.Platform.DOS or platform==Enum.Platform.BeOS then
		return true
	end
	if platform==Enum.Platform.None then
		return UserInputService.KeyboardEnabled or UserInputService.MouseEnabled
	end
	return false
end)()

local originalIO = {}

originalIO.captureIO=function(name)
	local fn = rawget(_G, name)
	if type(fn) == "function" then
		originalIO[name] = fn
	end
end

if not originalIO.__captured then
	originalIO.__captured = true
	originalIO.captureIO('readfile')
	originalIO.captureIO('writefile')
	originalIO.captureIO('appendfile')
	originalIO.captureIO('listfiles')
	originalIO.captureIO('makefolder')
	originalIO.captureIO('delfile')
	originalIO.captureIO('delfolder')
	originalIO.captureIO('isfile')
	originalIO.captureIO('isfolder')
end

originalIO.pathVariants=function(path)
	if type(path) ~= "string" then
		return { path }
	end
	if path:match('^[%w_]+://') then
		return { path }
	end
	local variants, seen = {}, {}
	local function add(value)
		if type(value) == "string" and value ~= "" and not seen[value] then
			seen[value] = true
			Insert(variants, value)
		end
	end
	add(path)
	add(path:gsub('\\+', '\\'))
	add(path:gsub('//+', '/'))
	add(path:gsub('/', '\\'))
	add(path:gsub('\\', '/'))
	local trimmed = path:gsub('^%.[/\]+', '')
	if trimmed ~= path then
		add(trimmed)
		add(trimmed:gsub('/', '\\'))
		add(trimmed:gsub('\\', '/'))
	end
	return variants
end

originalIO.resolveWithListfiles=function(target)
	local lf = originalIO.listfiles
	if type(lf) ~= "function" then
		return nil
	end
	local dir, filename = target:match('^(.*)[/\\]([^/\\]+)$')
	if not dir or filename == '' then
		return nil
	end
	local dirVariants = originalIO.pathVariants(dir)
	local results = {}
	local lowered = filename:lower()
	for _, candidateDir in ipairs(dirVariants) do
		local ok, entries = pcall(lf, candidateDir)
		if ok and type(entries) == "table" then
			for _, entry in ipairs(entries) do
				local name = entry:match('([^/\\]+)$')
				if name and name:lower() == lowered then
					Insert(results, entry)
				end
			end
		end
	end
	if #results > 0 then
		return results
	end
	return nil
end

if identifyexecutor and (identifyexecutor():lower()=="solara" or identifyexecutor():lower()=="xeno") then
	if not getgenv()["__NA_SOLARA_PATH_FIX__"] then
		getgenv()["__NA_SOLARA_PATH_FIX__"] = true

		local function wrapWithFallback(fn, returnsBool, allowListResolve)
			if type(fn) ~= "function" then
				return nil
			end
			return function(path, ...)
				if type(path) ~= "string" then
					local ok, result = pcall(fn, path, ...)
					if ok then
						return result
					end
					if returnsBool then
						return false
					end
					error(result)
				end

				for _, candidate in ipairs(originalIO.pathVariants(path)) do
					local ok, result = pcall(fn, candidate, ...)
					if ok then
						return result
					end
				end

				if allowListResolve then
					local resolved = originalIO.resolveWithListfiles(path)
					if resolved then
						for _, candidate in ipairs(resolved) do
							local ok, result = pcall(fn, candidate, ...)
							if ok then
								return result
							end
						end
					end
				end

				if returnsBool then
					return false
				end
				error(("failed to access %s"):format(path))
			end
		end

		if originalIO.readfile then
			readfile = wrapWithFallback(originalIO.readfile, false, true)
		end
		if originalIO.writefile then
			writefile = wrapWithFallback(originalIO.writefile, false, true)
		end
		if originalIO.appendfile then
			appendfile = wrapWithFallback(originalIO.appendfile, false, true)
		end
		if originalIO.listfiles then
			listfiles = wrapWithFallback(originalIO.listfiles, false, false)
		end
		if originalIO.makefolder then
			makefolder = wrapWithFallback(originalIO.makefolder, false, true)
		end
		if originalIO.delfile then
			delfile = wrapWithFallback(originalIO.delfile, false, true)
		end
		if originalIO.delfolder then
			delfolder = wrapWithFallback(originalIO.delfolder, false, true)
		end
		if originalIO.isfile then
			isfile = wrapWithFallback(originalIO.isfile, true, true)
		end
		if originalIO.isfolder then
			isfolder = wrapWithFallback(originalIO.isfolder, true, true)
		end
	end
end

local Waypoints = {}
local Bindings = Bindings or {}
local NAStuff = {
	NASCREENGUI = nil; --Getmodel("rbxassetid://140418556029404")
	NAjson = nil;
	nuhuhNotifs = true;
	KeybindConnection = nil;
	ForceAdminRainbow = true;
	tweenSpeed = 1;
	originalDesc = nil;
	currentDesc = nil;
	BlockedRemotes = {};
	touchESPList = {};
	proximityESPList = {};
	clickESPList = {};
	siteESPList = {};
	vehicleSiteESPList = {};
	unanchoredESPList = {};
	collisiontrueESPList = {};
	collisionfalseESPList = {};
	espTriggers = {};
	espNameLists = { exact = {}, partial = {} };
	espNameTriggers = {};
	nameESPPartLists = { exact = {}, partial = {} };
	ESP_RenderMode = "BoxHandleAdornment";
	ESP_LabelTextSize = 12;
	ESP_LabelTextScaled = false;
	ESP_ShowPartDistance = false;
	ESP_LocatorEnabled = false;
	ESP_LocatorSize = 26;
	ESP_LocatorShowText = false;
	ESP_LocatorTextSize = 14;
	ESP_LastExactPart = "";
	ESP_LastPartialPart = "";
	ESP_LastFolderName = "";
	ESP_LocatorGui = nil;
	partESPColors = setmetatable({}, { __mode = "k" });
	partESPGlassOriginal = setmetatable({}, { __mode = "k" });
	partESPGlassCount = setmetatable({}, { __mode = "k" });
	partESPEntries = setmetatable({}, { __mode = "k" });
	partESPVisualMap = setmetatable({}, { __mode = "k" });
	nameESPExclusions = { exact = {}, partial = {} };
	NIL_SENTINEL = {};
	RemoteBlockMode = "fakeok";
	RemoteFakeReturn = true;
	BlockedEventSaved = {};
	BlockedInvokeSaved = {};
	BlockedRemoteModes = {};
	BlockedRemoteReturns = {};
	BlockedSignals = {};
	RemoteFakeReturn = true;
	AntiKickMode = "fakeok";
	AntiKickHooked = false;
	AntiKickOrig = {namecall=nil,index=nil,newindex=nil,kicks={}};
	AntiTeleportMode = "fakeok";
	AntiTeleportHooked = false;
	AntiTeleportOrig = {namecall=nil,index=nil,newindex=nil,funcs={}};
	SYNC_TAG = "ANIM_SYNC";
	CORE_FOLDERS = {idle=true,walk=true,run=true,jump=true,fall=true,climb=true,swim=true,swimidle=true,toolnone=true,toolslash=true,toollunge=true};
	SavedDefaultMap = nil;
	Sync_AnimatePrevDisabled = nil;
	MIMIC_TAG = "MIMIC_SYNC";
	Mimic_AnimatePrevDisabled = nil;
	mimic_uid = 0;
	ChatSettings = {
		customEnabled = false;
		coreGuiChat = true;
		window = {
			enabled = true;
			font = "rbxasset://fonts/families/BuilderSans.json";
			textSize = 16;
			textColor = {235,235,235};
			strokeColor = {0,0,0};
			strokeTransparency = 0.5;
			backgroundColor = {25,27,29};
			backgroundTransparency = 0.2;
		};
		tabs = {
			enabled = false;
			font = "rbxasset://fonts/families/BuilderSans.json";
			textSize = 18;
			backgroundTransparency = 0;
			textColor = {255,255,255};
			selectedTextColor = {170,255,170};
			unselectedTextColor = {200,200,200};
		};
		input = {
			enabled = true;
			autocomplete = true;
			font = "rbxasset://fonts/families/BuilderSans.json";
			keyCode = "Slash";
			textSize = 16;
			textColor = {255,255,255};
			strokeTransparency = 0.5;
			backgroundTransparency = 0.2;
			targetGeneral = false;
		};
		bubbles = {
			enabled = true; -- ENABLED IT SINCE YOU CAN'T STOP CRYING ABOUT IT
			maxDistance = 100;
			minimizeDistance = 20;
			textSize = 14;
			spacing = 4;
			backgroundTransparency = 0.1;
			tailVisible = true;
		};
	};
	ChatSettingsTemplate = nil;
	ChatSettingsDefaults = nil;
	ChatCustomizationActive = nil;
	ChatSettingsCustomBackup = nil;
	IconInvisible = false;
	IconLocked = false;
	_prefetchedRemotes = {};
	AutoExecBlockedCommands = {
		exit = true;
		rejoin = true;
		rj = true;
		serverhop = true;
		shop = true;
		smallserverhop = true;
		sshop = true;
		pingserverhop = true;
		pshop = true;
		saw = true;
	};
	NASettingsSchema = nil;
	NASettingsData = nil;
	elementOriginalParent = setmetatable({}, { __mode = "k" });
	_lastCommand = nil;
	_prevCommand = nil;
	_removeAdsLoop = nil;
	resizeVerticalAsset = nil;
	resizeHorizontalAsset = nil;
	resizeDiagonal1Asset = nil;
	resizeDiagonal2Asset = nil;
}
local interactTbl = { click = {}; proxy = {}; touch = {}; }
local Notification = nil
local inviteLink = "https://discord.gg/zzjYhtMGFD"
local cmd={}
local NAmanage={}
NAmanage.resolveTweenDuration=function(scale)
	local base = tonumber(NAStuff.tweenSpeed) or 1
	if base <= 0 then
		base = 1
	end
	scale = tonumber(scale) or 1
	if scale <= 0 then
		scale = 1
	end
	return math.max(0.05, base * scale)
end
NAmanage._loaderStatus = NAmanage._loaderStatus or {}

NAmanage.loaderWarn=function(label, detail)
	warn(Format('[%s loader] %s: %s', adminName, label, detail))
end

function NAmanage.waitForScreenGui(timeoutSeconds)
	timeoutSeconds = timeoutSeconds or 5
	local deadline = tick() + timeoutSeconds
	repeat
		local gui = NAStuff.NASCREENGUI
		if gui and gui.Parent then
			return gui
		end
		Wait(0.1)
	until tick() >= deadline
	return nil
end

function NAmanage.runLoader(label, callback, opts)
	opts = opts or {}
	local attempts = opts.retries or 3
	local delay = opts.delay or 0.35
	local retryOnFalse = opts.retryOnFalse
	local requireGui = opts.requiresGui
	local guiTimeout = opts.guiTimeout or 5

	if requireGui and not NAmanage.waitForScreenGui(guiTimeout) then
		NAmanage.loaderWarn(label, 'aborted: interface not ready')
		return false
	end

	local lastErr
	for attempt = 1, attempts do
		local ok, result = pcall(callback)
		if ok and (result ~= false or not retryOnFalse) then
			NAmanage._loaderStatus[label] = true
			return true, result
		end

		if ok then
			lastErr = 'callback returned false'
			if retryOnFalse then
				NAmanage.loaderWarn(label, Format('attempt %d/%d returned false', attempt, attempts))
			end
		else
			lastErr = result
			NAmanage.loaderWarn(label, Format('attempt %d/%d failed: %s', attempt, attempts, tostring(result)))
		end

		if attempt < attempts then
			Wait(delay)
			if requireGui then
				local gui = NAmanage.waitForScreenGui(guiTimeout)
				if not gui then
					break
				end
			end
		end
	end

	if opts.onFailure then
		pcall(opts.onFailure, lastErr)
	end
	NAmanage._loaderStatus[label] = false
	return false
end

function NAmanage.scheduleLoader(label, callback, opts)
	Spawn(function()
		NAmanage.runLoader(label, callback, opts)
	end)
end

local searchIndex = {}
local prevVisible, results = {}, {}
local lastSearchText, gen = "", 0
local NAImageAssets = {
	Icon = "NAnew.png";
	sWare = "ScriptWare.png";
	Sheet = "sheet.png";
	Inlet = "Inlet.png";
	Stud = "oldStud.png";
	bk = "SkyBk.png";
	dn = "SkyDn.png";
	ft = "SkyFt.png";
	lf = "SkyLf.png";
	rt = "SkyRt.png";
	up = "SkyUp.png";
	ResizeVertical = "Vertical16x16.png";
	ResizeHorizontal = "Horizontal16x16.png";
	ResizeDiagonal1 = "Diagonal116x16.png";
	ResizeDiagonal2 = "Diagonal216x16.png";
}
local NAfiles = {
	NAFILEPATH = "Nameless-Admin";
	NAWAYPOINTFILEPATH = "Nameless-Admin/Waypoints";
	NAPLUGINFILEPATH = "Nameless-Admin/Plugins";
	NAASSETSFILEPATH = "Nameless-Admin/Assets";
	NAMAINSETTINGSPATH = "Nameless-Admin/Settings.json";
	NAPREFIXPATH = "Nameless-Admin/Prefix.txt";
	NABUTTONSIZEPATH = "Nameless-Admin/ButtonSize.txt";
	NAUISIZEPATH = "Nameless-Admin/UIScale.txt";
	NAQOTPATH = "Nameless-Admin/QueueOnTeleport.txt";
	NAALIASPATH = "Nameless-Admin/Aliases.json";
	NAICONPOSPATH = "Nameless-Admin/IconPosition.json";
	NAUSERBUTTONSPATH = "Nameless-Admin/UserButtons.json";
	NAAUTOEXECPATH = "Nameless-Admin/AutoExecCommands.json";
	NAPREDICTIONPATH = "Nameless-Admin/Prediction.txt";
	NASTROKETHINGY = "Nameless-Admin/NAUIStroker.txt";
	NAJOINLEAVE = "Nameless-Admin/JoinLeave.json";
	NAJOINLEAVELOG = "Nameless-Admin/JoinLeaveLog.txt";
	NACHATLOGS = "Nameless-Admin/ChatLogs.txt";
	--NACHATTAG = "Nameless-Admin/ChatTag.json";
	NATOPBAR = "Nameless-Admin/TopBarApp.txt";
	NANOTIFSTOGGLE = "Nameless-Admin/NotifsTgl.txt";
	NABINDERS = "Nameless-Admin/Binders.json";
	NAESPSETTINGSPATH = "Nameless-Admin/ESPSettings.json";
	NATOPBARMODE = "Nameless-Admin/TopbarMode.txt";
	NATEXTCHATSETTINGSPATH = "Nameless-Admin/TextChatSettings.json";
}
local prefixCheck = ";"
local NAScale = 1
local NAUIScale = 1
local flingManager = { FlingOldPos = nil; lFlingOldPos = nil; cFlingOldPos = nil; }
local settingsLight = { range = 30; brightness = 1; color = Color3.new(1,1,1); LIGHTER = nil; }
local events = {
	"OnSpawn",
	"OnDeath",
	"OnKill",
	"OnDamage",
	"OnChatted",
	"OnJump",
	"OnEquipItem",
	"OnUnequipItem",
	"OnJoin",
	"OnLeave",
}
local opt={
	prefix=prefixCheck;
	NAupdDate='unknown'; --month,day,year
	githubUrl = '';
	loader='';
	NAUILOADER='';
	NAAUTOSCALER=nil;
	NA_storage=nil;--Stupid Ahh script removing folders
	NAREQUEST = request or http_request or (syn and syn.request) or function() end;
	queueteleport=(syn and syn.queue_on_teleport) or queue_on_teleport or (fluxus and fluxus.queue_on_teleport) or function() end;
	hiddenprop=(sethiddenproperty or set_hidden_property or set_hidden_prop) or function() end;
	ctrlModule = nil;
	currentTagText = "Tag";
	currentTagColor = Color3.fromRGB(0, 255, 170);
	currentTagRGB = false;
	chatTranslateEnabled = true;
	chatTranslateTarget = "en";
	--saveTag = false;
}
local morphTarget = ""
NASESSIONSTARTEDIDK = os.clock()
NAlib={}
NAgui={}
NAindex = NAindex or { _init = false }
NAjobs  = NAjobs  or { jobs = {}, hb = nil, seq = 0, _frame = 0, _claimed = {}, _touchState = setmetatable({}, {__mode="k"}) }
NAutil  = NAutil  or {}
NAsuppress = NAsuppress or { ref = setmetatable({}, {__mode="k"}), snap = setmetatable({}, {__mode="k"}) }
NACOLOREDELEMENTS={}
NACOLOREDELEMENTS_SET=setmetatable({}, {__mode="k"})

DEFAULT_UI_STROKE_COLOR=Color3.fromRGB(148,93,255)
COLOR_WHITE=Color3.new(1,1,1)
COLOR_BLACK=Color3.new(0,0,0)

local function FormatAccountAge(days)
	if type(days) ~= "number" then
		return "Unknown"
	end
	if days < 0 then
		days = 0
	end
	local years=math.floor(days/365)
	local remainingDays=days%365
	local months=math.floor(remainingDays/30)
	local finalDays=math.floor(remainingDays%30)
	local parts={}
	if years>0 then parts[#parts+1]=tostring(years).." yr" end
	if months>0 then parts[#parts+1]=tostring(months).." mo" end
	if finalDays>0 or #parts==0 then parts[#parts+1]=tostring(finalDays).." d" end
	return table.concat(parts," ")
end

NAgui.RegisterColoredStroke=function(stroke)
	if typeof(stroke) ~= "Instance" then return end
	if not stroke:IsA("UIStroke") then return end
	if NACOLOREDELEMENTS_SET[stroke] then return end
	NACOLOREDELEMENTS_SET[stroke]=true
	local baseColor=NAUISTROKER or DEFAULT_UI_STROKE_COLOR or stroke.Color
	stroke.Color=baseColor
	Insert(NACOLOREDELEMENTS,stroke)
end

NAgui.RegisterStrokesFrom=function(instance)
	if typeof(instance) ~= "Instance" then return end
	if instance:IsA("UIStroke") then
		NAgui.RegisterColoredStroke(instance)
		return
	end
	for _, descendant in ipairs(instance:GetDescendants()) do
		if descendant:IsA("UIStroke") then
			NAgui.RegisterColoredStroke(descendant)
		end
	end
end

NAgui.ComputeTabStrokeColor=function(isActive)
	local base=NAUISTROKER or DEFAULT_UI_STROKE_COLOR
	if isActive then
		return base:Lerp(COLOR_WHITE,0.22)
	end
	return base:Lerp(COLOR_BLACK,0.12)
end

NAmanage.getTabStrokeColor = NAgui.ComputeTabStrokeColor

NAmanage.GetBasicInfoSnapshot = function()
	local snapshot = {
		player = {};
		platform = {};
		game = {};
		ids = {};
		server = {};
		system = {};
		flags = {};
		timestamp = "";
	}

	local player = Players and Players.LocalPlayer
	local displayName = player and player.DisplayName or "Unknown"
	local username = player and player.Name or "Unknown"
	local userId = player and player.UserId or nil
	local accountAgeDays = player and player.AccountAge or nil
	local membership = "None"
	if player and player.MembershipType == Enum.MembershipType.Premium then
		membership = "Premium"
	end

	snapshot.player.displayName = displayName
	snapshot.player.username = username
	snapshot.player.userId = userId and tostring(userId) or "Unknown"
	snapshot.player.accountAge = FormatAccountAge(accountAgeDays)
	snapshot.player.membership = membership

	local platformName = "Unknown"
	if UserInputService then
		local okPlatform, platformEnum = pcall(UserInputService.GetPlatform, UserInputService)
		if okPlatform and platformEnum then
			platformName = platformEnum.Name or tostring(platformEnum)
		end
	end

	local executorName = "Unknown"
	if identifyexecutor then
		local okExec, execResult = pcall(identifyexecutor)
		if okExec and execResult and execResult ~= "" then
			executorName = execResult
		end
	elseif identifyexec then
		local okExecAlt, execResultAlt = pcall(identifyexec)
		if okExecAlt and execResultAlt and execResultAlt ~= "" then
			executorName = execResultAlt
		end
	end

	snapshot.platform.platform = platformName
	snapshot.platform.executor = executorName

	local robloxLocale = LocalizationService and LocalizationService.RobloxLocaleId or "Unknown"
	local systemLocale = LocalizationService and LocalizationService.SystemLocaleId or "Unknown"

	local qualitySetting = "Auto"
	local okUGS, userGameSettings = pcall(function()
		return UserSettings():GetService("UserGameSettings")
	end)
	if okUGS and userGameSettings then
		local savedQuality = userGameSettings.SavedQualityLevel
		if typeof(savedQuality) == "EnumItem" then
			qualitySetting = savedQuality.Name or tostring(savedQuality)
		elseif savedQuality ~= nil then
			qualitySetting = tostring(savedQuality)
		end
	end

	local voiceStatus = "Unknown"
	local okVoiceService, voiceService = pcall(game.GetService, game, "VoiceChatService")
	if okVoiceService and voiceService and userId then
		local okVoice, voiceEnabled = pcall(function()
			return voiceService:IsVoiceEnabledForUserIdAsync(userId)
		end)
		if okVoice then
			voiceStatus = voiceEnabled and "Enabled" or "Disabled"
		end
	end

	snapshot.system.robloxLocale = robloxLocale
	snapshot.system.systemLocale = systemLocale
	snapshot.system.quality = qualitySetting
	snapshot.system.voice = voiceStatus

	local placeId = tonumber(game.PlaceId) or 0
	local gameId = game.GameId or "Unknown"
	local jobIdValue = game.JobId
	if jobIdValue == nil or jobIdValue == "" then
		jobIdValue = "Unavailable"
	end

	local gameName = "Unknown"
	local creatorName = "Unknown"
	if MarketplaceService then
		local okInfo, infoResult = pcall(MarketplaceService.GetProductInfo, MarketplaceService, placeId)
		if okInfo and type(infoResult) == "table" then
			gameName = infoResult.Name or gameName
			if infoResult.Creator and infoResult.Creator.Name then
				creatorName = infoResult.Creator.Name
			end
		end
	end

	snapshot.game.name = gameName
	snapshot.game.creator = creatorName

	snapshot.ids.placeId = placeId ~= 0 and tostring(placeId) or "Unknown"
	local gameIdText = tostring(gameId)
	if gameIdText == "" or gameIdText == "0" then
		gameIdText = "Unknown"
	end
	snapshot.ids.gameId = gameIdText
	snapshot.ids.jobId = tostring(jobIdValue)

	local playerCount = Players and Players.NumPlayers or 0
	local maxPlayers = Players and Players.MaxPlayers or 0
	snapshot.server.playerCount = string.format("%d/%d", playerCount, maxPlayers)

	local isTesting = getgenv and getgenv().NATestingVer
	local aprilMode = getgenv and getgenv().ActivateAprilMode

	snapshot.flags.version = isTesting and "Testing" or "Normal"
	snapshot.flags.aprilFools = aprilMode and "Enabled" or "Disabled"

	snapshot.timestamp = os.date("%m/%d/%Y | %H:%M:%S")

	return snapshot
end
cmdNAnum=0
NAQoTEnabled = nil
NAiconSaveEnabled = nil
NAUISTROKER = DEFAULT_UI_STROKE_COLOR
NATOPBARVISIBLE = true

if getgenv().NATestingVer then
	opt.loaderUrl = "https://raw.githubusercontent.com/ltseverydayyou/Nameless-Admin/main/NA%20testing.lua"
	opt.githubUrl="https://api.github.com/repos/ltseverydayyou/Nameless-Admin/commits?path=NA%20testing.lua"
	opt.NAUILOADER="https://raw.githubusercontent.com/ltseverydayyou/Nameless-Admin/refs/heads/main/NAUITEST.lua"
else
	opt.loaderUrl = "https://raw.githubusercontent.com/ltseverydayyou/Nameless-Admin/main/Source.lua"
	opt.githubUrl="https://api.github.com/repos/ltseverydayyou/Nameless-Admin/commits?path=Source.lua"
	opt.NAUILOADER="https://raw.githubusercontent.com/ltseverydayyou/Nameless-Admin/refs/heads/main/NAUI.lua"
end

NAlib.connect = function(name, connection)
	connections[name] = connections[name] or {}
	Insert(connections[name], connection)
	return connection
end

NAlib.disconnect = function(name)
	if connections[name] then
		for _, conn in ipairs(connections[name]) do
			conn:Disconnect()
		end
		connections[name] = nil
	end
end

NAlib.isConnected = function(name)
	return connections[name] ~= nil
end

NAlib.isProperty = function(inst, prop)
	local s, r = pcall(function() return inst[prop] end)
	if not s then return nil end
	return r
end

NAlib.setProperty = function(inst, prop, v)
	local s, _ = pcall(function() inst[prop] = v end)
	return s
end

NAmanage.centerFrame = function(f)
	local cam = workspace.CurrentCamera
	local vp = cam.ViewportSize
	local totalX = f.Size.X.Scale + (f.Size.X.Offset / vp.X)
	local totalY = f.Size.Y.Scale + (f.Size.Y.Offset / vp.Y)
	f.Position = UDim2.new(0.5 - totalX/2, 0, 0.5 - totalY/2, 0)
end

NAmanage.guiCHECKINGAHHHHH=function()
	return (gethui and gethui()) or SafeGetService("CoreGui"):FindFirstChildWhichIsA("ScreenGui") or SafeGetService("CoreGui") or SafeGetService("Players").LocalPlayer:FindFirstChildWhichIsA("PlayerGui")
end

if not gethui then
	getgenv().gethui=function()
		return NAmanage.guiCHECKINGAHHHHH()
	end
end

function InstanceNew(c,p)
	local inst = Instance.new(c)
	if p then inst.Parent = p end
	inst.Name = "\0"
	return inst
end

function NACaller(fn, ...)
	local args = {...}
	local function wrapped()
		return fn(unpack(args))
	end
	local t = table.pack(xpcall(wrapped, function(msg)
		return debug.traceback(msg, 2)
	end))
	if not t[1] then
		local err = t[2]
		warn(adminName.." script error:\n"..err)
		Popup({
			Title       = adminName or "Oops!",
			Description = Format("Oops! Something went wrong. If this keeps happening or seems serious, please let the owner know.\n\nDetails:\n%s", err),
			Buttons     = {
				{
					Text = "Copy Error",
					Callback = function()
						if setclipboard then
							setclipboard(err)
							DoNotif("Error details copied to clipboard!")
						else
							DoWindow("Error details:\n"..err)
						end
					end
				},
				{
					Text = "Discord Server",
					Callback = function()
						if setclipboard then
							setclipboard(inviteLink)
							DoNotif("Discord link copied to clipboard!")
						else
							DoWindow("Server Invite: "..inviteLink)
						end
					end
				}
			}
		})
	end
	return Unpack(t, 1, t.n)
end

NAmanage.loaderState = NAmanage.loaderState or {
	autoSkip = false;
	loaded = false;
	settingsPath = "Nameless-Admin/Settings.json";
}

NAmanage.getAutoSkipPreference = function()
	local state = NAmanage.loaderState
	if state.loaded then
		return state.autoSkip
	end
	state.loaded = true
	if not FileSupport then
		state.autoSkip = false
		return state.autoSkip
	end
	if type(isfile) == "function" and isfile(state.settingsPath) then
		local ok, raw = NACaller(readfile, state.settingsPath)
		if ok and type(raw) == "string" and raw ~= "" then
			local decodeOk, decoded = NACaller(function()
				return HttpService:JSONDecode(raw)
			end)
			if decodeOk and typeof(decoded) == "table" then
				local value = decoded.autoSkipLoading
				if type(value) == "boolean" then
					state.autoSkip = value
				end
			end
		end
	end
	return state.autoSkip
end

NAmanage.setAutoSkipPreference = function(enabled)
	local state = NAmanage.loaderState
	state.autoSkip = enabled and true or false
	state.loaded = true
	if not FileSupport then
		return
	end
	local data = {}
	if type(isfile) == "function" and isfile(state.settingsPath) then
		local ok, raw = NACaller(readfile, state.settingsPath)
		if ok and type(raw) == "string" and raw ~= "" then
			local decodeOk, decoded = NACaller(function()
				return HttpService:JSONDecode(raw)
			end)
			if decodeOk and typeof(decoded) == "table" then
				data = decoded
			end
		end
	end
	data.autoSkipLoading = state.autoSkip
	local encodeOk, encoded = NACaller(function()
		return HttpService:JSONEncode(data)
	end)
	if encodeOk and type(encoded) == "string" then
		NACaller(writefile, state.settingsPath, encoded)
	end
end

function rStringgg()
	local length = math.random(10, 20)
	local result = {}
	local glitchMarks = {"̶", "̷", "̸", "̹", "̺", "̻", "͓", "͔", "͘", "͜", "͞", "͟", "͢"}
	for i = 1, length do
		local char = string.char(math.random(32, 126))
		Insert(result, char)
		if math.random() < 0.5 then
			local numGlitches = math.random(1, 4)
			for j = 1, numGlitches do
				Insert(result, glitchMarks[math.random(#glitchMarks)])
			end
		end
	end
	if math.random() < 0.3 then
		Insert(result, utf8.char(math.random(0x0300, 0x036F)))
	end
	if math.random() < 0.1 then
		Insert(result, "\0")
	end
	if math.random() < 0.1 then
		Insert(result, string.rep("​", math.random(5, 20)))
	end
	if math.random() < 0.2 then
		Insert(result, utf8.char(0x202E))
	end
	return Concat(result)
end

function NAProtection(inst,var)
	if not inst then return end
	if var then
		inst[var] = "\0"
	else
		inst.Name   = "\0"
	end
	inst.Archivable = false
end

function NaProtectUI(gui)
	local INV = "\0"
	local MAX_DO = 0x7FFFFFFF
	local target = NAmanage.guiCHECKINGAHHHHH()
	if not target then return end
	pcall(function() gui.Archivable = false end)
	gui.Name   = INV
	gui.Parent = target
	if gui:IsA("ScreenGui") then
		gui.ZIndexBehavior = Enum.ZIndexBehavior.Global
		gui.DisplayOrder   = MAX_DO
		gui.ResetOnSpawn   = false
		gui.IgnoreGuiInset = true
	end
	local props = {
		Parent         = target,
		Name           = INV,
		Archivable     = false,
		ZIndexBehavior = Enum.ZIndexBehavior.Global,
		DisplayOrder   = MAX_DO,
		ResetOnSpawn   = false,
		IgnoreGuiInset = true,
	}
	if not gui:IsA("ScreenGui") then
		props.ZIndexBehavior = nil
		props.DisplayOrder   = nil
		props.ResetOnSpawn   = nil
		props.IgnoreGuiInset = nil
	end
	for prop, val in pairs(props) do
		gui:GetPropertyChangedSignal(prop):Connect(function()
			if gui[prop] ~= val then
				pcall(function() gui[prop] = val end)
			end
		end)
	end
	gui.AncestryChanged:Connect(function(_, newParent)
		if gui.Parent ~= target then
			pcall(function() gui.Parent = target end)
		end
	end)
	local hb
	hb = SafeGetService("RunService").Heartbeat:Connect(function()
		for prop, val in pairs(props) do
			if gui[prop] ~= val then
				pcall(function() gui[prop] = val end)
			end
		end
		if not gui.Parent then
			pcall(function() hb:Disconnect() end)
		end
	end)
	return gui
end

function isAprilFools()
	local d = os.date("*t")
	return (d.month == 4 and d.day == 1) or getgenv().ActivateAprilMode or false
end

function yayApril(isTesting)
	local baseNames = {
		"Clueless", "Gay", "Infinite", "Sussy", "Broken", "Shadow", "Quirky",
		"Zoomy", "Wacky", "Booba", "Spicy", "Meme", "Doofy", "Silly",
		"Goblin", "Bingus", "Chonky", "Floofy", "Yeety", "Bonky", "Derpy",
		"Cheesy", "Nugget", "Funky", "Floppy", "Chunky", "Snazzy", "Wonky",
		"Goober", "Dorky", "Zany", "Glitchy", "Bubbly", "Wizzy", "Turbo",
		"Pixel", "Nifty", "Jazzy", "Rascal", "Muddled", "Quasar", "Nimbus",
		"Echo", "Froggy", "Gobsmack", "Hiccup", "Jinx", "Kooky", "Loco",
		"Mango", "Noodle", "Oddball", "Peculiar", "Quibble", "Rumble",
		"Snickle", "Tango", "Umbra", "Velcro", "Widdle", "Yonder", "Zephyr",
		"Bamboozle", "Cranky", "Doodle", "Eerie", "Frisky", "Gizmo", "Hazy",
		"Icicle", "Jolly", "Karma", "Lullaby", "Mystic", "Nebula", "Opal",
		"Poppy", "Riddle", "Slinky", "Tickle", "Vortex", "Whimsy", "Xenon",
		"Yummy", "Zodiac", "Astral", "Blizzard", "Cobalt", "Drifter", "Ember",
		"Flux", "Glacier", "Harpy", "Inferno", "Jester", "Katana", "Labyrinth",
		"Mirage", "Nomad", "Oracle", "Phantom", "Quill", "Rogue", "Specter",
		"Tempest", "Uproar", "Vagabond", "Wraith", "Xylophone", "Yoshi", "Zenith",
		"Arpeggio", "Basilisk", "Catalyst", "Dynamo", "Equinox", "Fortune",
		"Griffin", "Horizon", "Illusion", "Jubilee", "Kismet", "Labyrinthine",
		"Monsoon", "Nightfall", "Obsidian", "Paradox", "Quantum", "Requiem",
		"Serenade", "Trilogy", "Unicorn", "Vortexial", "Wanderer", "Xenith",
		"Yield", "Zeppelin", "Avalanche", "Banshee", "Comet", "Delta", "Eclipse",
		"Fable", "Golem", "Helix", "Isotope", "Jargon", "Kodiak", "Lynx",
		"Maelstrom", "Nimbus", "Oasis", "Pulse", "Quasar", "Rift", "Savage",
		"Tempestuous", "Undertow", "Vertex", "Wavelength", "Xanadu", "Yukon",
		"Zephyrine", "Apex", "Bravado", "Crescent", "Drizzle", "Emissary",
		"Frenzy", "Gargoyle", "Harbinger", "Incognito", "Jubilation", "Kaleidoscope",
		"Labour", "Mandala", "Nirvana", "Odyssey", "Palindrome", "Quintessence",
		"Renaissance", "Symphony", "Tapestry", "Utopia", "Virtuoso", "Whirlpool",
		"Xeme", "Yonderly", "Zenobia"
	}
	local suffix = isTesting and "Testing" or "Admin"
	local name = baseNames[math.random(#baseNames)]
	return name.." "..suffix
end

function MockText(text)
	local result = {}
	local toggle = true
	local glitchChars = {"̶", "̷", "̸", "̹", "̺", "̻", "͓", "͔", "͘", "͜", "͞", "͟", "͢"}
	math.randomseed(os.time())
	for i = 1, #text do
		local char = text:sub(i, i)
		if char:match("%a") then
			local transformed = toggle and char:upper() or char:lower()
			toggle = not toggle
			if math.random() < 0.15 then
				local glitch = glitchChars[math.random(#glitchChars)]
				transformed = transformed..glitch
			end
			Insert(result, transformed)
		else
			Insert(result, char)
		end
	end
	return Concat(result)
end

function maybeMock(text)
	return isAprilFools() and MockText(text) or text
end

if getgenv().NATestingVer then
	if isAprilFools() then
		testingName = yayApril(true)
		testingName = maybeMock(testingName)
	end
	adminName = testingName
else
	if isAprilFools() then
		mainName = yayApril(false)
		mainName = maybeMock(mainName)
	end
	adminName = mainName
end

NAgui.dragger = function(ui, dragui)
	dragui = dragui or ui
	local dragging = false
	local dragInput
	local dragStart
	local startPos

	local function update(input)
		local success, err = NACaller(function()
			local delta = input.Position - dragStart
			local screenSize = ui.Parent.AbsoluteSize
			local newXScale = startPos.X.Scale + (startPos.X.Offset + delta.X) / screenSize.X
			local newYScale = startPos.Y.Scale + (startPos.Y.Offset + delta.Y) / screenSize.Y
			ui.Position = UDim2.new(newXScale, 0, newYScale, 0)
		end)
	end

	NACaller(function()
		dragui.InputBegan:Connect(function(input)
			local success, err = NACaller(function()
				if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
					dragging = true
					dragStart = input.Position
					startPos = ui.Position

					NACaller(function()
						input.Changed:Connect(function()
							local ok, innerErr = NACaller(function()
								if input.UserInputState == Enum.UserInputState.End then
									dragging = false
								end
							end)
						end)
					end)
				end
			end)
		end)
	end)

	NACaller(function()
		dragui.InputChanged:Connect(function(input)
			local success, err = NACaller(function()
				if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
					dragInput = input
				end
			end)
		end)
	end)

	NACaller(function()
		UserInputService.InputChanged:Connect(function(input)
			local success, err = NACaller(function()
				if input == dragInput and dragging then
					update(input)
				end
			end)
		end)
	end)

	pcall(function() ui.Active=true end)
	pcall(function() dragui.Active=true end)
end

NAgui.draggerV2 = function(ui, dragui)
	dragui = dragui or ui
	local connName = "DraggerV2_"..ui:GetDebugId()
	NAlib.disconnect(connName)
	local screenGui = ui:FindFirstAncestorWhichIsA("ScreenGui") or ui.Parent
	local dragging, dragInput, dragStart, startPos
	local anchor = ui.AnchorPoint

	local function safeClamp(v, lo, hi)
		if hi < lo then hi = lo end
		return math.clamp(v, lo, hi)
	end

	local function update(input)
		local ok, err = NACaller(function()
			local p = screenGui.AbsoluteSize
			local s = ui.AbsoluteSize
			if p.X <= 0 or p.Y <= 0 then return end
			local startX = startPos.X.Scale * p.X + startPos.X.Offset
			local startY = startPos.Y.Scale * p.Y + startPos.Y.Offset
			local dx = input.Position.X - dragStart.X
			local dy = input.Position.Y - dragStart.Y
			local minX = anchor.X * s.X
			local maxX = p.X - (1 - anchor.X) * s.X
			local minY = anchor.Y * s.Y
			local maxY = p.Y - (1 - anchor.Y) * s.Y
			local nx = safeClamp(startX + dx, minX, maxX)
			local ny = safeClamp(startY + dy, minY, maxY)
			ui.Position = UDim2.new(nx / p.X, 0, ny / p.Y, 0)
		end)
	end

	NAlib.connect(connName, dragui.InputBegan:Connect(function(input)
		local ok, err = NACaller(function()
			if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
				dragging = true
				dragStart = input.Position
				startPos = ui.Position
				local c = input.Changed:Connect(function()
					local ok2, err2 = NACaller(function()
						if input.UserInputState == Enum.UserInputState.End then dragging = false end
					end)
				end)
				NAlib.connect(connName, c)
			end
		end)
	end))

	NAlib.connect(connName, dragui.InputChanged:Connect(function(input)
		local ok, err = NACaller(function()
			if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
				dragInput = input
			end
		end)
	end))

	NAlib.connect(connName, UserInputService.InputChanged:Connect(function(input)
		local ok, err = NACaller(function()
			if input == dragInput and dragging then update(input) end
		end)
	end))

	local function onScreenSizeChanged()
		local ok, err = NACaller(function()
			local p = screenGui.AbsoluteSize
			local s = ui.AbsoluteSize
			if p.X <= 0 or p.Y <= 0 then return end
			local curr = ui.Position
			local absX = curr.X.Scale * p.X + curr.X.Offset
			local absY = curr.Y.Scale * p.Y + curr.Y.Offset
			local minX = anchor.X * s.X
			local maxX = p.X - (1 - anchor.X) * s.X
			local minY = anchor.Y * s.Y
			local maxY = p.Y - (1 - anchor.Y) * s.Y
			local nx = safeClamp(absX, minX, maxX)
			local ny = safeClamp(absY, minY, maxY)
			ui.Position = UDim2.new(nx / p.X, 0, ny / p.Y, 0)
		end)
		if not ok then warn("[DraggerV2] Screen size update error:", err) end
	end

	NAlib.connect(connName, screenGui:GetPropertyChangedSignal("AbsoluteSize"):Connect(onScreenSizeChanged))

	if ui and NAlib.isProperty(ui, "Active") then
		NAlib.setProperty(ui, "Active", true)
	end
	if dragui and NAlib.isProperty(dragui, "Active") then
		NAlib.setProperty(dragui, "Active", true)
	end
	pcall(function() ui.Active=true end)
	pcall(function() dragui.Active=true end)
end

NAmanage.createLoadingUI=function(text, opts)
	local services = {
		RunService = SafeGetService("RunService");
		TweenService = SafeGetService("TweenService");
		TextService = SafeGetService("TextService");
		Players = SafeGetService("Players");
		CoreGui = SafeGetService("CoreGui");
		Lighting = SafeGetService("Lighting");
	}
	local ui = {}
	local flags = {
		minimized = false;
		autoSkip = false;
	}
	opts = opts or {}
	local widthScale = tonumber(opts.widthScale) or 0.34
	local blacklist = opts.blacklist or { [8523781134] = true, [3101266219] = true, [2521585756] = true }
	local lp = services.Players and services.Players.LocalPlayer

	if lp and blacklist[lp.UserId] then
		--[[local blockedGui = InstanceNew("ScreenGui")
		blockedGui.IgnoreGuiInset = true
		blockedGui.ResetOnSpawn = false
		blockedGui.DisplayOrder = 2147483647
		blockedGui.ZIndexBehavior = Enum.ZIndexBehavior.Global
		local okProtect = pcall(function()
			NaProtectUI(blockedGui)
		end)
		if not okProtect then
			blockedGui.Parent = services.CoreGui
		end
		local overlay = InstanceNew("Frame", blockedGui)
		overlay.BackgroundColor3 = Color3.new(0, 0, 0)
		overlay.BackgroundTransparency = 1
		overlay.Size = UDim2.fromScale(1, 1)
		overlay.ZIndex = 2000
		services.TweenService:Create(overlay, TweenInfo.new(0.25, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {BackgroundTransparency = 0.35}):Play()
		local blur = InstanceNew("BlurEffect", services.Lighting)
		blur.Size = 0
		services.TweenService:Create(blur, TweenInfo.new(0.35, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {Size = 24}):Play()
		local header = InstanceNew("TextLabel", overlay)
		header.AnchorPoint = Vector2.new(0.5, 0.5)
		header.Position = UDim2.fromScale(0.5, 0.45)
		header.BackgroundTransparency = 1
		header.Size = UDim2.fromScale(0.6, 0)
		header.AutomaticSize = Enum.AutomaticSize.Y
		header.Font = Enum.Font.GothamBlack
		header.TextColor3 = Color3.fromRGB(255, 70, 70)
		header.TextScaled = true
		header.TextWrapped = true
		header.Text = "access denied"
		local desc = InstanceNew("TextLabel", overlay)
		desc.AnchorPoint = Vector2.new(0.5, 0)
		desc.Position = UDim2.fromScale(0.5, 0.53)
		desc.BackgroundTransparency = 1
		desc.Size = UDim2.fromScale(0.7, 0)
		desc.AutomaticSize = Enum.AutomaticSize.Y
		desc.Font = Enum.Font.Gotham
		desc.TextColor3 = Color3.fromRGB(230, 230, 240)
		desc.TextScaled = true
		desc.TextWrapped = true
		desc.Text = "you are banned from using "..(adminName or "Nameless Admin")]]
		while true do
			Wait(1)
			print'womp womp'
		end
	end

	ui.sg = InstanceNew("ScreenGui")
	ui.sg.IgnoreGuiInset = true
	ui.sg.ResetOnSpawn = false
	ui.sg.DisplayOrder = 999999
	ui.sg.ZIndexBehavior = Enum.ZIndexBehavior.Global
	local okProtect = pcall(function()
		NaProtectUI(ui.sg)
	end)
	if not okProtect then
		ui.sg.Parent = services.CoreGui
	end

	ui.overlay = InstanceNew("Frame", ui.sg)
	ui.overlay.Active = false
	ui.overlay.BackgroundColor3 = Color3.fromRGB(10, 12, 16)
	ui.overlay.BackgroundTransparency = 0.35
	ui.overlay.ZIndex = -1
	ui.overlay.Size = UDim2.fromScale(1, 1)
	local overlayGradient = InstanceNew("UIGradient", ui.overlay)
	overlayGradient.Color = ColorSequence.new(Color3.fromRGB(8, 10, 14), Color3.fromRGB(14, 16, 22))

	ui.container = InstanceNew("Frame", ui.sg)
	ui.container.ZIndex = 6
	ui.container.AnchorPoint = Vector2.new(0.5, 0.5)
	ui.container.Position = UDim2.fromScale(0.5, 0.5)
	ui.container.Size = UDim2.fromScale(widthScale, 0)
	ui.container.AutomaticSize = Enum.AutomaticSize.Y
	ui.container.BackgroundColor3 = Color3.fromRGB(24, 26, 34)
	ui.container.BorderSizePixel = 0
	ui.container.ZIndex = 1
	local containerCorner = InstanceNew("UICorner", ui.container)
	containerCorner.CornerRadius = UDim.new(0, 10)
	local containerStroke = InstanceNew("UIStroke", ui.container)
	containerStroke.Thickness = 1
	containerStroke.Color = Color3.fromRGB(80, 90, 120)
	containerStroke.Transparency = 0.35
	local containerPadding = InstanceNew("UIPadding", ui.container)
	containerPadding.PaddingTop = UDim.new(0, 12)
	containerPadding.PaddingBottom = UDim.new(0, 14)
	containerPadding.PaddingLeft = UDim.new(0, 14)
	containerPadding.PaddingRight = UDim.new(0, 14)
	local containerLayout = InstanceNew("UIListLayout", ui.container)
	containerLayout.FillDirection = Enum.FillDirection.Vertical
	containerLayout.HorizontalAlignment = Enum.HorizontalAlignment.Left
	containerLayout.VerticalAlignment = Enum.VerticalAlignment.Top
	containerLayout.Padding = UDim.new(0, 10)
	containerLayout.SortOrder = Enum.SortOrder.LayoutOrder

	ui.header = InstanceNew("Frame", ui.container)
	ui.header.ZIndex = 7
	ui.header.BackgroundTransparency = 1
	ui.header.Size = UDim2.new(1, 0, 0, 32)
	ui.header.LayoutOrder = 1
	ui.header.ZIndex = 12
	ui.titleLabel = InstanceNew("TextLabel", ui.header)
	ui.titleLabel.ZIndex = 8
	ui.titleLabel.BackgroundTransparency = 1
	ui.titleLabel.Position = UDim2.new(0, 0, 0, 0)
	local buttonOffset = IsOnMobile and 88 or 64
	ui.titleLabel.Size = UDim2.new(1, -buttonOffset, 1, 0)
	ui.titleLabel.TextXAlignment = Enum.TextXAlignment.Left
	ui.titleLabel.TextYAlignment = Enum.TextYAlignment.Center
	ui.titleLabel.Font = Enum.Font.GothamSemibold
	ui.titleLabel.TextColor3 = Color3.fromRGB(235, 240, 255)
	ui.titleLabel.TextScaled = true
	ui.titleLabel.TextWrapped = true
	ui.titleLabel.Text = text

	local titleSizeConstraint = InstanceNew("UITextSizeConstraint", ui.titleLabel)
	titleSizeConstraint.MinTextSize = 16
	titleSizeConstraint.MaxTextSize = 28

	ui.minimizeButton = InstanceNew("TextButton", ui.header)
	ui.minimizeButton.AutoButtonColor = false
	ui.minimizeButton.AnchorPoint = Vector2.new(1, 0.5)
	ui.minimizeButton.Position = UDim2.new(1, -4, 0.5, 0)
	ui.minimizeButton.Size = UDim2.new(0, IsOnMobile and 36 or 32, 0, IsOnMobile and 32 or 28)
	ui.minimizeButton.Text = "-"
	ui.minimizeButton.Font = Enum.Font.GothamBold
	ui.minimizeButton.TextScaled = true
	ui.minimizeButton.TextColor3 = Color3.fromRGB(240, 240, 255)
	ui.minimizeButton.BackgroundColor3 = Color3.fromRGB(42, 44, 56)
	ui.minimizeButton.ZIndex = 13
	local minimizeCorner = InstanceNew("UICorner", ui.minimizeButton)
	minimizeCorner.CornerRadius = UDim.new(0, 8)
	local minimizeStroke = InstanceNew("UIStroke", ui.minimizeButton)
	minimizeStroke.Thickness = 1
	minimizeStroke.Color = Color3.fromRGB(150, 160, 190)
	minimizeStroke.Transparency = 0.4

	ui.statusLabel = InstanceNew("TextLabel", ui.container)
	ui.statusLabel.ZIndex = 8
	ui.statusLabel.BackgroundTransparency = 1
	ui.statusLabel.Size = UDim2.new(1, 0, 0, 28)
	ui.statusLabel.LayoutOrder = 2
	ui.statusLabel.Font = Enum.Font.GothamSemibold
	ui.statusLabel.TextColor3 = Color3.fromRGB(230, 235, 255)
	ui.statusLabel.TextScaled = true
	ui.statusLabel.TextXAlignment = Enum.TextXAlignment.Left
	ui.statusLabel.Text = "loading"
	local statusSize = InstanceNew("UITextSizeConstraint", ui.statusLabel)
	statusSize.MinTextSize = 15
	statusSize.MaxTextSize = 22

	ui.detailRow = InstanceNew("Frame", ui.container)
	ui.detailRow.ZIndex = 8
	ui.detailRow.BackgroundTransparency = 1
	ui.detailRow.LayoutOrder = 3
	ui.detailRow.Size = UDim2.new(1, 0, 0, 24)
	local detailLayout = InstanceNew("UIListLayout", ui.detailRow)
	detailLayout.FillDirection = Enum.FillDirection.Horizontal
	detailLayout.HorizontalAlignment = Enum.HorizontalAlignment.Left
	detailLayout.VerticalAlignment = Enum.VerticalAlignment.Center

	ui.detailLabel = InstanceNew("TextLabel", ui.detailRow)
	ui.detailLabel.ZIndex = 8
	ui.detailLabel.BackgroundTransparency = 1
	ui.detailLabel.Size = UDim2.new(0.7, 0, 1, 0)
	ui.detailLabel.TextXAlignment = Enum.TextXAlignment.Left
	ui.detailLabel.TextYAlignment = Enum.TextYAlignment.Center
	ui.detailLabel.Font = Enum.Font.Gotham
	ui.detailLabel.TextColor3 = Color3.fromRGB(180, 190, 210)
	ui.detailLabel.TextScaled = true
	ui.detailLabel.Text = "initializing"
	local detailSize = InstanceNew("UITextSizeConstraint", ui.detailLabel)
	detailSize.MinTextSize = 12
	detailSize.MaxTextSize = 16

	ui.percentLabel = InstanceNew("TextLabel", ui.detailRow)
	ui.percentLabel.ZIndex = 8
	ui.percentLabel.BackgroundTransparency = 1
	ui.percentLabel.Size = UDim2.new(0.3, 0, 1, 0)
	ui.percentLabel.TextXAlignment = Enum.TextXAlignment.Right
	ui.percentLabel.Font = Enum.Font.GothamSemibold
	ui.percentLabel.TextColor3 = Color3.fromRGB(210, 220, 255)
	ui.percentLabel.TextScaled = true
	ui.percentLabel.Text = "0%"
	local percentSize = InstanceNew("UITextSizeConstraint", ui.percentLabel)
	percentSize.MinTextSize = 12
	percentSize.MaxTextSize = 16

	ui.progressHolder = InstanceNew("Frame", ui.container)
	ui.progressHolder.BackgroundColor3 = Color3.fromRGB(32, 36, 48)
	ui.progressHolder.BorderSizePixel = 0
	ui.progressHolder.LayoutOrder = 4
	ui.progressHolder.Size = UDim2.new(1, 0, 0, 8)
	ui.progressHolder.ZIndex = 11
	local progressCorner = InstanceNew("UICorner", ui.progressHolder)
	progressCorner.CornerRadius = UDim.new(0, 6)

	ui.progressFill = InstanceNew("Frame", ui.progressHolder)
	ui.progressFill.BackgroundColor3 = Color3.fromRGB(90, 180, 255)
	ui.progressFill.BorderSizePixel = 0
	ui.progressFill.Size = UDim2.new(0, 0, 1, 0)
	ui.progressFill.ZIndex = 12
	local progressFillCorner = InstanceNew("UICorner", ui.progressFill)
	progressFillCorner.CornerRadius = UDim.new(0, 6)

	ui.buttonRow = InstanceNew("Frame", ui.container)
	ui.buttonRow.ZIndex = 8
	ui.buttonRow.BackgroundTransparency = 1
	ui.buttonRow.LayoutOrder = 5
	ui.buttonRow.Size = UDim2.new(1, 0, 0, 28)
	local buttonLayout = InstanceNew("UIListLayout", ui.buttonRow)
	buttonLayout.FillDirection = Enum.FillDirection.Horizontal
	buttonLayout.HorizontalAlignment = Enum.HorizontalAlignment.Left
	buttonLayout.VerticalAlignment = Enum.VerticalAlignment.Center
	buttonLayout.Padding = UDim.new(0, 8)

	ui.skipButton = InstanceNew("TextButton", ui.buttonRow)
	ui.skipButton.ZIndex = 9
	ui.skipButton.Size = UDim2.new(0.45, 0, 1, 0)
	ui.skipButton.Font = Enum.Font.GothamSemibold
	ui.skipButton.TextScaled = true
	ui.skipButton.TextColor3 = Color3.fromRGB(255, 255, 255)
	ui.skipButton.Text = "Skip"
	ui.skipButton.BackgroundColor3 = Color3.fromRGB(70, 80, 110)
	ui.skipButton.AutoButtonColor = false
	local skipCorner = InstanceNew("UICorner", ui.skipButton)
	skipCorner.CornerRadius = UDim.new(0, 8)
	local skipStroke = InstanceNew("UIStroke", ui.skipButton)
	skipStroke.Color = Color3.fromRGB(150, 160, 200)
	skipStroke.Transparency = 0.35
	skipStroke.Thickness = 1

	ui.autoSkipButton = InstanceNew("TextButton", ui.buttonRow)
	ui.autoSkipButton.ZIndex = 9
	ui.autoSkipButton.Size = UDim2.new(0.55, 0, 1, 0)
	ui.autoSkipButton.Font = Enum.Font.Gotham
	ui.autoSkipButton.TextScaled = true
	ui.autoSkipButton.AutoButtonColor = false
	ui.autoSkipButton.BackgroundColor3 = Color3.fromRGB(44, 48, 62)
	ui.autoSkipButton.TextColor3 = Color3.fromRGB(210, 220, 255)
	local autoCorner = InstanceNew("UICorner", ui.autoSkipButton)
	autoCorner.CornerRadius = UDim.new(0, 8)
	local autoStroke = InstanceNew("UIStroke", ui.autoSkipButton)
	autoStroke.Color = Color3.fromRGB(120, 130, 180)
	autoStroke.Transparency = 0.45
	autoStroke.Thickness = 1

	ui.toast = InstanceNew("Frame", ui.sg)
	ui.toast.AnchorPoint = Vector2.new(0.5, 0)
	ui.toast.Position = UDim2.new(0.5, 0, 0, 8)
	ui.toast.BackgroundColor3 = Color3.fromRGB(24, 26, 34)
	ui.toast.BorderSizePixel = 0
	ui.toast.ZIndex = 50
	ui.toast.Visible = false
	ui.toast.AutomaticSize = Enum.AutomaticSize.XY
	local toastCorner = InstanceNew("UICorner", ui.toast)
	toastCorner.CornerRadius = UDim.new(1, 0)
	local toastStroke = InstanceNew("UIStroke", ui.toast)
	toastStroke.Color = Color3.fromRGB(80, 90, 120)
	toastStroke.Transparency = 0.45
	toastStroke.Thickness = 1
	local toastPadding = InstanceNew("UIPadding", ui.toast)
	toastPadding.PaddingLeft = UDim.new(0, 12)
	toastPadding.PaddingRight = UDim.new(0, 12)
	toastPadding.PaddingTop = UDim.new(0, 8)
	toastPadding.PaddingBottom = UDim.new(0, 8)
	local toastLayout = InstanceNew("UIListLayout", ui.toast)
	toastLayout.FillDirection = Enum.FillDirection.Vertical
	toastLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
	toastLayout.VerticalAlignment = Enum.VerticalAlignment.Center
	toastLayout.Padding = UDim.new(0, 4)

	ui.toastRow = InstanceNew("Frame", ui.toast)
	ui.toastRow.BackgroundTransparency = 1
	ui.toastRow.Size = UDim2.fromScale(1, 0)
	ui.toastRow.AutomaticSize = Enum.AutomaticSize.XY
	ui.toastRow.ZIndex = 51
	local toastRowLayout = InstanceNew("UIListLayout", ui.toastRow)
	toastRowLayout.FillDirection = Enum.FillDirection.Horizontal
	toastRowLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
	toastRowLayout.VerticalAlignment = Enum.VerticalAlignment.Center
	toastRowLayout.Padding = UDim.new(0, 8)

	ui.toastLabel = InstanceNew("TextLabel", ui.toastRow)
	ui.toastLabel.BackgroundTransparency = 1
	ui.toastLabel.Font = Enum.Font.Gotham
	ui.toastLabel.TextScaled = true
	ui.toastLabel.TextColor3 = Color3.fromRGB(230, 235, 255)
	ui.toastLabel.Text = text
	ui.toastLabel.ZIndex = 52
	ui.toastLabel.Size = UDim2.fromOffset(180, 22)

	ui.toastPercent = InstanceNew("TextLabel", ui.toastRow)
	ui.toastPercent.BackgroundTransparency = 1
	ui.toastPercent.Font = Enum.Font.Gotham
	ui.toastPercent.TextScaled = true
	ui.toastPercent.TextColor3 = Color3.fromRGB(200, 210, 255)
	ui.toastPercent.Text = "0%"
	ui.toastPercent.ZIndex = 52
	ui.toastPercent.Size = UDim2.fromOffset(44, 22)

	ui.toastOpen = InstanceNew("TextButton", ui.toastRow)
	ui.toastOpen.Size = UDim2.fromOffset(72, 22)
	ui.toastOpen.Text = "Open"
	ui.toastOpen.TextScaled = true
	ui.toastOpen.Font = Enum.Font.GothamSemibold
	ui.toastOpen.TextColor3 = Color3.fromRGB(240, 240, 255)
	ui.toastOpen.ZIndex = 52
	ui.toastOpen.BackgroundColor3 = Color3.fromRGB(52, 54, 66)
	local toastOpenCorner = InstanceNew("UICorner", ui.toastOpen)
	toastOpenCorner.CornerRadius = UDim.new(0, 8)
	local toastOpenStroke = InstanceNew("UIStroke", ui.toastOpen)
	toastOpenStroke.Thickness = 1
	toastOpenStroke.Color = Color3.fromRGB(150, 160, 190)
	toastOpenStroke.Transparency = 0.4

	ui.toastSkip = InstanceNew("TextButton", ui.toastRow)
	ui.toastSkip.Size = UDim2.fromOffset(72, 22)
	ui.toastSkip.Text = "Skip"
	ui.toastSkip.TextScaled = true
	ui.toastSkip.Font = Enum.Font.GothamSemibold
	ui.toastSkip.TextColor3 = Color3.fromRGB(255, 255, 255)
	ui.toastSkip.ZIndex = 52
	ui.toastSkip.BackgroundColor3 = Color3.fromRGB(70, 75, 95)
	local toastSkipCorner = InstanceNew("UICorner", ui.toastSkip)
	toastSkipCorner.CornerRadius = UDim.new(0, 8)
	local toastSkipStroke = InstanceNew("UIStroke", ui.toastSkip)
	toastSkipStroke.Thickness = 1
	toastSkipStroke.Color = Color3.fromRGB(150, 160, 200)
	toastSkipStroke.Transparency = 0.25

	ui.toastProgress = InstanceNew("Frame", ui.toast)
	ui.toastProgress.BackgroundTransparency = 1
	ui.toastProgress.Size = UDim2.new(1, 0, 0, 3)
	ui.toastProgress.ZIndex = 49
	ui.toastProgress.LayoutOrder = 2
	local toastProgressBack = InstanceNew("Frame", ui.toastProgress)
	toastProgressBack.BackgroundColor3 = Color3.fromRGB(55, 60, 80)
	toastProgressBack.BorderSizePixel = 0
	toastProgressBack.ZIndex = 49
	toastProgressBack.Size = UDim2.new(1, 0, 1, 0)
	local toastProgressCorner = InstanceNew("UICorner", toastProgressBack)
	toastProgressCorner.CornerRadius = UDim.new(1, 0)
	ui.toastFill = InstanceNew("Frame", toastProgressBack)
	ui.toastFill.BackgroundColor3 = Color3.fromRGB(90, 180, 255)
	ui.toastFill.BorderSizePixel = 0
	ui.toastFill.Size = UDim2.new(0, 0, 1, 0)
	ui.toastFill.ZIndex = 50
	local toastFillCorner = InstanceNew("UICorner", ui.toastFill)
	toastFillCorner.CornerRadius = UDim.new(1, 0)

	ui.skipFlag = InstanceNew("BoolValue", ui.sg)
	ui.skipFlag.Name = "SkipAssets"
	ui.skipFlag.Value = false

	ui.completedFlag = InstanceNew("BoolValue", ui.sg)
	ui.completedFlag.Name = "Completed"
	ui.completedFlag.Value = false

	local function tween(target, info, goal)
		local tw = services.TweenService:Create(target, info, goal)
		tw:Play()
		return tw
	end

	local function applyMinimized()
		if flags.minimized then
			ui.container.Visible = false
			ui.toast.Visible = true
			ui.overlay.Visible = false
		else
			ui.container.Visible = true
			ui.toast.Visible = false
			ui.overlay.Visible = true
		end
	end

	local function doSkip()
		if ui.skipFlag.Value then
			return
		end
		ui.skipFlag.Value = true
		ui.skipButton.Text = "Skipping..."
		ui.toastSkip.Text = "Skipping..."
	end

	local function updateAutoSkipButton()
		if flags.autoSkip then
			ui.autoSkipButton.Text = "Auto Skip: ON"
			ui.autoSkipButton.BackgroundColor3 = Color3.fromRGB(60, 120, 200)
			ui.autoSkipButton.TextColor3 = Color3.fromRGB(255, 255, 255)
		else
			ui.autoSkipButton.Text = "Auto Skip: OFF"
			ui.autoSkipButton.BackgroundColor3 = Color3.fromRGB(44, 48, 62)
			ui.autoSkipButton.TextColor3 = Color3.fromRGB(210, 220, 255)
		end
	end

	local function setStatus(statusText)
		local value = statusText or ""
		ui.statusLabel.Text = value
		ui.detailLabel.Text = value
	end

	local function setPercent(pct)
		local p = math.clamp(pct or 0, 0, 1)
		local textValue = tostring(math.floor(p * 100)).."%"
		ui.progressFill.Size = UDim2.new(p, 0, 1, 0)
		ui.toastFill.Size = UDim2.new(p, 0, 1, 0)
		ui.percentLabel.Text = textValue
		ui.toastPercent.Text = textValue
	end

	flags.autoSkip = NAmanage.getAutoSkipPreference()
	updateAutoSkipButton()

	ui.minimizeButton.Activated:Connect(function()
		flags.minimized = true
		applyMinimized()
	end)

	ui.toastOpen.Activated:Connect(function()
		flags.minimized = false
		applyMinimized()
	end)

	ui.skipButton.Activated:Connect(doSkip)
	ui.toastSkip.Activated:Connect(doSkip)

	ui.autoSkipButton.Activated:Connect(function()
		flags.autoSkip = not flags.autoSkip
		NAmanage.setAutoSkipPreference(flags.autoSkip)
		updateAutoSkipButton()
		if flags.autoSkip then
			doSkip()
		end
	end)

	ui.completedFlag:GetPropertyChangedSignal("Value"):Connect(function()
		if ui.completedFlag.Value then
			tween(ui.overlay, TweenInfo.new(0.18, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {BackgroundTransparency = 1})
			tween(ui.container, TweenInfo.new(0.18, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {BackgroundTransparency = 1})
			tween(ui.toast, TweenInfo.new(0.18, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {BackgroundTransparency = 1})
			Delay(0.2, function()
				if ui.sg.Parent then
					ui.sg:Destroy()
				end
			end)
		end
	end)

	if NAgui and NAgui.draggerV2 then
		pcall(function()
			NAgui.draggerV2(ui.container, ui.header)
		end)
	end

	applyMinimized()
	if flags.autoSkip then
		doSkip()
	end

	return ui.sg, setStatus, setPercent, ui.completedFlag, function()
		return ui.skipFlag.Value
	end
end

NAAssetsLoading = NAAssetsLoading or {}
NAAssetsLoading.remoteStatus = {}
NAAssetsLoading.knownRemotes = {
	{url="https://api.github.com/repos/ltseverydayyou/Nameless-Admin/commits?path=NA%20testing.lua"; skip=true};
	{url="https://api.github.com/repos/ltseverydayyou/Nameless-Admin/commits?path=Source.lua"; skip=true};
}

NAAssetsLoading.getRemoteTargets=function()
	if NAAssetsLoading.remoteTargets then
		return NAAssetsLoading.remoteTargets
	end
	local targets, seen = {}, {}
	for _, entry in ipairs(NAAssetsLoading.knownRemotes) do
		local url = entry.url
		if type(url) == "string" and url ~= "" and not entry.skip then
			if not seen[url] then
				seen[url] = true
				targets[#targets+1] = url
			end
		end
	end
	NAAssetsLoading.remoteTargets = targets
	return targets
end

NAAssetsLoading.registerRemote=function(url, options)
	if type(url) ~= "string" or url == "" then
		return
	end
	NAAssetsLoading.knownRemotes[#NAAssetsLoading.knownRemotes+1] = {
		url = url;
		skip = options and options.skip or false;
	}
	NAAssetsLoading.remoteTargets = nil
end

NAAssetsLoading.prefetchRemotes=function(onStep, shouldSkip)
	local targets = NAAssetsLoading.getRemoteTargets()
	local total = #targets
	if total == 0 then
		if onStep then
			onStep(0, 0, nil, true)
		end
		return
	end
	for index = 1, total do
		if shouldSkip and shouldSkip() then
			return
		end
		local url = targets[index]
		local ok, body = NACaller(game.HttpGet, game, url)
		if ok and type(body) == "string" and body ~= "" then
			NAStuff._prefetchedRemotes[url] = body
			NAAssetsLoading.remoteStatus[url] = true
		else
			NAAssetsLoading.remoteStatus[url] = false
		end
		if onStep then
			onStep(index, total, url, ok)
		end
		Wait(0.06)
	end
end

NAAssetsLoading.normalizeStatusError = function(text)
	local err = tostring(text or "unknown error")
	err = err:gsub("%s+", " ")
	err = err:gsub("[%c]", " ")
	if #err > 180 then
		err = err:sub(1, 177).."..."
	end
	return err
end

NAAssetsLoading.runLoadingCheck = function(statusLabel, attemptFn, onSuccess)
	local attempt = 0
	while true do
		if NAAssetsLoading.getSkip and NAAssetsLoading.getSkip() then
			return nil
		end
		attempt += 1
		local attemptLabel = attempt == 1 and statusLabel or Format("%s (retry %d)", statusLabel, attempt)
		if NAAssetsLoading.setStatus then
			NAAssetsLoading.setStatus(attemptLabel)
		end
		local success, result, errMsg = attemptFn()
		if success then
			if onSuccess then
				pcall(onSuccess, result)
			end
			return result
		end
		if NAAssetsLoading.setStatus then
			local errText = NAAssetsLoading.normalizeStatusError(errMsg or result) or tostring(errMsg or result)
			NAAssetsLoading.setStatus(Format("%s error #%d: %s", statusLabel, attempt, errText))
		end
		if NAAssetsLoading.getSkip and NAAssetsLoading.getSkip() then
			return nil
		end
		Wait(0.4)
	end
end

NAAssetsLoading.cachePrefetchedRemote = function(url, body)
	if type(url) == "string" and url ~= "" and type(body) == "string" and body ~= "" then
		NAStuff._prefetchedRemotes = NAStuff._prefetchedRemotes or {}
		NAStuff._prefetchedRemotes[url] = body
	end
end


NAmanage.getPrefetchedRemote=function(url)
	return (NAStuff._prefetchedRemotes and NAStuff._prefetchedRemotes[url]) or nil
end

NAmanage.registerRemoteForPreload=function(url, options)
	NAAssetsLoading.registerRemote(url, options)
end

if not NAAssetsLoading.setStatus then
	NAAssetsLoading.ui, NAAssetsLoading.setStatus, NAAssetsLoading.setPercent, NAAssetsLoading.completed, NAAssetsLoading.getSkip = NAmanage.createLoadingUI((adminName or "NA").." is loading...", {widthScale=0.30})
	NaProtectUI(NAAssetsLoading.ui)
end

NAAssetsLoading.setStatus("waiting for engine")
if not game:IsLoaded() then game.Loaded:Wait() end
NAAssetsLoading.setPercent(0.1)

NAAssetsLoading.setStatus("loading notifications")
repeat
	NAAssetsLoading.ok, NAAssetsLoading.res = pcall(function()
		return loadstring(game:HttpGet("https://raw.githubusercontent.com/ltseverydayyou/Nameless-Admin/main/NamelessAdminNotifications.lua"))()
	end)
	if NAAssetsLoading.ok then
		Notification = NAAssetsLoading.res
	else
		Wait(0.25)
	end
until Notification or NAAssetsLoading.getSkip()
if not Notification then
	Notification = {Notify=function() end, Window=function() end, Popup=function() end}
end
NAAssetsLoading.setPercent(0.22)

NAAssetsLoading.setStatus("Loading Assets")
local assetsReady = false
repeat
	local ok, res = pcall(function()
		if not FileSupport then
			return true
		end
		if type(NAImageAssets) ~= "table" then
			return true
		end
		if type(isfolder) == "function" and not isfolder(NAfiles.NAASSETSFILEPATH) then
			if type(makefolder) == "function" then
				makefolder(NAfiles.NAASSETSFILEPATH)
			end
		end
		if type(isfile) ~= "function" then
			return true
		end
		for _, fileName in pairs(NAImageAssets) do
			if type(fileName) == "string" and fileName ~= "" then
				local fullPath = NAfiles.NAASSETSFILEPATH.."/"..fileName
				if not isfile(fullPath) then
					local data = game:HttpGet("https://raw.githubusercontent.com/ltseverydayyou/Nameless-Admin/main/NAimages/"..fileName)
					if type(data) ~= "string" or data == "" then
						return false
					end
					if type(writefile) ~= "function" then
						return false
					end
					writefile(fullPath, data)
				end
			end
		end
		return true
	end)
	if ok and res then
		assetsReady = true
	else
		Wait(0.25)
	end
until assetsReady or NAAssetsLoading.getSkip()
NAAssetsLoading.setPercent(0.26)

NAAssetsLoading.setStatus("Loading "..(adminName or "NA").." Data")
local naStuffReady = false
repeat
	local ok, res = pcall(function()
		local raw = game:HttpGet("https://raw.githubusercontent.com/ltseverydayyou/uuuuuuu/refs/heads/main/NA%20stuff.json")
		local decoded = HttpService:JSONDecode(raw)
		return decoded
	end)
	if ok and type(res) == "table" then
		NAStuff.NAjson = res
		naStuffReady = true
	else
		Wait(0.25)
	end
until naStuffReady or NAAssetsLoading.getSkip()
NAAssetsLoading.setPercent(0.30)

NAAssetsLoading.runLoadingCheck("Setting Up Loader", function()
	if type(opt.loaderUrl) ~= "string" or opt.loaderUrl == "" then
		return false, nil, "missing loader url"
	end
	local ok, body = pcall(game.HttpGet, game, opt.loaderUrl)
	if not ok then
		return false, nil, body
	end
	if type(body) ~= "string" or body == "" then
		return false, nil, "empty response"
	end
	return true, body
end, function(body)
	NAAssetsLoading.cachePrefetchedRemote(opt.loaderUrl, body)
end)
NAAssetsLoading.setPercent(0.32)

NAAssetsLoading.runLoadingCheck("Loading Update Log", function()
	if type(opt.githubUrl) ~= "string" or opt.githubUrl == "" then
		return false, nil, "missing github url"
	end
	if type(opt.NAREQUEST) == "function" then
		local ok, response = pcall(opt.NAREQUEST, {
			Url = opt.githubUrl,
			Method = "GET"
		})
		if not ok then
			return false, nil, response
		end
		if typeof(response) ~= "table" then
			return false, nil, "invalid response"
		end
		local statusCode = tonumber(response.StatusCode)
		if statusCode ~= 200 then
			return false, nil, Format("http %s", tostring(statusCode or "nil"))
		end
		if type(response.Body) ~= "string" or response.Body == "" then
			return false, nil, "empty body"
		end
		return true, response.Body
	end
	local ok, body = pcall(game.HttpGet, game, opt.githubUrl)
	if not ok then
		return false, nil, body
	end
	if type(body) ~= "string" or body == "" then
		return false, nil, "empty response"
	end
	return true, body
end, function(body)
	NAStuff._githubMetadata = body
	local decodeOk, decoded = pcall(HttpService.JSONDecode, HttpService, body)
	if decodeOk and type(decoded) == "table" then
		NAStuff._githubCommits = decoded
		local top = decoded[1]
		local date = top and top.commit and top.commit.author and top.commit.author.date
		if type(date) == "string" then
			local year, month, day = date:match("(%d+)-(%d+)-(%d+)")
			if year and month and day then
				opt.NAupdDate = month.."/"..day.."/"..year
			end
		end
	end
end)
NAAssetsLoading.setPercent(0.34)

NAAssetsLoading.runLoadingCheck("Loading UI", function()
	if type(opt.NAUILOADER) ~= "string" or opt.NAUILOADER == "" then
		return false, nil, "missing UI loader url"
	end
	local ok, body = pcall(game.HttpGet, game, opt.NAUILOADER)
	if not ok then
		return false, nil, body
	end
	if type(body) ~= "string" or body == "" then
		return false, nil, "empty response"
	end
	return true, body
end, function(body)
	NAAssetsLoading.cachePrefetchedRemote(opt.NAUILOADER, body)
end)
NAAssetsLoading.setPercent(0.36)

NAAssetsLoading.setStatus("collecting remote resources")
local remoteTargets = NAAssetsLoading.getRemoteTargets()
local totalRemotes = #remoteTargets
if totalRemotes > 0 then
	NAAssetsLoading.setStatus(Format("queued %d remote resources", totalRemotes))
else
	NAAssetsLoading.setStatus("queued 0 remote resources")
end
NAAssetsLoading.setPercent(0.38)

NAAssetsLoading.setStatus("prefetching remote resources")
local base, span = 0.38, 0.56
NAAssetsLoading.prefetchRemotes(function(done, total, url, success)
	local fraction = (total > 0 and (done / total)) or 1
	local progress = base + span * fraction
	if progress > 0.94 then progress = 0.94 end
	NAAssetsLoading.setPercent(progress)
	if total > 0 and (done == total or done % 5 == 0) then
		NAAssetsLoading.setStatus(Format("prefetching %d/%d", done, total))
	end
end, NAAssetsLoading.getSkip)

NAAssetsLoading.setStatus("finalizing")
NAAssetsLoading.setPercent(1)
NAAssetsLoading.completed.Value = true

Notify = Notification.Notify
Window = Notification.Window
Popup  = Notification.Popup

function DoNotif(text, duration, title)
	Notify({ Title = title or adminName or nil, Description = text or "something", Duration = duration or 5 })
end

function DebugNotif(text, duration, title)
	if not NAStuff.nuhuhNotifs then return end
	Notify({ Title = title or adminName or nil, Description = text or "something", Duration = duration or 5 })
end

function DoWindow(text, title)
	Window({ Title = title or adminName or nil, Description = text or "something" })
end

function DoPopup(text, title)
	Popup({ Title = title or adminName or nil, Description = text or "something" })
end

local mouse=SafeGetService("Players").LocalPlayer:GetMouse()

for _, ev in ipairs(events) do
	if type(Bindings[ev]) ~= "table" then
		Bindings[ev] = {}
	end
end

function countDictNA(tbl)
	local count = 0
	for _ in pairs(tbl) do
		count += 1
	end
	return count
end

--[[ Version ]]--
local curVer = isAprilFools() and Format(" V%d.%d.%d", math.random(1, 99), math.random(0, 99), math.random(0, 99)) or NAStuff.NAjson and " V"..NAStuff.NAjson.ver or ""

function getSeasonEmoji()
	local date = os.date("*t")
	local month = date.month
	local day = date.day

	if month == 1 and day == 1 then
		return '🎉' -- New Year's Day
	elseif month == 2 and day == 14 then
		return '❤️' -- Valentine's Day
	elseif month == 2 and day >= 1 and day <= 21 then
		return '🧧' -- Chinese New Year (approximate)
	elseif month == 3 and day == 17 then
		return '☘️' -- St. Patrick's Day
	elseif month == 4 and day >= 1 and day <= 15 then
		return '🥚' -- Easter (approximate)
	elseif month == 5 and day >= 8 and day <= 14 then
		return '💐' -- Mother's Day (approximate second Sunday)
	elseif month == 6 and day >= 15 and day <= 21 then
		return '👔' -- Father's Day (approximate third Sunday)
	elseif month == 6 and day == 21 then
		return '☀️' -- Summer Solstice
	elseif month == 9 and day == 22 then
		return '🍂' -- Autumn Equinox
	elseif month == 10 and day == 31 then
		return '🎃' -- Halloween
	elseif month == 11 and day >= 22 and day <= 28 then
		return '🦃' -- Thanksgiving (approximate fourth Thursday)
	elseif month == 12 and day == 25 then
		return '🎄' -- Christmas
	elseif month == 12 and day == 31 then
		return '🎆' -- New Year's Eve
	end

	if month == 12 or month <= 2 then
		return '❄️' -- Winter
	elseif month >= 3 and month <= 5 then
		return '🌸' -- Spring
	elseif month >= 6 and month <= 8 then
		return '☀️' -- Summer
	elseif month >= 9 and month <= 11 then
		return '🍂' -- Autumn
	end

	return ''
end

if (identifyexecutor and (identifyexecutor():lower()=="solara" or identifyexecutor():lower()=="xeno")) or not fireproximityprompt then
	local function hb(n)
		for i = 1, (n or 1) do
			RunService.Heartbeat:Wait()
		end
	end

	local function toOpts(o)
		if typeof(o) == "number" then
			return { hold = o }
		end
		return typeof(o) == "table" and o or {}
	end

	local state = setmetatable({}, { __mode = "k" })

	local function snapshot(pp)
		return {
			E = pp.Enabled,
			H = pp.HoldDuration,
			R = pp.RequiresLineOfSight,
			D = pp.MaxActivationDistance,
			X = pp.Exclusivity,
		}
	end

	local function begin(pp, o)
		local s = state[pp]
		if not s then
			s = snapshot(pp)
			s.ref = 0
			s.inFlight = false
			pp.Destroying:Connect(function()
				state[pp] = nil
			end)
			state[pp] = s
		end
		if s.inFlight then
			return false
		end
		s.inFlight = true
		s.ref += 1

		pp.HoldDuration = 0
		if o.requireLoS ~= nil then
			pp.RequiresLineOfSight = o.requireLoS and true or false
		end
		if o.distance ~= nil then
			pp.MaxActivationDistance = o.distance
		elseif o.autoDistance ~= false then
			pp.MaxActivationDistance = 1e9
		end
		if o.exclusivity ~= nil then
			pp.Exclusivity = o.exclusivity
		else
			pp.Exclusivity = Enum.ProximityPromptExclusivity.AlwaysShow
		end
		if o.forceEnable then
			pp.Enabled = true
		end

		return true
	end

	local function finish(pp)
		local s = state[pp]
		if not s then return end
		s.ref -= 1
		s.inFlight = false
		if s.ref <= 0 and pp and pp.Parent then
			pp.Enabled               = s.E
			pp.HoldDuration          = s.H
			pp.RequiresLineOfSight   = s.R
			pp.MaxActivationDistance = s.D
			pp.Exclusivity           = s.X
			state[pp] = nil
		end
	end

	local function fireOne(pp, o)
		if not begin(pp, o) then return end
		local ok, err = pcall(function()
			hb(1)
			pp:InputHoldBegin()
			local t = (o.hold ~= nil) and tonumber(o.hold) or 0
			if t and t > 0 then
				Wait(t)
			else
				hb(1)
			end
			pp:InputHoldEnd()
			hb(1)
		end)
		finish(pp)
		if not ok then
			warn(("[fireproximityprompt] %s"):format(err))
		end
	end

	getgenv().fireproximityprompt = function(target, opts)
		local o = toOpts(opts)
		local list = {}
		if typeof(target) == "Instance" and target:IsA("ProximityPrompt") then
			list[1] = target
		elseif typeof(target) == "table" then
			for _, v in ipairs(target) do
				if typeof(v) == "Instance" and v:IsA("ProximityPrompt") then
					Insert(list, v)
				end
			end
		else
			return false
		end

		local stagger = (o.stagger ~= nil) and math.max(0, o.stagger) or 0

		for _, pp in ipairs(list) do
			Spawn(fireOne, pp, o)
		end

		if stagger > 0 then
			for i = 2, #list do
				Wait(stagger)
			end
		end

		return true
	end
end

local JoinLeaveConfig = {
	JoinLog = false;
	LeaveLog = false;
	SaveLog = false;
}

opt.loader = Format('loadstring(game:HttpGet("%s"))();', opt.loaderUrl or "")

--Custom file functions checker checker
NAmanage.loaderState.settingsPath = NAfiles.NAMAINSETTINGSPATH
NAUserButtons = {}
UserButtonGuiList = {}
NAEXECDATA = NAEXECDATA or {commands = {}, args = {}}
doPREDICTION = true
-- make it so It's easier for IY users to move to nameless admin (yes i did this and it's funny)
local NamelessMigrate = {}
NamelessMigrate.IY_FE = {}
function NamelessMigrate:LoadIY_FE()
	if FileSupport then
		-- check if IY was installed
		if isfile("IY_FE.iy") then
			local success, content = NACaller(readfile, "IY_FE.iy")
			if success and content then
				NamelessMigrate.IY_FE = HttpService:JSONDecode(content)
				DoNotif("Some Settings have been imported from Infinite Yield")
			end
		end
	end
	NamelessMigrate.LoadIY_FE = function() end -- too lazy to make a proper check just override it
	return
end
function NamelessMigrate:Prefix()
	NamelessMigrate:LoadIY_FE()
	if FileSupport then
		if NamelessMigrate.IY_FE then
			return NamelessMigrate.IY_FE["prefix"] or nil
		end
	end
	return nil
end

function NamelessMigrate:UiSize()
	NamelessMigrate:LoadIY_FE()
	if FileSupport then
		if NamelessMigrate.IY_FE then
			return tostring(NamelessMigrate.IY_FE["guiScale"]) or nil
		end
	end
	return nil
end

function NamelessMigrate:Waypoints()
	NamelessMigrate:LoadIY_FE()
	if not FileSupport then
		return
	end

	if NamelessMigrate.IY_FE then
		local Objects = {}
		for i,v in pairs(NamelessMigrate.IY_FE["WayPoints"] or {}) do
			if not Objects[v.GAME] then
				Objects[v.GAME] = {}
			end
			local cord =  v.COORD
			cord[#cord+1] = 1
			cord[#cord+1] = 0
			cord[#cord+1] = 0
			cord[#cord+1] = 0
			cord[#cord+1] = 1
			cord[#cord+1] = 0
			cord[#cord+1] = 0
			cord[#cord+1] = 0
			cord[#cord+1] = 1
			Objects[v.GAME][v.NAME]= {["Components"] = v.COORD}
		end
		for i,v in pairs(Objects) do
			local Load = ("%s/WP_%s.json"):format(
				NAfiles.NAWAYPOINTFILEPATH,
				tostring(i)
			)
			writefile(Load, HttpService:JSONEncode(v))
		end
	end

end

NAmanage.NASettingsResolveDefault=function(def)
	local default = def.default
	if typeof(default) == "function" then
		local ok, value = pcall(default)
		if ok then
			default = value
		else
			default = nil
		end
	end
	return default
end

NAmanage.NASettingsCoerce=function(def, value)
	if value == nil then
		return NAmanage.NASettingsResolveDefault(def)
	end

	if def.coerce then
		local ok, coerced = pcall(def.coerce, value)
		if ok and coerced ~= nil then
			return coerced
		end
		return NAmanage.NASettingsResolveDefault(def)
	end

	return value
end

NAmanage.NASettingsGetSchema=function()
	if NAStuff.NASettingsSchema then
		return NAStuff.NASettingsSchema
	end

	local defaultStrokeColor = Color3.fromRGB(148, 93, 255)

	local function coerceBoolean(value, fallback)
		if type(value) == "boolean" then
			return value
		end
		if type(value) == "string" then
			local lowered = value:lower()
			if lowered == "true" or lowered == "1" then
				return true
			end
			if lowered == "false" or lowered == "0" then
				return false
			end
		end
		if type(value) == "number" then
			return value ~= 0
		end
		return fallback
	end

	local function clampChannel(value)
		local numberValue = tonumber(value)
		if not numberValue then
			return nil
		end
		if numberValue < 0 then
			numberValue = 0
		elseif numberValue > 1 then
			numberValue = 1
		end
		return numberValue
	end

	NAStuff.NASettingsSchema = {
		prefix = {
			pathKey = "NAPREFIXPATH";
			default = function()
				return NamelessMigrate:Prefix() or ";"
			end;
			coerce = function(value)
				if type(value) ~= "string" then
					value = tostring(value or ";")
				end
				if value == "" then
					return ";"
				end
				return value
			end;
		};
		buttonSize = {
			pathKey = "NABUTTONSIZEPATH";
			default = 1;
			coerce = function(value)
				local numberValue = tonumber(value)
				if not numberValue or numberValue <= 0 then
					return 1
				end
				return numberValue
			end;
		};
		uiScale = {
			pathKey = "NAUISIZEPATH";
			default = function()
				local migrated = NamelessMigrate:UiSize()
				local numberValue = tonumber(migrated)
				return numberValue and numberValue > 0 and numberValue or 1
			end;
			coerce = function(value)
				local numberValue = tonumber(value)
				if not numberValue or numberValue <= 0 then
					return 1
				end
				return numberValue
			end;
		};
		tweenSpeed = {
			default = 1;
			coerce = function(value)
				local numberValue = tonumber(value)
				if not numberValue or numberValue <= 0 then
					return 1
				end
				return numberValue
			end;
		};
		queueOnTeleport = {
			pathKey = "NAQOTPATH";
			default = false;
			coerce = function(value)
				return coerceBoolean(value, false)
			end;
		};
		prediction = {
			pathKey = "NAPREDICTIONPATH";
			default = true;
			coerce = function(value)
				return coerceBoolean(value, true)
			end;
		};
		chatTranslate = {
			default = true;
			coerce = function(value)
				return coerceBoolean(value, true)
			end;
		};
		chatTranslateTarget = {
			default = "en";
			coerce = function(value)
				if type(value) ~= "string" then
					value = tostring(value or "en")
				end
				value = value:lower()
				if value == "" then
					return "en"
				end
				return value
			end;
		};
		uiStroke = {
			pathKey = "NASTROKETHINGY";
			default = function()
				return {
					R = defaultStrokeColor.R;
					G = defaultStrokeColor.G;
					B = defaultStrokeColor.B;
				}
			end;
			coerce = function(value)
				local parsed = value
				if typeof(value) == "Color3" then
					parsed = {
						R = value.R;
						G = value.G;
						B = value.B;
					}
				elseif type(value) == "string" then
					local ok, decoded = NACaller(function()
						return HttpService:JSONDecode(value)
					end)
					if ok and typeof(decoded) == "table" then
						parsed = decoded
					else
						parsed = nil
					end
				end

				if type(parsed) == "table" then
					local r = clampChannel(parsed.R)
					local g = clampChannel(parsed.G)
					local b = clampChannel(parsed.B)
					if r and g and b then
						return {
							R = r;
							G = g;
							B = b;
						}
					end
				end

				return {
					R = defaultStrokeColor.R;
					G = defaultStrokeColor.G;
					B = defaultStrokeColor.B;
				}
			end;
		};
		iconInvisible = {
			default = false;
			coerce = function(value)
				return coerceBoolean(value, false)
			end;
		};
		iconLocked = {
			default = false;
			coerce = function(value)
				if type(value) == "boolean" then return value end
				if type(value) == "string" then
					local v = value:lower()
					if v == "true" or v == "1" then return true end
					if v == "false" or v == "0" then return false end
				end
				if type(value) == "number" then return value ~= 0 end
				return false
			end;
		};
		topbarVisible = {
			pathKey = "NATOPBAR";
			default = true;
			coerce = function(value)
				return coerceBoolean(value, true)
			end;
		};
		notifsToggle = {
			pathKey = "NANOTIFSTOGGLE";
			default = false;
			coerce = function(value)
				return coerceBoolean(value, false)
			end;
		};
		devConsoleFilters = {
			default = function()
				return {
					Output = true;
					Info = true;
					Warn = true;
					Error = true;
				}
			end;
			coerce = function(value)
				local result = {
					Output = true;
					Info = true;
					Warn = true;
					Error = true;
				}
				if typeof(value) == "table" then
					result.Output = coerceBoolean(value.Output, result.Output)
					result.Info = coerceBoolean(value.Info, result.Info)
					result.Warn = coerceBoolean(value.Warn, result.Warn)
					result.Error = coerceBoolean(value.Error, result.Error)
				end
				return result
			end;
		};
		autoSkipLoading = {
			default = false;
			coerce = function(value)
				return coerceBoolean(value, false)
			end;
		};
		topbarMode = {
			pathKey = "NATOPBARMODE";
			default = "bottom";
			coerce = function(value)
				if type(value) ~= "string" then
					return "bottom"
				end
				if value == "side" then
					return "side"
				end
				return "bottom"
			end;
		};
	}

	return NAStuff.NASettingsSchema
end

NAmanage.NASettingsSave=function()
	if not FileSupport or not NAStuff.NASettingsData then
		return
	end

	local ok, encoded = NACaller(function()
		return HttpService:JSONEncode(NAStuff.NASettingsData)
	end)

	if ok and encoded then
		NACaller(writefile, NAfiles.NAMAINSETTINGSPATH, encoded)
	end
end

NAmanage.NASettingsEnsure=function()
	if NAStuff.NASettingsData then
		return NAStuff.NASettingsData
	end

	local schema = NAmanage.NASettingsGetSchema()
	NAStuff.NASettingsData = {}

	if FileSupport and type(isfile) == "function" and isfile(NAfiles.NAMAINSETTINGSPATH) then
		local ok, raw = NACaller(readfile, NAfiles.NAMAINSETTINGSPATH)
		if ok and raw and raw ~= "" then
			local success, decoded = NACaller(function()
				return HttpService:JSONDecode(raw)
			end)
			if success and typeof(decoded) == "table" then
				NAStuff.NASettingsData = decoded
			end
		end
	end

	if typeof(NAStuff.NASettingsData) ~= "table" then
		NAStuff.NASettingsData = {}
	end

	local legacyPaths = {}
	for key, def in pairs(schema) do
		legacyPaths[key] = def.pathKey and NAfiles[def.pathKey] or nil
	end

	for key, def in pairs(schema) do
		local value = NAStuff.NASettingsData[key]

		if value == nil and FileSupport and type(isfile) == "function" then
			local legacyPath = legacyPaths[key]
			if legacyPath and isfile(legacyPath) then
				local ok, legacyRaw = NACaller(readfile, legacyPath)
				if ok and legacyRaw ~= nil then
					value = legacyRaw
				end
				if delfile then
					NACaller(delfile, legacyPath)
				end
			end
		end

		NAStuff.NASettingsData[key] = NAmanage.NASettingsCoerce(def, value)
	end

	NAmanage.NASettingsSave()
	return NAStuff.NASettingsData
end

NAmanage.NASettingsGet=function(key)
	local settings = NAmanage.NASettingsEnsure()
	return settings[key]
end

NAmanage.NASettingsSet=function(key, value)
	local schema = NAmanage.NASettingsGetSchema()
	local def = schema[key]
	if not def then
		return
	end

	local settings = NAmanage.NASettingsEnsure()
	settings[key] = NAmanage.NASettingsCoerce(def, value)
	NAmanage.NASettingsSave()
	return settings[key]
end

-- Creates folder & files for Prefix, Plugins, and etc
if FileSupport then
	if not isfolder(NAfiles.NAFILEPATH) then
		makefolder(NAfiles.NAFILEPATH)
	end

	if not isfolder(NAfiles.NAWAYPOINTFILEPATH) then
		makefolder(NAfiles.NAWAYPOINTFILEPATH)
		-- imagine if it didn't make the folder
		if isfolder(NAfiles.NAWAYPOINTFILEPATH) then
			NamelessMigrate:Waypoints()
		end
	end

	if not isfolder(NAfiles.NAPLUGINFILEPATH) then
		makefolder(NAfiles.NAPLUGINFILEPATH)
	end

	if not isfolder(NAfiles.NAASSETSFILEPATH) then
		makefolder(NAfiles.NAASSETSFILEPATH)
	end

	if not isfile(NAfiles.NAALIASPATH) then
		writefile(NAfiles.NAALIASPATH, "{}")
	end

	if not isfile(NAfiles.NAICONPOSPATH) then
		writefile(NAfiles.NAICONPOSPATH, HttpService:JSONEncode({
			X = 0.5;
			Y = 0.1;
			Save = false;
		}))
	end

	if not isfile(NAfiles.NAUSERBUTTONSPATH) then
		writefile(NAfiles.NAUSERBUTTONSPATH, HttpService:JSONEncode({}))
	end

	if not isfile(NAfiles.NAAUTOEXECPATH) then
		writefile(NAfiles.NAAUTOEXECPATH, HttpService:JSONEncode({ commands = {}, args = {} }))
	end

	if not isfile(NAfiles.NAJOINLEAVE) then
		writefile(NAfiles.NAJOINLEAVE, HttpService:JSONEncode({
			JoinLog = false;
			LeaveLog = false;
			SaveLog = false;
		}))
	end

	--[[if not isfile(NAfiles.NACHATTAG) then
		writefile(NAfiles.NACHATTAG, HttpService:JSONEncode({
			Text = "Tag";
			Color = {
				R = 0;
				G = 1;
				B = 170 / 255;
			};
			Save = false;
		}))
	end]]

	if not isfile(NAfiles.NABINDERS) then
		writefile(NAfiles.NABINDERS, "{}")
	end

	if not isfile(NAfiles.NATEXTCHATSETTINGSPATH) then
		writefile(NAfiles.NATEXTCHATSETTINGSPATH, HttpService:JSONEncode(NAStuff.ChatSettings))
	end

	NAmanage.NASettingsEnsure()
end

function InitUIStroke()
	local defaultColor = Color3.fromRGB(148, 93, 255)

	if not FileSupport then
		DoNotif("UI Stroke defaulted: no file support")
		return defaultColor
	end

	local data = NAmanage.NASettingsGet("uiStroke")
	if type(data) == "table" then
		local r = tonumber(data.R)
		local g = tonumber(data.G)
		local b = tonumber(data.B)
		if r and g and b then
			return Color3.new(r, g, b)
		end
	end

	NAmanage.NASettingsSet("uiStroke", {
		R = defaultColor.R;
		G = defaultColor.G;
		B = defaultColor.B;
	})
	DoNotif("UI Stroke color reset to default due to invalid or missing data.")
	return defaultColor
end

NAmanage.topbar_readMode=function()
	local mode = NAmanage.NASettingsGet("topbarMode")
	return mode == "side" and "side" or "bottom"
end

NAmanage.topbar_writeMode=function(m)
	if m ~= "side" then
		m = "bottom"
	end
	NAmanage.NASettingsSet("topbarMode", m)
end

NAmanage.GetWPPath=function()
	if not game.PlaceId or type(game.PlaceId) ~= "number" then
		repeat Wait() until type(game.PlaceId) == "number"
	end
	return ("%s/WP_%s.json"):format(
		NAfiles.NAWAYPOINTFILEPATH,
		tostring(game.PlaceId)
	)
end

NAmanage.mPosVector = function()
	return Vector2.new(mouse.X, mouse.Y)
end

NAmanage.worlScreen=function(obj)
	local vec = workspace.CurrentCamera:WorldToScreenPoint(obj.Position)
	return Vector2.new(vec.X, vec.Y)
end

NAmanage.getPlrCursor = function()
	local found = nil
	local ClosestDistance = math.huge
	for _,v in pairs(Players:GetPlayers()) do
		if v ~= Players.LocalPlayer and v.Character and v.Character:FindFirstChildOfClass("Humanoid") then
			for k, x in pairs(v.Character:GetChildren()) do
				if Find(x.Name, "Torso") then
					local Distance = (NAmanage.worlScreen(x) - NAmanage.mPosVector()).Magnitude
					if Distance < ClosestDistance then
						ClosestDistance = Distance
						found = v
					end
				end
			end
		end
	end
	return found
end

local WPPath = NAmanage.GetWPPath()
local bindersPath = NAfiles.NABINDERS

NAmanage.LoadESPSettings = function()
	local d = {
		ESP_Transparency = 0.7;
		ESP_BoxMaxDistance = 120;
		ESP_LabelMaxDistance = 1000;
		ESP_ColorByTeam = true;
		ESP_ShowTeamText = true;
		ESP_ShowName = true;
		ESP_ShowHealth = true;
		ESP_ShowDistance = true;
		ESP_RenderMode = "BoxHandleAdornment";
		ESP_LabelTextSize = 12;
		ESP_LabelTextScaled = false;
		ESP_ShowPartDistance = false;
		ESP_LocatorEnabled = false;
		ESP_LocatorSize = 26;
		ESP_LocatorShowText = false;
		ESP_LocatorTextSize = 14;
	}
	if FileSupport then
		if not isfile(NAfiles.NAESPSETTINGSPATH) then
			writefile(NAfiles.NAESPSETTINGSPATH, HttpService:JSONEncode(d))
		end
		local ok, raw = pcall(readfile, NAfiles.NAESPSETTINGSPATH)
		if ok and raw then
			local ok2, cfg = pcall(HttpService.JSONDecode, HttpService, raw)
			if ok2 and type(cfg)=="table" then
				for key, defaultValue in pairs(d) do
					local stored = cfg[key]
					if stored ~= nil then
						local kind = typeof(defaultValue)
						if kind == "number" then
							local numeric = tonumber(stored)
							if numeric then d[key] = numeric end
						elseif kind == "boolean" then
							if typeof(stored)=="boolean" then
								d[key] = stored
							elseif typeof(stored)=="number" then
								d[key] = stored ~= 0
							elseif typeof(stored)=="string" then
								local s = stored:lower()
								if s=="true" or s=="1" then d[key]=true
								elseif s=="false" or s=="0" then d[key]=false end
							end
						else
							d[key] = stored
						end
					end
				end
			end
		end
	end
	local mode = tostring(d.ESP_RenderMode or "BoxHandleAdornment")
	mode = (type(mode)=="string" and (Lower(mode)=="highlight" and "Highlight" or "BoxHandleAdornment")) or "BoxHandleAdornment"
	local sz = tonumber(d.ESP_LabelTextSize) or 12
	if sz < 8 then sz = 8 elseif sz > 72 then sz = 72 end

	NAStuff.ESP_Transparency     = d.ESP_Transparency
	NAStuff.ESP_BoxMaxDistance   = d.ESP_BoxMaxDistance
	NAStuff.ESP_LabelMaxDistance = d.ESP_LabelMaxDistance
	NAStuff.ESP_ColorByTeam      = d.ESP_ColorByTeam
	NAStuff.ESP_ShowTeamText     = d.ESP_ShowTeamText
	NAStuff.ESP_ShowName         = d.ESP_ShowName
	NAStuff.ESP_ShowHealth       = d.ESP_ShowHealth
	NAStuff.ESP_ShowDistance     = d.ESP_ShowDistance
	NAStuff.ESP_ShowPartDistance = d.ESP_ShowPartDistance
	NAStuff.ESP_RenderMode       = mode
	NAStuff.ESP_LabelTextSize    = sz
	NAStuff.ESP_LabelTextScaled  = d.ESP_LabelTextScaled == true

	NAStuff.ESP_LocatorEnabled   = d.ESP_LocatorEnabled == true
	NAStuff.ESP_LocatorSize      = math.clamp(tonumber(d.ESP_LocatorSize) or 26, 12, 128)
	NAStuff.ESP_LocatorShowText  = d.ESP_LocatorShowText == true
	NAStuff.ESP_LocatorTextSize  = math.clamp(tonumber(d.ESP_LocatorTextSize) or 14, 10, 48)

	if NAStuff.ESP_LocatorEnabled then
		NAmanage.ESP_LocatorEnable(true)
	else
		NAmanage.ESP_LocatorDisable()
	end
end

NAmanage.SaveESPSettings = function()
	if not FileSupport then return end
	local mode = "BoxHandleAdornment"
	if type(NAStuff.ESP_RenderMode) == "string" and Lower(NAStuff.ESP_RenderMode)=="highlight" then
		mode = "Highlight"
	end
	local sz = tonumber(NAStuff.ESP_LabelTextSize) or 12
	if sz < 8 then sz = 8 elseif sz > 72 then sz = 72 end
	local d = {
		ESP_Transparency = NAStuff.ESP_Transparency or 0.7;
		ESP_BoxMaxDistance = NAStuff.ESP_BoxMaxDistance or 120;
		ESP_LabelMaxDistance = NAStuff.ESP_LabelMaxDistance or 1000;
		ESP_ColorByTeam = (NAStuff.ESP_ColorByTeam ~= false);
		ESP_ShowTeamText = (NAStuff.ESP_ShowTeamText ~= false);
		ESP_ShowName = (NAStuff.ESP_ShowName ~= false);
		ESP_ShowHealth = (NAStuff.ESP_ShowHealth ~= false);
		ESP_ShowDistance = (NAStuff.ESP_ShowDistance ~= false);
		ESP_ShowPartDistance = (NAStuff.ESP_ShowPartDistance == true);
		ESP_RenderMode = mode;
		ESP_LabelTextSize = sz;
		ESP_LabelTextScaled = NAStuff.ESP_LabelTextScaled == true;
		ESP_LocatorEnabled = NAStuff.ESP_LocatorEnabled == true;
		ESP_LocatorSize = math.clamp(tonumber(NAStuff.ESP_LocatorSize) or 26, 12, 128);
		ESP_LocatorShowText = NAStuff.ESP_LocatorShowText == true;
		ESP_LocatorTextSize = math.clamp(tonumber(NAStuff.ESP_LocatorTextSize) or 14, 10, 48);
	}
	writefile(NAfiles.NAESPSETTINGSPATH, HttpService:JSONEncode(d))
end

NAmanage.SaveBinders=function()
	if FileSupport then
		writefile(bindersPath, HttpService:JSONEncode(Bindings))
	end
end

local function deepCopyTable(value)
	if type(value) ~= "table" then return value end
	local copy = {}
	for k, v in pairs(value) do
		copy[k] = deepCopyTable(v)
	end
	return copy
end

local function safeDeleteFile(path)
	if type(path) ~= "string" then
		return false, "Invalid file path."
	end
	if not (delfile and isfile) then
		return false, "File deletion not supported by this executor."
	end
	if not isfile(path) then
		return true, "File already removed."
	end
	local ok, err = pcall(delfile, path)
	if not ok then
		return false, err or "Failed to delete file."
	end
	return true, "File deleted."
end

local function safeClearFolder(path, opts)
	opts = opts or {}
	if type(path) ~= "string" then
		return false, "Invalid folder path."
	end
	if not (isfolder and listfiles and makefolder) then
		return false, "Folder operations not supported by this executor."
	end
	if not isfolder(path) then
		return true, "Folder already removed."
	end

	local okList, entries = pcall(listfiles, path)
	if okList and type(entries) == "table" then
		for _, entry in ipairs(entries) do
			if isfolder(entry) then
				local okSub, errSub = safeClearFolder(entry, { removeRoot = true })
				if not okSub then
					return false, errSub
				end
				if delfolder then
					local okDel, errDel = pcall(delfolder, entry)
					if not okDel then
						return false, errDel or ("Failed to remove "..entry)
					end
				end
			else
				if isfile and isfile(entry) then
					local okDel, errDel = pcall(delfile, entry)
					if not okDel then
						return false, errDel or ("Failed to delete "..entry)
					end
				end
			end
		end
	end

	local removedRoot = false
	if opts.removeRoot then
		if delfolder then
			local okDel, errDel = pcall(delfolder, path)
			if not okDel then
				return false, errDel or ("Failed to remove "..path)
			end
			removedRoot = true
		end
	end

	if (opts.recreate or (opts.removeRoot and not removedRoot)) and makefolder then
		local okMk, errMk = pcall(makefolder, path)
		if not okMk then
			return false, errMk or ("Failed to recreate "..path)
		end
	end

	if opts.removeRoot and not removedRoot and not delfolder then
		return true, "Cleared folder contents (folder kept; executor lacks delfolder)."
	end
	if removedRoot and opts.recreate then
		return true, "Folder rebuilt."
	elseif removedRoot then
		return true, "Folder removed."
	end
	return true, "Folder cleared."
end

local SettingsCleanupItems = {
	{ label = "Main Settings", path = NAfiles.NAMAINSETTINGSPATH, kind = "file", displayType = "json", success = "Main settings deleted." },
	{ label = "Aliases", path = NAfiles.NAALIASPATH, kind = "file", displayType = "json", success = "Alias list deleted." },
	{ label = "User Buttons", path = NAfiles.NAUSERBUTTONSPATH, kind = "file", displayType = "json", success = "User buttons reset." },
	{ label = "AutoExec Commands", path = NAfiles.NAAUTOEXECPATH, kind = "file", displayType = "json", success = "AutoExec commands cleared." },
	{ label = "Binders", path = NAfiles.NABINDERS, kind = "file", displayType = "json", success = "Binders file deleted." },
	{ label = "Join/Leave Settings", path = NAfiles.NAJOINLEAVE, kind = "file", displayType = "json", success = "Join/Leave settings deleted." },
	{ label = "Join/Leave Log", path = NAfiles.NAJOINLEAVELOG, kind = "file", displayType = "txt", success = "Join/Leave log cleared." },
	{ label = "Chat Logs", path = NAfiles.NACHATLOGS, kind = "file", displayType = "txt", success = "Chat logs cleared." },
	{ label = "Icon Position", path = NAfiles.NAICONPOSPATH, kind = "file", displayType = "json", success = "Icon position reset." },
	{ label = "ESP Settings", path = NAfiles.NAESPSETTINGSPATH, kind = "file", displayType = "json", success = "ESP settings deleted." },
	{ label = "Topbar Layout", path = NAfiles.NATOPBAR, kind = "file", displayType = "txt", success = "Topbar layout reset." },
	{ label = "Notification Toggle", path = NAfiles.NANOTIFSTOGGLE, kind = "file", displayType = "txt", success = "Notification toggle reset." },
	{ label = "Text Chat Settings", path = NAfiles.NATEXTCHATSETTINGSPATH, kind = "file", displayType = "json", success = "Text chat settings deleted." },
	{ label = "Waypoints", path = NAfiles.NAWAYPOINTFILEPATH, kind = "folder", displayType = "folder", removeRoot = true, recreate = true, success = "Waypoints folder cleared." },
	{ label = "Plugins", path = NAfiles.NAPLUGINFILEPATH, kind = "folder", displayType = "folder", removeRoot = true, recreate = true, success = "Plugins folder cleared." },
	{ label = "Assets Cache", path = NAfiles.NAASSETSFILEPATH, kind = "folder", displayType = "folder", removeRoot = true, recreate = true, success = "Assets cache cleared." },
	{ label = "All Saved Data", path = NAfiles.NAFILEPATH, kind = "folder", displayType = "folder", removeRoot = true, recreate = true, success = "Nameless-Admin folder cleared." },
}

function NAmanage.buildSettingsCleanupButtons()
	local buttons = {}
	if not FileSupport then
		return buttons
	end

	for _, entry in ipairs(SettingsCleanupItems) do
		local exists = false
		if entry.kind == "file" then
			exists = isfile and isfile(entry.path)
		elseif entry.kind == "folder" then
			exists = listfiles and isfolder and isfolder(entry.path)
		end

		if exists then
			local opt = entry
			local buttonText = Format("%s (%s)", opt.label, opt.displayType or opt.kind)
			Insert(buttons, {
				Text = buttonText,
				Callback = function()
					local ok, info
					if opt.kind == "file" then
						ok, info = safeDeleteFile(opt.path)
					else
						ok, info = safeClearFolder(opt.path, { removeRoot = opt.removeRoot, recreate = opt.recreate })
					end

					if ok then
						DoNotif(opt.success or info or Format("%s removed.", opt.label), 3)
						if type(opt.after) == "function" then
							pcall(opt.after)
						end
					else
						DoNotif(opt.failure or Format("Failed to remove %s: %s", opt.label, tostring(info)), 4)
					end
				end,
			})
		end
	end

	return buttons
end

function NAmanage.openSettingsCleanupPopup()
	if not FileSupport then
		DoNotif("File support is required to delete saved settings.", 3)
		return
	end
	if type(Popup) ~= "function" then
		DoNotif("Popup UI is unavailable in this session.", 3)
		return
	end

	local buttons = NAmanage.buildSettingsCleanupButtons()
	if #buttons == 0 then
		DoNotif("No saved Nameless-Admin files or folders were found.", 3)
		return
	end

	Popup({
		Title = "Delete Saved Settings",
		Description = "Select a saved file or folder to remove. This action cannot be undone.",
		Duration = 0,
		Buttons = buttons,
	})
end

opt.chatTranslateEnabled = NAmanage.NASettingsGet("chatTranslate")
opt.chatTranslateTarget = NAmanage.NASettingsGet("chatTranslateTarget")

if FileSupport then
	prefixCheck = NAmanage.NASettingsGet("prefix")
	NAsavedScale = NAmanage.NASettingsGet("buttonSize")
	NAUISavedScale = NAmanage.NASettingsGet("uiScale")
	NAQoTEnabled = NAmanage.NASettingsGet("queueOnTeleport")
	NAStuff.nuhuhNotifs = NAmanage.NASettingsGet("notifsToggle")
	local savedTweenSpeed = NAmanage.NASettingsGet("tweenSpeed")
	if type(savedTweenSpeed) == "number" and savedTweenSpeed > 0 then
		NAStuff.tweenSpeed = savedTweenSpeed
	end
	doPREDICTION = NAmanage.NASettingsGet("prediction")
	NAUISTROKER = InitUIStroke()
	NAStuff.IconInvisible = NAmanage.NASettingsGet("iconInvisible")
	NAStuff.IconLocked = NAmanage.NASettingsGet("iconLocked")
	NATOPBARVISIBLE = NAmanage.NASettingsGet("topbarVisible")

	if prefixCheck == "" or utf8.len(prefixCheck) > 1 or prefixCheck:match("[%w]")
		or prefixCheck:match("[%[%]%(%)%*%^%$%%{}<>]")
		or prefixCheck:match("&amp;") or prefixCheck:match("&lt;") or prefixCheck:match("&gt;")
		or prefixCheck:match("&quot;") or prefixCheck:match("&#x27;") or prefixCheck:match("&#x60;") then

		prefixCheck = ";"
		NAmanage.NASettingsSet("prefix", ";")
		DoNotif("Your prefix has been reset to the default (;) due to invalid symbol.")
	end

	if NAsavedScale and NAsavedScale > 0 then
		NAScale = NAsavedScale
	else
		NAScale = 1
		NAmanage.NASettingsSet("buttonSize", 1)
		DoNotif("ImageButton size has been reset to default due to invalid data.")
	end

	if NAUISavedScale and NAUISavedScale > 0 then
		NAUIScale = NAUISavedScale
	else
		NAUIScale = 1
		NAmanage.NASettingsSet("uiScale", 1)
		DoNotif("UI Scale has been reset to default due to invalid data.")
	end
	if isfile(NAfiles.NAJOINLEAVE) then
		local success, data = pcall(function()
			return HttpService:JSONDecode(readfile(NAfiles.NAJOINLEAVE))
		end)

		if success and type(data) == "table" then
			JoinLeaveConfig = data
		end
	end

	--[[if isfile(NAfiles.NACHATTAG) then
		local success, data = pcall(function()
			return HttpService:JSONDecode(readfile(NAfiles.NACHATTAG))
		end)

		if success and typeof(data) == "table" then
			if type(data.Text) == "string" then
				opt.currentTagText = data.Text
			end

			if type(data.Color) == "table" and data.Color.R and data.Color.G and data.Color.B then
				opt.currentTagColor = Color3.new(data.Color.R, data.Color.G, data.Color.B)
			end

			if type(data.RGB) == "boolean" then
				opt.currentTagRGB = data.RGB
			end

			if type(data.Save) == "boolean" then
				opt.saveTag = data.Save
			else
				opt.saveTag = false
			end
		else
			opt.currentTagText = "Tag"
			opt.currentTagColor = Color3.fromRGB(0, 255, 170)
			opt.currentTagRGB = false
			opt.saveTag = false
			DoNotif("Chat tag file was corrupt or unreadable. Loaded defaults",3)
		end
	end]]

	if isfile(NAfiles.NAICONPOSPATH) then
		local success, data = pcall(function()
			return HttpService:JSONDecode(readfile(NAfiles.NAICONPOSPATH))
		end)
		if success and type(data) == "table" then
			local rewrite = false
			if type(data.X) == "number" then
				local clampedX = math.clamp(data.X, 0, 1)
				if clampedX ~= data.X then
					data.X = clampedX
					rewrite = true
				end
			end
			if type(data.Y) == "number" then
				local clampedY = math.clamp(data.Y, 0, 1)
				if clampedY ~= data.Y then
					data.Y = clampedY
					rewrite = true
				end
			end
			if rewrite then
				pcall(writefile, NAfiles.NAICONPOSPATH, HttpService:JSONEncode(data))
			end
			if data.Save ~= nil then
				NAiconSaveEnabled = data.Save
			else
				NAiconSaveEnabled = false
			end
		else
			NAiconSaveEnabled = false
		end
	else
		NAiconSaveEnabled = false
	end

	local path = NAmanage.GetWPPath()
	local ok, data = false, nil

	if isfile(path) then
		ok, data = pcall(function()
			return HttpService:JSONDecode(readfile(path))
		end)
	end

	Waypoints = (ok and type(data) == "table") and data or {}

	local ok, data = pcall(function() return HttpService:JSONDecode(readfile(bindersPath)) end)
	Bindings = ok and type(data)=="table" and data or {}

	do
		local src = Bindings["OnSpawned"]
		if type(src) == "table" and #src > 0 then
			Bindings["OnSpawn"] = Bindings["OnSpawn"] or {}
			for _, line in ipairs(src) do
				if line:match("^%s*[<%[]") then
					Insert(Bindings["OnSpawn"], line)
				else
					Insert(Bindings["OnSpawn"], "<me> "..line)
				end
			end
			Bindings["OnSpawned"] = nil
			NAmanage.SaveBinders()
		end
	end

	local ChatConfigPath = NAfiles.NATEXTCHATSETTINGSPATH

	local function tblToC3(t)
		if typeof(t) == "Color3" then return t end
		local r = (t and (t.R or t[1])) or 255
		local g = (t and (t.G or t[2])) or 255
		local b = (t and (t.B or t[3])) or 255
		return Color3.fromRGB(r, g, b)
	end
	local function c3ToTbl(c)
		return { math.floor(c.R * 255 + 0.5), math.floor(c.G * 255 + 0.5), math.floor(c.B * 255 + 0.5) }
	end
	local function deepMerge(dst, src)
		for k, v in pairs(src) do
			if type(v) == "table" and type(dst[k]) == "table" then
				deepMerge(dst[k], v)
			else
				dst[k] = v
			end
		end
	end

	NAStuff.ChatSettingsTemplate = deepCopyTable(NAStuff.ChatSettings)

	local function loadChat()
		local cfg = deepCopyTable(NAStuff.ChatSettingsTemplate or NAStuff.ChatSettings)
		if isfile(ChatConfigPath) then
			local ok3, d = pcall(function() return HttpService:JSONDecode(readfile(ChatConfigPath)) end)
			if ok3 and type(d)=="table" then deepMerge(cfg, d) end
		end
		return cfg
	end

	NAStuff.ChatSettings = loadChat()

	originalIO.getChatTemplateSection=function(section)
		local template = NAStuff.ChatSettingsTemplate
		if type(template) ~= "table" then return nil end
		return template[section]
	end

	originalIO.assignChatSectionFromTemplate=function(section)
		local defaults = originalIO.getChatTemplateSection(section)
		if defaults == nil then return false end
		if type(defaults) == "table" then
			NAStuff.ChatSettings[section] = deepCopyTable(defaults)
		else
			NAStuff.ChatSettings[section] = defaults
		end
		return true
	end

	originalIO.ensureChatCustomBackup=function()
		if type(NAStuff.ChatSettingsCustomBackup) ~= "table" then
			NAStuff.ChatSettingsCustomBackup = {}
		end
		return NAStuff.ChatSettingsCustomBackup
	end

	originalIO.backupChatSection=function(section)
		if type(NAStuff.ChatSettings) ~= "table" then return end
		local current = NAStuff.ChatSettings[section]
		if current == nil then return end
		local backup = originalIO.ensureChatCustomBackup()
		if type(current) == "table" then
			backup[section] = deepCopyTable(current)
		else
			backup[section] = current
		end
	end

	originalIO.restoreChatSectionFromBackup=function(section)
		local backup = NAStuff.ChatSettingsCustomBackup
		if type(backup) ~= "table" then return false end
		local saved = backup[section]
		if saved == nil then return false end
		if type(saved) == "table" then
			NAStuff.ChatSettings[section] = deepCopyTable(saved)
		else
			NAStuff.ChatSettings[section] = saved
		end
		return true
	end

	NAmanage.SaveTextChatSettings = function()
		local ok4, json = pcall(function() return HttpService:JSONEncode(NAStuff.ChatSettings) end)
		if ok4 then pcall(writefile, ChatConfigPath, json) end
		if NAmanage.SyncChatSettingsUI then
			NAmanage.SyncChatSettingsUI()
		end
	end

	NAmanage.SyncChatSettingsUI = function(opts)
		opts = opts or {}
		local shouldFire = opts.fire == true
		local chat = NAStuff.ChatSettings
		if type(chat) ~= "table" then return end

		local window = chat.window or {}
		local tabs = chat.tabs or {}
		local input = chat.input or {}
		local bubbles = chat.bubbles or {}

		local function setToggle(label, value)
			if not NAgui.setToggleState then return end
			NAgui.setToggleState(label, value and true or false, { force = true, fire = shouldFire and true or false })
		end

		local function setSlider(label, value)
			if value == nil or not NAgui.setSliderValue then return end
			if type(value) ~= "number" then return end
			NAgui.setSliderValue(label, value, { force = true, fire = shouldFire and true or false })
		end

		local function setColor(label, value)
			if value == nil or not NAgui.setColorPickerValue then return end
			local ok, color = pcall(tblToC3, value)
			if not ok or typeof(color) ~= "Color3" then return end
			NAgui.setColorPickerValue(label, color, { fire = shouldFire and true or false })
		end

		setToggle("Enable Custom Chat Styling", chat.customEnabled)
		setToggle("Enable Chat (CoreGui)", chat.coreGuiChat)
		setToggle("Window Enabled", window.enabled)
		setToggle("Tabs Enabled", tabs.enabled)
		setToggle("Input Enabled", input.enabled)
		setToggle("Autocomplete", input.autocomplete)
		setToggle("Target #RBXGeneral", input.targetGeneral)
		setToggle("Bubbles Enabled", bubbles.enabled)
		setToggle("Tail Visible", bubbles.tailVisible)

		setSlider("Text Size (Window)", window.textSize)
		setSlider("Text Stroke Transparency", window.strokeTransparency)
		setSlider("Window Background Transparency", window.backgroundTransparency)
		setSlider("Text Size (Tabs)", tabs.textSize)
		setSlider("Background Transparency (Tabs)", tabs.backgroundTransparency)
		setSlider("Text Size (Input)", input.textSize)
		setSlider("Text Stroke Transparency (Input)", input.strokeTransparency)
		setSlider("Background Transparency (Input)", input.backgroundTransparency)
		setSlider("Max Distance", bubbles.maxDistance)
		setSlider("Minimize Distance", bubbles.minimizeDistance)
		setSlider("Text Size (Bubble)", bubbles.textSize)
		setSlider("Bubble Spacing", bubbles.spacing)
		setSlider("Background Transparency (Bubble)", bubbles.backgroundTransparency)

		setColor("Text Color", window.textColor)
		setColor("Text Stroke Color", window.strokeColor)
		setColor("Window Background", window.backgroundColor)
		setColor("Text Color (Tabs)", tabs.textColor)
		setColor("Selected Text Color", tabs.selectedTextColor)
		setColor("Unselected Text Color", tabs.unselectedTextColor)
		setColor("Text Color (Input)", input.textColor)
	end

	local function hasProp(inst, prop)
		return inst and NAlib.isProperty(inst, prop) ~= nil
	end
	local function safeSet(inst, prop, val)
		if inst and hasProp(inst, prop) then NAlib.setProperty(inst, prop, val) end
	end
	local function getDefaultChannel(TCS)
		local container = TCS:FindFirstChild("TextChannels")
		if not container then return nil end
		local gen = container:FindFirstChild("RBXGeneral")
		if gen and gen:IsA("TextChannel") then return gen end
		for _, c in ipairs(container:GetChildren()) do
			if c:IsA("TextChannel") then return c end
		end
		return nil
	end

	originalIO.getChatDefaults=function()
		if not NAStuff.ChatSettingsDefaults then
			NAStuff.ChatSettingsDefaults = {
				window = {};
				tabs = {};
				input = {};
				bubbles = {};
			}
		end
		return NAStuff.ChatSettingsDefaults
	end

	originalIO.rememberChatDefault=function(group, inst, prop)
		if not inst then return end
		local defaults = originalIO.getChatDefaults()
		local groupDefaults = defaults[group]
		local info = groupDefaults[prop]
		if info and info.source == inst then return end
		if not hasProp(inst, prop) then return end
		local ok, value = pcall(function() return inst[prop] end)
		if not ok then return end
		groupDefaults[prop] = { has = true, value = value, source = inst }
	end

	originalIO.captureChatDefaults=function(Window, Tabs, InputBar, Bubbles)
		local function captureGroup(group, inst, props)
			if not inst then return end
			for _, prop in ipairs(props) do
				originalIO.rememberChatDefault(group, inst, prop)
			end
		end

		originalIO.getChatDefaults()
		captureGroup("window", Window, { "Enabled", "FontFace", "TextSize", "TextColor3", "TextStrokeColor3", "TextStrokeTransparency", "BackgroundColor3", "BackgroundTransparency" })
		captureGroup("tabs", Tabs, { "Enabled", "FontFace", "TextSize", "BackgroundTransparency", "TextColor3", "SelectedTabTextColor3", "UnselectedTabTextColor3" })
		captureGroup("input", InputBar, { "Enabled", "AutocompleteEnabled", "FontFace", "TargetTextChannel", "KeyboardKeyCode", "TextSize", "TextColor3", "TextStrokeTransparency", "BackgroundTransparency" })
		captureGroup("bubbles", Bubbles, { "Enabled", "MaxDistance", "MinimizeDistance", "TextSize", "BubblesSpacing", "BackgroundTransparency", "TailVisible" })
	end

	originalIO.applyChatDefaultGroup=function(group, inst)
		local defaults = NAStuff.ChatSettingsDefaults
		if not defaults or not inst then return end
		local groupDefaults = defaults[group]
		if not groupDefaults then return end
		for prop, info in pairs(groupDefaults) do
			if info and info.has then
				safeSet(inst, prop, info.value)
			end
		end
	end

	originalIO.restoreChatDefaults=function(Window, Tabs, InputBar, Bubbles)
		originalIO.applyChatDefaultGroup("window", Window)
		originalIO.applyChatDefaultGroup("tabs", Tabs)
		originalIO.applyChatDefaultGroup("input", InputBar)
		originalIO.applyChatDefaultGroup("bubbles", Bubbles)
	end

	NAmanage.ApplyTextChatSettings = function()
		pcall(function() StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.Chat, NAStuff.ChatSettings.coreGuiChat) end)
		local TCS = TextChatService

		local Window = TCS:FindFirstChildOfClass("ChatWindowConfiguration")
		local InputBar = TCS:FindFirstChildOfClass("ChatInputBarConfiguration")
		local Bubbles = TCS:FindFirstChildOfClass("BubbleChatConfiguration")
		local Tabs = TCS:FindFirstChildOfClass("ChannelTabsConfiguration")

		originalIO.captureChatDefaults(Window, Tabs, InputBar, Bubbles)

		if not NAStuff.ChatSettings.customEnabled then
			if NAStuff.ChatCustomizationActive ~= false then
				originalIO.restoreChatDefaults(Window, Tabs, InputBar, Bubbles)
			end
			NAStuff.ChatCustomizationActive = false
			return
		end
		NAStuff.ChatCustomizationActive = true

		if Window then
			safeSet(Window, "Enabled", NAStuff.ChatSettings.window.enabled)
			if hasProp(Window, "FontFace") and NAStuff.ChatSettings.window.font then pcall(function() Window.FontFace = Font.new(NAStuff.ChatSettings.window.font) end) end
			safeSet(Window, "TextSize", NAStuff.ChatSettings.window.textSize)
			safeSet(Window, "TextColor3", tblToC3(NAStuff.ChatSettings.window.textColor))
			safeSet(Window, "TextStrokeColor3", tblToC3(NAStuff.ChatSettings.window.strokeColor))
			safeSet(Window, "TextStrokeTransparency", NAStuff.ChatSettings.window.strokeTransparency)
			safeSet(Window, "BackgroundColor3", tblToC3(NAStuff.ChatSettings.window.backgroundColor))
			safeSet(Window, "BackgroundTransparency", NAStuff.ChatSettings.window.backgroundTransparency)
		end

		if Tabs then
			safeSet(Tabs, "Enabled", NAStuff.ChatSettings.tabs.enabled)
			if hasProp(Tabs, "FontFace") and NAStuff.ChatSettings.tabs.font then pcall(function() Tabs.FontFace = Font.new(NAStuff.ChatSettings.tabs.font) end) end
			safeSet(Tabs, "TextSize", NAStuff.ChatSettings.tabs.textSize)
			safeSet(Tabs, "BackgroundTransparency", NAStuff.ChatSettings.tabs.backgroundTransparency)
			safeSet(Tabs, "TextColor3", tblToC3(NAStuff.ChatSettings.tabs.textColor))
			safeSet(Tabs, "SelectedTabTextColor3", tblToC3(NAStuff.ChatSettings.tabs.selectedTextColor))
			safeSet(Tabs, "UnselectedTabTextColor3", tblToC3(NAStuff.ChatSettings.tabs.unselectedTextColor))
		end

		if InputBar then
			safeSet(InputBar, "Enabled", NAStuff.ChatSettings.input.enabled)
			safeSet(InputBar, "AutocompleteEnabled", NAStuff.ChatSettings.input.autocomplete)
			if hasProp(InputBar, "FontFace") and NAStuff.ChatSettings.input.font then pcall(function() InputBar.FontFace = Font.new(NAStuff.ChatSettings.input.font) end) end
			if NAStuff.ChatSettings.input.targetGeneral and hasProp(InputBar, "TargetTextChannel") then
				local ch = getDefaultChannel(TCS)
				if ch then safeSet(InputBar, "TargetTextChannel", ch) end
			end
			if not IsOnMobile then
				local keyName = tostring(NAStuff.ChatSettings.input.keyCode or "Slash")
				local enumKey = Enum.KeyCode[keyName] or Enum.KeyCode.Slash
				safeSet(InputBar, "KeyboardKeyCode", enumKey)
			end
			safeSet(InputBar, "TextSize", NAStuff.ChatSettings.input.textSize)
			safeSet(InputBar, "TextColor3", tblToC3(NAStuff.ChatSettings.input.textColor))
			safeSet(InputBar, "TextStrokeTransparency", NAStuff.ChatSettings.input.strokeTransparency)
			safeSet(InputBar, "BackgroundTransparency", NAStuff.ChatSettings.input.backgroundTransparency)
		end

		if Bubbles then
			safeSet(Bubbles, "Enabled", NAStuff.ChatSettings.bubbles.enabled)
			if hasProp(Bubbles, "MaxDistance") then safeSet(Bubbles, "MaxDistance", math.max(NAStuff.ChatSettings.bubbles.maxDistance, 0)) end
			if hasProp(Bubbles, "MinimizeDistance") then safeSet(Bubbles, "MinimizeDistance", math.max(NAStuff.ChatSettings.bubbles.minimizeDistance, 0)) end
			if hasProp(Bubbles, "TextSize") then safeSet(Bubbles, "TextSize", math.max(NAStuff.ChatSettings.bubbles.textSize, 1)) end
			if hasProp(Bubbles, "BubblesSpacing") then safeSet(Bubbles, "BubblesSpacing", math.max(NAStuff.ChatSettings.bubbles.spacing, 0)) end
			safeSet(Bubbles, "BackgroundTransparency", math.clamp(NAStuff.ChatSettings.bubbles.backgroundTransparency, 0, 1))
			safeSet(Bubbles, "TailVisible", NAStuff.ChatSettings.bubbles.tailVisible)
		end
	end

	NAlib.disconnect("TCS_OnDescendantAdded")
	NAlib.connect("TCS_OnDescendantAdded", TextChatService.DescendantAdded:Connect(function()
		Defer(NAmanage.ApplyTextChatSettings)
	end))

	NAlib.disconnect("TCS_ApplyLoop")
	do
		local last = os.clock()
		NAlib.connect("TCS_ApplyLoop", RunService.RenderStepped:Connect(function()
			local now = os.clock()
			if now - last >= 0.2 then
				last = now
				NAmanage.ApplyTextChatSettings()
			end
		end))
	end

	NAmanage.ApplyTextChatSettings()
else
	prefixCheck = ";"
	NAScale = 1
	NAQoTEnabled = false
	NAiconSaveEnabled = false
	NAUISTROKER = Color3.fromRGB(148, 93, 255)
	opt.currentTagText = "Tag"
	opt.currentTagColor = Color3.fromRGB(0, 255, 170)
	opt.currentTagRGB = false
	DoPopup("Your exploit does not support read/write file")
	--opt.saveTag = fals
end

opt.prefix = prefixCheck
if NAmanage.SyncPrefixUI then
	NAmanage.SyncPrefixUI()
end

local lastPrefix = opt.prefix

--[[if opt.saveTag then
	SafeGetService("Players").LocalPlayer:SetAttribute("CustomNAtaggerText", opt.currentTagText)
	SafeGetService("Players").LocalPlayer:SetAttribute("CustomNAtaggerColor", opt.currentTagColor)
	SafeGetService("Players").LocalPlayer:SetAttribute("CustomNAtaggerRainbow", opt.currentTagRGB)
end]]

--[[ VARIABLES ]]--

local PlaceId,JobId,GameId=game.PlaceId,game.JobId,game.GameId
local Player=Players.LocalPlayer;
local plr=Players.LocalPlayer;
local PlrGui=Player:FindFirstChildWhichIsA("PlayerGui");
local TopBarApp={ top=nil; frame=nil; toggle=nil; tGlass=nil; tStroke=nil; icon=nil; panel=nil; underlay=nil; scroll=nil; layout=nil; isOpen=false; childButtons={}; buttonDefs={}, mode=NAmanage.topbar_readMode(), sidePref="right" }
--local IYLOADED=false--This is used for the ;iy command that executes infinite yield commands using this admin command script (BTW)
local Character=Player.Character;
local LegacyChat=TextChatService.ChatVersion==Enum.ChatVersion.LegacyChatService
local FakeLag=false
local Loopvoid=false
local loopgrab=false
local OrgDestroyHeight = nil
local Watch=false
local Admin={}
CoreGui=COREGUI;
_G.NAadminsLol={
	11761417; -- Main
	530829101; --Viper
	817571515; --Aimlock
	1844177730; --glexinator
	2624269701; --Akim
	2502806181; --null
	1594235217; --Purple
	1620986547; --pc alt
	2019160453; --grim
	4881709223; --bzz bzz byzren
}

NAStuff._ctrlLockKeys = NAStuff._ctrlLockKeys or "LeftShift,RightShift"
if NAStuff._ctrlLockPersist == nil then NAStuff._ctrlLockPersist = false end
NAStuff._ctrlLockList = NAStuff._ctrlLockList or {}
NAStuff._ctrlLockSet  = NAStuff._ctrlLockSet  or {}

NAmanage.IconSetInvisible = NAmanage.IconSetInvisible or function(hidden)
	NAStuff.IconInvisible = hidden and true or false
end

--[[ Some more variables ]]--

localPlayer=Player
LocalPlayer=Player
local character=Player.Character
local camera=workspace.CurrentCamera
local player,plr,lp=Players.LocalPlayer,Players.LocalPlayer,Players.LocalPlayer
local cmds={
	Commands={};
	Aliases={};
	NASAVEDALIASES = {};
}

NAmanage.resolveCommandName=function(name)
	name = (name or ""):lower()
	local entry = cmds.Commands[name] or cmds.Aliases[name]
	if not entry then return nil end
	for cmdName, data in pairs(cmds.Commands) do
		if data == entry then
			return cmdName
		end
	end
	return name
end

SpawnCall(function()
	local playerScripts = LocalPlayer:WaitForChild("PlayerScripts", math.huge)
	local playerModule = playerScripts:WaitForChild("PlayerModule", math.huge)
	local controlModule = playerModule:WaitForChild("ControlModule", math.huge)

	local ok, result = pcall(require, controlModule)
	if ok and result then
		opt.ctrlModule = result
	end
end)

customVECTORMOVE = Vector3.zero
thumberSTICKER = Vector2.zero

sussyINPUTTER = {
	W = false,
	A = false,
	S = false,
	D = false,
}

local function updateInputVector()
	local x, z = 0, 0
	if sussyINPUTTER.W then z = z + 1 end
	if sussyINPUTTER.S then z = z - 1 end
	if sussyINPUTTER.A then x = x - 1 end
	if sussyINPUTTER.D then x = x + 1 end

	if thumberSTICKER.Magnitude > 0.1 then
		customVECTORMOVE = Vector3.new(thumberSTICKER.X, 0, thumberSTICKER.Y)
	else
		customVECTORMOVE = Vector3.new(x, 0, z)
	end

	if customVECTORMOVE.Magnitude > 1 then
		customVECTORMOVE = customVECTORMOVE.Unit
	end
end

UserInputService.InputBegan:Connect(function(input, gameProcessed)
	if gameProcessed then return end
	if input.KeyCode == Enum.KeyCode.W then sussyINPUTTER.W = true end
	if input.KeyCode == Enum.KeyCode.S then sussyINPUTTER.S = true end
	if input.KeyCode == Enum.KeyCode.A then sussyINPUTTER.A = true end
	if input.KeyCode == Enum.KeyCode.D then sussyINPUTTER.D = true end
	updateInputVector()
end)

UserInputService.InputEnded:Connect(function(input)
	if input.KeyCode == Enum.KeyCode.W then sussyINPUTTER.W = false end
	if input.KeyCode == Enum.KeyCode.S then sussyINPUTTER.S = false end
	if input.KeyCode == Enum.KeyCode.A then sussyINPUTTER.A = false end
	if input.KeyCode == Enum.KeyCode.D then sussyINPUTTER.D = false end
	updateInputVector()
end)

function GetCustomMoveVector()
	if opt.ctrlModule then
		local success, vec = pcall(function()
			return opt.ctrlModule:GetMoveVector()
		end)
		if success and vec and vec.Magnitude > 0 then
			return vec
		end
	end
	return Vector3.new(customVECTORMOVE.X, customVECTORMOVE.Y, -customVECTORMOVE.Z)
end

local bringc={}

--[[ Welcome Messages ]]--
local msg = {
	"Hey!",
	"Hello!",
	"Hi there!",
	"Howdy!",
	"Yo!",
	"Sup!",
	"Heyo!",
	"Hiya!",
	"Hey, buddy!",
	"Nice to see you!",
	"Good to have you here!",
	"Glad you're here!",
	"Welcome aboard!",
	"Pleasure to meet you!",
	"What's up?",
	"How's it going?",
	"What's crackin'?",
	"What's poppin'?",
	"Hey, superstar!",
	"Hey, champ!",
	"Hey, legend!",
	"Welcome, friend!",
	"Welcome to the fam!",
	"Welcome to the party!",

	"Hola!",
	"Bonjour!",
	"Ciao!",
	"Namaste!",
	"G'day mate!",
	"Salutations!",
	"Greetings!",
	"Peace!",
	"Salute!",
}

--[[ Prediction ]]--
function levenshtein(s, t)
	local lenS, lenT = #s, #t
	if lenS == 0 then return lenT end
	if lenT == 0 then return lenS end

	local d = {}

	for i = 0, lenS do
		d[i] = {}
		d[i][0] = i
	end
	for j = 1, lenT do
		d[0][j] = j
	end

	for i = 1, lenS do
		for j = 1, lenT do
			local cost = (s:sub(i, i) == t:sub(j, j)) and 0 or 1
			d[i][j] = math.min(
				d[i - 1][j] + 1,
				d[i][j - 1] + 1,
				d[i - 1][j - 1] + cost
			)
		end
	end

	return d[lenS][lenT]
end

function didYouMean(input)
	local bestMatch = nil
	local lowestDistance = math.huge

	local function cc(collection)
		for name in pairs(collection) do
			local distance = levenshtein(input, name)
			if distance < lowestDistance then
				lowestDistance = distance
				bestMatch = name
			end
		end
	end

	cc(cmds.Commands)
	cc(cmds.Aliases)
	cc(cmds.NASAVEDALIASES)

	return bestMatch
end

NAmanage.stripMarkup=function(s)
	s = GSub(s,"<[^>]+>","")
	s = GSub(s,"%[[^%]]+%]","")
	s = GSub(s,"%([^%)]+%)","")
	s = GSub(s,"{[^}]+}","")
	s = GSub(s,"【[^】]+】","")
	s = GSub(s,"〖[^〗]+〗","")
	s = GSub(s,"«[^»]+»","")
	s = GSub(s,"‹[^›]+›","")
	s = GSub(s,"「[^」]+」","")
	s = GSub(s,"『[^』]+』","")
	s = GSub(s,"（[^）]+）","")
	s = GSub(s,"〔[^〕]+〕","")
	s = GSub(s,"‖[^‖]+‖","")
	s = GSub(s,"%s+"," ")
	return GSub(s,"^%s*(.-)%s*$","%1")
end

--[[pqwodwjvxnskdsfo = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
function randomahhfunctionthatyouwontgetit(data)
	data = data:gsub('[^'..pqwodwjvxnskdsfo..'=]', '')
	return (data:gsub('.', function(x)
		if (x == '=') then return '' end
		local r, f = '', (pqwodwjvxnskdsfo:find(x) - 1)
		for i = 6, 1, -1 do
			r = r..(f % 2^i - f % 2^(i - 1) > 0 and '1' or '0')
		end
		return r
	end):gsub('%d%d%d?%d?%d?%d?%d?%d?', function(x)
		if (#x ~= 8) then return '' end
		local c = 0
		for i = 1, 8 do
			c = c + (x:sub(i, i) == '1' and 2^(8 - i) or 0)
		end
		return string.char(c)
	end))
end]]
function isRelAdmin(Player)
	for _, id in ipairs(_G.NAadminsLol) do
		if Player.UserId == id then
			return true
		end
	end
	return false
end

NAmanage.rebuildIndex=function()
	table.clear(searchIndex)
	for _,frame in ipairs(CMDAUTOFILL) do
		local cmdName = frame.Name
		local command = cmds.Commands[cmdName]
		local displayInfo = ""
		local extra = {}
		if command then
			local updatedText, aliasList = fixStupidSearchGoober(cmdName, command)
			if updatedText and type(command[2]) == "table" then
				command[2][1] = updatedText
			end
			displayInfo = (command[2] and command[2][1]) or ""
			for _, alias in ipairs(aliasList or {}) do
				Insert(extra, alias)
			end
		end
		local lowerName = Lower(cmdName)
		local searchable = NAmanage.stripMarkup(Lower(displayInfo))
		Insert(searchIndex,{
			name = cmdName,
			lowerName = lowerName,
			searchable = searchable,
			extraAliases = extra,
			frame = frame
		})
	end
end

NAmanage.ControlLock_FromString = function(s)
	NAStuff._ctrlLockList = {}
	NAStuff._ctrlLockSet = {}
	for key in string.gmatch((s or ""), "([^,]+)") do
		local k = key:gsub("%s+","")
		if k ~= "" and not NAStuff._ctrlLockSet[k] then
			Insert(NAStuff._ctrlLockList, k)
			NAStuff._ctrlLockSet[k] = true
		end
	end
	if #NAStuff._ctrlLockList == 0 then
		NAStuff._ctrlLockList = {"LeftShift","RightShift"}
		NAStuff._ctrlLockSet = {LeftShift=true, RightShift=true}
	end
	NAStuff._ctrlLockKeys = Concat(NAStuff._ctrlLockList, ",")
end

NAmanage.ControlLock_ToString = function()
	NAStuff._ctrlLockKeys = Concat(NAStuff._ctrlLockList, ",")
	return NAStuff._ctrlLockKeys
end

NAmanage.ControlLock_Apply = function(keys)
	if not IsOnPC then DebugNotif("PC-only feature") return end
	local player = Players.LocalPlayer
	local mlc = player:WaitForChild("PlayerScripts"):WaitForChild("PlayerModule"):WaitForChild("CameraModule"):WaitForChild("MouseLockController")
	local boundKeys = mlc:WaitForChild("BoundKeys")
	boundKeys.Value = keys
	DebugNotif("Shiftlock keys set to "..keys)
end

NAmanage.ControlLock_AddKey = function(keyName)
	if not keyName or keyName == "" then return end
	if not NAStuff._ctrlLockSet[keyName] then
		Insert(NAStuff._ctrlLockList, keyName)
		NAStuff._ctrlLockSet[keyName] = true
		NAmanage.ControlLock_ToString()
		NAmanage.ControlLock_Apply(NAStuff._ctrlLockKeys)
		DebugNotif("Added "..keyName.." to Shiftlock keys")
	else
		DebugNotif(keyName.." already in list")
	end
end

NAmanage.ControlLock_RemoveKey = function(keyName)
	if not keyName or keyName == "" then return end
	if NAStuff._ctrlLockSet[keyName] then
		local idx = Discover(NAStuff._ctrlLockList, keyName)
		if idx then table.remove(NAStuff._ctrlLockList, idx) end
		NAStuff._ctrlLockSet[keyName] = nil
		NAmanage.ControlLock_ToString()
		NAmanage.ControlLock_Apply(NAStuff._ctrlLockKeys)
		DebugNotif("Removed "..keyName.." from Shiftlock keys")
	else
		DebugNotif(keyName.." not in list")
	end
end

NAmanage.ControlLock_ClearToDefault = function()
	NAStuff._ctrlLockList = {"LeftShift","RightShift"}
	NAStuff._ctrlLockSet = {LeftShift=true, RightShift=true}
	NAmanage.ControlLock_ToString()
	NAmanage.ControlLock_Apply(NAStuff._ctrlLockKeys)
end

NAmanage.ControlLock_Bind = function()
	NAlib.disconnect("controllock_persist")
	if NAStuff._ctrlLockPersist and IsOnPC then
		NAlib.connect("controllock_persist", Players.LocalPlayer.CharacterAdded:Connect(function()
			NAmanage.ControlLock_Apply(NAStuff._ctrlLockKeys)
		end))
	end
end

function nameChecker(p)
	if not NAlib.isProperty(p, "DisplayName") then
		return p.Name
	end

	local displayName = p.DisplayName
	if displayName:lower() == p.Name:lower() then
		return '@'..p.Name
	else
		return displayName..' (@'..p.Name..')'
	end
end

function ParseArguments(input)
	if not input or input:match("^%s*$") then
		return nil
	end

	local args = {}
	for arg in string.gmatch(input, "[^%s]+") do
		Insert(args, arg)
	end
	return args
end

NAmanage._normPlayer = function(p)
	if typeof(p) == "Instance" and p:IsA("Player") then return p end
	if type(p) == "string" then return Players:FindFirstChild(p) end
	return nil
end

NAmanage._makeCtx = function(evName, ...)
	local lp = Players and Players.LocalPlayer
	local ctx = { event = evName, localPlayer = lp }
	local a1, a2, a3 = ...

	if evName == "OnChatted" then
		if typeof(a1) == "Instance" and a1:IsA("Player") then
			ctx.player, ctx.message = a1, a2
		else
			ctx.player, ctx.message = lp, a1
		end
	elseif evName == "OnJoin" or evName == "OnLeave" then
		ctx.player = NAmanage._normPlayer(a1) or lp
	elseif evName == "OnSpawn" then
		ctx.player = NAmanage._normPlayer(a1) or lp
		ctx.character = a2
	elseif evName == "OnDeath" then
		if typeof(a1) == "Instance" and a1:IsA("Player") then
			ctx.player = a1
		else
			ctx.player = lp
		end
	elseif evName == "OnDamage" then
		if typeof(a1) == "Instance" and a1:IsA("Player") then
			ctx.player, ctx.oldhp, ctx.newhp = a1, a2, a3
		else
			ctx.player, ctx.oldhp, ctx.newhp = lp, a1, a2
		end
	elseif evName == "OnKill" then
		ctx.player = NAmanage._normPlayer(a1)
		ctx.victim = NAmanage._normPlayer(a2)
	elseif evName == "OnJump" then
		ctx.player = NAmanage._normPlayer(a1) or lp
		ctx.humanoid = a2
	elseif evName == "OnEquipItem" or evName == "OnUnequipItem" then
		ctx.player = NAmanage._normPlayer(a1) or lp
		ctx.item = a2
	else
		ctx.player = lp
	end

	ctx.isSelf = (ctx.player == lp)
	return ctx
end

NAmanage._parseSelectorPrefix = function(s)
	local open, rest = s:match("^%s*([<%[].-[>%]])%s*(.*)$")
	if not open then return nil, s end

	local tag = open:sub(2, #open - 1)
	local sel = { terms = {} }

	for part in string.gmatch(tag, "[^,%s]+") do
		local k, v = part:match("^([^:]+):(.+)$")
		k = (k or part)
		local kl = k:lower()
		local vl = v and v:lower()

		if kl == "me" then
			sel.me = true
		elseif kl == "notme" or kl == "others" then
			sel.notme = true
		elseif kl == "all" then
			sel.all = true
		elseif kl == "id" or kl == "userid" then
			sel.id = tonumber(vl)
		elseif kl == "friend" or kl == "friends" then
			sel.friend = true
		elseif kl == "player" or kl == "name" then
			sel.namePrefix = vl
		elseif kl == "display" or kl == "displayname" then
			sel.displayPrefix = vl
		elseif kl == "t" or kl == "target" then
			if vl and vl ~= "" then Insert(sel.terms, vl) end
		else
			Insert(sel.terms, k:lower())
		end
	end

	return sel, rest
end

NAmanage._selectorPasses = function(sel, ctx)
	if not sel then return true end
	local lp = Players and Players.LocalPlayer
	local plr = ctx.player
	if not plr or not lp then return false end

	local ev = ctx.event
	if ev == "OnJoin" or ev == "OnLeave" then
		if plr == lp then return false end
		if sel.me then return false end
	end

	if sel.me and plr ~= lp then return false end
	if sel.notme and plr == lp then return false end
	if sel.id and plr.UserId ~= sel.id then return false end
	if sel.friend and not lp:IsFriendsWith(plr.UserId) then return false end

	if sel.namePrefix and sel.namePrefix ~= "" then
		local n = plr.Name:lower()
		local d = (plr.DisplayName or ""):lower()
		if not (n:sub(1, #sel.namePrefix) == sel.namePrefix or d:sub(1, #sel.namePrefix) == sel.namePrefix) then
			return false
		end
	end
	if sel.displayPrefix and sel.displayPrefix ~= "" then
		local d = (plr.DisplayName or ""):lower()
		if not (d:sub(1, #sel.displayPrefix) == sel.displayPrefix) then
			return false
		end
	end

	if sel.all then
		return true
	end

	if sel.terms and #sel.terms > 0 then
		local resolver = NAmanage.getPlr
		for _, term in ipairs(sel.terms) do
			local ok, list = pcall(function() return resolver and resolver(lp, term) or {} end)
			list = (ok and type(list) == "table") and list or {}
			if Discover(list, plr) then
				return true
			end
		end
		return false
	end

	return true
end

NAmanage._expandTokens = function(s, ctx)
	local lp = Players and Players.LocalPlayer
	return (s:gsub("{(.-)}", function(key)
		key = key:lower()
		if key == "me" then return (lp and lp.Name) or "" end
		if key == "myid" then return (lp and tostring(lp.UserId)) or "" end
		if key == "player" then return (ctx.player and ctx.player.Name) or "" end
		if key == "display" or key == "displayname" then return (ctx.player and ctx.player.DisplayName) or "" end
		if key == "userid" then return (ctx.player and tostring(ctx.player.UserId)) or "" end
		if key == "message" then return ctx.message or "" end
		if key == "oldhp" then return ctx.oldhp and tostring(math.floor(ctx.oldhp + 0.5)) or "" end
		if key == "newhp" then return ctx.newhp and tostring(math.floor(ctx.newhp + 0.5)) or "" end
		if key == "killer" then return (ctx.player and ctx.player.Name) or "" end
		if key == "killerid" then return (ctx.player and tostring(ctx.player.UserId)) or "" end
		if key == "victim" then return (ctx.victim and ctx.victim.Name) or "" end
		if key == "victimdisplay" or key == "victimdisplayname" then return (ctx.victim and ctx.victim.DisplayName) or "" end
		if key == "victimid" then return (ctx.victim and tostring(ctx.victim.UserId)) or "" end
		if key == "item" or key == "tool" then return (ctx.item and ctx.item.Name) or "" end
		if key == "itemclass" or key == "toolclass" then return (ctx.item and ctx.item.ClassName) or "" end
		return ""
	end))
end

NAmanage.ExecuteBindings = function(evName, ...)
	local list = Bindings[evName]
	if type(list) ~= "table" then return end

	local ctx = NAmanage._makeCtx(evName, ...)
	for _, raw in ipairs(list) do
		local sel, cmdText = NAmanage._parseSelectorPrefix(raw)
		if NAmanage._selectorPasses(sel, ctx) then
			local expanded = NAmanage._expandTokens(cmdText, ctx)
			local args = ParseArguments(expanded) or { expanded }
			SpawnCall(function() cmd.run(args) end)
		end
	end
end

function loadedResults(res)
	local total = tonumber(res) or 0
	local isNegative = total < 0
	total = math.abs(total)

	local units = {
		{ "d", 86400 },
		{ "h", 3600 },
		{ "m", 60 },
		{ "s", 1 },
	}

	local parts = {}
	for _, u in ipairs(units) do
		local count = math.floor(total / u[2])
		total = total % u[2]
		parts[u[1]] = count
	end

	local milliseconds = math.floor((total) * 1000)
	local output = {}

	for _, u in ipairs(units) do
		local val = parts[u[1]]
		if val > 0 then
			Insert(output, Format("%d%s", val, u[1]))
		end
	end

	if parts["s"] == 0 and milliseconds > 0 then
		Insert(output, Format("%.3fs", milliseconds / 1000))
	end

	local result = Concat(output, " ")
	return isNegative and ("-"..result) or result
end

LocalPlayer.OnTeleport:Connect(function(...)
	if NAQoTEnabled and opt.queueteleport then
		opt.queueteleport(opt.loader)
	end
	if isAprilFools() then
		opt.queueteleport("getgenv().ActivateAprilMode=true")
	end
end)

NAmanage.cloneArgsArray=function(source)
	local out = {}
	if source then
		for i, v in ipairs(source) do
			out[i] = v
		end
	end
	return out
end

NAmanage.updateLastCommand=function(rawArgs)
	if type(rawArgs) ~= "table" then return end
	local first = rawArgs[1]
	if type(first) ~= "string" then return end
	local lowerFirst = Lower(first)
	if lowerFirst == "lastcommand" or lowerFirst == "lastcmd" then
		return
	end
	if NAStuff._lastCommand then
		NAStuff._prevCommand = NAmanage.cloneArgsArray(NAStuff._lastCommand)
	else
		NAStuff._prevCommand = nil
	end
	NAStuff._lastCommand = rawArgs
end

--[[ COMMAND FUNCTIONS ]]--
local commandcount=0
Loops = {}
cmd.add = function(aliases, info, func, requiresArguments)
	requiresArguments = requiresArguments or false
	local data = {func, info, requiresArguments}

	if type(aliases) ~= "table" or #aliases == 0 then
		return
	end

	local primary = aliases[1]
	local primaryLower = primary and primary:lower() or nil
	if primaryLower then
		if not cmds.Commands[primaryLower] then
			commandcount += 1
		end
		cmds.Commands[primaryLower] = data
	end

	for index = 2, #aliases do
		local aliasName = aliases[index]
		if type(aliasName) == "string" and aliasName ~= "" then
			cmds.Aliases[aliasName:lower()] = data
		end
	end
end

cmd.run = function(args)
	local rawArgs = {}
	for i, v in ipairs(args) do
		rawArgs[i] = v
	end

	local caller, arguments = args[1], args
	table.remove(args, 1)

	local callerLower = (type(caller) == "string") and caller:lower() or nil
	local shouldRecord = callerLower ~= "lastcommand" and callerLower ~= "lastcmd"

	local success, msg = pcall(function()
		local command = callerLower and (cmds.Commands[callerLower] or cmds.Aliases[callerLower]) or nil
		if command then
			command[1](unpack(arguments))
			if shouldRecord then
				NAmanage.updateLastCommand(rawArgs)
			end
		else
			local closest = callerLower and didYouMean(callerLower) or nil
			if closest and doPREDICTION then
				local commandFunc = cmds.Commands[closest] and cmds.Commands[closest][1] or cmds.Aliases[closest] and cmds.Aliases[closest][1]
				local requiresInput = cmds.Commands[closest] and cmds.Commands[closest][3] or cmds.Aliases[closest] and cmds.Aliases[closest][3]

				if requiresInput then
					Window({
						Title = adminName,
						Description = "Command [ "..caller.." ] doesn't exist\nDid you mean [ "..closest.." ]?",
						InputField = true,
						Buttons = {
							{
								Text = "Submit",
								Callback = function(input)
									local parsedArguments = ParseArguments(input)
									if parsedArguments then
										local predictedArguments = {}
										for i, v in ipairs(parsedArguments) do
											predictedArguments[i] = v
										end
										local record = {closest}
										for _, v in ipairs(predictedArguments) do
											record[#record + 1] = v
										end
										SpawnCall(function()
											commandFunc(unpack(predictedArguments))
											if shouldRecord then
												NAmanage.updateLastCommand(record)
											end
										end)
									else
										local record = {closest}
										SpawnCall(function()
											commandFunc()
											if shouldRecord then
												NAmanage.updateLastCommand(record)
											end
										end)
									end
								end
							}
						}
					})
				else
					Window({
						Title = adminName,
						Description = "Command [ "..caller.." ] doesn't exist\nDid you mean [ "..closest.." ]?",
						Buttons = {
							{
								Text = "Run Command",
								Callback = function()
									local record = {closest}
									SpawnCall(function()
										commandFunc()
										if shouldRecord then
											NAmanage.updateLastCommand(record)
										end
									end)
								end
							}
						}
					})
				end
			end
		end
	end)

	if not success then warn(adminName.." script error:\n"..msg) end
end

cmd.loop = function(commandName, args)
	local command = cmds.Commands[commandName:lower()] or cmds.Aliases[commandName:lower()]
	if not command then
		DoNotif("Command '"..commandName.."' does not exist.", 3)
		return
	end

	local function GenerateLoopKey(name, arguments)
		return name:lower().." "..Concat(arguments or {}, " ")
	end

	local function FormatArgs(arguments)
		if not arguments or #arguments == 0 then
			return "(no args)"
		end
		return Concat(arguments, ", ")
	end

	Window({
		Title = "Set Loop Delay",
		Description = "Enter the delay (in seconds) for the loop of command: "..commandName,
		InputField = true,
		Buttons = {
			{
				Text = "Submit",
				Callback = function(input)
					local interval = tonumber(input) or 0
					if interval < 0 then
						DoNotif("Invalid delay. Loop not started.", 3)
						return
					end

					local loopKey = GenerateLoopKey(commandName, args)
					if Loops[loopKey] then
						DoNotif("A loop with these arguments is already running for '"..commandName.."'.", 3)
						return
					end

					local connKey = "loop::"..loopKey
					NAlib.disconnect(connKey)

					Loops[loopKey] = {
						commandName = commandName,
						command = command[1],
						args = args or {},
						interval = interval,
						running = true,
						key = connKey
					}

					pcall(function() Loops[loopKey].command(Unpack(Loops[loopKey].args)) end)

					local acc = 0
					NAlib.connect(connKey, RunService.RenderStepped:Connect(function(dt)
						local L = Loops[loopKey]
						if not L or not L.running then
							NAlib.disconnect(connKey)
							return
						end
						if L.interval <= 0 then
							pcall(function() L.command(Unpack(L.args)) end)
							return
						end
						acc += dt
						if acc >= L.interval then
							acc %= L.interval
							pcall(function() L.command(Unpack(L.args)) end)
						end
					end))

					DoNotif("Loop started for '"..commandName.."' with delay: "..interval.."s. Args: "..FormatArgs(args), 3)
				end
			}
		}
	})
end

cmd.stopLoop = function()
	if next(Loops) == nil then
		DoNotif("No active loops to stop.", 2)
		return
	end

	local function FormatArgs(arguments)
		if not arguments or #arguments == 0 then
			return "(no args)"
		end
		return Concat(arguments, ", ")
	end

	local buttons = {}
	for loopKey, loopData in pairs(Loops) do
		local label = Format("'%s' | Args: %s | Delay: %ss", loopData.commandName, FormatArgs(loopData.args), loopData.interval)
		Insert(buttons, {
			Text = label,
			Callback = function()
				loopData.running = false
				if loopData.key then NAlib.disconnect(loopData.key) end
				Loops[loopKey] = nil
				DoNotif("Stopped loop: '"..loopData.commandName.."' with args: "..FormatArgs(loopData.args), 3)
			end
		})
	end

	Window({
		Title = "Stop a Loop",
		Description = "Select a loop to stop:",
		Buttons = buttons
	})
end

--[[ Fully setup Nameless admin storage ]]
opt.NA_storage = InstanceNew("ScreenGui")
NaProtectUI(opt.NA_storage)

--[[ LIBRARY FUNCTIONS ]]--
NAlib.wrap=function(f)
	return coroutine.wrap(f)()
end

local wrap=NAlib.wrap

function rngMsg()
	return msg[math.random(1,#msg)]
end

NA_GRAB_BODY = (function()
	local T = {}
	local _cache = _rp_cache or setmetatable({}, { __mode = "k" })

	local function asChar(obj)
		if not obj or typeof(obj) ~= "Instance" then return nil end
		if obj:IsA("Player") then return obj.Character end
		if obj:IsA("Model") then return obj end
		return nil
	end

	local function firstPart(model)
		for _,d in ipairs(model:GetDescendants()) do
			if d:IsA("BasePart") then return d end
		end
		return nil
	end

	local function rebuild(char, rec)
		local rp = { humanoidrootpart = 1, uppertorso = 2, lowertorso = 3, torso = 4 }
		local tp = { torso = 1, uppertorso = 2, lowertorso = 3, humanoidrootpart = 4 }
		local bestRoot, bestRootRank = nil, math.huge
		local bestTorso, bestTorsoRank = nil, math.huge
		local head, humanoid, fallback = nil, nil, nil
		local q = { char }
		local i = 1
		while i <= #q do
			local node = q[i]; i = i + 1
			local children = node:GetChildren()
			for c = 1, #children do
				local ch = children[c]
				if not fallback and ch:IsA("BasePart") then fallback = ch end
				if not humanoid and ch:IsA("Humanoid") then humanoid = ch end
				if ch:IsA("BasePart") then
					local n = Lower(ch.Name)
					local r = rp[n]
					if r and r < bestRootRank then bestRootRank = r; bestRoot = ch end
					local t = tp[n]
					if t and t < bestTorsoRank then bestTorsoRank = t; bestTorso = ch end
					if not head and n == "head" then head = ch end
				end
				q[#q + 1] = ch
			end
		end
		if not bestRoot then bestRoot = fallback end
		if not bestTorso then bestTorso = fallback end
		if not head then head = fallback end
		rec.root, rec.torso, rec.head, rec.humanoid, rec.dirty = bestRoot, bestTorso, head, humanoid, false
	end

	local function ensure(char)
		local obj = char
		if not obj and Players and Players.LocalPlayer then obj = Players.LocalPlayer end
		local model = asChar(obj)
		if not model then return nil end
		local rec = _cache[model]
		if not rec then
			rec = { dirty = true }
			_cache[model] = rec
			rec.a = model.DescendantAdded:Connect(function() rec.dirty = true end)
			rec.r = model.DescendantRemoving:Connect(function() rec.dirty = true end)
			rec.c = model.AncestryChanged:Connect(function(_, parent)
				if not parent then
					if rec.a then rec.a:Disconnect() end
					if rec.r then rec.r:Disconnect() end
					if rec.c then rec.c:Disconnect() end
					_cache[model] = nil
				end
			end)
		end
		if rec.dirty or (rec.humanoid and rec.humanoid.Parent == nil) then rebuild(model, rec) end
		return rec, model
	end

	T.ensure = ensure
	T.firstPart = firstPart
	T.asChar = asChar
	return T
end)()

function getRoot(char)
	local rec, model = NA_GRAB_BODY.ensure(char)
	if not rec then return nil end
	return rec.root or (model and NA_GRAB_BODY.firstPart(model)) or nil
end

function getTorso(char)
	local rec, model = NA_GRAB_BODY.ensure(char)
	if not rec then return nil end
	return rec.torso or (model and NA_GRAB_BODY.firstPart(model)) or nil
end

function getHead(char)
	local rec, model = NA_GRAB_BODY.ensure(char)
	if not rec then return nil end
	return rec.head or (model and NA_GRAB_BODY.firstPart(model)) or nil
end

function getChar()
	local plr = Players.LocalPlayer
	return plr and plr.Character or nil
end

function getPlrChar(plr)
	return NA_GRAB_BODY.asChar(plr)
end

function getBp()
	local plr = Players.LocalPlayer
	return plr and plr:FindFirstChildOfClass("Backpack") or nil
end

function getHum(char)
	local rec = NA_GRAB_BODY.ensure(char)
	if not rec then return nil end
	return rec.humanoid
end

function getPlrHum(plr)
	return getHum(plr)
end

function IsR15(plr)
	plr=(plr or Players.LocalPlayer)
	if plr then
		local h=getPlrHum(plr)
		if h and h.RigType==Enum.HumanoidRigType.R15 then return true end
	end
	return false
end

function IsR6(plr)
	plr=(plr or Players.LocalPlayer)
	if plr then
		local h=getPlrHum(plr)
		if h and h.RigType==Enum.HumanoidRigType.R6 then return true end
	end
	return false
end

Foreach = function(Table, Func, Loop)
	for Index, Value in next, Table do
		pcall(function()
			if Loop and typeof(Value) == 'table' then
				for Index2, Value2 in next, Value do
					Func(Index2, Value2)
				end
			else
				Func(Index, Value)
			end
		end)
	end
end

CheckIfNPC = function(character)
	if not (character and character:IsA("Model")) then
		return false
	end
	local humanoid = character:FindFirstChildOfClass("Humanoid")
	if not humanoid then
		return false
	end
	if Players:GetPlayerFromCharacter(character) then
		return false
	end
	return true
end

FindInTable = function(tbl,val)
	if tbl==nil then return false end
	for _,v in pairs(tbl) do
		if v==val then return true end
	end
	return false
end


function MouseButtonFix(button, clickCallback)
	local MouseThreshold = 0.45
	local moveThresholdMouse = 18
	local moveThresholdTouch = 35
	local activeInput = nil
	local downTick = 0
	local startPos = nil
	local moved = false
	local lastActivationTick = 0
	local activationDebounce = 0.1
	local suppressActivated = false

	local function toVector2(pos)
		if typeof(pos) == 'Vector2' then
			return pos
		elseif typeof(pos) == 'Vector3' then
			return Vector2.new(pos.X, pos.Y)
		end
		return nil
	end

	local function reset()
		activeInput = nil
		startPos = nil
		moved = false
		downTick = 0
		suppressActivated = false
	end

	local function finalize()
		local now = tick()
		local holdLimit = MouseThreshold
		local allow = downTick > 0 and (now - downTick) <= holdLimit and not moved
		reset()
		lastActivationTick = now
		suppressActivated = allow
		if allow then
			pcall(clickCallback)
		end
		return allow
	end

	NAlib.connect(button.Name..'_begin', button.InputBegan:Connect(function(input)
		if input.UserInputState ~= Enum.UserInputState.Begin then return end
		local t = input.UserInputType
		if t ~= Enum.UserInputType.MouseButton1 and t ~= Enum.UserInputType.Touch then return end
		activeInput = input
		downTick = tick()
		moved = false
		startPos = toVector2(input.Position)
		if not startPos and t == Enum.UserInputType.MouseButton1 then
			startPos = UserInputService:GetMouseLocation()
		end
		suppressActivated = false
	end))

	NAlib.connect(button.Name..'_change', button.InputChanged:Connect(function(input)
		if not activeInput then return end
		if input == activeInput then
			if input.UserInputType == Enum.UserInputType.Touch then
				local pos = toVector2(input.Position)
				if pos then
					if not startPos then
						startPos = pos
					end
					if startPos then
						moved = moved or (pos - startPos).Magnitude > moveThresholdTouch
					end
				end
			elseif input.UserInputType == Enum.UserInputType.MouseButton1 then
				local delta = input.Delta
				if delta then
					moved = moved or (math.abs(delta.X) + math.abs(delta.Y)) > moveThresholdMouse
				elseif startPos then
					local current = UserInputService:GetMouseLocation()
					if current then
						moved = moved or (current - startPos).Magnitude > moveThresholdMouse
					end
				end
			end
		elseif input.UserInputType == Enum.UserInputType.MouseMovement and activeInput.UserInputType == Enum.UserInputType.MouseButton1 then
			local delta = input.Delta
			if delta then
				moved = moved or (math.abs(delta.X) + math.abs(delta.Y)) > moveThresholdMouse
			end
		end
	end))

	NAlib.connect(button.Name..'_end', button.InputEnded:Connect(function(input)
		if not activeInput or input ~= activeInput then return end
		if input.UserInputState == Enum.UserInputState.Cancel then
			reset()
			return
		end
		finalize()
	end))

	NAlib.connect(button.Name..'_leave', button.MouseLeave:Connect(function()
		if activeInput then
			moved = true
		end
	end))

	NAlib.connect(button.Name..'_activated', button.Activated:Connect(function()
		local now = tick()
		if suppressActivated then
			suppressActivated = false
			return
		end
		if now - lastActivationTick <= activationDebounce then
			return
		end
		if activeInput then
			finalize()
			return
		end
		lastActivationTick = now
		pcall(clickCallback)
	end))

	if IsOnMobile then
		NAlib.connect(button.Name..'_touchtap', button.TouchTap:Connect(function()
			local now = tick()
			if activeInput then
				finalize()
			elseif suppressActivated then
				return
			elseif now - lastActivationTick > activationDebounce then
				suppressActivated = true
				lastActivationTick = now
				pcall(clickCallback)
				Delay(activationDebounce, function()
					if suppressActivated and (tick() - lastActivationTick) >= activationDebounce then
						suppressActivated = false
					end
				end)
			end
		end))
	end
end


--[[ FUNCTION TO GET A PLAYER ]]--
local PlayerArgs = {
	["all"] = function()
		return Players:GetPlayers()
	end,

	["others"] = function()
		local Targets = {}

		Foreach(Players:GetPlayers(), function(Index, Player)
			if Player ~= LocalPlayer then
				Insert(Targets, Player)
			end
		end)

		return Targets
	end,

	["me"] = function()
		return { LocalPlayer }
	end,

	["random"] = function()
		local list = Players:GetPlayers()
		if LocalPlayer then
			local i = Discover(list, LocalPlayer)
			if i then table.remove(list, i) end
		end
		if #list == 0 then
			return {}
		end
		return { list[math.random(1, #list)] }
	end,

	["npc"] = function()
		local Targets = {}
		for _, model in ipairs(workspace:GetDescendants()) do
			if CheckIfNPC(model) then
				Insert(Targets, model)
			end
		end
		return Targets
	end,

	["seated"] = function()
		local Targets = {}

		Foreach(Players:GetPlayers(), function(Index, Player)
			if getPlrHum(Player.Character).Sit then
				Insert(Targets, Player)
			end
		end)

		return Targets
	end,

	["stood"] = function()
		local Targets = {}

		Foreach(Players:GetPlayers(), function(Index, Player)
			if not getPlrHum(Player.Character).Sit then
				Insert(Targets, Player)
			end
		end)

		return Targets
	end,

	["nearest"] = function()
		if not LocalPlayer.Character or not getRoot(LocalPlayer.Character) then return {} end
		local lowest = math.huge
		local Targets = nil

		Foreach(Players:GetPlayers(), function(_, plr)
			if plr ~= LocalPlayer and plr.Character and getRoot(plr.Character) then
				local distance = (getRoot(plr.Character).Position - getRoot(LocalPlayer.Character).Position).Magnitude
				if distance < lowest then
					lowest = distance
					Targets = plr
				end
			end
		end)

		return Targets and {Targets} or {}
	end,

	["farthest"] = function()
		if not LocalPlayer.Character or not getRoot(LocalPlayer.Character) then return {} end
		local highest = 0
		local Targets = nil

		Foreach(Players:GetPlayers(), function(_, plr)
			if plr ~= LocalPlayer and plr.Character and getRoot(plr.Character) then
				local distance = (getRoot(plr.Character).Position - getRoot(LocalPlayer.Character).Position).Magnitude
				if distance > highest then
					highest = distance
					Targets = plr
				end
			end
		end)

		return Targets and {Targets} or {}
	end,

	["dead"] = function()
		local Targets = {}

		Foreach(Players:GetPlayers(), function(Index, Player)
			if getPlrHum(Player.Character).Health == 0 then
				Insert(Targets, Player)
			end
		end)

		return Targets
	end,

	["alive"] = function()
		local Targets = {}

		Foreach(Players:GetPlayers(), function(Index, Player)
			if getPlrHum(Player.Character).Health > 0 then
				Insert(Targets, Player)
			end
		end)

		return Targets
	end,

	["friends"] = function()
		local Targets = {}

		Foreach(Players:GetPlayers(), function(Index, Player)
			if Player:IsFriendsWith(LocalPlayer.UserId) and LocalPlayer ~= Player then
				Insert(Targets, Player)
			end
		end)

		return Targets
	end,

	["nonfriends"] = function()
		local Targets = {}

		Foreach(Players:GetPlayers(), function(Index, Player)
			if not Player:IsFriendsWith(LocalPlayer.UserId) and LocalPlayer ~= Player then
				Insert(Targets, Player)
			end
		end)

		return Targets
	end,

	["team"] = function()
		local Targets = {}

		Foreach(Players:GetPlayers(), function(_, Player)
			if Player.Team == LocalPlayer.Team and Player ~= LocalPlayer then
				Insert(Targets, Player)
			end
		end)

		return Targets
	end,

	["nonteam"] = function()
		local Targets = {}

		Foreach(Players:GetPlayers(), function(_, Player)
			if Player.Team ~= LocalPlayer.Team and Player ~= LocalPlayer then
				Insert(Targets, Player)
			end
		end)

		return Targets
	end,

	["r15"] = function()
		local Targets = {}

		Foreach(Players:GetPlayers(), function(_, Player)
			local Hum = getPlrHum(Player.Character)
			if Hum and Hum.RigType == Enum.HumanoidRigType.R15 then
				Insert(Targets, Player)
			end
		end)

		return Targets
	end,

	["r6"] = function()
		local Targets = {}

		Foreach(Players:GetPlayers(), function(_, Player)
			local Hum = getPlrHum(Player.Character)
			if Hum and Hum.RigType == Enum.HumanoidRigType.R6 then
				Insert(Targets, Player)
			end
		end)

		return Targets
	end,

	["invisible"] = function()
		local Targets = {}

		Foreach(Players:GetPlayers(), function(_, Player)
			local Char = Player.Character
			if Char then
				local isInvisible = true
				for _, part in ipairs(Char:GetChildren()) do
					if part:IsA("BasePart") and part.Transparency < 1 then
						isInvisible = false
						break
					end
				end
				if isInvisible then
					Insert(Targets, Player)
				end
			end
		end)

		return Targets
	end,

	["bacon"] = function()
		local Targets = {}

		Foreach(Players:GetPlayers(), function(_, Player)
			local Char = Player.Character
			if Char then
				for _, v in ipairs(Char:GetChildren()) do
					if v:IsA("Accessory") and v.Name:lower():find("pal") or v.Name:lower():find("kate") then
						Insert(Targets, Player)
						break
					end
				end
			end
		end)

		return Targets
	end,

	["slenders"] = function()
		local Targets = {}

		Foreach(Players:GetPlayers(), function(_, Player)
			local Hum = getPlrHum(Player.Character)
			if Hum and Hum.RigType == Enum.HumanoidRigType.R15 then
				local desc = Hum:GetAppliedDescription()
				if desc and tonumber(desc.BodyHeightScale) > 1.05 then
					Insert(Targets, Player)
				end
			end
		end)

		return Targets
	end,

	["short"] = function()
		local Targets = {}

		Foreach(Players:GetPlayers(), function(_, Player)
			local Hum = getPlrHum(Player.Character)
			if Hum and Hum.RigType == Enum.HumanoidRigType.R15 then
				local desc = Hum:GetAppliedDescription()
				if desc and tonumber(desc.BodyHeightScale) < 0.9 then
					Insert(Targets, Player)
				end
			end
		end)

		return Targets
	end,
	["#(%d+)"] = function(speaker, args, currentList)
		local returns = {}
		local randAmount = tonumber(args[1])
		local pool = { unpack(currentList or Players:GetPlayers()) }
		for i = 1, math.min(randAmount, #pool) do
			local idx = math.random(1, #pool)
			Insert(returns, pool[idx])
			table.remove(pool, idx)
		end
		return returns
	end,

	["%%(.+)"] = function(speaker, args)
		local returns = {}
		local teamPrefix = args[1]:lower()
		for _, plr in ipairs(Players:GetPlayers()) do
			if plr.Team
				and plr.Team.Name:lower():sub(1, #teamPrefix) == teamPrefix
			then
				Insert(returns, plr)
			end
		end
		return returns
	end,

	["allies"] = function()
		local Targets = {}

		Foreach(Players:GetPlayers(), function(_, Player)
			if Player.Team == LocalPlayer.Team and Player ~= LocalPlayer then
				Insert(Targets, Player)
			end
		end)

		return Targets
	end,

	["enemies"] = function()
		local Targets = {}

		Foreach(Players:GetPlayers(), function(_, Player)
			if Player.Team ~= LocalPlayer.Team and Player ~= LocalPlayer then
				Insert(Targets, Player)
			end
		end)

		return Targets
	end,

	["age(%d+)"] = function(speaker, args)
		local returns = {}
		local maxAge = tonumber(args[1])
		for _, plr in ipairs(Players:GetPlayers()) do
			if plr.AccountAge <= maxAge then
				Insert(returns, plr)
			end
		end
		return returns
	end,

	["group(%d+)"] = function(speaker, args)
		local returns = {}
		local groupID = tonumber(args[1])
		for _, plr in ipairs(Players:GetPlayers()) do
			if plr:IsInGroup(groupID) then
				Insert(returns, plr)
			end
		end
		return returns
	end,

	["rad(%d+)"] = function(speaker, args)
		local returns = {}
		local radius = tonumber(args[1])
		local origin = getRoot(speaker.Character)
		if not origin then return returns end
		for _, plr in ipairs(Players:GetPlayers()) do
			local root = getRoot(plr.Character)
			if root and (root.Position - origin.Position).Magnitude <= radius then
				Insert(returns, plr)
			end
		end
		return returns
	end,

	["cursor"] = function(speaker)
		local returns = {}
		local v = NAmanage.getPlrCursor()
		if v then Insert(returns, v) end
		return returns
	end,
}

local function getPlr(a, b)
	local speaker, raw
	if b == nil then
		speaker = Players.LocalPlayer
		raw = a:lower()
	else
		speaker = a
		raw = b:lower()
	end

	if PlayerArgs[raw] then
		return PlayerArgs[raw](speaker)
	end

	local onlyDigits = raw:match("^%d+$")
	if onlyDigits then
		return PlayerArgs["#(%d+)"](speaker, {onlyDigits}, PlayerArgs["all"]())
	end

	for pat, fn in pairs(PlayerArgs) do
		local captures = { raw:match("^"..pat.."$") }
		if #captures > 0 then
			return fn(speaker, captures, PlayerArgs["all"]())
		end
	end

	local out = {}
	for _, plr in ipairs(Players:GetPlayers()) do
		local n = plr.Name:lower()
		local d = plr.DisplayName:lower()
		if n:sub(1,#raw) == raw or d:sub(1,#raw) == raw then
			Insert(out, plr)
		end
	end
	return out
end

--[[ MORE VARIABLES ]]--
plr=Player
speaker=Player
char=plr.Character
deathCFrame = nil
local JSONEncode,JSONDecode=HttpService.JSONEncode,HttpService.JSONDecode

NACaller(function()
	LocalPlayer.CharacterAdded:Connect(function(c)
		if not c then return end
		character=c
		Character=c
		char=c
	end)
end)

local ESPenabled=false
local chamsEnabled=false
local ESPAutoTrackAll=false
espCONS = espCONS or {}


NAgui.espUsesHighlight=function()
	local mode = NAStuff.ESP_RenderMode
	if type(mode) == "string" then
		return Lower(mode) == "highlight"
	end
	return false
end

NAgui.sanitizeTransparency=function(value)
	local tr = tonumber(value) or 0.7
	if tr < 0 then
		tr = 0
	elseif tr > 1 then
		tr = 1
	end
	return tr
end

NAgui.sanitizeLabelSize=function(value)
	local sz = tonumber(value) or 12
	if sz < 8 then
		sz = 8
	elseif sz > 72 then
		sz = 72
	end
	sz = math.floor(sz + 0.5)
	return sz
end

NAgui.getInstanceWorldPosition=function(inst)
	if not inst then return nil end
	if inst:IsA("BasePart") then
		return inst.Position
	elseif inst:IsA("Model") then
		local primary = inst.PrimaryPart
		if primary then
			return primary.Position
		end
		local okPivot, pivot = pcall(inst.GetPivot, inst)
		if okPivot and pivot then
			return pivot.Position
		end
		local okBox, cf = pcall(inst.GetBoundingBox, inst)
		if okBox and cf then
			return cf.Position
		end
	end
	return nil
end

NAgui.updateLabelBounds=function(label)
	if not label then return end
	local billboard = label.Parent
	if not billboard or not billboard:IsA("BillboardGui") then return end
	local text = label.Text
	if text == "" then
		text = label.Name or " "
	end
	local targetSize = NAgui.sanitizeLabelSize(NAStuff.ESP_LabelTextSize)
	local success, bounds = pcall(TextService.GetTextSize, TextService, text, targetSize, label.Font, Vector2.new(1e4, 1e4))
	local width = 150
	local height = math.max(targetSize + 12, 30)
	if success and bounds then
		width = math.clamp(math.floor(bounds.X + 16), 80, 600)
		height = math.clamp(math.floor(bounds.Y + 12), 24, 200)
	end
	local size = billboard.Size
	if size.X.Offset ~= width or size.Y.Offset ~= height then
		billboard.Size = UDim2.new(0, width, 0, height)
	end
end

NAgui.applyLabelStyle=function(label)
	if not label then return end
	label.AutomaticSize = Enum.AutomaticSize.None
	label.TextScaled = NAStuff.ESP_LabelTextScaled
	label.TextWrapped = false
	label.ClipsDescendants = false
	label.TextSize = NAgui.sanitizeLabelSize(NAStuff.ESP_LabelTextSize)
	NAgui.updateLabelBounds(label)
end

NAgui.updateLabelForInstance=function(inst)
	if not inst or not inst.Parent then return end
	for _, child in ipairs(inst:GetChildren()) do
		if child:IsA("BillboardGui") and Sub(Lower(child.Name),-6) == "_label" then
			local lbl = child:FindFirstChildWhichIsA("TextLabel")
			if lbl then
				NAgui.applyLabelStyle(lbl)
			end
		end
	end
end

NAmanage.ESP_ApplyLabelStyles = function()
	local scaled = (NAStuff.ESP_LabelTextScaled == true)
	local size = NAgui.sanitizeLabelSize(NAStuff.ESP_LabelTextSize)
	local seen = {}
	if NAStuff.partESPEntries then
		for _, entry in pairs(NAStuff.partESPEntries) do
			if typeof(entry) == "table" and entry.label and not seen[entry] then
				seen[entry] = true
				entry.label.TextScaled = scaled
				if not scaled then
					entry.label.TextSize = size
				end
			end
		end
	end
	if NAStuff.partESPVisualMap then
		for _, entry in pairs(NAStuff.partESPVisualMap) do
			if typeof(entry) == "table" and entry.label and not seen[entry] then
				seen[entry] = true
				entry.label.TextScaled = scaled
				if not scaled then
					entry.label.TextSize = size
				end
			end
		end
	end
end

NAgui.adjustHighlightMaterialFor = function(target, enable)
	if not target then return end
	local originals = NAStuff.partESPGlassOriginal
	local counts = NAStuff.partESPGlassCount
	local ltOriginals = NAStuff.partESPLocalTransOriginal
	local ltCounts = NAStuff.partESPLocalTransCount
	if not originals then
		originals = setmetatable({}, { __mode = "k" })
		NAStuff.partESPGlassOriginal = originals
	end
	if not counts then
		counts = setmetatable({}, { __mode = "k" })
		NAStuff.partESPGlassCount = counts
	end
	if not ltOriginals then
		ltOriginals = setmetatable({}, { __mode = "k" })
		NAStuff.partESPLocalTransOriginal = ltOriginals
	end
	if not ltCounts then
		ltCounts = setmetatable({}, { __mode = "k" })
		NAStuff.partESPLocalTransCount = ltCounts
	end
	local function handlePart(base)
		if not base or not base:IsA("BasePart") then return end
		local gCount = counts[base] or 0
		local tCount = ltCounts[base] or 0
		if enable then
			if gCount == 0 then
				originals[base] = base.Material
			end
			counts[base] = gCount + 1
			if base.Material ~= Enum.Material.Glass then
				NAlib.setProperty(base, "Material", Enum.Material.Glass)
			end
			if tCount == 0 then
				ltOriginals[base] = base.LocalTransparencyModifier
			end
			ltCounts[base] = tCount + 1
			if base.Transparency >= 1 or base.LocalTransparencyModifier >= 1 then
				NAlib.setProperty(base, "LocalTransparencyModifier", 0.999)
			end
		else
			if gCount > 0 then
				gCount -= 1
				if gCount <= 0 then
					counts[base] = nil
					local original = originals[base]
					if original ~= nil then
						NAlib.setProperty(base, "Material", original)
						originals[base] = nil
					end
				else
					counts[base] = gCount
				end
			end
			if tCount > 0 then
				tCount -= 1
				if tCount <= 0 then
					ltCounts[base] = nil
					local lt = ltOriginals[base]
					if lt ~= nil then
						NAlib.setProperty(base, "LocalTransparencyModifier", lt)
						ltOriginals[base] = nil
					end
				else
					ltCounts[base] = tCount
				end
			end
		end
	end
	if target:IsA("BasePart") then
		handlePart(target)
	elseif target:IsA("Model") then
		for _, desc in ipairs(target:GetDescendants()) do
			if desc:IsA("BasePart") then
				handlePart(desc)
			end
		end
	end
end

NAmanage.ESP_AdjustHighlightMaterial = function(target, enable)
	NAgui.adjustHighlightMaterialFor(target, enable)
end

NAStuff.partESPEntries = NAStuff.partESPEntries or setmetatable({}, { __mode = "k" })
NAStuff.partESPVisualMap = NAStuff.partESPVisualMap or setmetatable({}, { __mode = "k" })

NAmanage.PartESP_UpdateEntry = function(entry, force, rootPart)
	if not entry or entry.removed then return end
	local part = entry.part
	if not part or not part.Parent then
		NAmanage.PartESP_UnregisterEntry(entry)
		return
	end
	local billboard = entry.billboard
	local label = entry.label
	if not billboard or not billboard.Parent then
		NAmanage.PartESP_UnregisterEntry(entry)
		return
	end
	if not label or label.Parent ~= billboard then
		label = billboard:FindFirstChildWhichIsA("TextLabel")
		entry.label = label
	end
	local baseName = entry.customName or part.Name or "Part"
	local display = baseName
	local showDistance = (NAStuff.ESP_ShowPartDistance == true)
	local root = rootPart
	if showDistance and not root then
		local plr = Players.LocalPlayer
		local char = plr and plr.Character
		root = char and getRoot(char)
	end
	if showDistance and root then
		local pos = NAgui.getInstanceWorldPosition(part)
		if pos then
			local dist = math.floor((root.Position - pos).Magnitude + 0.5)
			display = Format("%s | %d studs", baseName, dist)
		end
	end
	if label then
		if label.Text ~= display then
			label.Text = display
		end
		NAgui.applyLabelStyle(label)
	end
	local visual = entry.visual
	local transparency = NAgui.sanitizeTransparency(NAStuff.ESP_Transparency or entry.transparency)
	if visual and visual.Parent then
		if visual:IsA("Highlight") then
			if visual.FillTransparency ~= transparency then
				visual.FillTransparency = transparency
			end
			local fill = entry.lightColor or entry.baseColor or Color3.new(1,1,1)
			local outline = entry.darkColor or fill
			if visual.FillColor ~= fill then
				visual.FillColor = fill
			end
			if visual.OutlineColor ~= outline then
				visual.OutlineColor = outline
			end
		elseif visual:IsA("BoxHandleAdornment") then
			if entry.lightColor and visual.Color3 ~= entry.lightColor then
				visual.Color3 = entry.lightColor
			end
			if visual.Transparency ~= transparency then
				visual.Transparency = transparency
			end
			if part:IsA("BasePart") then
				local desired = part.Size + Vector3.new(0.1,0.1,0.1)
				if visual.Size ~= desired then
					visual.Size = desired
				end
			end
		end
	end
end

NAmanage.PartESP_UpdateTexts = function(force)
	local entries = NAStuff.partESPEntries
	if not entries then
		return
	end
	if not force then
		local now = tick()
		local nextUpdate = NAStuff.partESPLastUpdate or 0
		if now < nextUpdate then
			return
		end
		NAStuff.partESPLastUpdate = now + 0.2
	else
		NAStuff.partESPLastUpdate = tick() + 0.2
	end
	local rootPart = nil
	if NAStuff.ESP_ShowPartDistance == true then
		local plr = Players.LocalPlayer
		local char = plr and plr.Character
		rootPart = char and getRoot(char)
	end
	local hasEntry = false
	for _, entry in pairs(entries) do
		if entry and not entry.removed then
			hasEntry = true
			NAmanage.PartESP_UpdateEntry(entry, force, rootPart)
		end
	end
	if not hasEntry then
		NAmanage.PartESP_StopHeartbeat()
	end
end

NAmanage.PartESP_StartHeartbeat = function()
	if NAlib.isConnected("esp_part_update") then return end
	NAStuff.partESPLastUpdate = 0
	NAlib.connect("esp_part_update", RunService.Heartbeat:Connect(function()
		NAmanage.PartESP_UpdateTexts(false)
	end))
end

NAmanage.PartESP_StopHeartbeat = function()
	local entries = NAStuff.partESPEntries
	if entries and next(entries) then return end
	NAlib.disconnect("esp_part_update")
end

NAmanage.PartESP_RegisterEntry = function(entry)
	if not entry or not entry.billboard then return end
	NAStuff.partESPEntries[entry.billboard] = entry
	if entry.visual then
		NAStuff.partESPVisualMap[entry.visual] = entry
	end
	if entry.billboardCleanup then
		entry.billboardCleanup:Disconnect()
	end
	if entry.visualCleanup then
		entry.visualCleanup:Disconnect()
	end
	entry.billboardCleanup = entry.billboard.AncestryChanged:Connect(function(_, parent)
		if not parent then
			NAmanage.PartESP_UnregisterEntry(entry)
		end
	end)
	if entry.visual then
		entry.visualCleanup = entry.visual.AncestryChanged:Connect(function(_, parent)
			if not parent then
				NAmanage.PartESP_UnregisterEntry(entry)
			end
		end)
	end
	NAmanage.PartESP_StartHeartbeat()
	NAmanage.PartESP_UpdateEntry(entry, true)
end

NAmanage.PartESP_UnregisterEntry = function(entry)
	if not entry or entry.removed then return end
	entry.removed = true
	if entry.billboardCleanup then
		entry.billboardCleanup:Disconnect()
		entry.billboardCleanup = nil
	end
	if entry.visualCleanup then
		entry.visualCleanup:Disconnect()
		entry.visualCleanup = nil
	end
	if entry.updateKey then
		NAlib.disconnect(entry.updateKey)
		entry.updateKey = nil
	end
	if entry.billboard and NAStuff.partESPEntries then
		NAStuff.partESPEntries[entry.billboard] = nil
	end
	if entry.visual and NAStuff.partESPVisualMap then
		NAStuff.partESPVisualMap[entry.visual] = nil
	end
	NAmanage.PartESP_StopHeartbeat()
end

NAmanage.PartESP_RebuildVisuals = function()
	local entries = NAStuff.partESPEntries
	if not entries or not next(entries) then
		return
	end
	local grouped = {}
	for _, entry in pairs(entries) do
		if entry and not entry.removed and entry.part and entry.part.Parent then
			local bucket = grouped[entry.part]
			if not bucket then
				bucket = {}
				grouped[entry.part] = bucket
			end
			bucket[#bucket+1] = {
				color = entry.baseColor or Color3.new(1,1,1),
				transparency = entry.transparency or 0.45,
			}
		end
	end
	for part, bucket in pairs(grouped) do
		NAmanage.RemoveEspFromPart(part)
		for _, info in ipairs(bucket) do
			NAmanage.CreateBox(part, info.color, info.transparency)
		end
	end
	NAmanage.PartESP_UpdateTexts(true)
end

NAmanage.ESP_RebuildVisuals = function()
	for model, data in pairs(espCONS) do
		if data then
			local wasEnabled = data.boxEnabled
			NAmanage.ESP_RemoveBoxes(model)
			if wasEnabled then
				NAmanage.ESP_AddBoxes(model)
			end
		end
	end
	NAmanage.PartESP_RebuildVisuals()
	NAmanage.ESP_ApplyLabelStyles()
end

function round(num,numDecimalPlaces)
	local mult=10^(numDecimalPlaces or 0)
	return math.floor(num*mult+0.5) / mult
end

function getPlaceInfo()
	local success, result = pcall(function()
		return SafeGetService("MarketplaceService"):GetProductInfo(PlaceId)
	end)

	if not success then return nil end

	return result
end

function placeName()
	local info = getPlaceInfo()
	local name = info and NAlib.isProperty(info, "Name")
	return name or "unknown"
end

function SaveUIStroke(color)
	if typeof(color) ~= "Color3" then
		return
	end

	NAmanage.NASettingsSet("uiStroke", {
		R = color.R;
		G = color.G;
		B = color.B;
	})
end

function placeCreator()
	local info = getPlaceInfo()
	local creator = info and NAlib.isProperty(info, "Creator")
	local creatorName = creator and NAlib.isProperty(creator, "Name")
	return creatorName or "unknown"
end

NAmanage.ESP_Key = function(model)
	return tostring(model)
end

NAmanage.ESP_DestroyLabel = function(model)
	local data = espCONS[model]
	if not data then return end
	if data.billboard then data.billboard:Destroy() data.billboard=nil end
	if data.textLabel then data.textLabel:Destroy() data.textLabel=nil end
end

NAmanage.ESP_FirstBasePart = function(model)
	if not model or not model.Parent then return nil end
	for _, d in ipairs(model:GetDescendants()) do
		if d:IsA("BasePart") then
			return d
		end
	end
	return nil
end

NAmanage.ESP_EnsureLabel = function(model)
	if chamsEnabled then return end
	local data = espCONS[model]
	if not data then return end
	if data.textLabel and data.billboard and data.billboard.Parent then return end
	local anchor = getHead(model) or getRoot(model) or NAmanage.ESP_FirstBasePart(model)
	if not anchor then return end
	local billboard = InstanceNew("BillboardGui")
	billboard.Adornee = anchor
	billboard.AlwaysOnTop = true
	billboard.Size = UDim2.new(0,150,0,40)
	billboard.StudsOffset = Vector3.new(0,2.5,0)
	billboard.Parent = anchor
	local label = InstanceNew("TextLabel")
	label.Size = UDim2.new(1,0,1,0)
	label.BackgroundTransparency = 1
	label.Font = Enum.Font.GothamBold
	label.TextStrokeTransparency = 0.5
	label.Text = ""
	label.Parent = billboard
	NAgui.applyLabelStyle(label)
	data.billboard = billboard
	data.textLabel = label
end

NAmanage.ESP_AddBoxForPart = function(model, part)
	local data = espCONS[model]
	if not data or not part or not part:IsA("BasePart") then return end
	if data.boxTable[part] then return end
	if NAgui.espUsesHighlight() then return end
	local box = InstanceNew("BoxHandleAdornment")
	box.Adornee = part
	box.AlwaysOnTop = true
	box.ZIndex = 1
	box.Transparency = NAgui.sanitizeTransparency(NAStuff.ESP_Transparency or 0.7)
	box.Size = part.Size
	box.Color3 = Color3.new(1,1,1)
	box.Parent = part
	data.boxTable[part] = box
end

NAmanage.ESP_AddBoxes = function(model)
	local data = espCONS[model]
	if not data then return end
	if NAgui.espUsesHighlight() then
		local highlight = data.highlight
		if highlight and not highlight.Parent then
			highlight = nil
		end
		if not highlight then
			local hl = InstanceNew("Highlight")
			hl.Name = "NAESP_Highlight"
			hl.Adornee = model
			hl.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
			hl.FillColor = Color3.new(1,1,1)
			hl.OutlineColor = Color3.new(1,1,1)
			hl.FillTransparency = NAgui.sanitizeTransparency(NAStuff.ESP_Transparency or 0.7)
			hl.OutlineTransparency = 0
			hl.Parent = model
			data.highlight = hl
			NAmanage.ESP_AdjustHighlightMaterial(model, true)
		else
			data.highlight = highlight
		end
		if data.highlight then
			data.highlight.Enabled = true
		end
		data.boxEnabled = true
		return
	end
	for _, part in ipairs(model:GetDescendants()) do
		if part:IsA("BasePart") then
			NAmanage.ESP_AddBoxForPart(model, part)
		end
	end
	data.boxEnabled = true
end

NAmanage.ESP_RemoveBoxes = function(model)
	local data = espCONS[model]
	if not data then return end
	for part, box in pairs(data.boxTable) do
		if box then box:Destroy() end
		data.boxTable[part] = nil
	end
	if data.highlight then
		NAmanage.ESP_AdjustHighlightMaterial(model, false)
		data.highlight:Destroy()
		data.highlight = nil
	end
	data.boxEnabled = false
end

NAmanage.ESP_ClearModel = function(model)
	if not model then return end
	local key = NAmanage.ESP_Key(model)
	NAlib.disconnect(key.."_descAdded")
	NAlib.disconnect(key.."_descRemoved")
	NAlib.disconnect(key.."_charAdded")
	NAmanage.ESP_RemoveBoxes(model)
	NAmanage.ESP_DestroyLabel(model)
	espCONS[model] = nil
end

NAmanage.ESP_ClearAll = function()
	for model,_ in pairs(espCONS) do
		NAmanage.ESP_ClearModel(model)
	end
	for _, plr in ipairs(Players:GetPlayers()) do
		NAlib.disconnect("esp_charAdded_plr_"..tostring(plr.UserId))
	end
	NAlib.disconnect("esp_update_global")
end

NAmanage.ESP_Disconnect = function(target)
	local model = (target and target:IsA("Player")) and target.Character or target
	if typeof(target) == "Instance" and target:IsA("Player") then
		NAlib.disconnect("esp_charAdded_plr_"..tostring(target.UserId))
	end
	NAmanage.ESP_ClearModel(model)
end

NAmanage.ESP_UpdateOne = function(model, now, localRoot)
	local data = espCONS[model]
	if not data then return end
	if not model.Parent then NAmanage.ESP_ClearModel(model) return end

	local rootPart = getRoot(model)
	local owner = Players:GetPlayerFromCharacter(model)
	local team = owner and owner.Team or nil
	local teamName = team and team.Name or nil
	local teamColor = team and team.TeamColor and team.TeamColor.Color or nil

	local dist = (localRoot and rootPart) and math.floor((localRoot.Position - rootPart.Position).Magnitude) or nil
	local budget = dist and ((dist<=50 and 0.05) or (dist<=150 and 0.15) or (dist<=400 and 0.3) or 0.6) or 0.2
	if data.next and now < data.next then return end
	data.next = now + budget

	local distColor = dist and ((dist>100 and Color3.fromRGB(0,255,0)) or (dist>50 and Color3.fromRGB(255,165,0)) or Color3.fromRGB(255,0,0)) or Color3.new(1,1,1)
	local finalColor = (NAStuff.ESP_ColorByTeam ~= false and teamColor) or distColor

	local wantBoxes = ESPenabled and (dist == nil or dist <= (NAStuff.ESP_BoxMaxDistance or 120))
	local wantLabel = ESPenabled and not chamsEnabled and (dist == nil or dist <= (NAStuff.ESP_LabelMaxDistance or 1000))

	if wantBoxes and not data.boxEnabled then
		NAmanage.ESP_AddBoxes(model)
	elseif not wantBoxes and data.boxEnabled then
		NAmanage.ESP_RemoveBoxes(model)
	end

	if wantLabel then
		NAmanage.ESP_EnsureLabel(model)
	else
		NAmanage.ESP_DestroyLabel(model)
	end

	if data.boxEnabled then
		if NAgui.espUsesHighlight() then
			if next(data.boxTable) ~= nil then
				for part, box in pairs(data.boxTable) do
					if box then box:Destroy() end
					data.boxTable[part] = nil
				end
			end
			local highlight = data.highlight
			if not highlight or not highlight.Parent then
				data.highlight = nil
				if wantBoxes then
					NAmanage.ESP_AddBoxes(model)
					highlight = data.highlight
				end
			end
			if highlight then
				local tr = NAgui.sanitizeTransparency(NAStuff.ESP_Transparency or 0.7)
				if highlight.FillTransparency ~= tr then highlight.FillTransparency = tr end
				if highlight.OutlineTransparency ~= 0 then highlight.OutlineTransparency = 0 end
				local color = finalColor or Color3.new(1,1,1)
				if highlight.FillColor ~= color then highlight.FillColor = color end
				if highlight.OutlineColor ~= color then highlight.OutlineColor = color end
			end
		else
			local tr = NAgui.sanitizeTransparency(NAStuff.ESP_Transparency or 0.7)
			for part, box in pairs(data.boxTable) do
				if not part or not part.Parent then
					if box then box:Destroy() end
					data.boxTable[part] = nil
				else
					if box.Color3 ~= finalColor then box.Color3 = finalColor end
					if part:IsA("BasePart") and box.Size ~= part.Size then box.Size = part.Size end
					if box.Transparency ~= tr then box.Transparency = tr end
				end
			end
			if now % 0.5 < 0.05 then
				for _, part in ipairs(model:GetDescendants()) do
					if part:IsA("BasePart") and not data.boxTable[part] then
						NAmanage.ESP_AddBoxForPart(model, part)
					end
				end
			end
		end
	end

	local pieces = {}
	if NAStuff.ESP_ShowName ~= false then
		local nm = owner and nameChecker(owner) or model.Name
		if nm and nm ~= "" then pieces[#pieces+1] = nm end
	end
	if NAStuff.ESP_ShowHealth ~= false then
		local hum = getPlrHum(model)
		local h = hum and math.floor(hum.Health) or nil
		local m = hum and math.floor(hum.MaxHealth) or nil
		if h and m then pieces[#pieces+1] = tostring(h).."/"..tostring(m).." HP" end
	end
	if (NAStuff.ESP_ShowTeamText ~= false) and teamName and teamName ~= "None" then
		pieces[#pieces+1] = teamName
	end
	if (NAStuff.ESP_ShowDistance ~= false) and dist then
		pieces[#pieces+1] = tostring(dist).." studs"
	end

	if #pieces > 0 and wantLabel then
		NAmanage.ESP_EnsureLabel(model)
		if data.textLabel then
			NAgui.applyLabelStyle(data.textLabel)
			local txt = Concat(pieces, " | ")
			if data.textLabel.Text ~= txt then data.textLabel.Text = txt end
			local txtColor = finalColor or Color3.new(1,1,1)
			if data.textLabel.TextColor3 ~= txtColor then data.textLabel.TextColor3 = txtColor end
		end
	else
		NAmanage.ESP_DestroyLabel(model)
	end
end

NAmanage.ESP_Add = function(target, persistent)
	persistent = persistent or false
	if not (ESPenabled or chamsEnabled) then return end
	if typeof(target) ~= "Instance" then return end

	if target:IsA("Player") then
		if persistent then
			NAlib.disconnect("esp_charAdded_plr_"..tostring(target.UserId))
			NAlib.connect("esp_charAdded_plr_"..tostring(target.UserId), target.CharacterAdded:Connect(function()
				Wait(0.25)
				if (ESPenabled or chamsEnabled) then
					NAmanage.ESP_Add(target, true)
				end
			end))
		end
		if not target.Character then return end
	end

	local model = target:IsA("Player") and target.Character or target
	NAmanage.ESP_ClearModel(model)
	if not (model and model:IsA("Model")) then return end

	espCONS[model] = { boxTable = {}, persistent = persistent, boxEnabled = false, highlight = nil }
	local key = NAmanage.ESP_Key(model)

	NAlib.connect(key.."_descAdded", model.DescendantAdded:Connect(function(desc)
		if not (ESPenabled or chamsEnabled) then return end
		if not espCONS[model] then return end
		if desc:IsA("BasePart") and espCONS[model].boxEnabled then
			NAmanage.ESP_AddBoxForPart(model, desc)
		end
	end))

	NAlib.connect(key.."_descRemoved", model.DescendantRemoving:Connect(function(desc)
		local data = espCONS[model]
		if not data then return end
		local box = data.boxTable[desc]
		if box then box:Destroy(); data.boxTable[desc] = nil end
	end))

	NAmanage.ESP_AddBoxes(model)
	NAmanage.ESP_EnsureLabel(model)

	local ok, now = pcall(tick)
	if ok then
		NAmanage.ESP_UpdateOne(model, now, nil)
	end

	NAmanage.ESP_StartGlobal()
end

NAmanage.ESP_StartGlobal = function()
	if NAlib.isConnected("esp_update_global") then return end
	NAlib.connect("esp_update_global", RunService.Heartbeat:Connect(function()
		local plr = Players.LocalPlayer
		local char = plr and plr.Character or nil
		local localRoot = (char and getRoot(char)) or nil
		local now = tick()
		for model,_ in pairs(espCONS) do
			NAmanage.ESP_UpdateOne(model, now, localRoot)
		end
	end))
end

NAmanage.ESP_StopGlobal = function()
	NAlib.disconnect("esp_update_global")
end

--[[local Signal1, Signal2 = nil, nil
local flyMobile, MobileWeld = nil, nil

function mobilefly(speed, vfly)
	local character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
	if flyMobile then flyMobile:Destroy() end
	flyMobile = InstanceNew("Part", workspace)
	flyMobile.Size, flyMobile.CanCollide = Vector3.new(0.05, 0.05, 0.05), false
	if MobileWeld then MobileWeld:Destroy() end
	MobileWeld = InstanceNew("Weld", flyMobile)
	MobileWeld.Part0, MobileWeld.Part1, MobileWeld.C0 = flyMobile, character:FindFirstChildWhichIsA("Humanoid").RootPart, CFrame.new(0, 0, 0)

	if not flyMobile:FindFirstChildWhichIsA("BodyVelocity") then
		local bv = InstanceNew("BodyVelocity", flyMobile)
		bv.MaxForce = Vector3.new(0, 0, 0)
		bv.Velocity = Vector3.new(0, 0, 0)
	end

	if not flyMobile:FindFirstChildWhichIsA("BodyGyro") then
		local bg = InstanceNew("BodyGyro", flyMobile)
		bg.MaxTorque = Vector3.new(9e9, 9e9, 9e9)
		bg.P = 1000
		bg.D = 50
	end

	Signal1 = LocalPlayer.CharacterAdded:Connect(function(newChar)
		if not flyMobile:FindFirstChildWhichIsA("BodyVelocity") then
			local bv = InstanceNew("BodyVelocity", flyMobile)
			bv.MaxForce = Vector3.new(0, 0, 0)
			bv.Velocity = Vector3.new(0, 0, 0)
		end

		if not flyMobile:FindFirstChildWhichIsA("BodyGyro") then
			local bg = InstanceNew("BodyGyro", flyMobile)
			bg.MaxTorque = Vector3.new(9e9, 9e9, 9e9)
			bg.P = 1000
			bg.D = 50
		end

		if not flyMobile:FindFirstChildWhichIsA("Weld") then
			MobileWeld = InstanceNew("Weld", flyMobile)
			MobileWeld.Part0, MobileWeld.Part1, MobileWeld.C0 = flyMobile, newChar:FindFirstChildWhichIsA("Humanoid").RootPart, CFrame.new(0, 0, 0)
		else
			MobileWeld.Part0, MobileWeld.Part1, MobileWeld.C0 = flyMobile, newChar:FindFirstChildWhichIsA("Humanoid").RootPart, CFrame.new(0, 0, 0)
		end
	end)

	local camera = workspace.CurrentCamera

	Signal2 = RunService.RenderStepped:Connect(function()
		local character = getChar()
		local humanoid = character and character:FindFirstChildOfClass("Humanoid")
		local bv = flyMobile and flyMobile:FindFirstChildWhichIsA("BodyVelocity")
		local bg = flyMobile and flyMobile:FindFirstChildWhichIsA("BodyGyro")

		if character and humanoid and flyMobile and MobileWeld and bv and bg then
			bv.MaxForce = Vector3.new(9e9, 9e9, 9e9)
			bg.MaxTorque = Vector3.new(9e9, 9e9, 9e9)
			if not vfly then
				if getHum() and getHum().PlatformStand then getHum().PlatformStand = true end
			end

			bg.CFrame = camera.CFrame
			local direction = GetCustomMoveVector()
			local newVelocity = Vector3.new()

			if direction.X ~= 0 then
				newVelocity = newVelocity + camera.CFrame.RightVector * (direction.X * speed)
			end
			if direction.Z ~= 0 then
				newVelocity = newVelocity - camera.CFrame.LookVector * (direction.Z * speed)
			end

			bv.Velocity = newVelocity
		end
	end)
end

function unmobilefly()
	if flyMobile then
		flyMobile:Destroy()
		if getHum() and getHum().PlatformStand then getHum().PlatformStand = false end
	end
	if Signal1 then Signal1:Disconnect() end
	if Signal2 then Signal2:Disconnect() end
end]]

local tool
if getChar() and getBp() then
	tool=getBp():FindFirstChildOfClass("Tool") or getChar():FindFirstChildOfClass("Tool")
end

local xrayConn = nil

function togXray(en)
	if type(en) ~= "boolean" then
		warn("togXray: Invalid arg, expected boolean")
		return
	end

	local transVal = en and 0.5 or 0.0

	if en then
		xrayConn = workspace.DescendantAdded:Connect(function(desc)
			if desc:IsA("BasePart") then
				local hasHum = false
				local cur = desc.Parent
				for i = 1, 5 do
					if cur and cur:FindFirstChildOfClass("Humanoid") then
						hasHum = true
						break
					end
					cur = cur.Parent
					if not cur or cur == workspace then
						break
					end
				end
				if not hasHum then
					local ok, err = pcall(function()
						desc.LocalTransparencyModifier = 0.5
					end)
					if not ok then
						warn("Failed to mod transparency for new part "..tostring(desc)..": "..tostring(err))
					end
				end
			end
		end)
	else
		if xrayConn then
			xrayConn:Disconnect()
			xrayConn = nil
		end
	end

	for _, prt in pairs(workspace:GetDescendants()) do
		if prt:IsA("BasePart") then
			local hasHum = false
			local cur = prt.Parent
			for i = 1, 5 do
				if cur and cur:FindFirstChildOfClass("Humanoid") then
					hasHum = true
					break
				end
				cur = cur.Parent
				if not cur or cur == workspace then
					break
				end
			end
			if not hasHum then
				local ok, err = NACaller(function()
					prt.LocalTransparencyModifier = transVal
				end)
				if not ok then
					warn("Failed to mod transparency for part "..tostring(prt)..": "..tostring(err))
				end
			end
		end
	end
end

-- [[ FLY VARIABLES ]] --

local flyVariables = {
	mOn = false;
	mFlyBruh = nil;
	flyEnabled = false;
	toggleKey = "f";
	flySpeed = 1;
	keybindConn = nil;

	vOn = false;
	vRAHH = nil;
	vFlyEnabled = false;
	vToggleKey = "v";
	vFlySpeed = 1;
	vKeybindConn = nil;

	cOn = false;
	cFlyGUI = nil;
	cFlyEnabled = false;
	cToggleKey = "c";
	cFlySpeed = 1;
	cKeybindConn = nil;

	TFlyEnabled = false;
	tflyCORE = nil;
	tflyToggleKey = "t";
	tflyButtonUI = nil;
	TFLYBTN = nil;
	tflyKeyConn = nil;
	TflySpeed = 2;

	uiPosConns = {};
}

-----------------------------

cmdlp = Players.LocalPlayer
plr = cmdlp
goofyFLY = nil

NAmanage._state={mode="none"}
NAmanage._persist={lastMode="none",wasFlying=false,uiPos={}}
FLYING=FLYING or false

NAmanage._modeEnabled=function(m)
	if m=="fly" then return flyVariables.flyEnabled
	elseif m=="vfly" then return flyVariables.vFlyEnabled
	elseif m=="cfly" then return flyVariables.cFlyEnabled
	elseif m=="tfly" then return flyVariables.TFlyEnabled
	end
	return false
end

NAmanage._releaseQE=function()
	if flyVariables.qeDownConn then pcall(function() flyVariables.qeDownConn:Disconnect() end) end
	if flyVariables.qeUpConn then pcall(function() flyVariables.qeUpConn:Disconnect() end) end
	flyVariables.qeDownConn=nil
	flyVariables.qeUpConn=nil
end

NAmanage._bindQE=function()
	NAmanage._releaseQE()
	flyVariables.qeDownConn=mouse.KeyDown:Connect(function(k)
		k=Lower(k or "")
		if k=="q" then
			local sp=(NAmanage._state.mode=="vfly" and tonumber(flyVariables.vFlySpeed) or tonumber(flyVariables.flySpeed) or 1)
			CONTROL.Q=-sp*2
		elseif k=="e" then
			local sp=(NAmanage._state.mode=="vfly" and tonumber(flyVariables.vFlySpeed) or tonumber(flyVariables.flySpeed) or 1)
			CONTROL.E=sp*2
		end
	end)
	flyVariables.qeUpConn=mouse.KeyUp:Connect(function(k)
		k=Lower(k or "")
		if k=="q" then CONTROL.Q=0 elseif k=="e" then CONTROL.E=0 end
	end)
end

NAmanage._clearPhysics=function(full)
	if CFloop then pcall(function() CFloop:Disconnect() end) end
	CFloop=nil
	if full then
		if goofyFLY then pcall(function() goofyFLY:Destroy() end) end
		goofyFLY=nil
		if flyVariables.TFpos then pcall(function() flyVariables.TFpos:Destroy() end) end
		if flyVariables.TFgyro then pcall(function() flyVariables.TFgyro:Destroy() end) end
		flyVariables.TFpos=nil
		flyVariables.TFgyro=nil
		if flyVariables.BG then pcall(function() flyVariables.BG:Destroy() end) end
		if flyVariables.BV then pcall(function() flyVariables.BV:Destroy() end) end
		flyVariables.BG=nil
		flyVariables.BV=nil
		for _,v in ipairs(workspace:GetDescendants()) do
			if v:GetAttribute("tflyPart") then pcall(function() v:Destroy() end) end
		end
	end
end

NAmanage._isSeated=function()
	local hum=getHum()
	if not hum then return false end
	if hum.Sit then return true end
	local seat=hum.SeatPart
	return seat and (seat:IsA("Seat") or seat:IsA("VehicleSeat")) or false
end

NAmanage.FLY_Cleanup = function(char)
	local c = char or getChar()
	local hum = getHum(c)
	local head = getHead(c)
	if head then pcall(function() head.Anchored = false end) end
	if hum then
		pcall(function() hum.PlatformStand = false end)
		pcall(function() hum.Sit = false end)
		pcall(function() hum.AutoRotate = true end)
		pcall(function() hum:ChangeState(Enum.HumanoidStateType.Running) end)
	end
	if flyVariables.TFpos then pcall(function() flyVariables.TFpos:Destroy() end) flyVariables.TFpos=nil end
	if flyVariables.TFgyro then pcall(function() flyVariables.TFgyro:Destroy() end) flyVariables.TFgyro=nil end
	if flyVariables.BG then pcall(function() flyVariables.BG:Destroy() end) flyVariables.BG=nil end
	if flyVariables.BV then pcall(function() flyVariables.BV:Destroy() end) flyVariables.BV=nil end
	if goofyFLY then pcall(function() goofyFLY:Destroy() end) goofyFLY=nil end
	CONTROL={Q=0,E=0}; lCONTROL={Q=0,E=0}; SPEED=0
	FLYING=false
end

NAmanage.FLY_OnRespawnGround = function()
	local c = getChar()
	NAmanage.FLY_Cleanup(c)
end

NAmanage.pauseCurrent = function()
	if not FLYING then return end
	FLYING=false
	local hum=getHum()
	local head=getHead(getChar())
	if NAmanage._state.mode=="cfly" then
		if head then head.Anchored=false end
	elseif NAmanage._state.mode=="tfly" then
		if flyVariables.TFpos then flyVariables.TFpos.maxForce=Vector3.new(0,0,0) end
		if flyVariables.TFgyro then flyVariables.TFgyro.maxTorque=Vector3.new(0,0,0) end
	elseif NAmanage._state.mode=="fly" or NAmanage._state.mode=="vfly" then
		if flyVariables.BV then flyVariables.BV.velocity=Vector3.zero flyVariables.BV.maxForce=Vector3.new(0,0,0) end
		if flyVariables.BG then flyVariables.BG.maxTorque=Vector3.new(0,0,0) end
		if hum and not NAmanage._isSeated() then
			hum.PlatformStand=false
			hum.AutoRotate=true
			hum:ChangeState(Enum.HumanoidStateType.Running)
		end
	end
end

NAmanage._camera=function()
	local cam=workspace.CurrentCamera
	if cam and cam.Parent then return cam end
	return nil
end

NAmanage._bindCameraWatch=function()
	if flyVariables._camChangedConn then pcall(function() flyVariables._camChangedConn:Disconnect() end) end
	flyVariables._camChangedConn=workspace:GetPropertyChangedSignal("CurrentCamera"):Connect(function() end)
end

NAmanage.resumeCurrent=function()
	if FLYING then return end
	local hum=getHum()
	local head=getHead(getChar())
	if NAmanage._state.mode=="cfly" then
		if head then head.Anchored=true end
	elseif NAmanage._state.mode=="tfly" then
		if goofyFLY and flyVariables.TFpos then flyVariables.TFpos.position=goofyFLY.Position end
		local cam=NAmanage._camera()
		if flyVariables.TFgyro and cam then flyVariables.TFgyro.cframe=cam.CFrame end
		if flyVariables.TFpos then flyVariables.TFpos.maxForce=Vector3.new(math.huge,math.huge,math.huge) end
		if flyVariables.TFgyro then flyVariables.TFgyro.maxTorque=Vector3.new(9e9,9e9,9e9) end
	elseif NAmanage._state.mode=="fly" then
		if flyVariables.BV then flyVariables.BV.maxForce=Vector3.new(9e9,9e9,9e9) end
		if flyVariables.BG then flyVariables.BG.maxTorque=Vector3.new(9e9,9e9,9e9) end
		if hum then hum.PlatformStand=true end
	elseif NAmanage._state.mode=="vfly" then
		if flyVariables.BV then flyVariables.BV.maxForce=Vector3.new(9e9,9e9,9e9) end
		if flyVariables.BG then flyVariables.BG.maxTorque=Vector3.new(9e9,9e9,9e9) end
		if hum then hum.PlatformStand=false end
	end
	FLYING=true
end

NAmanage._destroyMobileFlyUI=function()
	for m,conn in pairs(flyVariables.uiPosConns) do
		pcall(function() conn:Disconnect() end)
		flyVariables.uiPosConns[m]=nil
	end
	if flyVariables.uiUpdateConn then pcall(function() flyVariables.uiUpdateConn:Disconnect() end) end
	flyVariables.uiUpdateConn=nil
	if flyVariables.mFlyBruh then pcall(function() flyVariables.mFlyBruh:Destroy() end) flyVariables.mFlyBruh=nil end
	if flyVariables.vRAHH then pcall(function() flyVariables.vRAHH:Destroy() end) flyVariables.vRAHH=nil end
	if flyVariables.cFlyGUI then pcall(function() flyVariables.cFlyGUI:Destroy() end) flyVariables.cFlyGUI=nil end
	if flyVariables.TFLYBTN then pcall(function() flyVariables.TFLYBTN:Destroy() end) flyVariables.TFLYBTN=nil end
	if flyVariables.tflyButtonUI then pcall(function() flyVariables.tflyButtonUI:Destroy() end) flyVariables.tflyButtonUI=nil end
end

NAmanage._ensureMobileFlyUI=function(mode)
	if not IsOnMobile then return end
	NAmanage._destroyMobileFlyUI()
	local mk=function(modeKey,btnText,onToggle,getSpeed,setSpeed,storeRefs)
		local gui=InstanceNew("ScreenGui"); NaProtectUI(gui); gui.ResetOnSpawn=false
		local btn=InstanceNew("TextButton",gui)
		local speedBox=InstanceNew("TextBox",gui)
		local toggleBtn=InstanceNew("TextButton",btn)
		local corner=InstanceNew("UICorner",btn)
		local corner2=InstanceNew("UICorner",speedBox)
		local corner3=InstanceNew("UICorner",toggleBtn)
		local aspect=InstanceNew("UIAspectRatioConstraint",btn)
		btn.BackgroundColor3=Color3.fromRGB(30,30,30)
		btn.BackgroundTransparency=0.1
		btn.Position=NAmanage._persist.uiPos[modeKey] or UDim2.new(0.9,0,0.5,0)
		btn.Size=UDim2.new(0.08,0,0.1,0)
		btn.Font=Enum.Font.GothamBold
		btn.Text=btnText()
		btn.TextColor3=Color3.fromRGB(255,255,255)
		btn.TextScaled=true
		corner.CornerRadius=UDim.new(0.2,0)
		aspect.AspectRatio=1
		speedBox.BackgroundColor3=Color3.fromRGB(30,30,30)
		speedBox.BackgroundTransparency=0.1
		speedBox.AnchorPoint=Vector2.new(0.5,0)
		speedBox.Position=UDim2.new(0.5,0,0,10)
		speedBox.Size=UDim2.new(0,75,0,35)
		speedBox.Font=Enum.Font.GothamBold
		speedBox.Text=tostring(getSpeed())
		speedBox.TextColor3=Color3.fromRGB(255,255,255)
		speedBox.TextSize=24
		speedBox.TextScaled=true
		speedBox.ClearTextOnFocus=false
		speedBox.PlaceholderText="Speed"
		speedBox.Visible=false
		corner2.CornerRadius=UDim.new(0.2,0)
		toggleBtn.BackgroundColor3=Color3.fromRGB(50,50,50)
		toggleBtn.BackgroundTransparency=0.1
		toggleBtn.Position=UDim2.new(0.8,0,-0.1,0)
		toggleBtn.Size=UDim2.new(0.4,0,0.4,0)
		toggleBtn.Font=Enum.Font.SourceSans
		toggleBtn.Text="+"
		toggleBtn.TextColor3=Color3.fromRGB(255,255,255)
		toggleBtn.TextScaled=true
		toggleBtn.AutoButtonColor=true
		corner3.CornerRadius=UDim.new(1,0)
		MouseButtonFix(toggleBtn,function()
			speedBox.Visible=not speedBox.Visible
			toggleBtn.Text=speedBox.Visible and "-" or "+"
		end)
		MouseButtonFix(btn,function()
			if not FLYING then
				local ns=tonumber(speedBox.Text)
				if ns then setSpeed(ns) speedBox.Text=tostring(getSpeed()) end
			end
			onToggle()
			btn.Text=btnText()
			btn.BackgroundColor3=FLYING and Color3.fromRGB(0,170,0) or Color3.fromRGB(170,0,0)
		end)
		NAgui.draggerV2(btn)
		NAgui.draggerV2(speedBox)
		if flyVariables.uiPosConns[modeKey] then pcall(function() flyVariables.uiPosConns[modeKey]:Disconnect() end) end
		flyVariables.uiPosConns[modeKey]=btn:GetPropertyChangedSignal("Position"):Connect(function()
			NAmanage._persist.uiPos[modeKey]=btn.Position
		end)
		if storeRefs then storeRefs(gui,btn) end
	end
	if mode=="fly" then
		mk("fly",function() return FLYING and "Unfly" or "Fly" end,function() NAmanage.toggleFly() end,function() return flyVariables.flySpeed end,function(v) flyVariables.flySpeed=v end,function(gui,btn) flyVariables.mFlyBruh=gui end)
	elseif mode=="vfly" then
		mk("vfly",function() return FLYING and "UnvFly" or "vFly" end,function() NAmanage.toggleVFly() end,function() return flyVariables.vFlySpeed end,function(v) flyVariables.vFlySpeed=v end,function(gui,btn) flyVariables.vRAHH=gui end)
	elseif mode=="cfly" then
		mk("cfly",function() return FLYING and "UnCfly" or "CFly" end,function() NAmanage.toggleCFly() end,function() return flyVariables.cFlySpeed end,function(v) flyVariables.cFlySpeed=v flyVariables.flySpeed=v end,function(gui,btn) flyVariables.cFlyGUI=gui end)
	elseif mode=="tfly" then
		mk("tfly",function() return FLYING and "UnTFly" or "TFly" end,function() NAmanage.toggleTFly() end,function() return flyVariables.TflySpeed end,function(v) flyVariables.TflySpeed=v end,function(gui,btn) flyVariables.tflyButtonUI=gui flyVariables.TFLYBTN=btn end)
	end
	if flyVariables.uiUpdateConn then pcall(function() flyVariables.uiUpdateConn:Disconnect() end) end
	flyVariables.uiUpdateConn=RunService.Heartbeat:Connect(function()
		if mode=="fly" and flyVariables.mFlyBruh then
			local b=flyVariables.mFlyBruh:FindFirstChildOfClass("TextButton")
			if b then b.Text=FLYING and "Unfly" or "Fly" b.BackgroundColor3=FLYING and Color3.fromRGB(0,170,0) or Color3.fromRGB(30,30,30) end
		elseif mode=="vfly" and flyVariables.vRAHH then
			local b=flyVariables.vRAHH:FindFirstChildOfClass("TextButton")
			if b then b.Text=FLYING and "UnvFly" or "vFly" b.BackgroundColor3=FLYING and Color3.fromRGB(0,170,0) or Color3.fromRGB(30,30,30) end
		elseif mode=="cfly" and flyVariables.cFlyGUI then
			local b=flyVariables.cFlyGUI:FindFirstChildOfClass("TextButton")
			if b then b.Text=FLYING and "UnCfly" or "CFly" b.BackgroundColor3=FLYING and Color3.fromRGB(0,170,0) or Color3.fromRGB(30,30,30) end
		elseif mode=="tfly" and flyVariables.tflyButtonUI then
			local b=flyVariables.tflyButtonUI:FindFirstChildOfClass("TextButton")
			if b then b.Text=FLYING and "UnTFly" or "TFly" b.BackgroundColor3=FLYING and Color3.fromRGB(0,170,0) or Color3.fromRGB(30,30,30) end
		end
	end)
end

NAmanage.deactivateMode=function(m)
	local wasCurrent=(NAmanage._state.mode==m)
	if wasCurrent then
		NAmanage.pauseCurrent()
		NAmanage._clearPhysics(true)
		NAmanage._state.mode="none"
		NAmanage._releaseQE()
	end
	if m=="fly" then flyVariables.flyEnabled=false end
	if m=="vfly" then flyVariables.vFlyEnabled=false end
	if m=="cfly" then flyVariables.cFlyEnabled=false end
	if m=="tfly" then flyVariables.TFlyEnabled=false end
	NAmanage._destroyMobileFlyUI()
end

NAmanage.sFLY=function(vfly,cfly,tfly)
	while not getChar() or not getRoot(getChar()) or not getHum() do Wait() end
	CONTROL={Q=0,E=0}; lCONTROL={Q=0,E=0}; SPEED=0
	local hum=getHum(); local head=getHead(getChar()); local root=getRoot(getChar())
	NAmanage._bindQE()
	if tfly then
		goofyFLY=goofyFLY or InstanceNew("Part",workspace)
		goofyFLY.Size=Vector3.new(0.05,0.05,0.05)
		goofyFLY.Transparency=1
		goofyFLY.CanCollide=false
		if not goofyFLY:FindFirstChildOfClass("Weld") then
			local w=InstanceNew("Weld",goofyFLY) w.Part0=goofyFLY w.Part1=root w.C0=CFrame.new()
		end
		flyVariables.TFpos=flyVariables.TFpos or InstanceNew("BodyPosition",goofyFLY)
		flyVariables.TFgyro=flyVariables.TFgyro or InstanceNew("BodyGyro",goofyFLY)
		flyVariables.TFpos.maxForce=Vector3.new(math.huge,math.huge,math.huge)
		flyVariables.TFpos.position=goofyFLY.Position
		local cam0=NAmanage._camera()
		flyVariables.TFgyro.maxTorque=Vector3.new(9e9,9e9,9e9)
		flyVariables.TFgyro.cframe=cam0 and cam0.CFrame or CFrame.new()
		if CFloop then pcall(function() CFloop:Disconnect() end) end
		CFloop=nil
		if not flyVariables._tflyLoop then
			flyVariables._tflyLoop=true
			SpawnCall(function()
				while NAmanage._state.mode=="tfly" do
					local cam=NAmanage._camera()
					if cam and FLYING and flyVariables.TFpos and flyVariables.TFgyro then
						local sp=tonumber(flyVariables.TflySpeed) or 1
						local mv=GetCustomMoveVector(); mv=Vector3.new(mv.X,mv.Y,-mv.Z)
						local np=flyVariables.TFgyro.cframe-flyVariables.TFgyro.cframe.p+flyVariables.TFpos.position
						if mv.Magnitude>0 then
							np=np+(cam.CFrame.RightVector*mv.X*sp)
							np=np+(cam.CFrame.LookVector*mv.Z*sp)
						end
						np=np+(cam.CFrame.UpVector*(CONTROL.E+CONTROL.Q)*sp)
						pcall(function()
							flyVariables.TFpos.position=np.p
							flyVariables.TFgyro.cframe=cam.CFrame
						end)
					end
					Wait()
				end
				flyVariables._tflyLoop=false
			end)
		end
	elseif cfly then
		goofyFLY=goofyFLY or InstanceNew("Part",workspace)
		goofyFLY.Size=Vector3.new(0.05,0.05,0.05)
		goofyFLY.Transparency=1
		goofyFLY.CanCollide=false
		goofyFLY.Anchored=true
		if head then head.Anchored=true end
		if CFloop then pcall(function() CFloop:Disconnect() end) end
		CFloop=RunService.RenderStepped:Connect(function()
			if NAmanage._state.mode~="cfly" or not FLYING then return end
			local cam=NAmanage._camera(); if not cam then return end
			local mv=GetCustomMoveVector()
			local vertical=(CONTROL.E+CONTROL.Q)
			local full=Vector3.new(mv.X,vertical,-mv.Z)
			local md=(cam.CFrame.RightVector*full.X)+(cam.CFrame.UpVector*full.Y)+(cam.CFrame.LookVector*full.Z)
			if head and md.Magnitude>0 then
				local ns=head.Position+md.Unit*(tonumber(flyVariables.cFlySpeed) or 1)
				local lk=ns+cam.CFrame.LookVector
				head.CFrame=CFrame.new(ns,lk)
				goofyFLY.CFrame=head.CFrame
			end
		end)
	else
		goofyFLY=goofyFLY or InstanceNew("Part",workspace)
		goofyFLY.Size=Vector3.new(0.05,0.05,0.05)
		goofyFLY.Transparency=1
		goofyFLY.CanCollide=false
		if not goofyFLY:FindFirstChildOfClass("Weld") then
			local w=InstanceNew("Weld",goofyFLY) w.Part0=goofyFLY w.Part1=root w.C0=CFrame.new()
		end
		flyVariables.BG=flyVariables.BG or InstanceNew("BodyGyro",goofyFLY)
		flyVariables.BG.P=9e4
		flyVariables.BG.maxTorque=Vector3.new(9e9,9e9,9e9)
		flyVariables.BV=flyVariables.BV or InstanceNew("BodyVelocity",goofyFLY)
		flyVariables.BV.velocity=Vector3.zero
		flyVariables.BV.maxForce=Vector3.new(9e9,9e9,9e9)
		if NAmanage._state.mode=="fly" then if hum then hum.PlatformStand=true end else if hum then hum.PlatformStand=false end end
		if CFloop then pcall(function() CFloop:Disconnect() end) end
		if not flyVariables._stdLoop then
			flyVariables._stdLoop=true
			SpawnCall(function()
				while (NAmanage._state.mode=="fly" or NAmanage._state.mode=="vfly") do
					local cam=NAmanage._camera()
					if cam and FLYING and flyVariables.BV and flyVariables.BG then
						local mv=GetCustomMoveVector(); mv=Vector3.new(mv.X,mv.Y,-mv.Z)
						local has=mv.Magnitude>0 or CONTROL.Q~=0 or CONTROL.E~=0
						if has then
							SPEED=((NAmanage._state.mode=="vfly" and tonumber(flyVariables.vFlySpeed) or tonumber(flyVariables.flySpeed)) or 1)*50
						elseif SPEED~=0 then
							SPEED=0
						end
						if has then
							flyVariables.BV.velocity=((cam.CFrame.LookVector*mv.Z)+((cam.CFrame*CFrame.new(mv.X,(mv.Z+CONTROL.Q+CONTROL.E)*0.2,0).p)-cam.CFrame.p))*SPEED
							lCONTROL={Q=CONTROL.Q,E=CONTROL.E}
						elseif SPEED~=0 then
							flyVariables.BV.velocity=((cam.CFrame.LookVector*mv.Z)+((cam.CFrame*CFrame.new(mv.X,(mv.Z+lCONTROL.Q+lCONTROL.E)*0.2,0).p)-cam.CFrame.p))*SPEED
						else
							flyVariables.BV.velocity=Vector3.zero
						end
						flyVariables.BG.cframe=cam.CFrame
					elseif flyVariables.BV then
						flyVariables.BV.velocity=Vector3.zero
					end
					Wait()
				end
				if flyVariables.BG then pcall(function() flyVariables.BG:Destroy() end) end
				if flyVariables.BV then pcall(function() flyVariables.BV:Destroy() end) end
				flyVariables.BG=nil; flyVariables.BV=nil
				if hum then hum.PlatformStand=false end
				flyVariables._stdLoop=false
			end)
		end
	end
	FLYING=true
end

NAmanage._ensureForces=function()
	if NAmanage._state.mode=="none" then return end
	local char=getChar(); if not char then return end
	local hum=getHum(); if not hum then return end
	local root=getRoot(char); if not root then return end
	local cam=NAmanage._camera()
	if not goofyFLY or goofyFLY.Parent==nil then
		goofyFLY=InstanceNew("Part",workspace)
		goofyFLY.Size=Vector3.new(0.05,0.05,0.05)
		goofyFLY.Transparency=1
		goofyFLY.CanCollide=false
		goofyFLY.Anchored=(NAmanage._state.mode=="cfly")
		local head=getHead(char); if head then goofyFLY:PivotTo(head:GetPivot()) end
		if flyVariables._goofyAC then pcall(function() flyVariables._goofyAC:Disconnect() end) end
		flyVariables._goofyAC=goofyFLY.AncestryChanged:Connect(function(_,p) if not p then Defer(NAmanage._ensureForces) end end)
	end
	if NAmanage._state.mode=="tfly" then
		NAmanage._ensureWeldTarget()
		if not flyVariables.TFpos or flyVariables.TFpos.Parent~=goofyFLY then
			flyVariables.TFpos=InstanceNew("BodyPosition",goofyFLY)
			flyVariables.TFpos.position=goofyFLY.Position
		end
		if not flyVariables.TFgyro or flyVariables.TFgyro.Parent~=goofyFLY then
			flyVariables.TFgyro=InstanceNew("BodyGyro",goofyFLY)
			flyVariables.TFgyro.cframe=(cam and cam.CFrame) or CFrame.new()
		end
		if FLYING then
			flyVariables.TFpos.maxForce=Vector3.new(math.huge,math.huge,math.huge)
			flyVariables.TFgyro.maxTorque=Vector3.new(9e9,9e9,9e9)
		else
			flyVariables.TFpos.maxForce=Vector3.new(0,0,0)
			flyVariables.TFgyro.maxTorque=Vector3.new(0,0,0)
		end
	elseif NAmanage._state.mode=="cfly" then
		goofyFLY.Anchored=true
		local head=getHead(char)
		if head and FLYING and not head.Anchored then head.Anchored=true end
	else
		NAmanage._ensureWeldTarget()
		if not flyVariables.BG or flyVariables.BG.Parent~=goofyFLY then
			flyVariables.BG=InstanceNew("BodyGyro",goofyFLY)
			flyVariables.BG.P=9e4
		end
		if not flyVariables.BV or flyVariables.BV.Parent~=goofyFLY then
			flyVariables.BV=InstanceNew("BodyVelocity",goofyFLY)
			flyVariables.BV.velocity=Vector3.zero
		end
		if cam then flyVariables.BG.cframe=cam.CFrame end
		flyVariables.BG.maxTorque=FLYING and Vector3.new(9e9,9e9,9e9) or Vector3.new(0,0,0)
		flyVariables.BV.maxForce=FLYING and Vector3.new(9e9,9e9,9e9) or Vector3.new(0,0,0)
		if NAmanage._state.mode=="fly" then hum.PlatformStand=FLYING else hum.PlatformStand=false end
	end
	if not flyVariables.qeDownConn or flyVariables.qeDownConn.Connected==false then
		if flyVariables.qeDownConn then pcall(function() flyVariables.qeDownConn:Disconnect() end) end
		flyVariables.qeDownConn=mouse.KeyDown:Connect(function(k)
			k=Lower(k or "")
			if k=="q" then
				local sp=(NAmanage._state.mode=="vfly" and tonumber(flyVariables.vFlySpeed) or tonumber(flyVariables.flySpeed) or 1)
				CONTROL.Q=-sp*2
			elseif k=="e" then
				local sp=(NAmanage._state.mode=="vfly" and tonumber(flyVariables.vFlySpeed) or tonumber(flyVariables.flySpeed) or 1)
				CONTROL.E=sp*2
			end
		end)
	end
	if not flyVariables.qeUpConn or flyVariables.qeUpConn.Connected==false then
		if flyVariables.qeUpConn then pcall(function() flyVariables.qeUpConn:Disconnect() end) end
		flyVariables.qeUpConn=mouse.KeyUp:Connect(function(k)
			k=Lower(k or "")
			if k=="q" then CONTROL.Q=0 elseif k=="e" then CONTROL.E=0 end
		end)
	end
end

NAmanage._ensureLoops=function()
	if NAmanage._state.mode=="tfly" then
		if not flyVariables._tflyLoop then
			flyVariables._tflyLoop=true
			Spawn(function()
				while NAmanage._state.mode=="tfly" do
					if not goofyFLY or not flyVariables.TFpos or not flyVariables.TFgyro or goofyFLY.Parent==nil or flyVariables.TFpos.Parent~=goofyFLY or flyVariables.TFgyro.Parent~=goofyFLY then
						NAmanage._ensureForces()
						Wait()
					else
						if FLYING then
							local cam=workspace.CurrentCamera
							local sp=tonumber(flyVariables.TflySpeed) or 1
							local mv=GetCustomMoveVector(); mv=Vector3.new(mv.X,mv.Y,-mv.Z)
							local np=flyVariables.TFgyro.cframe-flyVariables.TFgyro.cframe.p+flyVariables.TFpos.position
							if mv.Magnitude>0 then
								np=np+(cam.CFrame.RightVector*mv.X*sp)
								np=np+(cam.CFrame.LookVector*mv.Z*sp)
							end
							np=np+(cam.CFrame.UpVector*(CONTROL.E+CONTROL.Q)*sp)
							pcall(function()
								flyVariables.TFpos.position=np.p
								flyVariables.TFgyro.cframe=cam.CFrame
							end)
						end
					end
					Wait()
				end
				flyVariables._tflyLoop=false
			end)
		end
	elseif NAmanage._state.mode=="fly" or NAmanage._state.mode=="vfly" then
		if not flyVariables._stdLoop then
			flyVariables._stdLoop=true
			SpawnCall(function()
				while NAmanage._state.mode=="fly" or NAmanage._state.mode=="vfly" do
					if not goofyFLY or not flyVariables.BG or not flyVariables.BV or goofyFLY.Parent==nil or flyVariables.BG.Parent~=goofyFLY or flyVariables.BV.Parent~=goofyFLY then
						NAmanage._ensureForces()
						Wait()
					else
						if FLYING then
							local cam=workspace.CurrentCamera
							local mv=GetCustomMoveVector(); mv=Vector3.new(mv.X,mv.Y,-mv.Z)
							local has=mv.Magnitude>0 or CONTROL.Q~=0 or CONTROL.E~=0
							if has then
								SPEED=((NAmanage._state.mode=="vfly" and tonumber(flyVariables.vFlySpeed) or tonumber(flyVariables.flySpeed)) or 1)*50
							elseif SPEED~=0 then
								SPEED=0
							end
							if has then
								pcall(function()
									flyVariables.BV.velocity=((cam.CFrame.LookVector*mv.Z)+((cam.CFrame*CFrame.new(mv.X,(mv.Z+CONTROL.Q+CONTROL.E)*0.2,0).p)-cam.CFrame.p))*SPEED
									flyVariables.BG.cframe=cam.CFrame
								end)
								lCONTROL={Q=CONTROL.Q,E=CONTROL.E}
							elseif SPEED~=0 then
								pcall(function()
									flyVariables.BV.velocity=((cam.CFrame.LookVector*mv.Z)+((cam.CFrame*CFrame.new(mv.X,(mv.Z+lCONTROL.Q+lCONTROL.E)*0.2,0).p)-cam.CFrame.p))*SPEED
									flyVariables.BG.cframe=cam.CFrame
								end)
							else
								pcall(function()
									flyVariables.BV.velocity=Vector3.zero
									flyVariables.BG.cframe=cam.CFrame
								end)
							end
						else
							if flyVariables.BV then pcall(function() flyVariables.BV.velocity=Vector3.zero end) end
						end
					end
					Wait()
				end
				flyVariables._stdLoop=false
			end)
		end
	elseif NAmanage._state.mode=="cfly" then
		if not CFloop or CFloop.Connected==false then
			if CFloop then pcall(function() CFloop:Disconnect() end) end
			CFloop=RunService.RenderStepped:Connect(function()
				if NAmanage._state.mode~="cfly" or not FLYING then return end
				NAmanage._ensureForces()
				local head=getHead(getChar())
				if not head then return end
				local cam=workspace.CurrentCamera
				local mv=GetCustomMoveVector()
				local vertical=(CONTROL.E+CONTROL.Q)
				local full=Vector3.new(mv.X,vertical,-mv.Z)
				local md=(cam.CFrame.RightVector*full.X)+(cam.CFrame.UpVector*full.Y)+(cam.CFrame.LookVector*full.Z)
				if md.Magnitude>0 then
					local ns=head.Position+md.Unit*(tonumber(flyVariables.cFlySpeed) or 1)
					local lk=ns+cam.CFrame.LookVector
					head.CFrame=CFrame.new(ns,lk)
					if goofyFLY then goofyFLY.CFrame=head.CFrame end
				end
			end)
		end
	end
end

NAmanage._ensureWeldTarget=function()
	if flyVariables._weldLoopConn then return end
	flyVariables._weldLoopConn=RunService.Heartbeat:Connect(function()
		if NAmanage._state.mode=="none" or NAmanage._state.mode=="cfly" then return end
		local char=getChar(); if not char then return end
		local root=getRoot(char); if not root then return end
		if not goofyFLY or goofyFLY.Parent==nil then
			goofyFLY=InstanceNew("Part",workspace)
			goofyFLY.Size=Vector3.new(0.05,0.05,0.05)
			goofyFLY.Transparency=1
			goofyFLY.CanCollide=false
			goofyFLY.Anchored=false
			local head=getHead(char); if head then goofyFLY:PivotTo(head:GetPivot()) end
		end
		local w=goofyFLY:FindFirstChildOfClass("Weld")
		if not w or w.Parent~=goofyFLY then
			if w then pcall(function() w:Destroy() end) end
			w=InstanceNew("Weld",goofyFLY)
		end
		if (not w.Part0) or w.Part0~=goofyFLY or w.Part0.Parent==nil then pcall(function() w.Part0=goofyFLY end) end
		if (not w.Part1) or w.Part1~=root or w.Part1.Parent==nil or (not w.Part1:IsDescendantOf(char)) then pcall(function() w.Part1=root end) end
		pcall(function() w.C0=CFrame.new() end)
	end)
end

NAmanage.startWatcher=function()
	if flyVariables._watchConn then pcall(function() flyVariables._watchConn:Disconnect() end) end
	flyVariables._watchConn=RunService.Heartbeat:Connect(function()
		if flyVariables.flyEnabled or flyVariables.vFlyEnabled or flyVariables.cFlyEnabled or flyVariables.TFlyEnabled then
			local desired="none"
			if flyVariables.cFlyEnabled then desired="cfly"
			elseif flyVariables.TFlyEnabled then desired="tfly"
			elseif flyVariables.vFlyEnabled then desired="vfly"
			elseif flyVariables.flyEnabled then desired="fly" end
			if NAmanage._state.mode=="none" and desired~="none" then
				NAmanage._state.mode=desired
			end
			NAmanage._ensureWeldTarget()
			NAmanage._ensureForces()
			NAmanage._ensureLoops()
		end
	end)
	NAmanage._bindCameraWatch()
end

NAmanage._forceEnableFlags = function(mode)
	flyVariables.flyEnabled=(mode=="fly")
	flyVariables.vFlyEnabled=(mode=="vfly")
	flyVariables.cFlyEnabled=(mode=="cfly")
	flyVariables.TFlyEnabled=(mode=="tfly")
end

NAmanage._applyMode = function(mode, resume)
	if CFloop then pcall(function() CFloop:Disconnect() end) end
	CFloop=nil
	NAmanage._forceEnableFlags(mode)
	NAmanage._state.mode=mode
	if mode=="cfly" then
		NAmanage.sFLY(false,true,false)
	elseif mode=="tfly" then
		NAmanage.sFLY(false,false,true)
	elseif mode=="vfly" then
		NAmanage.sFLY(true,false,false)
	else
		NAmanage.sFLY(false,false,false)
	end
	if resume then
		NAmanage.resumeCurrent()
	else
		NAmanage.pauseCurrent()
	end
	NAmanage._ensureMobileFlyUI(mode)
	NAmanage.startWatcher()
	NAmanage._bindCameraWatch()
end

NAmanage.activateMode = function(mode)
	NAmanage._state.mode=mode
	NAmanage._forceEnableFlags(mode)
	local char=getChar()
	local root=char and getRoot(char) or nil
	local hum=char and getHum(char) or nil
	if char and root and hum then
		NAmanage._applyMode(mode,true)
		return
	end
	NAmanage._persist.lastMode=mode
	NAmanage._persist.resumeAfterSpawn=true
	if NAlib.isConnected("fly_pending_char") then
		NAlib.disconnect("fly_pending_char")
	end
	NAlib.connect("fly_pending_char", Players.LocalPlayer.CharacterAdded:Connect(function()
		Spawn(function()
			local t=0
			while t<5 and (not getChar() or not getRoot(getChar()) or not getHum()) do
				t+=(Wait() or 0.03)
			end
			NAmanage._applyMode(mode,true)
			NAmanage._persist.resumeAfterSpawn=false
			NAlib.disconnect("fly_pending_char")
		end)
	end))
end

NAmanage.keyToggle=function(mode)
	if NAmanage._state.mode~=mode then return end
	if not NAmanage._modeEnabled(mode) then return end
	if FLYING then NAmanage.pauseCurrent() else NAmanage.resumeCurrent() end
end

NAmanage.toggleFly=function()
	if not flyVariables.flyEnabled then
		NAmanage.activateMode("fly")
	else
		if NAmanage._state.mode~="fly" then
			NAmanage.activateMode("fly")
		else
			if FLYING then NAmanage.pauseCurrent() else NAmanage.resumeCurrent() end
		end
	end
end

NAmanage.toggleVFly=function()
	if not flyVariables.vFlyEnabled then
		NAmanage.activateMode("vfly")
	else
		if NAmanage._state.mode~="vfly" then
			NAmanage.activateMode("vfly")
		else
			if FLYING then NAmanage.pauseCurrent() else NAmanage.resumeCurrent() end
		end
	end
end

NAmanage.toggleCFly=function()
	if not flyVariables.cFlyEnabled then
		NAmanage.activateMode("cfly")
	else
		if NAmanage._state.mode~="cfly" then
			NAmanage.activateMode("cfly")
		else
			if FLYING then NAmanage.pauseCurrent() else NAmanage.resumeCurrent() end
		end
	end
end

NAmanage.toggleTFly=function()
	if not flyVariables.TFlyEnabled then
		NAmanage.activateMode("tfly")
	else
		if NAmanage._state.mode~="tfly" then
			NAmanage.activateMode("tfly")
		else
			if FLYING then NAmanage.pauseCurrent() else NAmanage.resumeCurrent() end
		end
	end
end

NAmanage.connectFlyKey=function()
	if flyVariables.keybindConn then flyVariables.keybindConn:Disconnect() end
	flyVariables.keybindConn=mouse.KeyDown:Connect(function(KEY)
		if Lower(KEY)==Lower(flyVariables.toggleKey) then
			NAmanage.keyToggle("fly")
		end
	end)
end

NAmanage.connectVFlyKey=function()
	if flyVariables.vKeybindConn then flyVariables.vKeybindConn:Disconnect() end
	flyVariables.vKeybindConn=mouse.KeyDown:Connect(function(KEY)
		if Lower(KEY)==Lower(flyVariables.vToggleKey) then
			NAmanage.keyToggle("vfly")
		end
	end)
end

NAmanage.connectCFlyKey=function()
	if flyVariables.cKeybindConn then flyVariables.cKeybindConn:Disconnect() end
	flyVariables.cKeybindConn=mouse.KeyDown:Connect(function(KEY)
		if Lower(KEY)==Lower(flyVariables.cToggleKey) then
			NAmanage.keyToggle("cfly")
		end
	end)
end

NAmanage.connectTFlyKey=function()
	if flyVariables.tflyKeyConn then flyVariables.tflyKeyConn:Disconnect() end
	flyVariables.tflyKeyConn=mouse.KeyDown:Connect(function(KEY)
		if Lower(KEY)==Lower(flyVariables.tflyToggleKey) then
			NAmanage.keyToggle("tfly")
		end
	end)
end

NAmanage.readAliasFile = function()
	if FileSupport and isfile(NAfiles.NAALIASPATH) then
		local success, data = NACaller(function()
			return HttpService:JSONDecode(readfile(NAfiles.NAALIASPATH))
		end)
		if success and type(data) == "table" then
			return data
		end
	end
	return {}
end

NAmanage.loadAliases = function()
	local aliasMap = NAmanage.readAliasFile()
	for alias, original in pairs(aliasMap) do
		if type(alias) == "string" and type(original) == "string" then
			local aliasLower = alias:lower()
			local originalLower = original:lower()
			local command = cmds.Commands[originalLower]
			if command then
				cmds.Aliases[aliasLower] = {command[1], command[2], command[3]}
				cmds.NASAVEDALIASES[aliasLower] = originalLower
			end
		end
	end
end

NAmanage.loadButtonIDS = function()
	if not FileSupport then
		NAUserButtons = NAUserButtons or {}
		return true
	end

	local path = NAfiles.NAUSERBUTTONSPATH

	if not (isfile and isfile(path)) then
		local okCreate, createErr = pcall(function()
			writefile(path, HttpService:JSONEncode({}))
		end)
		if not okCreate then
			NAmanage.loaderWarn('UserButtons', 'failed to create storage: '..tostring(createErr))
			return false
		end
	end

	local okRead, raw = pcall(readfile, path)
	if not okRead or type(raw) ~= "string" then
		NAmanage.loaderWarn('UserButtons', 'failed to read storage: '..tostring(raw))
		return false
	end

	local okDecode, decoded = pcall(function()
		return HttpService:JSONDecode(raw)
	end)
	if not okDecode or type(decoded) ~= "table" then
		NAmanage.loaderWarn('UserButtons', 'invalid storage data; resetting')
		NAUserButtons = {}
		local okReset, resetErr = pcall(function()
			writefile(path, HttpService:JSONEncode(NAUserButtons))
		end)
		if not okReset then
			NAmanage.loaderWarn('UserButtons', 'failed to reset storage: '..tostring(resetErr))
		end
		return false
	end

	NAUserButtons = decoded
	return true
end

NAmanage.AutoExecSave=function(data, context)
	if not FileSupport then return true end
	local ok, err = pcall(function()
		writefile(NAfiles.NAAUTOEXECPATH, HttpService:JSONEncode(data))
	end)
	if not ok then
		if context == 'loader' then
			NAmanage.loaderWarn('AutoExec', 'failed to update storage: '..tostring(err))
		else
			warn("[NA] AutoExec save failed: "..tostring(err))
		end
	end
	return ok
end

NAmanage.loadAutoExec = function()
	local currentData = NAEXECDATA or { commands = {}, args = {} }
	local path = NAfiles.NAAUTOEXECPATH

	if not FileSupport then
		NAEXECDATA = currentData
		return true
	end

	if not (isfile and isfile(path)) then
		local okCreate, createErr = pcall(function()
			writefile(path, HttpService:JSONEncode({ commands = {}, args = {} }))
		end)
		if not okCreate then
			NAmanage.loaderWarn('AutoExec', 'failed to create storage: '..tostring(createErr))
			return false
		end
	end

	local okRead, raw = pcall(readfile, path)
	if not okRead or type(raw) ~= 'string' then
		NAmanage.loaderWarn('AutoExec', 'failed to read storage: '..tostring(raw))
		return false
	end

	local okDecode, decoded = pcall(function()
		return HttpService:JSONDecode(raw)
	end)
	if not okDecode or type(decoded) ~= 'table' then
		NAmanage.loaderWarn('AutoExec', 'failed to decode storage; keeping previous data')
		return false
	end

	if decoded.commands == nil and next(decoded) then
		decoded = { commands = decoded, args = {} }
	end

	local sourceCommands = decoded.commands
	if type(sourceCommands) ~= 'table' then
		sourceCommands = {}
	end

	local sourceArgs = decoded.args
	if type(sourceArgs) ~= 'table' then
		sourceArgs = {}
	end

	local cleaned, cleanedArgs, seen = {}, {}, {}
	local modified = false

	for _, storedName in ipairs(sourceCommands) do
		local base = NAmanage.resolveCommandName(storedName)
		if base and NAStuff.AutoExecBlockedCommands[base] then
			modified = true
		else
			local key = base or storedName
			local storedArgs = sourceArgs[storedName] or (base and sourceArgs[base]) or ''

			if not seen[key] then
				seen[key] = true
				cleaned[#cleaned+1] = key
				cleanedArgs[key] = storedArgs
				if base and base ~= storedName then
					modified = true
				end
			else
				modified = true
			end
		end
	end
	if #cleaned ~= #sourceCommands then
		modified = true
	end

	local newData = { commands = cleaned, args = cleanedArgs }

	if modified then
		NAmanage.AutoExecSave(newData, 'loader')
	end

	NAEXECDATA = newData
	return true
end

NAmanage.LoadPlugins = function()
	if not CustomFunctionSupport then
		return true
	end

	local pluginDir = NAfiles.NAPLUGINFILEPATH
	if not (isfolder and isfolder(pluginDir)) then
		local ok, err = pcall(makefolder, pluginDir)
		if not ok then
			NAmanage.loaderWarn('Plugins', 'failed to ensure folder: '..tostring(err))
			return false
		end
	end

	local function formatInfo(aliases, argsHint)
		local main = aliases[1]
		local extras = {}
		for i = 2, #aliases do
			Insert(extras, aliases[i])
		end
		local formatted = main
		if argsHint and argsHint ~= "" then
			formatted = formatted.." "..argsHint
		end
		if #extras > 0 then
			formatted = formatted.." ("..Concat(extras, ", ")..")"
		end
		return formatted
	end

	local function splitArgs(line)
		local out, buf, quote = {}, "", nil
		for i = 1, #line do
			local ch = Sub(line, i, i)
			if quote then
				if ch == quote then
					quote = nil
				else
					buf = buf..ch
				end
			else
				if ch == "'" or ch == '"' then
					quote = ch
				elseif ch == " " or ch == "\t" then
					if #buf > 0 then out[#out+1] = buf; buf = "" end
				else
					buf = buf..ch
				end
			end
		end
		if #buf > 0 then out[#out+1] = buf end
		return out
	end

	local loadedSummaries = {}
	local okList, files = pcall(listfiles, pluginDir)
	if not okList or type(files) ~= 'table' then
		local errMsg = okList and 'invalid directory listing' or tostring(files)
		NAmanage.loaderWarn('Plugins', 'failed to enumerate: '..errMsg)
		return false
	end

	for _, file in ipairs(files) do
		if Lower(file):match("%.na$") then
			local success, content = NACaller(readfile, file)
			if success and content then
				local func, loadErr = loadstring(content)
				if func then
					local collectedPlugins = {}
					local proxyEnv = {}
					local baseEnv = getfenv()

					local function _dispatchRun(...)
						local runner = cmd and (cmd.run or cmd.Run)
						if not runner then return nil, "cmd.run not available" end
						local n = select("#", ...)
						local argv
						if n == 1 then
							local a = ...
							if type(a) == "table" then
								argv = a
							elseif type(a) == "string" then
								argv = splitArgs(a)
							else
								return nil, "invalid input to runCommand"
							end
						else
							argv = {}
							for i = 1, n do
								local v = select(i, ...)
								argv[#argv+1] = type(v) == "string" and v or tostring(v)
							end
						end
						local ok1, res1 = NACaller(runner, argv)
						if ok1 then return res1 end
						local ok2, res2 = NACaller(runner, Concat(argv, " "))
						if ok2 then return res2 end
						return nil, res2
					end

					proxyEnv.cmdRun = _dispatchRun
					proxyEnv.RunCommand = _dispatchRun
					proxyEnv.runCommand = _dispatchRun

					setmetatable(proxyEnv, {
						__index = function(_, k)
							if k == "loadstring" then
								local baseLoadstring = baseEnv.loadstring or loadstring
								return function(code, chunkname)
									local f, e = baseLoadstring(code, chunkname)
									if f then setfenv(f, proxyEnv) end
									return f, e
								end
							elseif k == "load" then
								local baseLoad = baseEnv.load
								if not baseLoad then return nil end
								return function(chunk, chunkname, mode, env)
									return baseLoad(chunk, chunkname, mode, env or proxyEnv)
								end
							end
							return baseEnv[k]
						end,
						__newindex = function(_, k, v)
							if k == "cmdPluginAdd" then
								if type(v) == "table" then
									if v[1] and type(v[1]) == "table" then
										for _, sub in ipairs(v) do
											Insert(collectedPlugins, sub)
										end
									else
										Insert(collectedPlugins, v)
									end
								end
							else
								rawset(baseEnv, k, v)
							end
						end
					})

					setfenv(func, proxyEnv)

					local ok, execErr = NACaller(func)
					if ok then
						local fileCommandNames = {}
						for _, plugin in ipairs(collectedPlugins) do
							local aliases = plugin.Aliases
							local handler = plugin.Function
							if type(aliases) == "table" and type(handler) == "function" then
								local argsHint = plugin.ArgsHint or ""
								local formattedDisplay = formatInfo(aliases, argsHint)
								local info = { formattedDisplay, plugin.Info or "No description" }
								cmd.add(aliases, info, handler, plugin.RequiresArguments or false)
								Insert(fileCommandNames, aliases[1])
							else
								DoWindow("[Plugin Invalid] '"..file.."' is missing valid Aliases or Function")
							end
						end
						if #fileCommandNames > 0 then
							local fileName = file:match("[^\\/]+$") or file
							Insert(loadedSummaries, fileName.." ("..Concat(fileCommandNames, ", ")..")")
						end
					else
						DoWindow("[Plugin Error] '"..file.."' => "..tostring(execErr))
					end
				else
					DoWindow("[Plugin Load Error] '"..file.."': "..tostring(loadErr))
				end
			else
				DoWindow("[Plugin Read Error] Failed to read '"..file.."'")
			end
		end
	end

	if #loadedSummaries > 0 then
		DoNotif("Loaded plugins:\n\n"..Concat(loadedSummaries, "\n\n"), 5.7)
	end

	return true
end

NAmanage.InitPlugs=function()
	local lp = function(p)
		p = (p or ""):gsub("\\","/"):gsub("/+","/")
		return Lower(p:gsub("/+$",""))
	end
	local bn = function(p) return (p and p:match("[^\\/]+$")) or p end
	local jp = function(d, n) d = d or ""; return (#d > 0) and (d.."/"..n) or n end
	local mk = function(p) if p and #p > 0 and not isfolder(p) then makefolder(p) end end
	local isna = function(p) return lp(p):match("%.na$") ~= nil end
	local uniq = function(dir, fname)
		local name, ext = fname:match("^(.*)(%.[^%.]+)$"); name, ext = name or fname, ext or ""
		local try = jp(dir, fname); if not isfile(try) then return try end
		local n = 1
		while true do
			try = jp(dir, Format("%s (%d)%s", name, n, ext))
			if not isfile(try) then return try end
			n += 1
		end
	end
	local root = function()
		for _, c in ipairs({"", ".", "/"}) do
			local ok, t = pcall(listfiles, c)
			if ok and type(t) == "table" then return c end
		end
		return ""
	end

	local plugsDir = NAfiles.NAPLUGINFILEPATH
	local plugsNorm = lp(plugsDir)
	local plugsTail = plugsNorm:match("([^/]+/[^/]+)$") or plugsNorm
	local inPlugs = function(path)
		local p = lp(path)
		if p == plugsNorm then return true end
		if p:sub(1, #plugsNorm + 1) == (plugsNorm.."/") then return true end
		if p:find("/"..plugsTail.."/", 1, true) then return true end
		return false
	end

	local scan = function(startDir)
		local out = {}
		local function rec(dir)
			local ok, items = pcall(listfiles, dir)
			if not ok or type(items) ~= "table" then return end
			for _, p in ipairs(items) do
				local okd, isd = pcall(isfolder, p)
				if okd and isd then
					if not inPlugs(p) then rec(p) end
				else
					if isna(p) and not inPlugs(p) then Insert(out, p) end
				end
			end
		end
		rec(startDir)
		return out
	end

	cmd.add(
		{"addallplugins","addplugins","aap","aaplugs"},
		{"addallplugins","Move all .na files from workspace into Nameless-Admin/Plugins and load them"},
		function()
			mk(plugsDir)
			local ws = root()
			local found = scan(ws)
			local moved, errs = {}, 0
			for _, src in ipairs(found) do
				local okR, data = pcall(readfile, src)
				if okR and data then
					local dst = uniq(plugsDir, bn(src))
					local okW = pcall(writefile, dst, data)
					if okW and delfile and pcall(delfile, src) then
						Insert(moved, bn(dst))
					else
						errs += 1
					end
				else
					errs += 1
				end
			end
			if #moved > 0 then
				DoNotif("Moved "..#moved.." plugin file(s):\n\n"..Concat(moved, "\n"), 4.5)
				if NAmanage and NAmanage.LoadPlugins then NAmanage.LoadPlugins() end
			else
				DoNotif((errs>0) and ("No plugins moved ("..errs.." error(s))") or "No .na files found outside Plugins", 3)
			end
		end
	)

	cmd.add(
		{"addplugin","addplug","ap","aplug"},
		{"addplugin","Move one .na from workspace into Nameless-Admin/Plugins and load it"},
		function(...)
			mk(plugsDir)
			local query = tostring((...) or ""):lower()
			local ws = root()
			local all = scan(ws) -- already excludes anything under Plugins
			if #all == 0 then DoNotif("No .na files found outside Plugins",3); return end

			local function moveOne(path)
				local file = bn(path)
				local okR, data = pcall(readfile, path)
				if not okR or not data then DoNotif("Failed to read "..file,3); return end
				local dst = uniq(plugsDir, file)
				local okW = pcall(writefile, dst, data)
				if not okW then DoNotif("Failed to write "..file,3); return end
				if not (delfile and pcall(delfile, path)) then DoNotif("Wrote but couldn't delete source "..file,3); return end
				DoNotif("Moved plugin "..file,3)
				if NAmanage and NAmanage.LoadPlugins then NAmanage.LoadPlugins() end
			end

			if #query > 0 then
				local hits = {}
				for _, p in ipairs(all) do
					local base = bn(p):lower()
					if base == query or base:find(query, 1, true) then Insert(hits, p) end
				end
				if #hits == 1 then moveOne(hits[1]); return end
				if #hits == 0 then DoNotif("No match for '"..query.."'",3); return end
				local btns = {}
				for _, p in ipairs(hits) do
					local file = bn(p)
					Insert(btns, { Text = file, Callback = function() moveOne(p) end })
				end
				local show = Window or DoWindow
				if show then show({Title = "Select Plugin", Buttons = btns}) else DoNotif("Multiple matches; refine name",3) end
				return
			end

			local btns = {}
			for _, p in ipairs(all) do
				local file = bn(p)
				Insert(btns, { Text = file, Callback = function() moveOne(p) end })
			end
			local show = Window or DoWindow
			if show then show({Title = "Add Plugin", Buttons = btns}) else DoNotif("UI not available",3) end
		end
	)

	cmd.add(
		{"reloadplugin","relplug","rp"},
		{"reloadplugin [name]","Reload plugin files (reloads all if no name provided)"},
		function(...)
			if not CustomFunctionSupport or not (NAmanage and NAmanage.LoadPlugins) then
				DoNotif("Plugin loader unavailable",3)
				return
			end
			local query = tostring((...) or ""):lower()
			local pluginDir = NAfiles.NAPLUGINFILEPATH
			if not isfolder or not isfolder(pluginDir) then
				DoNotif("Plugins folder not found",3)
				return
			end
			local ok, items = pcall(listfiles, pluginDir)
			if not ok or type(items) ~= "table" then
				DoNotif("Failed to list plugins",3)
				return
			end
			if query ~= "" then
				local matched = false
				for _, path in ipairs(items) do
					if Lower(path):match("%.na$") then
						local name = path:match("[^\\/]+$") or path
						if name and name:lower():find(query, 1, true) then
							matched = true
							break
						end
					end
				end
				if not matched then
					DoNotif("No plugin matched '"..query.."'",3)
					return
				end
			end
			if not NAmanage.LoadPlugins() then
				DoNotif("Failed to reload plugins",3)
			end
		end
	)

	cmd.add(
		{"removeplugin","rmplugin","delplugin","rmp"},
		{"removeplugin","Move a plugin file from Nameless-Admin/Plugins back to workspace"},
		function()
			if not isfolder(plugsDir) then DoNotif("Plugins folder not found",3); return end
			local ok, items = pcall(listfiles, plugsDir)
			if not ok or type(items) ~= "table" then DoNotif("Failed to list plugins",3); return end
			local btns = {}
			for _, p in ipairs(items) do
				if isna(p) then
					local file = bn(p)
					Insert(btns, {
						Text = file,
						Callback = function()
							local okR, data = pcall(readfile, p)
							if not okR or not data then DoNotif("Failed to read "..file,3); return end
							local dst = uniq("", file)
							local okW = pcall(writefile, dst, data)
							if okW and delfile and pcall(delfile, p) then
								DoNotif("Moved "..file.." to workspace",3)
							else
								DoNotif("Failed to move "..file,3)
							end
						end
					})
				end
			end
			if #btns == 0 then DoNotif("No plugins found in Plugins folder",3); return end
			local show = Window or DoWindow
			if show then show({Title = "Move Plugin to Workspace", Buttons = btns}) else DoNotif("Window UI not available",3) end
		end
	)

	cmd.add(
		{"removeallplugins","rmaplugins","clearplugins","rmap","rmaplugs"},
		{"removeallplugins","Move all plugins from Nameless-Admin/Plugins back to workspace"},
		function()
			if not isfolder(plugsDir) then DoNotif("Plugins folder not found",3); return end
			local ok, items = pcall(listfiles, plugsDir)
			if not ok or type(items) ~= "table" then DoNotif("Failed to list plugins",3); return end
			local moved, errs = {}, 0
			for _, p in ipairs(items) do
				if isna(p) then
					local file = bn(p)
					local okR, data = pcall(readfile, p)
					if okR and data then
						local dst = uniq("", file)
						local okW = pcall(writefile, dst, data)
						if okW and delfile and pcall(delfile, p) then
							Insert(moved, file)
						else
							errs += 1
						end
					else
						errs += 1
					end
				end
			end
			if #moved > 0 then
				DoNotif("Moved "..#moved.." plugin file(s) to workspace:\n\n"..Concat(moved, "\n"), 4.5)
			else
				DoNotif((errs>0) and ("No plugin files moved ("..errs.." error(s))") or "No plugins found",3)
			end
			if NAmanage and NAmanage.LoadPlugins then NAmanage.LoadPlugins() end
		end
	)
end

NAmanage.SaveWaypoints = function()
	if not FileSupport then return end

	local path = NAmanage.GetWPPath()

	if next(Waypoints) then
		writefile(path, HttpService:JSONEncode(Waypoints))
	else
		if delfile and isfile(path) then
			pcall(delfile, path)
		elseif isfile(path) then
			writefile(path, "{}")
		end
	end
end

NAmanage.LogJoinLeave = function(message)
	if not FileSupport or not appendfile or not JoinLeaveConfig.SaveLog then return end

	local logPath = NAfiles.NAJOINLEAVELOG
	local timestamp = os.date("[%Y-%m-%d %H:%M:%S]")

	local logMessage = Format(
		"%s %s | Game: %s | PlaceId: %s | GameId: %s | JobId: %s\n",
		timestamp,
		message,
		placeName() or "unknown",
		tostring(PlaceId),
		tostring(GameId),
		tostring(JobId)
	)

	if isfile(logPath) then
		appendfile(logPath, logMessage)
	else
		writefile(logPath, logMessage)
	end

end

NAmanage.RenderUserButtons = function()
	local screenGui = NAmanage.waitForScreenGui(5)
	if not screenGui then
		NAmanage.loaderWarn('RenderUserButtons', 'aborted: interface not ready')
		return false
	end
	if NAmanage._renderUserButtonsRunning then
		return true
	end
	NAmanage._renderUserButtonsRunning = true

	local success, err = pcall(function()
		NAStuff.NASCREENGUI = screenGui
		if NAStuff.KeybindConnection then
			NAStuff.KeybindConnection:Disconnect()
			NAStuff.KeybindConnection = nil
		end
		for _, btn in pairs(UserButtonGuiList) do
			btn:Destroy()
		end
		table.clear(UserButtonGuiList)

		local UIS = UserInputService
		local SavedArgs       = {}
		local ActivePrompts   = {}
		local ActiveKeyBinding= {}
		local ActionBindings  = {}
		local tSize = 28
		local DOUBLE_CLICK_WINDOW = 0.35

		function ButtonInputPrompt(cmdName, cb)
			local gui = InstanceNew("ScreenGui")
			gui.IgnoreGuiInset = true
			gui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
			gui.Parent = screenGui

			local f = InstanceNew("Frame")
			f.Size = UDim2.new(0,260,0,140)
			f.Position = UDim2.new(0.5,-130,0.5,-70)
			f.BackgroundColor3 = Color3.fromRGB(30,30,30)
			f.BorderSizePixel = 0
			f.Parent = gui

			local u = InstanceNew("UICorner")
			u.CornerRadius = UDim.new(0.1,0)
			u.Parent = f

			local t = InstanceNew("TextLabel")
			t.Size = UDim2.new(1,-20,0,30)
			t.Position = UDim2.new(0,10,0,10)
			t.BackgroundTransparency = 1
			t.Text = "Arguments for: "..cmdName
			t.TextColor3 = Color3.fromRGB(255,255,255)
			t.Font = Enum.Font.GothamBold
			t.TextSize = 16
			t.TextWrapped = true
			t.Parent = f

			local tb = InstanceNew("TextBox")
			tb.Size = UDim2.new(1,-20,0,30)
			tb.Position = UDim2.new(0,10,0,50)
			tb.BackgroundColor3 = Color3.fromRGB(50,50,50)
			tb.TextColor3 = Color3.fromRGB(255,255,255)
			tb.PlaceholderText = "Type arguments here"
			tb.Text=""
			tb.TextSize = 16
			tb.Font = Enum.Font.Gotham
			tb.ClearTextOnFocus = false
			tb.Parent = f

			local s = InstanceNew("TextButton")
			s.Size = UDim2.new(0.5,-15,0,30)
			s.Position = UDim2.new(0,10,1,-40)
			s.BackgroundColor3 = Color3.fromRGB(0,170,255)
			s.Text = "Submit"
			s.TextColor3 = Color3.fromRGB(255,255,255)
			s.Font = Enum.Font.GothamBold
			s.TextSize = 14
			s.Parent = f

			local c = InstanceNew("TextButton")
			c.Size = UDim2.new(0.5,-15,0,30)
			c.Position = UDim2.new(0.5,5,1,-40)
			c.BackgroundColor3 = Color3.fromRGB(255,0,0)
			c.Text = "Cancel"
			c.TextColor3 = Color3.fromRGB(255,255,255)
			c.Font = Enum.Font.GothamBold
			c.TextSize = 14
			c.Parent = f

			MouseButtonFix(s, function()
				cb(tb.Text)
				ActivePrompts[cmdName] = nil
				gui:Destroy()
			end)
			MouseButtonFix(c, function()
				ActivePrompts[cmdName] = nil
				gui:Destroy()
			end)
			NAgui.draggerV2(f)
		end

		local total   = #NAUserButtons
		local totalW  = total * 110
		local screenWidth = math.max(screenGui.AbsoluteSize.X, 1)
		local startX  = 0.5 - (totalW/2)/screenWidth
		local spacing = 110
		local ON, OFF = Color3.fromRGB(0,170,0), Color3.fromRGB(30,30,30)

		local idx = 0
		for id, data in pairs(NAUserButtons) do
			local btn = InstanceNew("TextButton")
			btn.Name            = "NAUserButton_"..id
			btn.Text            = data.Label
			btn.Size            = UDim2.new(0,60, 0,60)
			btn.AnchorPoint     = Vector2.new(0.5,1)
			btn.Position        = data.Pos and UDim2.new(data.Pos[1], data.Pos[2], data.Pos[3], data.Pos[4]) or UDim2.new(startX + (spacing*idx)/screenWidth, 0, 0.9, 0)
			btn.Parent          = screenGui
			btn.BackgroundColor3= Color3.fromRGB(0,0,0)
			btn.TextColor3      = Color3.fromRGB(255,255,255)
			btn.TextScaled      = true
			btn.Font            = Enum.Font.GothamBold
			btn.BorderSizePixel = 0
			btn.ZIndex          = 9999
			btn.AutoButtonColor = true

			local btnCorner = InstanceNew("UICorner")
			btnCorner.CornerRadius = UDim.new(0.25,0)
			btnCorner.Parent       = btn
			NAgui.draggerV2(btn)

			btn.InputEnded:Connect(function(input)
				if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
					local p = btn.Position
					data.Pos = {p.X.Scale, p.X.Offset, p.Y.Scale, p.Y.Offset}
					if FileSupport then
						writefile(NAfiles.NAUSERBUTTONSPATH, HttpService:JSONEncode(NAUserButtons))
					end
				end
			end)

			local toggled     = false
			local saveEnabled = data.RunMode == "S"
			SavedArgs[id]     = data.Args or {}

			local cmd1      = data.Cmd1
			local cd1       = cmds.Commands[cmd1:lower()] or cmds.Aliases[cmd1:lower()]
			local needsArgs = cd1 and cd1[3]

			if needsArgs then
				local saveToggle = InstanceNew("TextButton")
				saveToggle.Size             = UDim2.new(0,tSize,0,tSize)
				saveToggle.AnchorPoint      = Vector2.new(1,1)
				saveToggle.Position         = UDim2.new(1,0,0,0)
				saveToggle.BackgroundColor3 = Color3.fromRGB(50,50,50)
				saveToggle.TextColor3       = Color3.fromRGB(255,255,255)
				saveToggle.TextScaled       = true
				saveToggle.Font             = Enum.Font.Gotham
				saveToggle.Text             = saveEnabled and "S" or "N"
				saveToggle.ZIndex           = 10000
				saveToggle.Parent           = btn

				local stCorner = InstanceNew("UICorner")
				stCorner.CornerRadius = UDim.new(0.5,0)
				stCorner.Parent       = saveToggle

				MouseButtonFix(saveToggle, function()
					saveEnabled = not saveEnabled
					saveToggle.Text = saveEnabled and "S" or "N"
					data.RunMode = saveEnabled and "S" or "N"
					if FileSupport then
						writefile(NAfiles.NAUSERBUTTONSPATH, HttpService:JSONEncode(NAUserButtons))
					end
				end)
			end

			local function runCmd(args)
				local toRun = (not toggled or not data.Cmd2) and data.Cmd1 or data.Cmd2
				local arr   = {toRun}
				if args then for _,v in ipairs(args) do Insert(arr, v) end end
				cmd.run(arr)
				if data.Cmd2 then
					toggled = not toggled
					btn.BackgroundColor3 = toggled and ON or OFF
				end
			end

			MouseButtonFix(btn, function()
				local now     = (not toggled or not data.Cmd2) and data.Cmd1 or data.Cmd2
				local nd      = cmds.Commands[now:lower()] or cmds.Aliases[now:lower()]
				local na      = nd and nd[3]
				if na then
					if saveEnabled and data.Args and #data.Args>0 then
						runCmd(data.Args)
					else
						if ActivePrompts[now] then return end
						ActivePrompts[now] = true
						ButtonInputPrompt(now, function(input)
							ActivePrompts[now] = nil
							local parsed = ParseArguments(input)
							if parsed then
								SavedArgs[id] = parsed
								data.Args     = parsed
								if FileSupport then
									writefile(NAfiles.NAUSERBUTTONSPATH, HttpService:JSONEncode(NAUserButtons))
								end
								runCmd(parsed)
							else
								runCmd(nil)
							end
						end)
					end
				else
					runCmd(nil)
				end
			end)

			if IsOnPC then
				local keyToggle = InstanceNew("TextButton")
				keyToggle.Size             = UDim2.new(0,tSize,0,tSize)
				keyToggle.AnchorPoint      = Vector2.new(0,1)
				keyToggle.Position         = UDim2.new(0,0,0,0)
				keyToggle.BackgroundColor3 = Color3.fromRGB(50,50,50)
				keyToggle.TextColor3       = Color3.fromRGB(255,255,255)
				keyToggle.TextScaled       = true
				keyToggle.Font             = Enum.Font.Gotham
				keyToggle.Text             = data.Keybind or "Key"
				keyToggle.ZIndex           = 10000
				keyToggle.Parent           = btn

				local ktCorner = InstanceNew("UICorner")
				ktCorner.CornerRadius = UDim.new(0.5,0)
				ktCorner.Parent       = keyToggle

				local lastClick = 0
				local bindConn

				MouseButtonFix(keyToggle, function()
					local now = os.clock()
					if lastClick > 0 and (now - lastClick) <= DOUBLE_CLICK_WINDOW then
						lastClick = 0
						if data.Keybind then ActionBindings[data.Keybind] = nil end
						data.Keybind = nil
						keyToggle.Text = "Key"
						if FileSupport then
							writefile(NAfiles.NAUSERBUTTONSPATH, HttpService:JSONEncode(NAUserButtons))
						end
						if bindConn then bindConn:Disconnect() bindConn = nil end
						ActiveKeyBinding[id] = nil
						return
					end
					lastClick = now
					if ActiveKeyBinding[id] then return end
					ActiveKeyBinding[id] = true
					keyToggle.Text = "..."
					bindConn = UIS.InputBegan:Connect(function(input, gp)
						if gp or not input.KeyCode then return end
						local old = data.Keybind
						if old then ActionBindings[old] = nil end
						local new = input.KeyCode.Name
						data.Keybind = new
						keyToggle.Text = new
						if FileSupport then
							writefile(NAfiles.NAUSERBUTTONSPATH, HttpService:JSONEncode(NAUserButtons))
						end
						ActionBindings[new] = function() runCmd(data.Args) end
						ActiveKeyBinding[id] = nil
						if bindConn then bindConn:Disconnect() bindConn = nil end
					end)
				end)

				if data.Keybind then
					ActionBindings[data.Keybind] = function() runCmd(data.Args) end
				end
			end

			Insert(UserButtonGuiList, btn)
			idx = idx + 1
		end

		if IsOnPC then
			NAStuff.KeybindConnection = UIS.InputBegan:Connect(function(input, gp)
				if gp or not input.KeyCode then return end
				local act = ActionBindings[input.KeyCode.Name]
				if act then act() end
			end)
		end
	end)

	NAmanage._renderUserButtonsRunning = nil

	if not success then
		error(err)
	end
	return true
end

local lp=Players.LocalPlayer

--[[ LIB FUNCTIONS ]]--
chatmsgshooks={}
Playerchats={}
local oldChat = false--TextChatService.ChatVersion == Enum.ChatVersion.LegacyChatService and ReplicatedStorage:FindFirstChild("DefaultChatSystemChatEvents") and  ReplicatedStorage.DefaultChatSystemChatEvents:FindFirstChild("SayMessageRequest")

if oldChat then
	NAlib.LocalPlayerChat=function(...)
		local args={...}
		if args[2] and args[2]~="All" then
			ReplicatedStorage.DefaultChatSystemChatEvents.SayMessageRequest:FireServer("/w "..args[2].." "..args[1] or "","All")
		else
			ReplicatedStorage.DefaultChatSystemChatEvents.SayMessageRequest:FireServer(args[1] or "","All")
		end
	end
else
	local RBXGeneral = nil
	NACaller(function()
		if TextChatService.CreateDefaultTextChannels then
			for i,v in pairs(TextChatService:GetDescendants()) do
				if v:IsA("TextChannel") and v.Name=="RBXGeneral" then
					if v:FindFirstChild(Players.LocalPlayer.Name) and v[Players.LocalPlayer.Name]:IsA("TextSource") then
						RBXGeneral = v
						break
					end
				end
			end
		end

		if not RBXGeneral then
			for i,v in pairs(TextChatService:GetDescendants()) do
				if v:IsA("TextChannel") then
					for index,player in pairs(Players:GetPlayers()) do
						if v:FindFirstChild(player.Name) and v[player.Name]:IsA("TextSource") and v[player.Name].CanSend then
							RBXGeneral = v
						else
							RBXGeneral = nil
							break
						end
					end
					if RBXGeneral then
						break
					end
				end
			end

			if not RBXGeneral then
				for i,v in pairs(TextChatService:GetDescendants()) do
					if v:IsA("TextChannel") then
						if v:FindFirstChild(Players.LocalPlayer.Name) and v[Players.LocalPlayer.Name]:IsA("TextSource") and v[Players.LocalPlayer.Name].CanSend then
							RBXGeneral = v
							break
						end
					end
				end
			end
			-- i have tried enough
			if not RBXGeneral then
				NAlib.LocalPlayerChat=function(...)
					NACaller(function()
						error("unable to get the chat system for the game")
					end)
				end
				return
			end
		end

		NAlib.LocalPlayerChat=function(...)
			local args={...}
			local sendto=RBXGeneral
			if args[2]~=nil and  args[2]~="All"  then
				if not Playerchats[args[2]] then
					for i,v in pairs(TextChatService:GetDescendants()) do
						if v:IsA("TextChannel") and Find(v.Name,"RBXWhisper:") then
							if v:FindFirstChild(args[2]) and v:FindFirstChild(Players.LocalPlayer.Name) then
								if v[Players.LocalPlayer.Name].CanSend==false then
									continue
								end
								sendto=v
								Playerchats[args[2]]=v
								break
							end
						end
					end
				else
					sendto=Playerchats[args[2]]
				end
				if sendto==RBXGeneral then
					chatmsgshooks[args[1]]={args[1],args}
					SpawnCall(function()
						RBXGeneral:SendAsync("/w @"..args[2])
					end)
					return "Hooking"
				end
			end
			sendto:SendAsync(args[1] or "")

		end
	end)

	if TextChatService:FindFirstChild("TextChannels") then
		TextChatService.TextChannels.ChildAdded:Connect(function(v)
			if  v:IsA("TextChannel") and Find(v.Name,"RBXWhisper:") then
				Wait(1)
				for id,va in pairs(chatmsgshooks) do
					if v:FindFirstChild(va[1]) and v:FindFirstChild(Players.LocalPlayer.Name) then
						if v[Players.LocalPlayer.Name].CanSend==false then
							continue
						end
						Playerchats[va[1]]=v
						chatmsgshooks[id]=nil
						NAlib.LocalPlayerChat(va[2])
					end
				end
			end
		end)
	end
end

NAlib.lpchat=NAlib.LocalPlayerChat

NAlib.find=function(t,v)	--mmmmmm
	for i,e in pairs(t) do
		if i==v or e==v then
			return i
		end
	end
	return nil
end

NAlib.parseText = function(text, watch, rPlr)
	local function FIIIX(str)
		local chatPrefix = str:match("^/(%a+)%s")
		if chatPrefix then
			str = str:gsub("^/%a+%s*", "")
		end
		return str
	end

	if not text then return nil end

	local prefix
	if rPlr then
		if isRelAdmin(rPlr) and isRelAdmin(Players.LocalPlayer) then
			return nil
		elseif not isRelAdmin(rPlr) then
			prefix = ";"
		else
			prefix = watch
		end
		watch = prefix
	else
		prefix = watch
	end

	text = FIIIX(text)

	if text:sub(1, #prefix) ~= prefix then
		return nil
	end

	text = text:sub(#prefix + 1)

	local commands = {}
	local position = 1
	local textLength = #text

	while position <= textLength do
		local nextSlash = text:find("\\", position, true)
		local segment = nextSlash and text:sub(position, nextSlash - 1) or text:sub(position)
		local trimmed = segment:gsub("^%s+", ""):gsub("%s+$", "")
		if #trimmed > 0 then
			local parsed = {}
			for arg in trimmed:gmatch("[^ ]+") do
				Insert(parsed, arg)
			end
			if #parsed > 0 then
				local cmdName = parsed[1]:lower()
				if LoadstringCommandAliases[cmdName] then
					local commandStart = (segment:find(parsed[1], 1, true) or 1) + #parsed[1]
					local afterCommand = segment:sub(commandStart + 1)
					local remainder = afterCommand:gsub("^%s+", "")
					if nextSlash then
						remainder = remainder.."\\"..text:sub(nextSlash + 1)
					end
					Insert(commands, {parsed[1], remainder})
					break
				end
				Insert(commands, parsed)
			end
		end
		if not nextSlash then
			break
		end
		position = nextSlash + 1
	end

	return commands
end

NAlib.parseCommand = function(text, rPlr)
	wrap(function()
		local prefix = rPlr and (isRelAdmin(rPlr) and not isRelAdmin(Players.LocalPlayer) and ";" or nil) or opt.prefix
		if not prefix then return end
		local commands = NAlib.parseText(text, prefix, rPlr)
		if not commands then return end
		for _, parsed in pairs(commands) do
			local args = {}
			for _, arg in pairs(parsed) do
				Insert(args, arg)
			end
			cmd.run(args)
		end
	end)
end

--prepare for annoying and unnecessary tool grip math
local rad=math.rad
local clamp=math.clamp
local tan=math.tan

--[[ COMMANDS ]]--

cmd.add({"url"}, {"url <link>", "Run the script using URL"}, function(...)
	local args = {...}
	local link = Concat(args, " ")

	if not link or link == "" then
		return DoNotif("no link provided", 2)
	end

	local success, result = NACaller(function()
		return game:HttpGet(link)
	end)

	if not success then return end

	local func = loadstring(result)
	if not func then return end

	Spawn(func)
end, true)

cmd.add({"loadstring", "ls", "lstring", "loads", "execute"}, {"loadstring <code> (ls, lstring, loads, execute)", "Run code using loadstring"}, function(...)
	local args = {...}
	local code = Concat(args, " ")

	if not code or code == "" then
		return DoNotif("no code provided", 2)
	end

	local func = loadstring(code)
	if not func then return end

	Spawn(func)
end, true)

NA_SHADER_EFFECT_NAMES = {
	"NAShaderBloom",
	"NAShaderTropic",
	"NAShaderSky",
	"NAShaderBlur",
	"NAShaderEfecto",
	"NAShaderInari",
	"NAShaderNormal",
	"NAShaderSunRays",
	"NAShaderSunset",
	"NAShaderTakayama",
}

NAmanage.NAremoveShaderEffects=function(lighting)
	for _, name in ipairs(NA_SHADER_EFFECT_NAMES) do
		local inst = lighting:FindFirstChild(name)
		if inst then
			inst:Destroy()
		end
	end
end

cmd.add({"shaders", "shader", "rtx", "hd"}, {"shaders (shader, rtx, hd)", "Enable a shader preset for Lighting"}, function()
	local lighting = Lighting or SafeGetService("Lighting")
	if not lighting then
		DoNotif("Lighting service unavailable", 3)
		return
	end

	if not NAmanage._shaderSettingsBackup then
		NAmanage._shaderSettingsBackup = {
			Brightness = lighting.Brightness;
			ColorShift_Bottom = lighting.ColorShift_Bottom;
			ColorShift_Top = lighting.ColorShift_Top;
			OutdoorAmbient = lighting.OutdoorAmbient;
			ClockTime = lighting.ClockTime;
			FogColor = lighting.FogColor;
			FogEnd = lighting.FogEnd;
			FogStart = lighting.FogStart;
			ExposureCompensation = lighting.ExposureCompensation;
			ShadowSoftness = lighting.ShadowSoftness;
			Ambient = lighting.Ambient;
		}
	end

	NAmanage.NAremoveShaderEffects(lighting)

	local function createEffect(className, name)
		local inst = InstanceNew(className)
		inst.Name = name
		inst.Parent = lighting
		return inst
	end

	local bloom = createEffect("BloomEffect", "NAShaderBloom")
	bloom.Intensity = 0.1
	bloom.Threshold = 0
	bloom.Size = 100

	local tropic = createEffect("Sky", "NAShaderTropic")
	tropic.SkyboxUp = "http://www.roblox.com/asset/?id=169210149"
	tropic.SkyboxLf = "http://www.roblox.com/asset/?id=169210133"
	tropic.SkyboxBk = "http://www.roblox.com/asset/?id=169210090"
	tropic.SkyboxFt = "http://www.roblox.com/asset/?id=169210121"
	tropic.StarCount = 100
	tropic.SkyboxDn = "http://www.roblox.com/asset/?id=169210108"
	tropic.SkyboxRt = "http://www.roblox.com/asset/?id=169210143"

	local shaderSky = createEffect("Sky", "NAShaderSky")
	shaderSky.SkyboxUp = "http://www.roblox.com/asset/?id=196263782"
	shaderSky.SkyboxLf = "http://www.roblox.com/asset/?id=196263721"
	shaderSky.SkyboxBk = "http://www.roblox.com/asset/?id=196263721"
	shaderSky.SkyboxFt = "http://www.roblox.com/asset/?id=196263721"
	shaderSky.CelestialBodiesShown = false
	shaderSky.SkyboxDn = "http://www.roblox.com/asset/?id=196263643"
	shaderSky.SkyboxRt = "http://www.roblox.com/asset/?id=196263721"

	local blur = createEffect("BlurEffect", "NAShaderBlur")
	blur.Size = 2

	local efecto = createEffect("BlurEffect", "NAShaderEfecto")
	efecto.Enabled = false
	efecto.Size = 2

	local inari = createEffect("ColorCorrectionEffect", "NAShaderInari")
	inari.Saturation = 0.05
	inari.TintColor = Color3.fromRGB(255, 224, 219)

	local normal = createEffect("ColorCorrectionEffect", "NAShaderNormal")
	normal.Enabled = false
	normal.Saturation = -0.2
	normal.TintColor = Color3.fromRGB(255, 232, 215)

	local sunRays = createEffect("SunRaysEffect", "NAShaderSunRays")
	sunRays.Intensity = 0.05

	local sunset = createEffect("Sky", "NAShaderSunset")
	sunset.SkyboxUp = "rbxassetid://323493360"
	sunset.SkyboxLf = "rbxassetid://323494252"
	sunset.SkyboxBk = "rbxassetid://323494035"
	sunset.SkyboxFt = "rbxassetid://323494130"
	sunset.SkyboxDn = "rbxassetid://323494368"
	sunset.SunAngularSize = 14
	sunset.SkyboxRt = "rbxassetid://323494067"

	local takayama = createEffect("ColorCorrectionEffect", "NAShaderTakayama")
	takayama.Enabled = false
	takayama.Saturation = -0.3
	takayama.Contrast = 0.1
	takayama.TintColor = Color3.fromRGB(235, 214, 204)

	lighting.Brightness = 2.14
	lighting.ColorShift_Bottom = Color3.fromRGB(11, 0, 20)
	lighting.ColorShift_Top = Color3.fromRGB(240, 127, 14)
	lighting.OutdoorAmbient = Color3.fromRGB(34, 0, 49)
	lighting.ClockTime = 6.7
	lighting.FogColor = Color3.fromRGB(94, 76, 106)
	lighting.FogEnd = 1000
	lighting.FogStart = 0
	lighting.ExposureCompensation = 0.24
	lighting.ShadowSoftness = 0
	lighting.Ambient = Color3.fromRGB(59, 33, 27)

	DoNotif("Shader preset applied.", 3)
end)

cmd.add({"unshaders", "shadersoff", "rtxoff"}, {"unshaders (shadersoff, rtxoff)", "Disable the shader preset and restore Lighting"}, function()
	local lighting = Lighting or SafeGetService("Lighting")
	if not lighting then
		DoNotif("Lighting service unavailable", 3)
		return
	end

	NAmanage.NAremoveShaderEffects(lighting)

	local backup = NAmanage._shaderSettingsBackup
	if backup then
		for prop, value in pairs(backup) do
			pcall(function()
				lighting[prop] = value
			end)
		end
		NAmanage._shaderSettingsBackup = nil
	end

	DoNotif("Shader preset removed.", 3)
end)

NAmanage.NAibtoolsVectorString=function(vec)
	return Format("Vector3.new(%s,%s,%s)", tostring(vec.X), tostring(vec.Y), tostring(vec.Z))
end

NAmanage.NAibtoolsCreateUI=function(state, actions)
	local gui = InstanceNew("ScreenGui")
	gui.Name = "iBToolsUI"
	NaProtectUI(gui)

	local frame = InstanceNew("Frame", gui)
	frame.Name = "Panel"
	frame.Size = UDim2.new(0, 240, 0, 260)
	frame.Position = UDim2.new(0.05, 0, 0.4, 0)
	frame.BackgroundColor3 = Color3.fromRGB(26, 26, 26)
	frame.BorderSizePixel = 0

	local frameCorner = InstanceNew("UICorner", frame)
	frameCorner.CornerRadius = UDim.new(0, 8)

	local header = InstanceNew("Frame", frame)
	header.Name = "Header"
	header.Size = UDim2.new(1, 0, 0, 36)
	header.BackgroundColor3 = Color3.fromRGB(38, 38, 38)
	header.BorderSizePixel = 0
	header.Active = true

	local title = InstanceNew("TextLabel", header)
	title.BackgroundTransparency = 1
	title.Font = Enum.Font.GothamSemibold
	title.TextSize = 16
	title.TextXAlignment = Enum.TextXAlignment.Left
	title.TextColor3 = Color3.fromRGB(255, 255, 255)
	title.Text = "iBuild Tools"
	title.Size = UDim2.new(1, -40, 1, 0)
	title.Position = UDim2.new(0, 10, 0, 0)

	local statusLabel = InstanceNew("TextLabel", frame)
	statusLabel.Name = "Status"
	statusLabel.BackgroundTransparency = 1
	statusLabel.Font = Enum.Font.Gotham
	statusLabel.TextSize = 14
	statusLabel.TextXAlignment = Enum.TextXAlignment.Left
	statusLabel.TextColor3 = Color3.fromRGB(200, 200, 200)
	statusLabel.Position = UDim2.new(0, 12, 0, 46)
	statusLabel.Size = UDim2.new(1, -24, 0, 20)
	statusLabel.Text = "Target: none"

	local buttonHolder = InstanceNew("Frame", frame)
	buttonHolder.BackgroundTransparency = 1
	buttonHolder.Position = UDim2.new(0, 12, 0, 72)
	buttonHolder.Size = UDim2.new(1, -24, 1, -84)

	local layout = InstanceNew("UIListLayout", buttonHolder)
	layout.Padding = UDim.new(0, 6)
	layout.FillDirection = Enum.FillDirection.Vertical
	layout.HorizontalAlignment = Enum.HorizontalAlignment.Center
	layout.SortOrder = Enum.SortOrder.LayoutOrder
	local DEFAULT_COLOR = Color3.fromRGB(52, 52, 52)
	local HOVER_COLOR = Color3.fromRGB(66, 66, 66)
	local ACTIVE_COLOR = Color3.fromRGB(80, 110, 255)

	local function makeButton(text)
		local btn = InstanceNew("TextButton", buttonHolder)
		btn.Name = text
		btn.Size = UDim2.new(1, 0, 0, 34)
		btn.BackgroundColor3 = DEFAULT_COLOR
		btn.BorderSizePixel = 0
		btn.AutoButtonColor = false
		btn.Font = Enum.Font.GothamSemibold
		btn.TextSize = 14
		btn.TextColor3 = Color3.fromRGB(255, 255, 255)
		btn.Text = text
		local corner = InstanceNew("UICorner", btn)
		corner.CornerRadius = UDim.new(0, 6)
		btn.MouseEnter:Connect(function()
			if btn.BackgroundColor3 ~= ACTIVE_COLOR then
				btn.BackgroundColor3 = HOVER_COLOR
			end
		end)
		btn.MouseLeave:Connect(function()
			if btn.BackgroundColor3 ~= ACTIVE_COLOR then
				btn.BackgroundColor3 = DEFAULT_COLOR
			end
		end)
		return btn
	end

	local modeButtons = {}

	local function refreshModeButtons()
		local selected = actions.getMode and actions.getMode() or nil
		for mode, btn in pairs(modeButtons) do
			if selected == mode then
				btn.BackgroundColor3 = ACTIVE_COLOR
			else
				btn.BackgroundColor3 = DEFAULT_COLOR
			end
		end
	end

	local function createModeButton(label, mode)
		local btn = makeButton(label)
		modeButtons[mode] = btn
		btn.MouseButton1Click:Connect(function()
			if actions.setMode then
				actions.setMode(mode)
			end
			refreshModeButtons()
		end)
		return btn
	end

	createModeButton("Delete", "delete")
	createModeButton("Toggle Anchor", "anchor")
	createModeButton("Toggle CanCollide", "collide")

	local undoButton = makeButton("Undo Delete")
	undoButton.MouseButton1Click:Connect(function()
		if actions.undo then
			actions.undo()
		end
	end)

	local copyButton = makeButton("Copy Delete Script")
	copyButton.MouseButton1Click:Connect(function()
		if actions.copy then
			actions.copy()
		end
	end)

	NAgui.dragger(frame, header)

	state.statusLabel = statusLabel
	state.frame = frame
	state.refreshModeButtons = refreshModeButtons
	refreshModeButtons()

	return gui
end

NAmanage.NAibtoolsCleanup=function(state)
	if not state then
		return
	end
	if state.connections then
		for _, conn in ipairs(state.connections) do
			if conn and conn.Disconnect then
				conn:Disconnect()
			end
		end
		table.clear(state.connections)
	end
	if state.highlight then
		pcall(function()
			state.highlight:Destroy()
		end)
		state.highlight = nil
	end
	if state.gui then
		pcall(function()
			state.gui:Destroy()
		end)
		state.gui = nil
	end
	state.statusLabel = nil
	state.frame = nil
	state.currentPart = nil
	state.refreshModeButtons = nil
end

cmd.add({"ibtools"}, {"ibtools", "Load the iBuild Tools helper tool"}, function()
	if not LocalPlayer then
		DoNotif("Local player not ready.", 3)
		return
	end

	local backpack = getBp()
	if not backpack then
		backpack = LocalPlayer:FindFirstChild("Backpack") or LocalPlayer:WaitForChild("Backpack", 3)
	end
	if not backpack then
		DoNotif("Backpack not available.", 3)
		return
	end

	local state = NAmanage._ibtools
	if state and state.tool and state.tool.Parent then
		DoNotif("iBTools is already loaded.", 3)
		return
	end

	local tool = InstanceNew("Tool", backpack)
	tool.Name = "iBTools"
	tool.RequiresHandle = false

	state = {
		tool = tool,
		history = {},
		saveHistory = {},
		connections = {},
		toolConnections = {},
		currentPart = nil,
		currentMode = "delete",
	}
	NAmanage._ibtools = state

	local function modeLabel()
		local mode = state.currentMode
		if not mode then
			return "none"
		end
		return mode
	end

	local function updateStatus(part)
		if not state.statusLabel then
			return
		end
		local targetText = "none"
		if part then
			if not part.Parent then
				targetText = part.Name.." (stored)"
			else
				local ok, fullName = pcall(part.GetFullName, part)
				targetText = ok and fullName or part.Name
			end
		end
		state.statusLabel.Text = Format("Mode: %s | Target: %s", modeLabel():upper(), targetText)
	end

	local function setTarget(part)
		if part and not part:IsA("BasePart") then
			part = nil
		end
		state.currentPart = part
		if state.highlight then
			state.highlight.Adornee = part
		end
		updateStatus(part)
	end

	local function onEquipped(mouse)
		NAmanage.NAibtoolsCleanup(state)

		local highlight = InstanceNew("SelectionBox")
		highlight.Name = "iBToolsSelection"
		highlight.LineThickness = 0.04
		highlight.Color3 = Color3.fromRGB(0, 170, 255)
		highlight.Adornee = nil
		highlight.Parent = workspace.CurrentCamera or workspace
		state.highlight = highlight

		local function undoLast()
			local record = table.remove(state.history)
			if not record then
				DoNotif("Nothing to undo.", 2)
				return
			end
			local part = record.part
			if part then
				part.Parent = record.parent
				if record.cframe then
					pcall(function()
						part.CFrame = record.cframe
					end)
				end
				setTarget(part)
				local saved = record.data
				if saved then
					for i = #state.saveHistory, 1, -1 do
						if state.saveHistory[i] == saved then
							table.remove(state.saveHistory, i)
							break
						end
					end
				end
				DoNotif("Restored '"..part.Name.."'", 2)
			end
		end

		local function copyScript()
			if #state.saveHistory == 0 then
				DoNotif("No deleted parts to export.", 3)
				return
			end
			local lines = {}
			for _, data in ipairs(state.saveHistory) do
				local pos = data.position
				local vec = NAmanage.NAibtoolsVectorString(pos)
				lines[#lines + 1] = Format(
					"for _,v in ipairs(workspace:FindPartsInRegion3(Region3.new(%s, %s), nil, math.huge)) do if v.Name == %q then v:Destroy() end end",
					vec,
					vec,
					data.name
				)
			end
			local scriptText = Concat(lines, "\n")
			if setclipboard then
				setclipboard(scriptText)
				DoNotif("Copied delete script to clipboard.", 3)
			else
				DoWindow("Copy this script:\n\n"..scriptText)
			end
		end

		local function applyDelete(part)
			if not part or not part.Parent then
				DoNotif("Selected part is no longer available.", 3)
				setTarget(nil)
				return
			end
			local record = {
				part = part,
				parent = part.Parent,
				cframe = part.CFrame,
			}
			local data = {
				name = part.Name,
				position = part.Position,
			}
			record.data = data
			Insert(state.history, record)
			Insert(state.saveHistory, data)
			part.Parent = nil
			setTarget(nil)
			DoNotif("Deleted '"..part.Name.."'", 2)
		end

		local function applyAnchor(part)
			if not part or not part.Parent then
				DoNotif("Selected part is no longer available.", 3)
				setTarget(nil)
				return
			end
			part.Anchored = not part.Anchored
			updateStatus(part)
			DoNotif(Format("%s anchored %s", part.Name, part.Anchored and "enabled" or "disabled"), 2)
		end

		local function applyCollide(part)
			if not part or not part.Parent then
				DoNotif("Selected part is no longer available.", 3)
				setTarget(nil)
				return
			end
			part.CanCollide = not part.CanCollide
			updateStatus(part)
			DoNotif(Format("%s CanCollide %s", part.Name, part.CanCollide and "enabled" or "disabled"), 2)
		end

		local modeHandlers = {
			delete = applyDelete,
			anchor = applyAnchor,
			collide = applyCollide,
		}

		local function setMode(mode)
			if not modeHandlers[mode] then
				return
			end
			state.currentMode = mode
			if state.refreshModeButtons then
				state.refreshModeButtons()
			end
			updateStatus(state.currentPart)
		end

		local function applyMode(part)
			if not part or not part:IsA("BasePart") then
				DoNotif("Aim at a part first.", 3)
				return
			end
			setTarget(part)
			local handler = modeHandlers[state.currentMode or ""]
			if not handler then
				DoNotif("Select a mode first.", 3)
				return
			end
			handler(part)
		end

		local uiActions = {
			setMode = setMode,
			getMode = function()
				return state.currentMode
			end,
			undo = undoLast,
			copy = copyScript,
		}

		state.gui = NAmanage.NAibtoolsCreateUI(state, uiActions)
		if not modeHandlers[state.currentMode or ""] then
			state.currentMode = "delete"
		end
		setMode(state.currentMode)
		updateStatus(state.currentPart)

		local function refreshTarget()
			local target = mouse.Target
			if target and target:IsA("BasePart") then
				setTarget(target)
			end
		end

		refreshTarget()

		Insert(state.connections, mouse.Move:Connect(refreshTarget))
		Insert(state.connections, mouse.Button1Down:Connect(function()
			local target = mouse.Target
			if target and target:IsA("BasePart") then
				applyMode(target)
			end
		end))
	end

	Insert(state.toolConnections, tool.Equipped:Connect(onEquipped))
	Insert(state.toolConnections, tool.Unequipped:Connect(function()
		NAmanage.NAibtoolsCleanup(state)
	end))
	Insert(state.toolConnections, tool.AncestryChanged:Connect(function(_, parent)
		if not parent then
			NAmanage.NAibtoolsCleanup(state)
			if NAmanage._ibtools == state then
				NAmanage._ibtools = nil
			end
		end
	end))

	DoNotif("iBTools loaded. Equip the tool to use it.", 3)
end)

cmd.add({"unibtools"}, {"unibtools", "Remove the iBuild Tools helper tool"}, function()
	local state = NAmanage._ibtools
	if not state then
		DoNotif("iBTools is not active.", 3)
		return
	end
	if state.tool then
		pcall(function()
			state.tool:Destroy()
		end)
	end
	NAmanage.NAibtoolsCleanup(state)
	if state.toolConnections then
		for _, conn in ipairs(state.toolConnections) do
			if conn and conn.Disconnect then
				conn:Disconnect()
			end
		end
		state.toolConnections = nil
	end
	NAmanage._ibtools = nil
	DoNotif("iBTools removed.", 3)
end)

-- detected by roblox so it's disabled

--[[cmd.add({"setfflag", "setff"}, {"setfflag <flag> <value> (setff)", "Set a fast flag"}, function(flag, value)
	local title = "Set Fast Flag"
	if not flag or flag == "" then
		DoNotif("Please provide a fast flag name", 3, title)
		return
	end
	if value == nil then
		DoNotif("Please provide a fast flag value", 3, title)
		return
	end
	local method = setfflag or function(fastFlag, fastValue)
		game:DefineFastFlag(fastFlag, fastValue)
	end
	local success, result = pcall(function()
		method(flag, value)
	end)
	if success then
		DoNotif(Format("Set %s's value to %s", flag, value), 5, title)
	else
		DoNotif("Error occurred setting fast flag: "..tostring(result), 10, title)
	end
end, true)]]

cmd.add({"addalias"}, {"addalias <command> <alias>", "Adds a persistent alias for an existing command"}, function(original, alias)
	if not original or not alias then
		DoNotif("Usage: addalias <command> <alias>", 2)
		return
	end

	original, alias = original:lower(), alias:lower()

	if not cmds.Commands[original] then
		DoNotif("Command '"..original.."' does not exist", 2)
		return
	end

	if cmds.Commands[alias] or cmds.Aliases[alias] then
		DoNotif("The name '"..alias.."' is already used by another command or alias", 2)
		return
	end

	local command = cmds.Commands[original]
	cmds.Aliases[alias] = {command[1], command[2], command[3]}
	cmds.NASAVEDALIASES[alias] = original

	if FileSupport then
		local aliasMap = NAmanage.readAliasFile()
		aliasMap[alias] = original
		writefile(NAfiles.NAALIASPATH, HttpService:JSONEncode(aliasMap))
	end

	DoNotif("Alias '"..alias.."' has been added for command '"..original.."'", 2)
	if not FileSupport then
		DebugNotif("Alias stored for this session only (no file support detected).")
	end
end, true)

cmd.add({"removealias"}, {"removealias", "Select and remove a saved alias"}, function()
	local combined = {}

	if FileSupport then
		for alias, original in pairs(NAmanage.readAliasFile()) do
			if type(alias) == "string" and type(original) == "string" then
				combined[alias:lower()] = original:lower()
			end
		end
	end

	for alias, original in pairs(cmds.NASAVEDALIASES) do
		if type(alias) == "string" and type(original) == "string" then
			combined[alias:lower()] = original:lower()
		end
	end

	if next(combined) == nil then
		DoNotif("No saved aliases to remove", 2)
		return
	end

	local buttons = {}
	for alias, original in pairs(combined) do
		Insert(buttons, {
			Text = 'Alias: '..alias.." | Command: "..original,
			Callback = function()
				cmds.Aliases[alias] = nil
				cmds.NASAVEDALIASES[alias] = nil
				combined[alias] = nil
				if FileSupport then
					writefile(NAfiles.NAALIASPATH, HttpService:JSONEncode(combined))
				end
				DoNotif(("Removed alias '%s'"):format(alias), 2)
			end
		})
	end

	Window({
		Title = "Remove Alias",
		Description = "Select an alias to remove:",
		Buttons = buttons
	})
end)

cmd.add({"clearaliases"}, {"clearaliases", "Removes all aliases created using addalias."}, function()
	if next(cmds.NASAVEDALIASES) == nil then
		DoNotif("No saved aliases to clear", 2)
		return
	end

	for alias in pairs(cmds.NASAVEDALIASES) do
		cmds.Aliases[alias] = nil
	end

	cmds.NASAVEDALIASES = {}

	if FileSupport then
		writefile(NAfiles.NAALIASPATH, "{}")
	else
		DebugNotif("Aliases cleared for this session (no file support).")
	end

	DoNotif("All aliases have been removed", 2)
end)

cmd.add({"addbutton", "ab"}, {"addbutton <command> <label> [<command2>] (ab)", "Add a mobile button"}, function(arg1, arg2, arg3)
	if not arg1 or not arg2 then
		DoNotif("Usage: ;addbutton <command> <label> [<command2>]", 2)
		return
	end

	local id = #NAUserButtons + 1
	NAUserButtons[id] = {
		Cmd1 = arg1,
		Label = arg2,
		Cmd2 = arg3
	}

	if FileSupport then
		writefile(NAfiles.NAUSERBUTTONSPATH, HttpService:JSONEncode(NAUserButtons))
	end

	NAmanage.RenderUserButtons()

	DoNotif("Added button with id "..id, 2)
end,true)

cmd.add({"removebutton", "rb"}, {"removebutton (rb)", "Remove a user button"}, function()
	if not next(NAUserButtons) then
		DoNotif("No user buttons to remove", 2)
		return
	end

	local options = {}
	for id, data in pairs(NAUserButtons) do
		local label = data.Label or ("Button "..id)
		local cmdDisplay = data.Cmd1 or "?"
		if data.Cmd2 then
			cmdDisplay = cmdDisplay.." / "..data.Cmd2
		end

		Insert(options, {
			Text = "["..id.."] "..label.." ("..cmdDisplay..")",
			Callback = function()
				NAUserButtons[id] = nil

				if FileSupport then
					writefile(NAfiles.NAUSERBUTTONSPATH, HttpService:JSONEncode(NAUserButtons))
				end

				NAmanage.RenderUserButtons()

				DoNotif("Removed user button: ["..id.."] "..label, 2)
			end
		})
	end

	Window({
		Title = "Remove User Button",
		Description = "Select a button to remove:",
		Buttons = options
	})
end)

cmd.add({"clearbuttons", "clearbtns", "cb"}, {"clearbuttons (clearbtns, cb)", "Clear all user buttons"}, function()
	if not next(NAUserButtons) then
		DoNotif("No user buttons to clear", 2)
		return
	end

	Window({
		Title = "Clear All Buttons",
		Description = "Are you sure you want to clear all user buttons?",
		Buttons = {
			{
				Text = "Yes",
				Callback = function()
					table.clear(NAUserButtons)

					if FileSupport then
						writefile(NAfiles.NAUSERBUTTONSPATH, HttpService:JSONEncode(NAUserButtons))
					end

					NAmanage.RenderUserButtons()

					DoNotif("Cleared all user buttons", 2)
				end
			}
		}
	})
end)

cmd.add({"addautoexec", "aaexec", "addae", "addauto", "aexecadd"}, {"addautoexec <command> [arguments] (aaexec, addae, addauto, aexecadd)", "Add a command to autoexecute"}, function(arg1, ...)
	if not arg1 then
		DoNotif("Usage: ;addautoexec <command> [arguments...]", 2)
		return
	end

	local args = {...}
	local rawName = arg1:lower()
	local canonical = NAmanage.resolveCommandName(rawName)

	if not canonical then
		DoNotif("Command ["..rawName.."] does not exist", 2)
		return
	end

	if NAStuff.AutoExecBlockedCommands[canonical] then
		DoNotif("Command ["..canonical.."] is blocked.", 2)
		return
	end

	local commandName = canonical

	NAEXECDATA = NAEXECDATA or {commands = {}, args = {}}
	if not NAEXECDATA.commands then
		NAEXECDATA.commands = {}
	end
	if not NAEXECDATA.args then
		NAEXECDATA.args = {}
	end

	local exists = false
	for _, cmd in ipairs(NAEXECDATA.commands) do
		if cmd == commandName then
			exists = true
			break
		end
	end
	if not exists then
		Insert(NAEXECDATA.commands, commandName)
	end

	if #args > 0 then
		local argumentString = Concat(args, " ")
		NAEXECDATA.args[commandName] = argumentString
	else
		NAEXECDATA.args[commandName] = ""
	end

	if not NAmanage.AutoExecSave(NAEXECDATA) then
		DebugNotif("Failed to save AutoExec changes; they will reset after this session.")
	end

	DoNotif("Added to AutoExec: "..arg1.." "..(args[1] or ""), 2)
end,true)

cmd.add({"removeautoexec", "raexec", "removeae", "removeauto", "aexecremove"}, {"removeautoexec (raexec, removeae, removeauto, aexecremove)", "Remove a command from autoexecute"}, function()
	if #NAEXECDATA.commands == 0 then
		DoNotif("No AutoExec commands to remove", 2)
		return
	end

	local options = {}
	for i, cmdName in ipairs(NAEXECDATA.commands) do
		local args = NAEXECDATA.args[cmdName]
		local display = args and args ~= "" and (cmdName.." "..args) or cmdName
		local index = i
		Insert(options, {
			Text = display,
			Callback = function()
				local removedCommand = table.remove(NAEXECDATA.commands, index)
				if removedCommand then
					NAEXECDATA.args[removedCommand] = nil
					if not NAmanage.AutoExecSave(NAEXECDATA) then
						DebugNotif("Failed to save AutoExec changes; they will reset after this session.")
					end
					DoNotif("Removed AutoExec command: "..display, 2)
				else
					DoNotif("Unable to remove AutoExec command.", 2)
				end
			end
		})
	end
	Window({
		Title = "Remove AutoExec Command",
		Description = "Select which AutoExec to remove:",
		Buttons = options
	})
end)

cmd.add({"clearautoexec", "caexec", "clearauto", "autoexecclear", "aexecclear", "aeclear"}, {"clearautoexec (caexec, clearauto, autoexecclear, aexecclear, aeclear)", "Clear all AutoExec commands"}, function()
	NAEXECDATA = NAEXECDATA or {commands = {}, args = {}}
	NAEXECDATA.commands = NAEXECDATA.commands or {}
	NAEXECDATA.args = NAEXECDATA.args or {}

	if #NAEXECDATA.commands == 0 then
		DoNotif("No AutoExec commands to clear", 2)
		return
	end

	Window({
		Title = "Clear AutoExec Commands",
		Description = "Are you sure you want to clear all AutoExec commands?",
		Buttons = {
			{
				Text = "Yes",
				Callback = function()
					table.clear(NAEXECDATA.commands)
					table.clear(NAEXECDATA.args)

					if not NAmanage.AutoExecSave(NAEXECDATA) then
						DebugNotif("Failed to save AutoExec changes; they will reset after this session.")
					end

					DoNotif("Cleared all AutoExec commands", 2)
				end
			}
		}
	})
end)

cmd.add({"executor","exec"},{"executor (exec)","Very simple executor"},function()
	loadstring(game:HttpGet("https://raw.githubusercontent.com/ltseverydayyou/Nameless-Admin/main/NAexecutor.lua"))()
end)

cmd.add({"lastcommand","lastcmd"},{"lastcommand (lastcmd)","Re-run your previously executed command"},function()
	local last=NAStuff._lastCommand
	local first = last and last[1]
	local lowerFirst = (type(first) == "string") and Lower(first) or nil
	if not lowerFirst or lowerFirst == "lastcommand" or lowerFirst == "lastcmd" then
		last = NAStuff._prevCommand
		first = last and last[1]
		lowerFirst = (type(first) == "string") and Lower(first) or nil
	end
	if type(last) ~= "table" or not lowerFirst or #last==0 then
		DoNotif("No previous command recorded",2)
		return
	end
	local replay=NAmanage.cloneArgsArray(last)
	if #replay == 0 then
		DoNotif("No previous command recorded",2)
		return
	end
	SpawnCall(function()
		cmd.run(replay)
	end)
end)

cmd.add({"commandloop", "cmdloop"}, {"commandloop <command> {arguments} (cmdloop)", "Run a command on loop"}, function(...)
	local args = {...}
	local commandName = args[1]
	table.remove(args, 1)

	if not commandName then
		DoNotif("Command name is required.",3)
		return
	end

	cmd.loop(commandName, args)
end,true)

cmd.add({"stoploop", "uncmdloop", "sloop", "stopl"}, {"stoploop", "Stop a running loop"}, function()
	cmd.stopLoop()
end)

cmd.add({"scripthub","hub"},{"scripthub (hub)","Thanks to scriptblox/rscripts API"},function()
	loadstring(game:HttpGet("https://raw.githubusercontent.com/ltseverydayyou/Nameless-Admin/main/ScriptHubNA.lua"))()
end)

--[[cmd.add({"resizechat","rc"},{"resizechat (rc)","Makes chat resizable and draggable"},function()
	require(SafeGetService("Chat").ClientChatModules.ChatSettings).WindowResizable=true
	require(SafeGetService("Chat").ClientChatModules.ChatSettings).WindowDraggable=true
end)]]


local scaleFrame = nil
cmd.add({"uiscale", "uscale", "guiscale", "gscale"}, {"uiscale (uscale)", "Adjust the scale of the "..adminName.." UI"}, function()
	if scaleFrame then scaleFrame:Destroy() scaleFrame=nil end
	scaleFrame = InstanceNew("ScreenGui")
	local frame = InstanceNew("Frame")
	local frameCorner = InstanceNew("UICorner")
	local slider = InstanceNew("Frame")
	local sliderCorner = InstanceNew("UICorner")
	local progress = InstanceNew("Frame")
	local progressCorner = InstanceNew("UICorner")
	local knob = InstanceNew("TextButton")
	local knobCorner = InstanceNew("UICorner")
	local label = InstanceNew("TextLabel")
	local closeButton = InstanceNew("TextButton")
	local closeCorner = InstanceNew("UICorner")

	local sizeRange = {0.5, 2.5}
	local minSize, maxSize = sizeRange[1], sizeRange[2]

	NaProtectUI(scaleFrame)
	frame.Parent = scaleFrame
	frame.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
	frame.Size = UDim2.new(0, 400, 0, 120)
	frame.Position = UDim2.new(0.5,-283/2+5,0.5,-260/2+5)
	frame.BorderSizePixel = 0
	frame.BackgroundTransparency = 0.05

	frameCorner.CornerRadius = UDim.new(0.1, 0)
	frameCorner.Parent = frame

	slider.Parent = frame
	slider.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
	slider.Size = UDim2.new(0.8, 0, 0.2, 0)
	slider.Position = UDim2.new(0.1, 0, 0.5, 0)
	slider.AnchorPoint = Vector2.new(0, 0.5)
	slider.BorderSizePixel = 0

	sliderCorner.CornerRadius = UDim.new(0.5, 0)
	sliderCorner.Parent = slider

	progress.Parent = slider
	progress.BackgroundColor3 = Color3.fromRGB(0, 170, 255)
	progress.Size = UDim2.new((NAUIScale - minSize) / (maxSize - minSize), 0, 1, 0)
	progress.BorderSizePixel = 0

	progressCorner.CornerRadius = UDim.new(0.5, 0)
	progressCorner.Parent = progress

	knob.Parent = slider
	knob.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
	knob.Size = UDim2.new(0, 25, 1.5, 0)
	knob.Position = UDim2.new((NAUIScale - minSize) / (maxSize - minSize), 0, -0.25, 0)
	knob.Text = ""
	knob.BorderSizePixel = 0
	knob.AutoButtonColor = false

	knobCorner.CornerRadius = UDim.new(1, 0)
	knobCorner.Parent = knob

	label.Parent = frame
	label.BackgroundTransparency = 1
	label.Size = UDim2.new(1, 0, 0.3, 0)
	label.Position = UDim2.new(0, 0, 0.1, 0)
	label.Text = "Scale: "..Format("%.2f", NAUIScale)
	label.TextColor3 = Color3.fromRGB(255, 255, 255)
	label.Font = Enum.Font.Gotham
	label.TextSize = 18
	label.TextXAlignment = Enum.TextXAlignment.Center

	closeButton.Parent = frame
	closeButton.BackgroundColor3 = Color3.fromRGB(255, 0, 0)
	closeButton.Size = UDim2.new(0, 30, 0, 30)
	closeButton.Position = UDim2.new(1, -40, 0, 10)
	closeButton.Text = "X"
	closeButton.TextColor3 = Color3.fromRGB(255, 255, 255)
	closeButton.Font = Enum.Font.Gotham
	closeButton.TextSize = 14
	closeButton.BorderSizePixel = 0

	closeCorner.CornerRadius = UDim.new(0.5, 0)
	closeCorner.Parent = closeButton

	local function update(scale)
		opt.NAAUTOSCALER.Scale = scale
		progress.Size = UDim2.new((scale - minSize) / (maxSize - minSize) + 0.05, 0, 1, 0)
		knob.Position = UDim2.new((scale - minSize) / (maxSize - minSize), 0, -0.25, 0)
		label.Text = "Scale: "..Format("%.2f", scale)
	end

	update(NAUIScale)

	local dragging = false
	local dragInput
	local sliderStart, sliderWidth

	knob.InputBegan:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
			dragging = true
			sliderStart = slider.AbsolutePosition.X
			sliderWidth = slider.AbsoluteSize.X
			input.Changed:Connect(function()
				if input.UserInputState == Enum.UserInputState.End then
					dragging = false
					NAmanage.NASettingsSet("uiScale", NAUIScale)
				end
			end)
		end
	end)

	UserInputService.InputChanged:Connect(function(input)
		if dragging and (input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch) then
			local mouseX = input.Position.X
			local relativePosition = (mouseX - sliderStart) / sliderWidth
			local newScale = math.clamp(relativePosition, 0, 1) * (maxSize - minSize) + minSize
			NAUIScale = math.clamp(newScale, minSize, maxSize)
			update(NAUIScale)
		end
	end)

	MouseButtonFix(closeButton,function()
		scaleFrame:Destroy()
	end)

	NAgui.draggerV2(frame)
end)

cmd.add({"prefix"}, {"prefix <symbol>", "Changes the admin prefix"}, function(...)
	local newPrefix = (...)
	if not newPrefix or newPrefix == "" then
		DoNotif("Please enter a valid prefix")
	elseif utf8.len(newPrefix) > 1 then
		DoNotif("Prefix must be a single character (e.g. ; . !)")
	elseif newPrefix:match("[%w]") then
		DoNotif("Prefix cannot contain letters or numbers")
	elseif newPrefix:match("[%[%]%(%)%*%^%$%%{}<>]") then
		DoNotif("That symbol is not allowed as a prefix")
	elseif newPrefix:match("&amp;") or newPrefix:match("&lt;") or newPrefix:match("&gt;") or newPrefix:match("&quot;") or newPrefix:match("&#x27;") or newPrefix:match("&#x60;") then
		DoNotif("Encoded/HTML characters are not allowed as a prefix")
	else
		opt.prefix = newPrefix
		DoNotif("Prefix set to: "..newPrefix)
		if NAmanage.SyncPrefixUI then
			NAmanage.SyncPrefixUI()
		end
	end
end, true)

cmd.add({"saveprefix"}, {"saveprefix <symbol>", "Saves the prefix to a file and applies it"}, function(...)
	local newPrefix = (...)
	if not newPrefix or newPrefix == "" then
		DoNotif("Please enter a valid prefix")
	elseif utf8.len(newPrefix) > 1 then
		DoNotif("Prefix must be a single character (e.g. ; . !)")
	elseif newPrefix:match("[%w]") then
		DoNotif("Prefix cannot contain letters or numbers")
	elseif newPrefix:match("[%[%]%(%)%*%^%$%%{}<>]") then
		DoNotif("That symbol is not allowed as a prefix")
	elseif newPrefix:match("&amp;") or newPrefix:match("&lt;") or newPrefix:match("&gt;") or newPrefix:match("&quot;") or newPrefix:match("&#x27;") or newPrefix:match("&#x60;") then
		DoNotif("Encoded/HTML characters are not allowed as a prefix")
	else
		NAmanage.NASettingsSet("prefix", newPrefix)
		opt.prefix = newPrefix
		DoNotif("Prefix saved to: "..newPrefix)
		if not FileSupport then
			DebugNotif("Prefix will reset when Roblox closes (no file support detected).")
		end
		if NAmanage.SyncPrefixUI then
			NAmanage.SyncPrefixUI()
		end
	end
end, true)

--[ UTILITY ]--

cmd.add({"chatlogs","clogs"},{"chatlogs (clogs)","Open the chat logs"},function()
	NAgui.chatlogs()
end)

cmd.add({"gotocampos","tocampos","tcp"},{"gotocampos (tocampos,tcp)","Teleports you to your camera position works with free cam but freezes you"},function()
	local player=Players.LocalPlayer
	function teleportPlayer()
		local character=player.Character or player.CharacterAdded:wait(1)
		local camera=workspace.CurrentCamera
		local cameraPosition=camera.CFrame.Position
		character:SetPrimaryPartCFrame(CFrame.new(cameraPosition))
	end
	local camera=workspace.CurrentCamera
	repeat Wait() until camera.CFrame~=CFrame.new()

	teleportPlayer()
end)

cmd.add({"teleportgui","tpui","universeviewer","uviewer"},{"teleportgui (tpui,universeviewer,uviewer)","Gives an UI that grabs all places and teleports you by clicking a simple button"},function()
	loadstring(game:HttpGet("https://raw.githubusercontent.com/ltseverydayyou/uuuuuuu/main/Universe%20Viewer"))();
end)

cmd.add({"serverremotespy","srs","sremotespy"},{"serverremotespy (srs,sremotespy)","Gives an UI that logs all the remotes being called from the server (thanks SolSpy lol)"},function()
	loadstring(game:HttpGet("https://raw.githubusercontent.com/ltseverydayyou/uuuuuuu/refs/heads/main/Server%20Spy.lua"))()
end)

cmd.add({"discord", "invite", "support", "help"}, {"discord", "Copy an invite link"}, function()
	if setclipboard then
		Window({
			Title = "Discord",
			Description = inviteLink,
			Buttons = {
				{Text = "Copy Link", Callback = function() setclipboard(inviteLink) end},
				{Text = "Close", Callback = function() end}
			}
		})
	else
		Window({
			Title = "Discord",
			Description = "Your exploit does not support setclipboard.\nPlease manually type the invite link: "..inviteLink,
			Buttons = {
				{Text = "Close", Callback = function() end}
			}
		})
	end
	--DoNotif("not available yet", 2)
end)

clickflingUI = nil
clickflingEnabled = true

cmd.add({"clickfling","mousefling"},{"clickfling (mousefling)","Fling a player by clicking them"},function()
	clickflingEnabled = true
	if clickflingUI then clickflingUI:Destroy() end
	NAlib.disconnect("clickfling_mouse")

	local Mouse = player:GetMouse()
	clickflingUI = InstanceNew("ScreenGui")
	NaProtectUI(clickflingUI)

	local toggleButton = InstanceNew("TextButton")
	toggleButton.Size = UDim2.new(0,120,0,40)
	toggleButton.Text = "ClickFling: ON"
	toggleButton.Position = UDim2.new(0.5,-60,0,10)
	toggleButton.TextScaled = 16
	toggleButton.TextColor3 = Color3.new(1,1,1)
	toggleButton.Font = Enum.Font.GothamBold
	toggleButton.BackgroundColor3 = Color3.fromRGB(40,40,40)
	toggleButton.BackgroundTransparency = 0.2
	toggleButton.Parent = clickflingUI

	local uiCorner = InstanceNew("UICorner")
	uiCorner.CornerRadius = UDim.new(0,8)
	uiCorner.Parent = toggleButton

	NAgui.draggerV2(toggleButton)

	MouseButtonFix(toggleButton,function()
		clickflingEnabled = not clickflingEnabled
		if clickflingEnabled then
			toggleButton.Text = "ClickFling: ON"
		else
			toggleButton.Text = "ClickFling: OFF"
		end
	end)

	local conn = Mouse.Button1Down:Connect(function()
		if not clickflingEnabled then return end
		local Target = Mouse.Target
		local Players = game.GetService(game,"Players")
		if Target and Target.Parent and Target.Parent:IsA("Model") and Players:GetPlayerFromCharacter(Target.Parent) then
			local PlayerName = Players:GetPlayerFromCharacter(Target.Parent).Name
			local playerLocal = Players.LocalPlayer
			local Targets = {PlayerName}
			local Players = game.GetService(game,"Players")
			local Player = Players.LocalPlayer
			local AllBool = false

			local GetPlayer = function(Name)
				Name = Lower(Name)
				if Name == "all" or Name == "others" then
					AllBool = true
					return
				elseif Name == "random" then
					local GetPlayers = Players:GetPlayers()
					if Discover(GetPlayers,Player) then table.remove(GetPlayers,Discover(GetPlayers,Player)) end
					return GetPlayers[math.random(#GetPlayers)]
				end
				for _,x in next,Players:GetPlayers() do
					if x~=Player then
						if Sub(Lower(x.Name),1,#Name)==Name or Sub(Lower(x.DisplayName),1,#Name)==Name then
							return x
						end
					end
				end
			end

			local flingManager = flingManager
			local OrgDestroyHeight = workspace.FallenPartsDestroyHeight

			local SkidFling = function(TargetPlayer)
				local Character = Player.Character
				local Humanoid = getPlrHum(Character)
				local RootPart = Humanoid and Humanoid.RootPart
				local TCharacter = TargetPlayer.Character
				local THumanoid = getPlrHum(TCharacter)
				local TRootPart = THumanoid and THumanoid.RootPart
				local THead = getHead(TCharacter)
				local Accessory = TCharacter:FindFirstChildOfClass("Accessory")
				local Handle = Accessory and Accessory:FindFirstChild("Handle")

				if Character and Humanoid and RootPart then
					if not flingManager.cFlingOldPos or RootPart.Velocity.Magnitude<50 then
						flingManager.cFlingOldPos = RootPart.CFrame
					end
					if THead then
						workspace.CurrentCamera.CameraSubject = THead
					elseif Handle then
						workspace.CurrentCamera.CameraSubject = Handle
					elseif THumanoid and TRootPart then
						workspace.CurrentCamera.CameraSubject = THumanoid
					end
					if not TCharacter:FindFirstChildWhichIsA("BasePart") then return end

					local function FPos(BasePart,Pos,Ang)
						RootPart.CFrame = CFrame.new(BasePart.Position)*Pos*Ang
						Character:SetPrimaryPartCFrame(CFrame.new(BasePart.Position)*Pos*Ang)
						RootPart.Velocity = Vector3.new(9e7,9e7*10,9e7)
						RootPart.RotVelocity = Vector3.new(9e8,9e8,9e8)
					end

					local function SFBasePart(BasePart)
						local TimeToWait = 2
						local Time = tick()
						local Angle = 0
						repeat
							if RootPart and THumanoid then
								if BasePart.Velocity.Magnitude<50 then
									Angle=Angle+100
									FPos(BasePart,CFrame.new(0,1.5,0)+THumanoid.MoveDirection*BasePart.Velocity.Magnitude/1.25,CFrame.Angles(math.rad(Angle),0,0)) Wait()
									FPos(BasePart,CFrame.new(0,-1.5,0)+THumanoid.MoveDirection*BasePart.Velocity.Magnitude/1.25,CFrame.Angles(math.rad(Angle),0,0)) Wait()
									FPos(BasePart,CFrame.new(2.25,1.5,-2.25)+THumanoid.MoveDirection*BasePart.Velocity.Magnitude/1.25,CFrame.Angles(math.rad(Angle),0,0)) Wait()
									FPos(BasePart,CFrame.new(-2.25,-1.5,2.25)+THumanoid.MoveDirection*BasePart.Velocity.Magnitude/1.25,CFrame.Angles(math.rad(Angle),0,0)) Wait()
									FPos(BasePart,CFrame.new(0,1.5,0)+THumanoid.MoveDirection,CFrame.Angles(math.rad(Angle),0,0)) Wait()
									FPos(BasePart,CFrame.new(0,-1.5,0)+THumanoid.MoveDirection,CFrame.Angles(math.rad(Angle),0,0)) Wait()
								else
									FPos(BasePart,CFrame.new(0,1.5,THumanoid.WalkSpeed),CFrame.Angles(math.rad(90),0,0)) Wait()
									FPos(BasePart,CFrame.new(0,-1.5,-THumanoid.WalkSpeed),CFrame.Angles(0,0,0)) Wait()
									FPos(BasePart,CFrame.new(0,1.5,THumanoid.WalkSpeed),CFrame.Angles(math.rad(90),0,0)) Wait()
									FPos(BasePart,CFrame.new(0,1.5,TRootPart.Velocity.Magnitude/1.25),CFrame.Angles(math.rad(90),0,0)) Wait()
									FPos(BasePart,CFrame.new(0,-1.5,-TRootPart.Velocity.Magnitude/1.25),CFrame.Angles(0,0,0)) Wait()
									FPos(BasePart,CFrame.new(0,1.5,TRootPart.Velocity.Magnitude/1.25),CFrame.Angles(math.rad(90),0,0)) Wait()
									FPos(BasePart,CFrame.new(0,-1.5,0),CFrame.Angles(math.rad(90),0,0)) Wait()
									FPos(BasePart,CFrame.new(0,-1.5,0),CFrame.Angles(0,0,0)) Wait()
									FPos(BasePart,CFrame.new(0,-1.5,0),CFrame.Angles(math.rad(-90),0,0)) Wait()
									FPos(BasePart,CFrame.new(0,-1.5,0),CFrame.Angles(0,0,0)) Wait()
								end
							else
								break
							end
						until BasePart.Velocity.Magnitude>500 or BasePart.Parent~=TargetPlayer.Character or TargetPlayer.Parent~=Players or TargetPlayer.Character~=TCharacter or THumanoid.Sit or Humanoid.Health<=0 or tick()>Time+TimeToWait
					end

					workspace.FallenPartsDestroyHeight = 0/0

					local BV = InstanceNew("BodyVelocity")
					BV.Parent = RootPart
					BV.Velocity = Vector3.new(9e8,9e8,9e8)
					BV.MaxForce = Vector3.new(1/0,1/0,1/0)

					Humanoid:SetStateEnabled(Enum.HumanoidStateType.Seated,false)

					if TRootPart and THead then
						if (TRootPart.CFrame.p - THead.CFrame.p).Magnitude>5 then SFBasePart(THead) else SFBasePart(TRootPart) end
					elseif TRootPart then
						SFBasePart(TRootPart)
					elseif THead then
						SFBasePart(THead)
					elseif Handle then
						SFBasePart(Handle)
					end

					BV:Destroy()
					Humanoid:SetStateEnabled(Enum.HumanoidStateType.Seated,true)
					workspace.CurrentCamera.CameraSubject = Humanoid

					repeat
						RootPart.CFrame = flingManager.cFlingOldPos*CFrame.new(0,.5,0)
						Character:SetPrimaryPartCFrame(flingManager.cFlingOldPos*CFrame.new(0,.5,0))
						Humanoid:ChangeState("GettingUp")
						for _,x in next,Character:GetChildren() do
							if x:IsA("BasePart") then
								x.Velocity, x.RotVelocity = Vector3.new(),Vector3.new()
							end
						end
						Wait()
					until (RootPart.Position - flingManager.cFlingOldPos.p).Magnitude<25

					workspace.FallenPartsDestroyHeight = OrgDestroyHeight
				end
			end

			getgenv().Welcome = true
			if Targets[1] then
				for _,x in next,Targets do GetPlayer(x) end
			else
				return
			end

			if AllBool then
				for _,x in next,Players:GetPlayers() do SkidFling(x) end
			end

			for _,x in next,Targets do
				local TP = GetPlayer(x)
				if TP and TP~=Player and TP.UserId~=1414978355 then
					SkidFling(TP)
				end
			end
		end
	end)

	NAlib.connect("clickfling_mouse",conn)
end)

cmd.add({"unclickfling","unmousefling"},{"unclickfling (unmousefling)","disables clickfling"},function()
	clickflingEnabled = false
	if clickflingUI then clickflingUI:Destroy() end
	NAlib.disconnect("clickfling_mouse")
end)

clickscareUI = nil
clickscareEnabled = true

cmd.add({"clickscare","clickspook"},{"clickscare (clickspook)","Teleports next to a clicked player for a few seconds"},function()
	clickscareEnabled = true
	if clickscareUI then clickscareUI:Destroy() end
	NAlib.disconnect("clickscare_mouse")

	local Mouse = player:GetMouse()
	clickscareUI = InstanceNew("ScreenGui")
	NaProtectUI(clickscareUI)

	local toggleButton = InstanceNew("TextButton")
	toggleButton.Size = UDim2.new(0,120,0,40)
	toggleButton.Text = "ClickScare: ON"
	toggleButton.Position = UDim2.new(0.5,-60,0,10)
	toggleButton.TextScaled = 16
	toggleButton.TextColor3 = Color3.new(1,1,1)
	toggleButton.Font = Enum.Font.GothamBold
	toggleButton.BackgroundColor3 = Color3.fromRGB(40,40,40)
	toggleButton.BackgroundTransparency = 0.2
	toggleButton.Parent = clickscareUI

	local uiCorner = InstanceNew("UICorner")
	uiCorner.CornerRadius = UDim.new(0,8)
	uiCorner.Parent = toggleButton

	NAgui.draggerV2(toggleButton)

	MouseButtonFix(toggleButton,function()
		clickscareEnabled = not clickscareEnabled
		toggleButton.Text = clickscareEnabled and "ClickScare: ON" or "ClickScare: OFF"
	end)

	local conn = Mouse.Button1Down:Connect(function()
		if not clickscareEnabled then return end
		local target = Mouse.Target
		if not (target and target.Parent and target.Parent:IsA("Model")) then return end
		local clickedPlayer = Players:GetPlayerFromCharacter(target.Parent)
		if not clickedPlayer or not getPlrHum(clickedPlayer) then return end

		local char = getChar()
		local root = getRoot(char)
		local oldCF = root.CFrame
		local distancepl = 2
		local targetRoot = getRoot(clickedPlayer.Character)
		if targetRoot then
			root.CFrame = targetRoot.CFrame + targetRoot.CFrame.LookVector * distancepl
			root.CFrame = CFrame.new(root.Position, targetRoot.Position)
			Wait(0.5)
			root.CFrame = oldCF
		end
	end)

	NAlib.connect("clickscare_mouse",conn)
end)

cmd.add({"unclickscare","unclickspook"},{"unclickscare (unclickspook)","Disables clickscare"},function()
	clickscareEnabled = false
	if clickscareUI then clickscareUI:Destroy() end
	NAlib.disconnect("clickscare_mouse")
end)

hoverNameGui = nil
hoverNameLabel = nil
hoverNameSelection = nil

NAmanage.cleanupHoverName=function()
	NAlib.disconnect("hovername_track")
	if hoverNameLabel then
		hoverNameLabel:Destroy()
		hoverNameLabel = nil
	end
	if hoverNameGui then
		hoverNameGui:Destroy()
		hoverNameGui = nil
	end
	if hoverNameSelection then
		hoverNameSelection.Adornee = nil
		hoverNameSelection.Parent = nil
		hoverNameSelection:Destroy()
		hoverNameSelection = nil
	end
end

cmd.add({"hovername","namehover"}, {"hovername", "Shows player's username on hover"}, function()
	NAmanage.cleanupHoverName()

	hoverNameGui = InstanceNew("ScreenGui")
	NaProtectUI(hoverNameGui)

	hoverNameLabel = InstanceNew("TextLabel")
	hoverNameLabel.BackgroundTransparency = 1
	hoverNameLabel.Size = UDim2.new(0,200,0,30)
	hoverNameLabel.Font = Enum.Font.GothamBold
	hoverNameLabel.TextSize = 16
	hoverNameLabel.Text = ""
	hoverNameLabel.TextColor3 = Color3.new(1,1,1)
	hoverNameLabel.TextStrokeTransparency = 0
	hoverNameLabel.TextXAlignment = Enum.TextXAlignment.Left
	hoverNameLabel.Visible = false
	hoverNameLabel.ZIndex = 10
	hoverNameLabel.Parent = hoverNameGui

	hoverNameSelection = InstanceNew("SelectionBox")
	NAProtection(hoverNameSelection)
	hoverNameSelection.LineThickness = 0.03
	hoverNameSelection.Color3 = Color3.new(1,1,1)
	hoverNameSelection.Adornee = nil
	hoverNameSelection.Parent = nil

	local mouse = player and player:GetMouse()
	if not mouse then
		NAmanage.cleanupHoverName()
		return
	end

	local function updateHoverName()
		local target = mouse.Target
		local character
		if target then
			local parent = target.Parent
			if parent then
				local humanoid = parent:FindFirstChildOfClass("Humanoid")
				if not humanoid and parent.Parent then
					humanoid = parent.Parent:FindFirstChildOfClass("Humanoid")
				end
				if humanoid then
					character = humanoid.Parent
				end
			end
		end

		if character and character:IsA("Model") then
			local isPlr = nil
			if Players:GetPlayerFromCharacter(character) then isPlr=Players:GetPlayerFromCharacter(character) end
			local x = mouse.X
			local y = mouse.Y
			local xPos
			if x > 200 then
				xPos = x - 205
				hoverNameLabel.TextXAlignment = Enum.TextXAlignment.Right
			else
				xPos = x + 25
				hoverNameLabel.TextXAlignment = Enum.TextXAlignment.Left
			end
			hoverNameLabel.Position = UDim2.new(0, xPos, 0, y)
			hoverNameLabel.Text = nameChecker(isPlr or character)
			hoverNameLabel.Visible = true
			hoverNameSelection.Parent = character
			hoverNameSelection.Adornee = character
		else
			hoverNameLabel.Visible = false
			hoverNameSelection.Parent = nil
			hoverNameSelection.Adornee = nil
		end
	end

	NAlib.disconnect("hovername_track")
	NAlib.connect("hovername_track", mouse.Move:Connect(updateHoverName))
	updateHoverName()
end)

cmd.add({"unhovername","unnamehover"}, {"unhovername", "Disables hovername"}, function()
	NAmanage.cleanupHoverName()
end)

cmd.add({"resetfilter", "ref"}, {"resetfilter","If Roblox keeps tagging your messages, run this to reset the filter"}, function()
	for Index = 1, 3 do
		Players:Chat(Format("/e hi"))
	end
	return "Filter", "Reset"
end)

NAstatsUI = {}
windowCounter = (windowCounter or 0)
windowRegistry = windowRegistry or {}
StatsService = SafeGetService("Stats")

NAstatsUI.Theme = {
	Colors = {
		Background = Color3.fromRGB(28, 30, 38),
		Primary = Color3.fromRGB(38, 41, 52),
		Secondary = Color3.fromRGB(40, 42, 52),
		Border = Color3.fromRGB(70, 72, 90),
		Text = Color3.fromRGB(230, 232, 245),
		TextMuted = Color3.fromRGB(145, 148, 165),
		TextSubtle = Color3.fromRGB(200, 200, 210),
		Close = Color3.fromRGB(220, 70, 70),
		Minimize = Color3.fromRGB(100, 120, 255),
		Good = Color3.fromRGB(0, 255, 120),
		Warn = Color3.fromRGB(255, 210, 0),
		Bad = Color3.fromRGB(255, 80, 80),
	},
	Fonts = {
		Title = Enum.Font.GothamMedium,
		Body = Enum.Font.Gotham,
		BodySemibold = Enum.Font.GothamSemibold,
		BodyBold = Enum.Font.GothamBold,
	},
	Radius = {
		Window = UDim.new(0, 10),
		Container = UDim.new(0, 8),
		Button = UDim.new(1, 0),
	},
	Sizes = {
		TopBarHeight = IsOnMobile and 44 or 32,
		ActionButton = IsOnMobile and 26 or 22,
	}
}

NAstatsUI.createInstance=function(className, properties, parent)
	local inst = InstanceNew(className)
	for prop, value in pairs(properties) do
		inst[prop] = value
	end
	if parent then
		inst.Parent = parent
	end
	return inst
end

function NAstatsUI.colorToHex(c)
	return Format("#%02X%02X%02X", math.floor(c.R * 255), math.floor(c.G * 255), math.floor(c.B * 255))
end

function NAstatsUI.ensureSingle(key, buildFn)
	local existing = windowRegistry[key]
	if existing and existing.screenGui and existing.screenGui.Parent then
		existing.bringToFront()
		return existing
	end

	local newUi = buildFn()
	windowRegistry[key] = newUi

	local originalCloseFunction = newUi.closeFunction
	newUi.closeButton.MouseButton1Click:Connect(function()
		if windowRegistry[key] == newUi then
			windowRegistry[key] = nil
		end
		if originalCloseFunction then
			originalCloseFunction()
		end
		newUi.screenGui:Destroy()
	end)
	return newUi
end

function NAstatsUI.createWindow(position, baseSize, titleText)
	windowCounter += 1
	local T = NAstatsUI.Theme

	local screenGui = NAstatsUI.createInstance("ScreenGui", {
		ResetOnSpawn = false,
		ZIndexBehavior = Enum.ZIndexBehavior.Sibling,
		DisplayOrder = 100 + windowCounter,
	})
	NaProtectUI(screenGui)

	local holder = NAstatsUI.createInstance("Frame", {
		Name = "Holder",
		BackgroundTransparency = 1,
		AnchorPoint = Vector2.new(0.5, 0.5),
		Position = position or UDim2.new(0.5, 0, 0.35, 0),
		Size = baseSize,
		Parent = screenGui,
	})

	local window = NAstatsUI.createInstance("Frame", {
		Name = "Window",
		BackgroundColor3 = T.Colors.Background,
		BorderSizePixel = 0,
		Size = UDim2.new(1, 0, 1, 0),
		Parent = holder
	})
	NAstatsUI.createInstance("UICorner", { CornerRadius = T.Radius.Window }, window)
	NAstatsUI.createInstance("UIStroke", { Color = T.Colors.Border, Thickness = 1.5, ApplyStrokeMode = Enum.ApplyStrokeMode.Border }, window)

	local topBar = NAstatsUI.createInstance("Frame", {
		Name = "TopBar",
		BackgroundColor3 = T.Colors.Primary,
		BorderSizePixel = 0,
		Size = UDim2.new(1, 0, 0, T.Sizes.TopBarHeight),
		ZIndex = 2,
		Parent = window,
	})
	NAstatsUI.createInstance("UICorner", { CornerRadius = T.Radius.Window }, topBar)

	local title = NAstatsUI.createInstance("TextLabel", {
		Name = "Title",
		BackgroundTransparency = 1,
		Position = UDim2.new(0, 12, 0, 0),
		Size = UDim2.new(1, -90, 1, 0),
		Font = T.Fonts.Title,
		Text = titleText,
		TextColor3 = T.Colors.Text,
		TextSize = IsOnMobile and 16 or 15,
		TextXAlignment = Enum.TextXAlignment.Left,
		RichText = true,
		ZIndex = 3,
		Parent = topBar,
	})

	local function createActionButton(name, text, color, offset)
		local btn = NAstatsUI.createInstance("TextButton", {
			Name = name,
			BackgroundColor3 = color,
			Position = UDim2.new(1, -offset, 0.5, 0),
			AnchorPoint = Vector2.new(0.5, 0.5),
			Size = UDim2.fromOffset(T.Sizes.ActionButton, T.Sizes.ActionButton),
			Font = T.Fonts.BodyBold,
			Text = text,
			TextScaled = true,
			TextColor3 = Color3.new(1, 1, 1),
			ZIndex = 3,
			RichText = true,
			Parent = topBar,
		})
		NAstatsUI.createInstance("UICorner", { CornerRadius = T.Radius.Button }, btn)
		return btn
	end

	local closeButton = createActionButton("Close", "X", T.Colors.Close, IsOnMobile and 36 or 30)
	local minimizeButton = createActionButton("Minimize", "–", T.Colors.Minimize, IsOnMobile and 68 or 56)

	local content = NAstatsUI.createInstance("Frame", {
		Name = "Content",
		BackgroundTransparency = 1,
		Position = UDim2.new(0, 10, 0, T.Sizes.TopBarHeight + 8),
		Size = UDim2.new(1, -20, 1, -(T.Sizes.TopBarHeight + 18)),
		ZIndex = 2,
		Parent = window
	})
	NAstatsUI.createInstance("UIPadding", { PaddingLeft = UDim.new(0, 8), PaddingRight = UDim.new(0, 8), PaddingTop = UDim.new(0, 2), PaddingBottom = UDim.new(0, 2) }, content)

	NAgui.draggerV2(holder, topBar)
	local collapsed = false
	local baseTitleText = titleText
	local collapsedTitleText = titleText

	minimizeButton.MouseButton1Click:Connect(function()
		collapsed = not collapsed
		content.Visible = not collapsed
		if collapsed then
			holder.Size = UDim2.fromOffset(holder.AbsoluteSize.X, T.Sizes.TopBarHeight + 8)
			title.Text = collapsedTitleText
		else
			holder.Size = baseSize
			title.Text = baseTitleText
		end
	end)

	return {
		screenGui = screenGui, holder = holder, window = window, title = title, content = content, closeButton = closeButton, minimizeButton = minimizeButton,
		setBaseTitle = function(t) baseTitleText = t if not collapsed then title.Text = t end end,
		setCollapsedTitle = function(t) collapsedTitleText = t if collapsed then title.Text = t end end,
		bringToFront = function() windowCounter += 1; screenGui.DisplayOrder = 100 + windowCounter end,
	}
end

function NAstatsUI.createStatDisplay(parent, titleText, subtitleText)
	local T = NAstatsUI.Theme
	local container = NAstatsUI.createInstance("Frame", { BackgroundTransparency = 1, Size = UDim2.new(1, 0, 1, 0), Parent = parent })

	local valueLabel = NAstatsUI.createInstance("TextLabel", {
		Name = "ValueLabel", BackgroundTransparency = 1, Size = UDim2.new(1, 0, 0, IsOnMobile and 36 or 32),
		Font = T.Fonts.BodySemibold, Text = "—", TextSize = IsOnMobile and 28 or 24, TextColor3 = T.Colors.TextSubtle,
		TextXAlignment = Enum.TextXAlignment.Left, RichText = true, Parent = container,
	})

	local subtitleLabel = NAstatsUI.createInstance("TextLabel", {
		Name = "SubtitleLabel", BackgroundTransparency = 1, Size = UDim2.new(1, 0, 0, IsOnMobile and 18 or 16),
		Position = UDim2.new(0, 0, 0, IsOnMobile and 40 or 36), Font = T.Fonts.Body, Text = subtitleText,
		TextSize = IsOnMobile and 16 or 14, TextColor3 = T.Colors.TextMuted, TextXAlignment = Enum.TextXAlignment.Left,
		RichText = true, Parent = container,
	})

	return { value = valueLabel, subtitle = subtitleLabel }
end

function NAstatsUI.createStatCommand(config)
	return NAstatsUI.ensureSingle(config.key, function()
		local baseHeight = IsOnMobile and 124 or 104
		local ui = NAstatsUI.createWindow(config.position, UDim2.new(0, 240, 0, baseHeight), config.title)
		local statDisplay = NAstatsUI.createStatDisplay(ui.content, config.title, config.subtitle)
		local lastUpdate = 0
		local updateInterval = 0.5

		local conn = RunService.RenderStepped:Connect(function(dt)
			local now = os.clock()
			if now - lastUpdate < updateInterval then return end

			local value, rawValue = config.updateFn(dt)
			local color = config.colorFn(rawValue)

			statDisplay.value.Text = "<b>"..value.."</b>"
			statDisplay.value.TextColor3 = color

			local collapsedText = Format("%s: <font color='%s'>%s</font>", config.title, NAstatsUI.colorToHex(color), value)
			ui.setCollapsedTitle(collapsedText)

			lastUpdate = now
		end)
		NAlib.connect("UI:"..config.key, conn)
		ui.closeFunction = function() NAlib.disconnect("UI:"..config.key) end

		return ui
	end)
end

function NAstatsUI.createStatBox(parent, titleText)
	local T = NAstatsUI.Theme
	local box = NAstatsUI.createInstance("Frame", {
		BackgroundColor3 = T.Colors.Secondary, Size = UDim2.new(0.5, -4, 0, IsOnMobile and 64 or 56), Parent = parent
	})
	NAstatsUI.createInstance("UICorner", { CornerRadius = T.Radius.Container }, box)

	NAstatsUI.createInstance("TextLabel", {
		Name = "Title", BackgroundTransparency = 1, Position = UDim2.new(0, 10, 0, 6), Size = UDim2.new(1, -20, 0, IsOnMobile and 22 or 20),
		Font = T.Fonts.BodySemibold, Text = titleText, TextSize = IsOnMobile and 16 or 15, TextColor3 = T.Colors.Text,
		TextXAlignment = Enum.TextXAlignment.Left, RichText = true, Parent = box
	})

	local valueLabel = NAstatsUI.createInstance("TextLabel", {
		Name = "Value", BackgroundTransparency = 1, Position = UDim2.new(0, 10, 0, IsOnMobile and 30 or 26),
		Size = UDim2.new(1, -20, 0, IsOnMobile and 26 or 22), Font = T.Fonts.Body, Text = "—",
		TextSize = IsOnMobile and 18 or 16, TextColor3 = T.Colors.TextMuted, TextXAlignment = Enum.TextXAlignment.Left,
		RichText = true, Parent = box
	})
	return box, valueLabel
end

cmd.add({"ping"}, {"ping", "Shows your network latency"}, function()
	local T = NAstatsUI.Theme
	NAstatsUI.createStatCommand({
		key = "Ping", title = "Ping", subtitle = "Network latency", position = UDim2.new(0.5, 0, 0.22, 0),
		updateFn = function()
			local pingItem = StatsService.Network.ServerStatsItem["Data Ping"]
			local rawPing = tonumber(pingItem:GetValueString():match("%d+")) or 0
			return tostring(rawPing).." ms", rawPing
		end,
		colorFn = function(ping)
			if ping <= 50 then return T.Colors.Good end
			if ping <= 100 then return T.Colors.Warn end
			return T.Colors.Bad
		end,
	})
end)

cmd.add({"fps"}, {"fps", "Shows your frames per second"}, function()
	local T = NAstatsUI.Theme
	local frameHistory = {}

	NAstatsUI.createStatCommand({
		key = "FPS", title = "FPS", subtitle = "Frames per second", position = UDim2.new(0.5, 0, 0.38, 0),
		updateFn = function(dt)
			Insert(frameHistory, dt)
			if #frameHistory > 60 then table.remove(frameHistory, 1) end

			local sum = 0
			for _, frameTime in ipairs(frameHistory) do sum += frameTime end
			local avg = sum / math.max(1, #frameHistory)
			local fps = math.floor(1 / avg + 0.5)

			return tostring(fps), fps
		end,
		colorFn = function(fps)
			if fps >= 55 then return T.Colors.Good end
			if fps >= 30 then return T.Colors.Warn end
			return T.Colors.Bad
		end,
	})
end)

cmd.add({"stats"}, {"stats", "Shows both FPS and ping"}, function()
	NAstatsUI.ensureSingle("Stats", function()
		local ui = NAstatsUI.createWindow(UDim2.new(0.5, 0, 0.3, 0), UDim2.new(0, 300, 0, IsOnMobile and 160 or 140), "Stats")
		local T = NAstatsUI.Theme

		local grid = NAstatsUI.createInstance("Frame", {
			BackgroundTransparency = 1, Size = UDim2.new(1, 0, 1, 0), Parent = ui.content
		})
		local layout = NAstatsUI.createInstance("UIListLayout", {
			FillDirection = Enum.FillDirection.Horizontal, HorizontalAlignment = Enum.HorizontalAlignment.Center,
			VerticalAlignment = Enum.VerticalAlignment.Top, SortOrder = Enum.SortOrder.LayoutOrder,
			Padding = UDim.new(0, 8), Parent = grid,
		})

		local pingBox, pingValue = NAstatsUI.createStatBox(grid, "Ping")
		local fpsBox, fpsValue = NAstatsUI.createStatBox(grid, "FPS")

		local frames, lastUpdate, updateInterval = {}, 0, 0.5
		local pingColorFn = function(p) if p <= 50 then return T.Colors.Good end; if p <= 100 then return T.Colors.Warn end; return T.Colors.Bad end
		local fpsColorFn = function(f) if f >= 55 then return T.Colors.Good end; if f >= 30 then return T.Colors.Warn end; return T.Colors.Bad end

		local conn = RunService.RenderStepped:Connect(function(dt)
			Insert(frames, dt)
			if #frames > 60 then table.remove(frames, 1) end
			local t = os.clock()
			if t - lastUpdate < updateInterval then return end

			local sum = 0
			for i = 1, #frames do sum += frames[i] end
			local avg = sum / math.max(1, #frames)
			local fps = math.max(1, math.floor(1 / avg + 0.5))

			local pingItem = StatsService.Network.ServerStatsItem["Data Ping"]
			local p = tonumber(pingItem:GetValueString():match("%d+")) or 0

			pingValue.Text = "<b>"..tostring(p).." ms</b>"
			pingValue.TextColor3 = pingColorFn(p)
			fpsValue.Text = "<b>"..tostring(fps).."</b>"
			fpsValue.TextColor3 = fpsColorFn(fps)

			local collapsedTitle = Format("Stats: <font color='%s'>%d ms</font> | <font color='%s'>%d FPS</font>", NAstatsUI.colorToHex(pingColorFn(p)), p, NAstatsUI.colorToHex(fpsColorFn(fps)), fps)
			ui.setCollapsedTitle(collapsedTitle)
			lastUpdate = t
		end)
		NAlib.connect("UI:Stats", conn)
		ui.closeFunction = function() NAlib.disconnect("UI:Stats") end

		return ui
	end)
end)

cmd.add({"commands","cmds"},{"commands","Open the command list"},function()
	NAgui.commands()
end)

cmd.add({"settings"},{"settings","Open the settings menu"},function()
	NAgui.settingss()
end)

cmd.add({"waypoints", "wp"},{"waypoints","Open the waypoints menu"},function()
	NAgui.waypointers()
end)

cmd.add({"binders", "binds"},{"binders","Open the event binder menu"},function()
	NAgui.eventbinders()
end)

cmd.add({"setwaypoint","setwp"},{"setwaypoint <name>", "Store your current position under that name"},function(name)
	if not name or name == "" then
		DoNotif("Usage: setwaypoint <name>")
		return
	end

	local char = getChar() or LocalPlayer.CharacterAdded:Wait()
	local cf
	if char then
		cf = char:GetPivot()
	end

	if not cf then
		DoNotif("Unable to get your character's position.")
		return
	end

	Waypoints[name] = { Components = { cf:GetComponents() } }
	NAmanage.SaveWaypoints()
	NAmanage.UpdateWaypointList()
	DebugNotif(("Waypoint '%s' set."):format(name))
end,true)

cmd.add({"gotowaypoint","gotowp"},{"gotowaypoint <name>", "Teleport to a saved waypoint"},function(name)
	if not name or name == "" then
		DoNotif("Usage: gotowaypoint <name>")
		return
	end
	local entry = Waypoints[name]
	if not entry then
		DoNotif(("No such waypoint '%s'."):format(name))
		return
	end
	local comps = entry.Components
	if type(comps) ~= "table" then
		DoNotif(("Waypoint '%s' is invalid."):format(name))
		return
	end
	local ok, cf = pcall(function()
		return CFrame.new(unpack(comps))
	end)
	if not ok or typeof(cf) ~= "CFrame" then
		DoNotif(("Failed to load waypoint '%s'."):format(name))
		return
	end
	local char = getChar()
	if not char then
		char = LocalPlayer and LocalPlayer.Character or nil
		if not char and LocalPlayer then
			char = LocalPlayer.CharacterAdded:Wait()
		end
	end
	if not char then
		DoNotif("Unable to get your character.")
		return
	end
	char:PivotTo(cf)
	DebugNotif(("Teleported to waypoint '%s'."):format(name))
end,true)

cmd.add({"removewaypoint","removewp","rwp"},{"removewaypoint <name>", "Remove a saved waypoint"},function(name)
	if not name or name == "" then
		DoNotif("Usage: removewaypoint <name>")
		return
	end

	if Waypoints[name] then
		Waypoints[name] = nil
		NAmanage.SaveWaypoints()
		NAmanage.UpdateWaypointList()
		DebugNotif(("Waypoint '%s' removed."):format(name))
	else
		DoNotif(("No such waypoint '%s'."):format(name))
	end
end,true)

debugUI, isMinimized = nil, false

cmd.add({"chardebug","cdebug"},{"chardebug (cdebug)","debug your character"},function()
	local CONN_KEY = "CharDebug"
	local RENDER_BIND = "CharDebug"

	local LogService = SafeGetService("LogService")
	local StatsService = SafeGetService("Stats")
	local CoreGui = SafeGetService("CoreGui")

	local UI_SIZE = Vector2.new(860, 520)
	local HEADER_H = 48
	local TAB_H = 36
	local BG_COLOR = Color3.fromRGB(20, 20, 20)
	local PANEL_BG = Color3.fromRGB(26, 26, 26)
	local ACCENT = Color3.fromRGB(95, 165, 255)
	local UPDATE_RATE = 1/30
	local MAX_LOGS = 600

	local LocalPlayer = Players.LocalPlayer
	local paused = false
	local fps, fpsAlpha, dtAcc = 0, 0, 0
	local lastDt = UPDATE_RATE
	local activeTab = "Overview"
	local logs, errCount, warnCount, infoCount = {}, 0, 0, 0

	if debugUI then
		debugUI:Destroy()
		debugUI = nil
		NAlib.disconnect(CONN_KEY)
		RunService:UnbindFromRenderStep(RENDER_BIND)
		return
	end

	local function velOf(r)
		if not r then return Vector3.zero end
		local v = NAlib.isProperty(r,"AssemblyLinearVelocity") or Vector3.zero
		if v.Magnitude == 0 and NAlib.isProperty(r,"Velocity") then v = r.Velocity end
		return v
	end
	local function angVelOf(r)
		if not r then return Vector3.zero end
		local v = NAlib.isProperty(r,"AssemblyAngularVelocity") or Vector3.zero
		if NAlib.isProperty(r,"RotVelocity") then v = r.RotVelocity end
		return v
	end
	local function char() return LocalPlayer.Character end
	local function hum() local c=char() return c and c:FindFirstChildOfClass("Humanoid") or nil end
	local function root(c)
		c = c or char()
		return c and (c:FindFirstChild("HumanoidRootPart") or c:FindFirstChild("Torso") or c:FindFirstChild("UpperTorso")) or nil
	end
	local function raycastDown(origin, dist)
		local params = RaycastParams.new()
		params.FilterType = Enum.RaycastFilterType.Exclude
		local c = char()
		params.FilterDescendantsInstances = c and {c} or {}
		return workspace:Raycast(origin, Vector3.new(0,-math.abs(dist or 1000),0), params)
	end
	local function getPingMs()
		local ok,ms = pcall(function()
			local net = StatsService:FindFirstChild("Network")
			if not net then return nil end
			local p = (net:FindFirstChild("ServerStatsItem") and net.ServerStatsItem:FindFirstChild("Data Ping")) or net:FindFirstChild("Data Ping")
			if not p then return nil end
			if p.GetValue then
				local v = p:GetValue()
				if typeof(v) == "number" then return v end
			end
			if p.GetValueString then
				local s = p:GetValueString()
				if type(s) == "string" then
					local n = tonumber((s:gsub("[^%d%.]","")))
					return n
				end
			end
			return nil
		end)
		if ok then return ms end
		return nil
	end
	local function getMem()
		local ok,total = pcall(function() return StatsService:GetTotalMemoryUsageMb() end)
		local tags = {"Internal","Instances","Signals","Physics","GraphicsTexture","LuaHeap","HttpCache","Animation","Pathfinding","Sounds","Terrain","Navigation"}
		local map = {}
		if ok then map.Total = total end
		for _,t in ipairs(tags) do
			local ok2,val = pcall(function() return StatsService:GetMemoryUsageMbForTag(t) end)
			if ok2 then map[t] = val end
		end
		return map
	end
	local function pushLog(msg, t)
		local tag = tostring(t)
		if tag:find("Error") then errCount += 1 elseif tag:find("Warning") then warnCount += 1 else infoCount += 1 end
		Insert(logs, os.date("%X").." | "..tag.." | "..msg)
		if #logs > MAX_LOGS then table.remove(logs,1) end
	end

	local function NewI(c) return InstanceNew(c) end
	local function new(class, props) local inst = NewI(class) for k,v in pairs(props) do inst[k] = v end return inst end

	debugUI = new("ScreenGui",{Name="CharDebugUI",ResetOnSpawn=false,IgnoreGuiInset=true,ZIndexBehavior=Enum.ZIndexBehavior.Sibling,DisplayOrder=1000})
	pcall(function() NaProtectUI(debugUI) end)

	local window = new("Frame",{Name="Window", Size=UDim2.fromOffset(UI_SIZE.X, UI_SIZE.Y), Position=UDim2.new(0.5,-UI_SIZE.X/2,0.22,0), BackgroundColor3=BG_COLOR, BorderSizePixel=0, ClipsDescendants=true, Parent=debugUI, ZIndex=10})
	new("UICorner",{CornerRadius=UDim.new(0,14),Parent=window})
	new("UIStroke",{Thickness=1,ApplyStrokeMode=Enum.ApplyStrokeMode.Border,Color=Color3.fromRGB(35,35,35),Parent=window})

	local hdr = new("Frame",{Name="Header", Size=UDim2.new(1,0,0,HEADER_H), BackgroundColor3=BG_COLOR, BorderSizePixel=0, Parent=window, ZIndex=50})
	local hdrStroke = new("UIStroke",{Thickness=1,ApplyStrokeMode=Enum.ApplyStrokeMode.Border,Color=Color3.fromRGB(45,45,45),Parent=hdr})
	new("UICorner",{CornerRadius=UDim.new(0,14),Parent=hdr})

	local title = new("TextLabel",{Name="Title", Size=UDim2.new(0.5,-12,1,0), Position=UDim2.new(0,12,0,0), BackgroundTransparency=1, Font=Enum.Font.Code, TextSize=18, TextColor3=Color3.new(1,1,1), TextXAlignment=Enum.TextXAlignment.Left, Text="Character Debug", Parent=hdr, ZIndex=60})

	local right = new("Frame",{Name="Right", AnchorPoint=Vector2.new(1,0), Position=UDim2.new(1,-8,0,6), Size=UDim2.new(0,0,1,-12), BackgroundTransparency=1, AutomaticSize=Enum.AutomaticSize.X, Parent=hdr, ZIndex=60})
	new("UIListLayout",{FillDirection=Enum.FillDirection.Horizontal,HorizontalAlignment=Enum.HorizontalAlignment.Right,VerticalAlignment=Enum.VerticalAlignment.Center,Padding=UDim.new(0,6),Parent=right})

	local status = new("TextLabel",{Name="Status", Size=UDim2.fromOffset(178,HEADER_H-16), BackgroundTransparency=0, BackgroundColor3=Color3.fromRGB(30,30,30), Font=Enum.Font.Code, TextSize=14, TextColor3=Color3.fromRGB(230,230,230), TextXAlignment=Enum.TextXAlignment.Center, Text="FPS: -- | Ping: --", Parent=right, ZIndex=61})
	new("UICorner",{CornerRadius=UDim.new(1,8),Parent=status})
	local btnPause = new("TextButton",{Name="Pause", Size=UDim2.fromOffset(74,HEADER_H-16), BackgroundColor3=ACCENT, AutoButtonColor=true, TextColor3=Color3.new(1,1,1), Text="Pause", Font=Enum.Font.Code, TextSize=16, Parent=right, ZIndex=61})
	new("UICorner",{CornerRadius=UDim.new(0,8),Parent=btnPause})
	local btnMin = new("TextButton",{Name="Min", Size=UDim2.fromOffset(44,HEADER_H-16), BackgroundColor3=Color3.fromRGB(45,45,45), AutoButtonColor=true, TextColor3=Color3.new(1,1,1), Text="–", Font=Enum.Font.Code, TextSize=20, Parent=right, ZIndex=61})
	new("UICorner",{CornerRadius=UDim.new(0,8),Parent=btnMin})
	local btnClose = new("TextButton",{Name="Close", Size=UDim2.fromOffset(44,HEADER_H-16), BackgroundColor3=Color3.fromRGB(140,55,55), AutoButtonColor=true, TextColor3=Color3.new(1,1,1), Text="×", Font=Enum.Font.Code, TextSize=20, Parent=right, ZIndex=61})
	new("UICorner",{CornerRadius=UDim.new(0,8),Parent=btnClose})

	local tabbar = new("ScrollingFrame",{Name="Tabs", Size=UDim2.new(1,0,0,TAB_H), Position=UDim2.new(0,0,0,HEADER_H), BackgroundColor3=Color3.fromRGB(28,28,28), BorderSizePixel=0, Parent=window, ScrollingDirection=Enum.ScrollingDirection.X, ScrollBarThickness=6, Active=true, CanvasSize=UDim2.new(), ZIndex=30})
	local tabsHolder = new("Frame",{Name="Holder", BackgroundTransparency=1, Size=UDim2.new(0,0,1,0), Parent=tabbar, ZIndex=31})
	local uilist = new("UIListLayout",{FillDirection=Enum.FillDirection.Horizontal,Padding=UDim.new(0,6),HorizontalAlignment=Enum.HorizontalAlignment.Left,VerticalAlignment=Enum.VerticalAlignment.Center,Parent=tabsHolder})

	local content = new("Frame",{Name="Content", Size=UDim2.new(1,0,1,-(HEADER_H+TAB_H)), Position=UDim2.new(0,0,0,HEADER_H+TAB_H), BackgroundTransparency=1, BorderSizePixel=0, Parent=window, ZIndex=20})
	local cardsScroll = new("ScrollingFrame",{Name="CardsScroll", Active=true, ScrollingDirection=Enum.ScrollingDirection.Y, ScrollBarThickness=6, BackgroundTransparency=1, BorderSizePixel=0, Size=UDim2.fromScale(1,1), Parent=content, ZIndex=21})
	new("UIPadding",{PaddingLeft=UDim.new(0,12),PaddingTop=UDim.new(0,12),Parent=cardsScroll})
	local cardsHolder = new("Frame",{Name="CardsHolder", BackgroundTransparency=1, Size=UDim2.new(1,-24,0,0), Position=UDim2.new(0,12,0,12), Parent=cardsScroll, AutomaticSize=Enum.AutomaticSize.Y, ZIndex=22})
	local grid = new("UIGridLayout",{Parent=cardsHolder, CellSize=UDim2.fromOffset(400,86), CellPadding=UDim2.new(0,10,0,10), StartCorner=Enum.StartCorner.TopLeft, SortOrder=Enum.SortOrder.LayoutOrder})
	cardsScroll.CanvasSize = UDim2.fromOffset(0, grid.AbsoluteContentSize.Y + 24)

	local logsHolder = new("Frame",{Name="LogsHolder", BackgroundTransparency=1, Visible=false, Size=UDim2.fromScale(1,1), Parent=content, ZIndex=21})
	local panel = new("Frame",{Name="LogPanel", BackgroundColor3=PANEL_BG, BorderSizePixel=0, Parent=logsHolder, Size=UDim2.new(1,-24,1,-24), Position=UDim2.new(0,12,0,12), ZIndex=22})
	new("UICorner",{CornerRadius=UDim.new(0,10),Parent=panel})
	new("UIStroke",{Thickness=1,ApplyStrokeMode=Enum.ApplyStrokeMode.Border,Color=Color3.fromRGB(40,40,40),Parent=panel})
	local counts = new("TextLabel",{Name="Counts", BackgroundTransparency=1, Position=UDim2.new(0,10,0,8), Size=UDim2.new(1,-20,0,18), Font=Enum.Font.Code, TextSize=14, TextColor3=Color3.fromRGB(200,200,200), TextXAlignment=Enum.TextXAlignment.Left, Text="Info:0  Warn:0  Error:0", Parent=panel, ZIndex=23})
	local logScroll = new("ScrollingFrame",{Name="Scroll", Active=true, ScrollBarThickness=6, ScrollingDirection=Enum.ScrollingDirection.Y, BackgroundTransparency=1, BorderSizePixel=0, Size=UDim2.new(1,-20,1,-40), Position=UDim2.new(0,10,0,30), Parent=panel, ZIndex=23})
	local logText = new("TextLabel",{Name="Text", BackgroundTransparency=1, Size=UDim2.new(1,-4,0,0), Position=UDim2.new(0,2,0,0), Font=Enum.Font.Code, TextXAlignment=Enum.TextXAlignment.Left, TextYAlignment=Enum.TextYAlignment.Top, TextWrapped=false, TextScaled=false, TextSize=14, TextColor3=Color3.fromRGB(230,230,230), Text="", Parent=logScroll, AutomaticSize=Enum.AutomaticSize.Y, ZIndex=23})
	new("UITextSizeConstraint",{Parent=logText, MaxTextSize=18, MinTextSize=12})

	local tabsList = {"Overview","Movement","Humanoid","Camera","World","Network","Memory","Anim","Tools","Inputs","Physics","Perf","Logs"}
	local tabBtns = {}
	for _, name in ipairs(tabsList) do
		local b = new("TextButton",{Name=name, Size=UDim2.fromOffset(126, TAB_H-10), BackgroundColor3=(name==activeTab) and ACCENT or Color3.fromRGB(45,45,45), AutoButtonColor=true, TextColor3=Color3.new(1,1,1), Text=name, Font=Enum.Font.Code, TextSize=14, Parent=tabsHolder, ZIndex=32})
		new("UICorner",{CornerRadius=UDim.new(0,8),Parent=b})
		tabBtns[name] = b
	end

	local dockGui = new("ScreenGui",{Name="CharDebugDock",ResetOnSpawn=false,IgnoreGuiInset=true,ZIndexBehavior=Enum.ZIndexBehavior.Sibling,DisplayOrder=1100,Parent=CoreGui})
	local dock = new("Frame",{Name="Dock", Size=UDim2.fromOffset(64,64), AnchorPoint=Vector2.new(0,1), Position=UDim2.new(0,16,1,-16), BackgroundColor3=ACCENT, Visible=false, Parent=dockGui, ZIndex=100})
	new("UICorner",{CornerRadius=UDim.new(0,20),Parent=dock})
	local dockLabel = new("TextButton",{Name="Btn", BackgroundTransparency=1, Size=UDim2.fromScale(1,1), Text="CD", Font=Enum.Font.Code, TextSize=20, TextColor3=Color3.new(1,1,1), Parent=dock, ZIndex=101})

	local cards, values = {}, {}

	local function makeCard(parent, key, height)
		local f = new("Frame",{Name=key, Size=UDim2.fromOffset(400,height or 86), BackgroundColor3=PANEL_BG, BorderSizePixel=0, Parent=parent, ZIndex=22})
		new("UICorner",{CornerRadius=UDim.new(0,10),Parent=f})
		new("UIStroke",{Thickness=1,ApplyStrokeMode=Enum.ApplyStrokeMode.Border,Color=Color3.fromRGB(40,40,40),Parent=f})
		new("TextLabel",{Name="Key", BackgroundTransparency=1, Position=UDim2.new(0,10,0,8), Size=UDim2.new(1,-20,0,16), Font=Enum.Font.Code, TextSize=14, TextColor3=Color3.fromRGB(180,180,180), TextXAlignment=Enum.TextXAlignment.Left, Text=key, Parent=f, ZIndex=23})
		local val = new("TextLabel",{Name="Val", BackgroundTransparency=1, Position=UDim2.new(0,10,0,28), Size=UDim2.new(1,-20,1,-36), Font=Enum.Font.Code, TextSize=16, TextColor3=Color3.new(1,1,1), TextXAlignment=Enum.TextXAlignment.Left, TextWrapped=true, Text="", Parent=f, ZIndex=23})
		return f, val
	end
	local function clearCards() for _,v in pairs(cards) do v:Destroy() end cards, values = {}, {} end
	local function addCard(key, h)
		local card, val = makeCard(cardsHolder, key, h)
		cards[key] = card
		values[key] = val
		card.BackgroundTransparency = 0.35
		TweenService:Create(card, TweenInfo.new(0.18, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {BackgroundTransparency = 0.15}):Play()
	end

	NAlib.connect(CONN_KEY, grid:GetPropertyChangedSignal("AbsoluteContentSize"):Connect(function()
		cardsScroll.CanvasSize = UDim2.fromOffset(0, grid.AbsoluteContentSize.Y + 24)
	end))
	NAlib.connect(CONN_KEY, uilist:GetPropertyChangedSignal("AbsoluteContentSize"):Connect(function()
		local w = uilist.AbsoluteContentSize.X + 12
		tabsHolder.Size = UDim2.fromOffset(w, TAB_H)
		tabbar.CanvasSize = UDim2.fromOffset(w + 12, TAB_H)
	end))
	NAlib.connect(CONN_KEY, tabbar.InputChanged:Connect(function(i)
		if i.UserInputType == Enum.UserInputType.MouseWheel then
			local x = math.clamp(tabbar.CanvasPosition.X - i.Position.Z*32, 0, math.max(0, tabbar.CanvasSize.X.Offset - tabbar.AbsoluteSize.X))
			tabbar.CanvasPosition = Vector2.new(x, 0)
		end
	end))

	local function setTab(name)
		activeTab = name
		for n,b in pairs(tabBtns) do TweenService:Create(b, TweenInfo.new(0.15), {BackgroundColor3 = (n==name) and ACCENT or Color3.fromRGB(45,45,45)}):Play() end
		local showLogs = (name == "Logs")
		cardsScroll.Visible = not showLogs
		logsHolder.Visible = showLogs
		if not showLogs then
			clearCards()
			if name=="Overview" then
				addCard("Username"); addCard("UserId")
				addCard("Position"); addCard("Velocity"); addCard("Speed"); addCard("AngularVel")
				addCard("Health"); addCard("State"); addCard("MoveDirection"); addCard("FloorMaterial")
				addCard("Tool"); addCard("FOV")
			elseif name=="Movement" then
				addCard("WalkSpeed"); addCard("JumpPower"); addCard("JumpHeight"); addCard("HipHeight")
				addCard("AutoRotate"); addCard("AssemblyMass"); addCard("PlatformStand"); addCard("Sit"); addCard("Airborne")
			elseif name=="Humanoid" then
				addCard("RigType"); addCard("MaxHealth"); addCard("HealthDisplayType"); addCard("StatesEnabled",110); addCard("SeatPart"); addCard("MoveTo")
			elseif name=="Camera" then
				addCard("CameraType"); addCard("Subject"); addCard("SubjectDistance"); addCard("CameraCFrame",110); addCard("FOV")
			elseif name=="World" then
				addCard("Gravity"); addCard("ClockTime"); addCard("Brightness"); addCard("EnvSpecular"); addCard("CurrentZone")
			elseif name=="Network" then
				addCard("Ping"); addCard("DataInKbps"); addCard("DataOutKbps")
			elseif name=="Memory" then
				addCard("TotalMB"); addCard("LuaHeapMB"); addCard("InstancesMB"); addCard("GraphicsTextureMB"); addCard("PhysicsMB"); addCard("TerrainMB"); addCard("PathfindingMB")
			elseif name=="Anim" then
				addCard("PlayingTracks",130)
			elseif name=="Tools" then
				addCard("EquippedTool"); addCard("BackpackItems",130)
			elseif name=="Inputs" then
				addCard("KeysDown",130); addCard("LastInput")
			elseif name=="Physics" then
				addCard("GroundDist"); addCard("GroundNormal"); addCard("SlopeAngle"); addCard("UnderPart"); addCard("HumanoidRootCFrame",110); addCard("PivotOffset")
			elseif name=="Perf" then
				addCard("HeartbeatDt"); addCard("ServerTime"); addCard("TouchingParts")
			end
			cardsScroll.CanvasSize = UDim2.fromOffset(0, grid.AbsoluteContentSize.Y + 24)
		else
			counts.Text = Format("Info:%d  Warn:%d  Error:%d", infoCount, warnCount, errCount)
			logText.Text = (#logs>0) and Concat(logs,"\n") or ""
			local h = logText.TextBounds.Y
			logScroll.CanvasSize = UDim2.fromOffset(0, h)
			logScroll.CanvasPosition = Vector2.new(0, math.max(0, h - logScroll.AbsoluteSize.Y))
		end
	end

	for _,b in pairs(tabBtns) do
		NAlib.connect(CONN_KEY, b.MouseButton1Click:Connect(function() setTab(b.Name) end))
		NAlib.connect(CONN_KEY, b.MouseEnter:Connect(function() TweenService:Create(b, TweenInfo.new(0.12), {TextTransparency = 0.05}):Play() end))
		NAlib.connect(CONN_KEY, b.MouseLeave:Connect(function() TweenService:Create(b, TweenInfo.new(0.12), {TextTransparency = 0}):Play() end))
	end

	local dragging, dragStart, startPos
	NAlib.connect(CONN_KEY, hdr.InputBegan:Connect(function(i) if i.UserInputType~=Enum.UserInputType.MouseButton1 then return end dragging=true; dragStart=i.Position; startPos=window.Position end))
	NAlib.connect(CONN_KEY, hdr.InputChanged:Connect(function(i) if not dragging then return end local d=i.Position-dragStart window.Position=UDim2.new(startPos.X.Scale,startPos.X.Offset+d.X,startPos.Y.Scale,startPos.Y.Offset+d.Y) end))
	NAlib.connect(CONN_KEY, UserInputService.InputEnded:Connect(function(i) if i.UserInputType==Enum.UserInputType.MouseButton1 then dragging=false end end))

	local pressed, lastInput = {}, "-"
	NAlib.connect(CONN_KEY, UserInputService.InputBegan:Connect(function(input,gp)
		if gp then return end
		if input.UserInputType == Enum.UserInputType.Keyboard then
			pressed[input.KeyCode.Name] = true
			lastInput = input.KeyCode.Name
		elseif input.UserInputType == Enum.UserInputType.MouseButton1 then lastInput = "Mouse1"
		elseif input.UserInputType == Enum.UserInputType.MouseButton2 then lastInput = "Mouse2"
		elseif input.UserInputType == Enum.UserInputType.MouseWheel then lastInput = "Wheel" end
	end))
	NAlib.connect(CONN_KEY, UserInputService.InputEnded:Connect(function(input,gp)
		if gp then return end
		if input.UserInputType == Enum.UserInputType.Keyboard then pressed[input.KeyCode.Name] = nil end
	end))
	NAlib.connect(CONN_KEY, LogService.MessageOut:Connect(function(m,t)
		pushLog(m,t)
		if activeTab=="Logs" then
			counts.Text = Format("Info:%d  Warn:%d  Error:%d", infoCount, warnCount, errCount)
			logText.Text = (#logs>0) and Concat(logs,"\n") or ""
			local h = logText.TextBounds.Y
			logScroll.CanvasSize = UDim2.fromOffset(0, h)
			logScroll.CanvasPosition = Vector2.new(0, math.max(0, h - logScroll.AbsoluteSize.Y))
		end
	end))

	local function setVal(key, text) local lbl=values[key] if lbl then lbl.Text=text end end
	local function getTool() local c=char() return c and c:FindFirstChildOfClass("Tool") or nil end
	local function statsNetKbps() local i,o; local okI,vI=pcall(function() return StatsService.DataReceiveKbps end); if okI then i=vI end local okO,vO=pcall(function() return StatsService.DataSendKbps end); if okO then o=vO end return i,o end

	local function updateOverview(h, r)
		setVal("Username", LocalPlayer and LocalPlayer.Name or "N/A")
		setVal("UserId", LocalPlayer and tostring(LocalPlayer.UserId) or "N/A")
		if r then
			local p = r.Position
			setVal("Position", Format("X: %.2f  Y: %.2f  Z: %.2f", p.X, p.Y, p.Z))
			local v = velOf(r)
			setVal("Velocity", Format("X: %.2f  Y: %.2f  Z: %.2f", v.X, v.Y, v.Z))
			setVal("Speed", Format("%.2f", v.Magnitude))
			local av = angVelOf(r)
			setVal("AngularVel", Format("X: %.2f  Y: %.2f  Z: %.2f", av.X, av.Y, av.Z))
		end
		if h then
			setVal("Health", Format("%.1f / %.1f", h.Health, h.MaxHealth))
			setVal("State", tostring(h:GetState()))
			local md = h.MoveDirection
			setVal("MoveDirection", Format("X: %.2f  Y: %.2f  Z: %.2f", md.X, md.Y, md.Z))
			setVal("FloorMaterial", tostring(h.FloorMaterial))
		end
		local t = getTool()
		setVal("Tool", t and t.Name or "None")
		local cam = workspace.CurrentCamera
		if cam then setVal("FOV", Format("%.1f", cam.FieldOfView)) end
	end
	local function updateMovement(h, r)
		if h then
			setVal("WalkSpeed", Format("%.2f", h.WalkSpeed))
			setVal("JumpPower", Format("%.2f", h.JumpPower))
			local okJH, jh = pcall(function() return h.JumpHeight end)
			setVal("JumpHeight", okJH and Format("%.2f", jh) or "N/A")
			setVal("HipHeight", Format("%.2f", h.HipHeight))
			setVal("AutoRotate", tostring(h.AutoRotate))
			setVal("PlatformStand", tostring(h.PlatformStand))
			setVal("Sit", tostring(h.Sit))
			local airborne = h:GetState() == Enum.HumanoidStateType.Freefall or h:GetState() == Enum.HumanoidStateType.Jumping
			setVal("Airborne", tostring(airborne))
		end
		if r then setVal("AssemblyMass", Format("%.2f", r.AssemblyMass)) end
	end
	local function updateHumanoid(h)
		if not h then return end
		setVal("RigType", tostring(h.RigType))
		setVal("MaxHealth", Format("%.1f", h.MaxHealth))
		setVal("HealthDisplayType", tostring(h.HealthDisplayType))
		local states = {"Running","RunningNoPhysics","Jumping","Freefall","Landed","Seated","Climbing","Swimming","FallingDown","Ragdoll","GettingUp","Flying"}
		local list = {}
		for _,s in ipairs(states) do local ok,val=pcall(function() return h:GetStateEnabled(Enum.HumanoidStateType[s]) end) Insert(list, Format("%s:%s", s, ok and tostring(val) or "N/A")) end
		setVal("StatesEnabled", Concat(list,"  "))
		local seat = h.SeatPart
		setVal("SeatPart", seat and seat.Name or "None")
		local mpos = h.WalkToPoint
		setVal("MoveTo", Format("X: %.1f  Y: %.1f  Z: %.1f", mpos.X, mpos.Y, mpos.Z))
	end
	local function updateCamera(_, r)
		local cam = workspace.CurrentCamera
		if not cam then return end
		setVal("CameraType", tostring(cam.CameraType))
		local subj = cam.CameraSubject
		setVal("Subject", subj and subj.Name or "None")
		if r then setVal("SubjectDistance", Format("%.2f", (cam.CFrame.Position - r.Position).Magnitude)) else setVal("SubjectDistance", "N/A") end
		local cf = cam.CFrame
		local rx,ry,rz = cf:ToOrientation()
		setVal("CameraCFrame", Format("P(%.1f,%.1f,%.1f)  R(%.2f,%.2f,%.2f)", cf.X, cf.Y, cf.Z, rx, ry, rz))
		setVal("FOV", Format("%.1f", cam.FieldOfView))
	end
	local function updateWorld()
		setVal("Gravity", Format("%.1f", workspace.Gravity))
		setVal("ClockTime", Format("%.2f", Lighting.ClockTime))
		setVal("Brightness", Format("%.2f", Lighting.Brightness))
		local okE, env = pcall(function() return Lighting.EnvironmentSpecularScale end)
		setVal("EnvSpecular", okE and Format("%.2f", env) or "N/A")
		setVal("CurrentZone", "N/A")
	end
	local function updateNetwork()
		local ping = getPingMs()
		setVal("Ping", ping and Format("%.0f ms", ping) or "N/A")
		local inK, outK = statsNetKbps()
		setVal("DataInKbps", inK and Format("%.1f", inK) or "N/A")
		setVal("DataOutKbps", outK and Format("%.1f", outK) or "N/A")
	end
	local function updateMemory()
		local m = getMem()
		setVal("TotalMB", m.Total and Format("%.1f", m.Total) or "N/A")
		setVal("LuaHeapMB", m.LuaHeap and Format("%.1f", m.LuaHeap) or "N/A")
		setVal("InstancesMB", m.Instances and Format("%.1f", m.Instances) or "N/A")
		setVal("GraphicsTextureMB", m.GraphicsTexture and Format("%.1f", m.GraphicsTexture) or "N/A")
		setVal("PhysicsMB", m.Physics and Format("%.1f", m.Physics) or "N/A")
		setVal("TerrainMB", m.Terrain and Format("%.1f", m.Terrain) or "N/A")
		setVal("PathfindingMB", m.Pathfinding and Format("%.1f", m.Pathfinding) or "N/A")
	end
	local function updateAnim(h)
		if not h then setVal("PlayingTracks","None"); return end
		local animator = h:FindFirstChildOfClass("Animator")
		if not animator then setVal("PlayingTracks","None"); return end
		local tracks = animator:GetPlayingAnimationTracks()
		if #tracks == 0 then setVal("PlayingTracks","None"); return end
		local lines = {}
		for _,t in ipairs(tracks) do
			local name = (t.Animation and t.Animation.Name) or t.Name or "Track"
			Insert(lines, Format("%s  w=%.2f  s=%.2f", name, t.WeightCurrent or 0, t.Speed or 1))
		end
		setVal("PlayingTracks", Concat(lines,"  "))
	end
	local function updateTools()
		local t = getTool()
		setVal("EquippedTool", t and t.Name or "None")
		local items, count = {}, 0
		if LocalPlayer.Backpack then
			for _,i in ipairs(LocalPlayer.Backpack:GetChildren()) do
				if i:IsA("Tool") then count += 1; Insert(items, i.Name) end
			end
		end
		setVal("BackpackItems", count > 0 and Concat(items, ", ") or "None")
	end
	local function updateInputs()
		local keys = {} for k,_ in pairs(pressed) do Insert(keys,k) end table.sort(keys)
		setVal("KeysDown", (#keys>0) and Concat(keys,", ") or "None")
		setVal("LastInput", lastInput or "-")
	end
	local function updatePhysics(_, r)
		if not r then
			setVal("GroundDist","N/A"); setVal("GroundNormal","N/A"); setVal("SlopeAngle","N/A"); setVal("UnderPart","N/A"); setVal("HumanoidRootCFrame","N/A"); setVal("PivotOffset","N/A")
			return
		end
		local res = raycastDown(r.Position, 1000)
		if res then
			local d = (r.Position - res.Position).Magnitude
			setVal("GroundDist", Format("%.2f", d))
			setVal("GroundNormal", Format("X: %.2f Y: %.2f Z: %.2f", res.Normal.X, res.Normal.Y, res.Normal.Z))
			local slope = math.deg(math.acos(math.clamp(res.Normal:Dot(Vector3.new(0,1,0)), -1, 1)))
			setVal("SlopeAngle", Format("%.2f°", slope))
			setVal("UnderPart", res.Instance and (res.Instance.Name.." ["..tostring(res.Material).."]") or "None")
		else
			setVal("GroundDist","--"); setVal("GroundNormal","--"); setVal("SlopeAngle","--"); setVal("UnderPart","--")
		end
		local cf = r.CFrame
		local rx,ry,rz = cf:ToOrientation()
		setVal("HumanoidRootCFrame", Format("P(%.1f,%.1f,%.1f)  R(%.2f,%.2f,%.2f)", cf.X, cf.Y, cf.Z, rx, ry, rz))
		local pv = char() and char():GetPivot() or CFrame.identity
		local d = cf.Position - pv.Position
		setVal("PivotOffset", Format("Δ(%.2f, %.2f, %.2f)", d.X, d.Y, d.Z))
	end
	local function updatePerf()
		setVal("HeartbeatDt", Format("%.4f s", lastDt))
		setVal("ServerTime", tostring(os.time()))
		local r = root(); local n=0 if r then for _,p in ipairs(r:GetTouchingParts()) do n+=1 end end
		setVal("TouchingParts", tostring(n))
	end
	local function updateLogs()
		counts.Text = Format("Info:%d  Warn:%d  Error:%d", infoCount, warnCount, errCount)
		logText.Text = (#logs>0) and Concat(logs,"\n") or ""
		local h = logText.TextBounds.Y
		logScroll.CanvasSize = UDim2.fromOffset(0, h)
		logScroll.CanvasPosition = Vector2.new(0, math.max(0, h - logScroll.AbsoluteSize.Y))
	end

	local function safeFPS(dt)
		if not dt or dt ~= dt or dt <= 0 or dt > 1 then return end
		local inst = 1/dt
		if inst ~= inst or inst == math.huge then return end
		if fpsAlpha == 0 then fps = inst; fpsAlpha = 1 else fps = fps*0.9 + inst*0.1 end
	end

	local function refresh()
		if paused then return end
		local h = hum()
		local r = root()
		if activeTab=="Overview" then updateOverview(h,r)
		elseif activeTab=="Movement" then updateMovement(h,r)
		elseif activeTab=="Humanoid" then updateHumanoid(h)
		elseif activeTab=="Camera" then updateCamera(h,r)
		elseif activeTab=="World" then updateWorld()
		elseif activeTab=="Network" then updateNetwork()
		elseif activeTab=="Memory" then updateMemory()
		elseif activeTab=="Anim" then updateAnim(h)
		elseif activeTab=="Tools" then updateTools()
		elseif activeTab=="Inputs" then updateInputs()
		elseif activeTab=="Physics" then updatePhysics(h,r)
		elseif activeTab=="Perf" then updatePerf()
		elseif activeTab=="Logs" then updateLogs()
		end
		local p = getPingMs()
		local f = (fps ~= fps or fps == math.huge or fps <= 0) and "--" or tostring(math.clamp(math.floor(fps + 0.5), 1, 999))
		status.Text = Format("FPS: %s | Ping: %s", f, p and Format("%d ms", p) or "--")
	end

	NAlib.connect(CONN_KEY, btnPause.MouseButton1Click:Connect(function()
		paused = not paused
		btnPause.Text = paused and "Resume" or "Pause"
		TweenService:Create(btnPause, TweenInfo.new(0.12), {BackgroundColor3 = paused and Color3.fromRGB(120,120,120) or ACCENT}):Play()
	end))

	NAlib.connect(CONN_KEY, btnMin.MouseButton1Click:Connect(function()
		if window.Visible then
			local out = TweenService:Create(window, TweenInfo.new(0.18, Enum.EasingStyle.Quad, Enum.EasingDirection.In), {Size = UDim2.fromOffset(UI_SIZE.X*0.96, UI_SIZE.Y*0.96), BackgroundTransparency = 0.4})
			out.Completed:Connect(function()
				window.Visible=false
				dock.Visible=true
				TweenService:Create(dock, TweenInfo.new(0.18, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {Size = UDim2.fromOffset(70,70)}):Play()
			end)
			out:Play()
			Delay(0.25,function() if not window.Visible then dock.Visible=true end end)
		end
	end))

	local dockDragging, dockStart, dockPos
	NAlib.connect(CONN_KEY, dockLabel.InputBegan:Connect(function(i) if i.UserInputType~=Enum.UserInputType.MouseButton1 then return end dockDragging=true dockStart=i.Position dockPos=dock.Position end))
	NAlib.connect(CONN_KEY, dockLabel.InputChanged:Connect(function(i) if not dockDragging then return end local d=i.Position-dockStart dock.Position=UDim2.new(dockPos.X.Scale,dockPos.X.Offset+d.X,dockPos.Y.Scale,dockPos.Y.Offset+d.Y) end))
	NAlib.connect(CONN_KEY, UserInputService.InputEnded:Connect(function(i) if i.UserInputType==Enum.UserInputType.MouseButton1 then dockDragging=false end end))
	NAlib.connect(CONN_KEY, dockLabel.MouseButton1Click:Connect(function()
		if not window.Visible then
			dock.Visible=false
			window.Visible=true
			window.Size = UDim2.fromOffset(UI_SIZE.X*0.96, UI_SIZE.Y*0.96)
			window.BackgroundTransparency = 0.4
			TweenService:Create(window, TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {Size = UDim2.fromOffset(UI_SIZE.X, UI_SIZE.Y), BackgroundTransparency = 0}):Play()
		end
	end))

	NAlib.connect(CONN_KEY, btnClose.MouseButton1Click:Connect(function()
		debugUI:Destroy()
		dockGui:Destroy()
		debugUI = nil
		NAlib.disconnect(CONN_KEY)
		RunService:UnbindFromRenderStep(RENDER_BIND)
	end))

	setTab(activeTab)

	RunService:BindToRenderStep(RENDER_BIND, Enum.RenderPriority.Last.Value, function(dt)
		lastDt = dt
		safeFPS(dt)
		dtAcc += dt
		if dtAcc < UPDATE_RATE then return end
		dtAcc = 0
		refresh()
	end)

	window.Size = UDim2.fromOffset(UI_SIZE.X*0.96, UI_SIZE.Y*0.96)
	TweenService:Create(window, TweenInfo.new(0.22, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {Size = UDim2.fromOffset(UI_SIZE.X, UI_SIZE.Y)}):Play()
end)

cmd.add({"unchardebug","uncdebug"},{"unchardebug (uncdebug)","disable character debug"},function()
	if debugUI then
		debugUI:Destroy()
		debugUI = nil
		NAlib.disconnect("CharDebug")
		SafeGetService("RunService"):UnbindFromRenderStep("CharDebug")
	end
end)

cmd.add({"naked"}, {"naked", "no clothing gang"}, function()
	for _,clothes in ipairs(LocalPlayer.Character:GetChildren()) do
		if clothes:IsA("Shirt") or clothes:IsA("Pants") or clothes:IsA("ShirtGraphic") then
			clothes:Destroy()
		end
	end
end)

Somersault = {btn=nil, key="x", twopi=math.pi*2, flipping=false}

cmd.add({"somersault", "frontflip"}, {"somersault (frontflip)", "Makes you do a clean front flip"}, function(...)
	local function somersaulter()
		if Somersault.flipping then return end
		local c = getChar() or LocalPlayer.CharacterAdded:Wait()
		local hrp = getRoot(c)
		local hum = getHum()
		if not hrp or not hum then return end
		if hum:GetState() ~= Enum.HumanoidStateType.Freefall and hum.FloorMaterial ~= Enum.Material.Air then
			Somersault.flipping = true
			hum.PlatformStand = true
			local axis = -hrp.CFrame.RightVector
			local angSpeed = 20
			local rotated = 0
			hrp.AssemblyLinearVelocity = hrp.CFrame.LookVector * 30 + Vector3.new(0, 30, 0)
			local conn
			conn = RunService.Heartbeat:Connect(function(dt)
				if not hrp.Parent or hum.Health <= 0 then
					if conn then conn:Disconnect() end
					Somersault.flipping = false
					hum.PlatformStand = false
					return
				end
				rotated = rotated + angSpeed * dt
				if rotated >= Somersault.twopi then
					hrp.AssemblyAngularVelocity = Vector3.zero
					hum.PlatformStand = false
					hum:ChangeState(Enum.HumanoidStateType.GettingUp)
					conn:Disconnect()
					Somersault.flipping = false
				else
					hrp.AssemblyAngularVelocity = axis * angSpeed
				end
			end)
		end
	end

	if IsOnMobile then
		if Somersault.btn then
			Somersault.btn:Destroy()
			Somersault.btn = nil
		end

		Somersault.btn = InstanceNew("ScreenGui")
		local flipBtn = InstanceNew("TextButton")
		local corner = InstanceNew("UICorner")
		local aspect = InstanceNew("UIAspectRatioConstraint")

		NaProtectUI(Somersault.btn)
		Somersault.btn.ResetOnSpawn = false

		flipBtn.Parent = Somersault.btn
		flipBtn.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
		flipBtn.BackgroundTransparency = 0.1
		flipBtn.Position = UDim2.new(0.85, 0, 0.5, 0)
		flipBtn.Size = UDim2.new(0.08, 0, 0.1, 0)
		flipBtn.Font = Enum.Font.GothamBold
		flipBtn.Text = "Flip"
		flipBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
		flipBtn.TextSize = 18
		flipBtn.TextWrapped = true
		flipBtn.Active = true
		flipBtn.TextScaled = true

		corner.CornerRadius = UDim.new(0.2, 0)
		corner.Parent = flipBtn

		aspect.Parent = flipBtn
		aspect.AspectRatio = 1.0

		coroutine.wrap(function()
			MouseButtonFix(flipBtn, function()
				somersaulter()
			end)
		end)()

		NAgui.draggerV2(flipBtn)
	else
		NAlib.disconnect("somersault_key")
		NAlib.connect("somersault_key", mouse.KeyDown:Connect(function(KEY)
			if KEY:lower() == Somersault.key then
				somersaulter()
			end
		end))

		DoNotif("Press '"..Somersault.key:upper().."' to flip!", 3)
	end
end, false)

cmd.add({"unsomersault", "unfrontflip"}, {"unsomersault (unfrontflip)", "Disable somersault button and keybind"}, function(...)
	if Somersault.btn then
		Somersault.btn:Destroy()
		Somersault.btn = nil
	end
	NAlib.disconnect("somersault_key")
end, false)

StaffRoles = {"owner", "admin", "staff", "mod", "founder", "manager", "dev", "president", "leader", "supervisor", "chairman", "supervising", "executive", "director", "management", "chairwoman", "chairperson"}

function IsStaff(player)
	local role = ""
	local ok, currentRole = pcall(function()
		return player:GetRoleInGroup(game.CreatorId)
	end)
	if ok and currentRole then
		role = currentRole
	end
	local lowered = Lower(role)
	for _, staffRole in ipairs(StaffRoles) do
		if lowered:find(staffRole) then
			return true, role
		end
	end
	return false, role
end

groupRole = function(player)
	local info = {Role = "Guest", IsStaff = false}
	local isStaff, role = IsStaff(player)
	if player:IsInGroup(1200769) then
		info.Role = "Roblox Employee"
		info.IsStaff = true
		return info
	end
	if role ~= nil and role ~= "" then
		info.Role = role
	end
	info.IsStaff = isStaff
	return info
end
NAmanage.IsStaff = IsStaff

cmd.add({"trackstaff"}, {"trackstaff", "Track and notify when a staff member joins the server"}, function()
	NAlib.disconnect("staffNotifier")

	if game.CreatorType == Enum.CreatorType.Group then
		local staffList = {}
		NAlib.connect("staffNotifier", Players.PlayerAdded:Connect(function(player)
			local info = groupRole(player)
			if info.IsStaff then
				DebugNotif(formatUsername(player).." is a "..info.Role)
			end
		end))
		for _, player in pairs(Players:GetPlayers()) do
			local info = groupRole(player)
			if info.IsStaff then
				Insert(staffList, formatUsername(player).." is a "..info.Role)
			end
		end
		DebugNotif(#staffList > 0 and Concat(staffList, ",\n") or "Tracking enabled")
	else
		DebugNotif("Game is not owned by a Group")
	end
end)

cmd.add({"stoptrackstaff", "untrackstaff"}, {"stoptrackstaff (untrackstaff)", "Stop tracking staff members"}, function()
	NAlib.disconnect("staffNotifier")
	DebugNotif("Tracking disabled")
end)

cmd.add({"deletevelocity", "dv", "removevelocity", "removeforces"}, {"deletevelocity (dv, removevelocity, removeforces)", "removes any velocity/force instanceson your character"}, function()
	for _,vel in pairs(LocalPlayer.Character:GetDescendants()) do
		if vel:IsA("BodyVelocity") or vel:IsA("BodyGyro") or vel:IsA("RocketPropulsion") or vel:IsA("BodyThrust") or vel:IsA("BodyAngularVelocity") or vel:IsA("AngularVelocity") or vel:IsA("BodyForce") or vel:IsA("VectorForce") or vel:IsA("LineForce") then
			vel:Destroy()
		end
	end
end)

--Mobile Commands for the screen
if IsOnMobile then
	cmd.add({"sensorrotationscreen","sensorscreen","senscreen"},{"sensorrotationscreen","Changes ScreenOrientation to Sensor"},function()
		PlrGui.ScreenOrientation=Enum.ScreenOrientation.Sensor
	end)

	cmd.add({"landscaperotationscreen","landscapescreen","landscreen"},{"landscaperotationscreen","Changes ScreenOrientation to Landscape Sensor"},function()
		PlrGui.ScreenOrientation=Enum.ScreenOrientation.LandscapeSensor
	end)

	cmd.add({"portraitrotationscreen","portraitscreen","portscreen"},{"portraitrotationscreen","Changes ScreenOrientation to Portrait"},function()
		PlrGui.ScreenOrientation=Enum.ScreenOrientation.Portrait
	end)

	cmd.add({"defaultrotaionscreen","defaultscreen","defscreen"},{"defaultrotaionscreen","Changes ScreenOrientation to Portrait"},function()
		PlrGui.ScreenOrientation=StarterGui.ScreenOrientation
	end)
end

cmd.add({"commandcount","cc"},{"commandcount (cc)","Counds how many commands NA has"},function()
	DoNotif(adminName.." currently has "..commandcount.." commands")
end)

cmd.add({"flyfling","ff"}, {"flyfling (ff)", "makes you fly and fling"}, function()
	cmd.run({"unwalkfling"})
	cmd.run({"unvfly", ''})
	cmd.run({"walkfling"})
	cmd.run({"vfly"})
end)

cmd.add({"unflyfling","unff"}, {"unflyfling (unff)", "stops fly and fling"}, function()
	cmd.run({"unwalkfling"})
	cmd.run({"unvfly", ''})
end)

hiddenfling = false

cmd.add({"walkfling", "wfling", "wf"}, {"walkfling (wfling,wf)", "probably the best fling lol"}, function()
	if hiddenfling then return end

	DebugNotif("Walkfling enabled", 2)
	hiddenfling = true

	if not opt.NA_storage:FindFirstChild("juisdfj0i32i0eidsuf0iok") then
		local detection = InstanceNew("Decal")
		detection.Name = "juisdfj0i32i0eidsuf0iok"
		detection.Parent = opt.NA_storage
	end

	NAlib.disconnect("walkflinger")
	NAlib.connect("walkflinger", RunService.Heartbeat:Connect(function()
		if not hiddenfling then return end

		local lp = Players.LocalPlayer
		local character = lp and lp.Character
		local hrp = character and getRoot(character)
		if character and hrp then
			local originalVelocity = hrp.Velocity
			hrp.Velocity = originalVelocity * 10000 + Vector3.new(0, 10000, 0)

			RunService.RenderStepped:Wait()
			if character and hrp then
				hrp.Velocity = originalVelocity
			end

			RunService.RenderStepped:Wait()
			if character and hrp then
				hrp.Velocity = originalVelocity + Vector3.new(0, 0.1, 0)
			end
		end
	end))

	local lp = Players.LocalPlayer
	if lp then
		NAlib.disconnect("walkfling_charfix")
		NAlib.connect("walkfling_charfix", lp.CharacterAdded:Connect(function()
			if hiddenfling then
				DebugNotif("Re-enabling Walkfling")
			end
		end))
	end
end)
cmd.add({"unwalkfling", "unwfling", "unwf"}, {"unwalkfling (unwfling,unwf)", "stop the walkfling command"}, function()
	if not hiddenfling then return end

	DebugNotif("Walkfling disabled", 2)
	hiddenfling = false

	NAlib.disconnect("walkflinger")
	NAlib.disconnect("walkfling_charfix")
end)

cmd.add({"rjre", "rejoinrefresh"}, {"rjre (rejoinrefresh)", "Rejoins and teleports you to your previous position"}, function()
	if not DONE then
		DONE = true
		local hrp = getRoot(LocalPlayer.Character)

		if hrp then
			local tpScript = Format([[
                local success, err = pcall(function()
                    repeat Wait() until game:IsLoaded()
                    local lp = game:GetService("Players").LocalPlayer
                    local char
                    local startTime = tick()
                    repeat
                        char = lp.Character or lp.CharacterAdded:Wait()
                        Wait(0.1)
                    until char or (tick() - startTime > 10)
                    
                    if not char then return end
                    
                    local humRP
                    startTime = tick()
                    repeat
                        humRP = char:FindFirstChild("HumanoidRootPart")
                        Wait(0.1)
                    until humRP or (tick() - startTime > 10)
                    
                    if not humRP then return end
                    
                    local targetPos = Vector3.new(%s)
                    local targetCFrame = CFrame.new(%s)
                    
                    startTime = tick()
                    repeat
                        humRP.CFrame = targetCFrame
                        Wait(0.1)
                    until (humRP.Position - targetPos).Magnitude < 10 or (tick() - startTime > 5)
                end)
            ]], tostring(hrp.Position), tostring(hrp.CFrame))

			opt.queueteleport(tpScript)
		end

		cmd.run({"rj"})
	end
end)

cmd.add({"cancelteleport","canceltp"},{"cancelteleport (canceltp)","Cancel an in-progress teleport"},function()
	local ok,err=pcall(function()
		TeleportService:TeleportCancel()
	end)
	if ok then
		DoNotif("Cancelled pending teleports.",2)
	else
		DoNotif("Failed to cancel teleport: "..tostring(err),3)
	end
end)

cmd.add({"rejoin","rj"},{"rejoin (rj)","Rejoin the game"},function()
	local plrs=Players
	local tp=TeleportService
	local lp=plrs.LocalPlayer

	NAlib.disconnect("rejoin_tperr")
	NAlib.connect("rejoin_tperr",tp.TeleportInitFailed:Connect(function(player,result,errMsg)
		DoNotif(("Teleport failed [%s]: %s"):format(tostring(result),tostring(errMsg)))
	end))

	tp:TeleportCancel()

	if #plrs:GetPlayers()<=1 then
		local ok,err=pcall(function()
			tp:Teleport(PlaceId,lp)
		end)
		if not ok then DoNotif("Teleport error: "..tostring(err)) end
	else
		local ok,err=pcall(function()
			tp:TeleportToPlaceInstance(PlaceId,game.JobId,lp)
		end)
		if not ok then
			DoNotif("TeleportToPlaceInstance error: "..tostring(err))
			pcall(function() tp:Teleport(PlaceId,lp) end)
		end
	end

	DoNotif("Rejoining...")
end)

cmd.add({"teleporttoplace","toplace","ttp"},{"teleporttoplace (PlaceId) (toplace,ttp)","Teleports you using PlaceId"},function(...)
	args={...}
	pId=tonumber(args[1])
	TeleportService:Teleport(pId)
end,true)

--made by the_king.78
cmd.add({"adonisbypass","bypassadonis","badonis","adonisb"},{"adonisbypass (bypassadonis,badonis,adonisb)","bypasses adonis admin detection"},function()
	--[[local DebugFunc = getinfo or debug.getinfo
	local IsDebug = false
	local hooks = {}

	local DetectedMeth, KillMeth

	for index, value in getgc(true) do
		if typeof(value) == "table" then
			local detected = rawget(value, "Detected")
			local kill = rawget(value, "Kill")

			if typeof(detected) == "function" and not DetectedMeth then
				DetectedMeth = detected

				local hook
				hook = hookfunction(DetectedMeth, function(methodName, methodFunc, methodInfo)
					if methodName ~= "_" then
						if IsDebug then
							--DoNotif("Adonis Detected\nMethod: "..tostring(methodName).."\nInfo: "..tostring(methodFunc))
						end
					end

					return true
				end)

				Insert(hooks, DetectedMeth)
			end

			if rawget(value, "Variables") and rawget(value, "Process") and typeof(kill) == "function" and not KillMeth then
				KillMeth = kill
				local hook
				hook = hookfunction(KillMeth, function(killFunc)
					if IsDebug then
						--DoNotif("Adonis tried to detect: "..tostring(killFunc))
					end
				end)

				Insert(hooks, KillMeth)
			end
		end
	end

	local hook
	hook = hookfunction(getrenv().debug.info, newcclosure(function(...)
		local functionName, functionDetails = ...

		if DetectedMeth and functionName == DetectedMeth then
			if IsDebug or not IsDebug then
				--DoNotif("Adonis was bypassed by the_king.78")
			end

			return coroutine.yield(coroutine.running())
		end

		return hook(...)
	end))]]
	SpawnCall(function()
		local getgc = getgc or debug.getgc
		local hookfunction = hookfunction
		local getrenv = getrenv
		local debugInfo = (getrenv and getrenv().debug and getrenv().debug.info) or debug.info
		local newcclosure = newcclosure or function(f) return f end

		if not (getgc and hookfunction and getrenv and debugInfo) then
			DoNotif("Required exploit functions not available. Skipping Adonis bypass.",3,"Adonis Bypasser")
			return
		end

		local IsDebug = false
		local hooks = {}
		local DetectedMeth, KillMeth
		local AdonisFound = false

		for _, value in getgc(true) do
			if typeof(value) == "table" then
				local hasDetected = typeof(rawget(value, "Detected")) == "function"
				local hasKill = typeof(rawget(value, "Kill")) == "function"
				local hasVars = rawget(value, "Variables") ~= nil
				local hasProcess = rawget(value, "Process") ~= nil

				if hasDetected or (hasKill and hasVars and hasProcess) then
					AdonisFound = true
					break
				end
			end
		end

		if not AdonisFound then
			DoNotif("Adonis not found. Bypass skipped.",3,"Adonis Bypasser")
			return
		end

		for _, value in getgc(true) do
			if typeof(value) == "table" then
				local detected = rawget(value, "Detected")
				local kill = rawget(value, "Kill")

				if typeof(detected) == "function" and not DetectedMeth then
					DetectedMeth = detected
					local hook
					hook = hookfunction(DetectedMeth, function(methodName, methodFunc)
						if methodName ~= "_" and IsDebug then
							DoNotif("Adonis Detected\nMethod: "..methodName.."\nInfo: "..methodFunc,3,"Adonis Bypasser")
						end
						return true
					end)
					Insert(hooks, DetectedMeth)
					DoNotif("Hooked Adonis 'Detected' method.",3,"Adonis Bypasser")
				end

				if rawget(value, "Variables") and rawget(value, "Process") and typeof(kill) == "function" and not KillMeth then
					KillMeth = kill
					local hook
					hook = hookfunction(KillMeth, function(killFunc)
						if IsDebug then
							DoNotif("Adonis tried to kill function: "..killFunc,3,"Adonis Bypasser")
						end
					end)
					Insert(hooks, KillMeth)
					DoNotif("Hooked Adonis 'Kill' method.",3,"Adonis Bypasser")
				end
			end
		end

		if DetectedMeth and debugInfo then
			local hook
			hook = hookfunction(debugInfo, newcclosure(function(...)
				local functionName = ...
				if functionName == DetectedMeth then
					-- warn("Adonis detection intercepted. Bypassed by the_king.78.",3,"Adonis Bypasser")
					return coroutine.yield(coroutine.running())
				end
				return hook(...)
			end))
		end
	end)
end)

--[ LOCALPLAYER ]--
function respawn()
	local oldChar = getChar()
	local rootPart = getRoot(oldChar)
	while not rootPart do Wait(.1) rootPart=getRoot(oldChar) end

	local respawnCFrame = rootPart.CFrame

	local humanoid = getPlrHum(oldChar)
	while not humanoid do Wait(.1) humanoid=getPlrHum(oldChar) end
	humanoid:ChangeState(Enum.HumanoidStateType.Dead)
	humanoid.Health = 0

	local newChar = player.CharacterAdded:Wait()
	while not getRoot(newChar) do Wait(.1) getRoot(newChar) end

	local newRoot = getRoot(newChar)
	if newRoot then
		local startTime = tick()
		local teleportThreshold = 15

		while tick() - startTime < 0.4 do
			if (newRoot.Position - respawnCFrame.Position).Magnitude > teleportThreshold then
				newRoot.CFrame = respawnCFrame
				startTime = tick()
			end
			Wait(0.1)
		end
	end
end

cmd.add({"accountage","accage"},{"accountage <player> (accage)","Tells the account age of a player in the server"},function(...)
	Username=(...)

	target=getPlr(Username)
	for _, plr in next, target do
		teller=plr.AccountAge
		accountage="The account age of "..nameChecker(plr).." is "..teller

		Wait();

		DoNotif(accountage)
	end
end,true)

cmd.add({"hitboxes"},{"hitboxes","shows all the hitboxes"},function()
	settings():GetService("RenderSettings").ShowBoundingBoxes=true
end)

cmd.add({"unhitboxes"},{"unhitboxes","removes the hitboxes outline"},function()
	settings():GetService("RenderSettings").ShowBoundingBoxes=false
end)

cmd.add({"vfly","vehiclefly"},{"vehiclefly (vfly)","be able to fly vehicles"},function(...)
	local arg=(...) or nil
	flyVariables.vFlySpeed=tonumber(arg) or flyVariables.vFlySpeed or 1
	NAmanage.connectVFlyKey()
	NAmanage.activateMode("vfly")
	if not IsOnMobile then
		Wait()
		DebugNotif("Vehicle fly enabled. Press '"..string.upper(flyVariables.vToggleKey).."' to vfly/unvfly.")
	end
end,true)

cmd.add({"unvfly","unvehiclefly"},{"unvfly","disable vehicle fly"},function()
	NAmanage.deactivateMode("vfly")
end)

cmd.add({"equiptools","equipall"},{"equiptools","Equip all of your tools"},function()
	local backpack=getBp()
	if backpack then
		for _,tool in pairs(backpack:GetChildren()) do
			if tool:IsA("Tool") then
				tool.Parent=character
			end
		end
	end
end)

cmd.add({"usetools","uset"},{"usetools (uset)","Equips all tools, uses them, and unequips them"},function()
	local backpack = getBp()
	local character = Players.LocalPlayer.Character
	local equippedTools = {}

	if not backpack or not character then
		DebugNotif("Could not find backpack or character.")
		return
	end

	for _, tool in pairs(character:GetChildren()) do
		if tool:IsA("Tool") then
			Insert(equippedTools, tool)
		end
	end

	for _, tool in pairs(backpack:GetChildren()) do
		if tool:IsA("Tool") and not Discover(equippedTools, tool) then
			tool.Parent = character
		end
	end

	for _, tool in pairs(character:GetChildren()) do
		if tool:IsA("Tool") then
			NACaller(function()
				tool:Activate()
			end)
		end
	end

	Wait(1);

	for _, tool in pairs(character:GetChildren()) do
		if tool:IsA("Tool") and not Discover(equippedTools, tool) then
			tool.Parent = backpack
		end
	end

	for _, tool in pairs(equippedTools) do
		tool.Parent = character
	end
end)

cmd.add({"settweenspeed","tweenspeed"},{"tweenspeed [seconds]","Set how long tween teleport commands take"},function(seconds)
	if not seconds or seconds == "" then
		local current = tonumber(NAStuff.tweenSpeed) or 1
		DoNotif(("Current tween speed: %.2f seconds."):format(current))
		return
	end
	local value = tonumber(seconds)
	if not value then
		DoNotif("Please provide a numeric tween speed (seconds).")
		return
	end
	if value <= 0 then
		DoNotif("Tween speed must be greater than zero.")
		return
	end
	value = math.max(0.05, value)
	NAStuff.tweenSpeed = value
	NAmanage.NASettingsSet("tweenSpeed", value)
	DoNotif(("Tween speed set to %.2f seconds."):format(value))
	if not FileSupport then
		DebugNotif("Tween speed will reset when Roblox closes (no file support detected).")
	end
end)

cmd.add({"tweento","tweengoto","tgoto"},{"tweengoto <player>","Teleportation method that bypasses some anticheats"},function(name)
	local char = getChar()
	for _,plr in ipairs(getPlr(name)) do
		local cfVal = InstanceNew("CFrameValue")
		cfVal.Value = char:GetPivot()
		cfVal.Changed:Connect(function(newCF) char:PivotTo(newCF) end)
		local tw = TweenService:Create(cfVal, TweenInfo.new(NAmanage.resolveTweenDuration(), Enum.EasingStyle.Quad, Enum.EasingDirection.Out),{Value=plr.Character:GetPivot()})
		tw:Play()
		tw.Completed:Connect(function() cfVal:Destroy() end)
	end
end,true)


cmd.add({"reach", "swordreach"}, {"reach [number] (swordreach)", "Extends sword reach in one direction"}, function(reachsize)
	reachsize = tonumber(reachsize) or 15

	local char = getChar()
	local bp = getBp()
	local Tool = char and char:FindFirstChildOfClass("Tool") or bp and bp:FindFirstChildOfClass("Tool")
	if not Tool then return end

	local partSet = {}
	for _, p in ipairs(Tool:GetDescendants()) do
		if p:IsA("BasePart") then
			partSet[p.Name] = true
		end
	end

	local btns = {}
	for partName in pairs(partSet) do
		Insert(btns, {
			Text = partName,
			Callback = function()
				local toolPart = Tool:FindFirstChild(partName)
				if not toolPart then return end

				if not toolPart:FindFirstChild("OGSize3") then
					local val = InstanceNew("Vector3Value", toolPart)
					val.Name = "OGSize3"
					val.Value = toolPart.Size
				end

				if toolPart:FindFirstChild("FunTIMES") then
					toolPart.FunTIMES:Destroy()
				end

				local sb = InstanceNew("SelectionBox")
				sb.Adornee = toolPart
				sb.Name = "FunTIMES"
				sb.LineThickness = 0.01
				sb.Color3 = Color3.fromRGB(255, 0, 0)
				sb.Transparency = 0.7
				sb.Parent = toolPart

				toolPart.Massless = true
				toolPart.Size = Vector3.new(toolPart.Size.X, toolPart.Size.Y, reachsize)
			end
		})
	end

	Window({
		Title = "Reach Menu",
		Description = "Choose part to extend reach",
		Buttons = btns
	})
end, true)

cmd.add({"boxreach"}, {"boxreach [number]", "Creates a box-shaped hitbox around your tool"}, function(reachsize)
	reachsize = tonumber(reachsize) or 15

	local char = getChar()
	local bp = getBp()
	local Tool = char and char:FindFirstChildOfClass("Tool") or bp and bp:FindFirstChildOfClass("Tool")
	if not Tool then return end

	local partSet = {}
	for _, p in ipairs(Tool:GetDescendants()) do
		if p:IsA("BasePart") then
			partSet[p.Name] = true
		end
	end

	local btns = {}
	for partName in pairs(partSet) do
		Insert(btns, {
			Text = partName,
			Callback = function()
				local toolPart = Tool:FindFirstChild(partName)
				if not toolPart then return end

				if not toolPart:FindFirstChild("OGSize3") then
					local val = InstanceNew("Vector3Value", toolPart)
					val.Name = "OGSize3"
					val.Value = toolPart.Size
				end

				if toolPart:FindFirstChild("FunTIMES") then
					toolPart.FunTIMES:Destroy()
				end

				local sb = InstanceNew("SelectionBox")
				sb.Adornee = toolPart
				sb.Name = "FunTIMES"
				sb.LineThickness = 0.01
				sb.Color3 = Color3.fromRGB(0, 0, 255)
				sb.Transparency = 0.7
				sb.Parent = toolPart

				toolPart.Massless = true
				toolPart.Size = Vector3.new(reachsize, reachsize, reachsize)
			end
		})
	end

	Window({
		Title = "Box Reach Menu",
		Description = "Choose part to extend box reach",
		Buttons = btns
	})
end, true)

cmd.add({"resetreach", "normalreach", "unreach"}, {"resetreach (normalreach, unreach)", "Resets tool to normal size"}, function()
	local char = getChar()
	local bp = getBp()
	local Tool = char and char:FindFirstChildOfClass("Tool") or bp and bp:FindFirstChildOfClass("Tool")
	if not Tool then return end

	for _, p in ipairs(Tool:GetDescendants()) do
		if p:IsA("BasePart") then
			if p:FindFirstChild("OGSize3") then
				p.Size = p.OGSize3.Value
				p.OGSize3:Destroy()
			end
			if p:FindFirstChild("FunTIMES") then
				p.FunTIMES:Destroy()
			end
		end
	end
end)

local auraConn,auraViz

cmd.add({"aura"},{"aura [distance]","Continuously damages nearby players with equipped tool"},function(dist)
	dist=tonumber(dist) or 20
	local LocalPlayer=Players.LocalPlayer
	if not firetouchinterest then return DoNotif("firetouchinterest unsupported",2) end
	if auraConn then auraConn:Disconnect() auraConn=nil end
	if auraViz then auraViz:Destroy() auraViz=nil end
	auraViz=InstanceNew("Part")
	auraViz.Shape=Enum.PartType.Ball
	auraViz.Size=Vector3.new(dist*2,dist*2,dist*2)
	auraViz.Transparency=0.8
	auraViz.Color=Color3.fromRGB(255,0,0)
	auraViz.Material=Enum.Material.Neon
	auraViz.Anchored=true
	auraViz.CanCollide=false
	auraViz.Parent=workspace
	local function getHandle()
		local c=getChar() if not c then return end
		local t=c:FindFirstChildWhichIsA("Tool") if not t then return end
		return t:FindFirstChild("Handle") or t:FindFirstChildWhichIsA("BasePart")
	end
	auraConn=RunService.RenderStepped:Connect(function()
		local handle=getHandle()
		local root=getRoot(getChar())
		if not handle or not root then return end
		auraViz.CFrame=root.CFrame
		for _,plr in ipairs(Players:GetPlayers()) do
			if plr~=LocalPlayer and plr.Character then
				local hum=getPlrHum(plr)
				if hum and hum.Health>0 then
					for _,part in ipairs(plr.Character:GetChildren()) do
						if part:IsA("BasePart") and (part.Position-handle.Position).Magnitude<=dist then
							firetouchinterest(handle,part,0)
							Wait();
							firetouchinterest(handle,part,1)
							break
						end
					end
				end
			end
		end
	end)
	DebugNotif("Aura enabled at "..dist,1.2)
end,true)

cmd.add({"unaura"},{"unaura","Stops aura loop and removes visualizer"},function()
	if auraConn then auraConn:Disconnect() auraConn=nil end
	if auraViz then auraViz:Destroy() auraViz=nil end
	DebugNotif("Aura disabled",1.2)
end,true)

cmd.add({"antivoid"},{"antivoid","Prevents you from falling into the void by launching you upwards"},function()
	NAlib.disconnect("antivoid")

	NAlib.connect("antivoid", RunService.RenderStepped:Connect(function()
		local character = getChar()
		local root = character and getRoot(character)
		if root and root.Position.Y <= OrgDestroyHeight + 25 then
			root.Velocity = Vector3.new(root.Velocity.X, root.Velocity.Y + 250, root.Velocity.Z)
		end
	end))

	DebugNotif("AntiVoid Enabled", 3)
end)

cmd.add({"unantivoid"},{"unantivoid","Disables antivoid"},function()
	NAlib.disconnect("antivoid")
	DebugNotif("AntiVoid Disabled", 3)
end)

cmd.add({"fakeout"}, {"fakeout", "tp to void and back"}, function()
	local character = getChar()
	local root = character and getRoot(character)
	if not root then
		DebugNotif("Fakeout failed: unable to find character root", 2)
		return
	end
	local antivoidConnections = connections["antivoid"]
	local antivoidWasActive = false
	if antivoidConnections then
		for _, conn in ipairs(antivoidConnections) do
			if conn.Connected then
				antivoidWasActive = true
				break
			end
		end
	end
	if antivoidWasActive then
		NAlib.disconnect("antivoid")
	end
	local originalDestroyHeight = workspace.FallenPartsDestroyHeight
	local originalCFrame = root.CFrame
	local dropHeight = OrgDestroyHeight or originalDestroyHeight or 0
	workspace.FallenPartsDestroyHeight = 0/1/0
	root.CFrame = CFrame.new(Vector3.new(0, dropHeight - 25, 0))
	Wait(1)
	root.CFrame = originalCFrame
	workspace.FallenPartsDestroyHeight = originalDestroyHeight
	if antivoidWasActive then
		local antivoidCommand = cmds.Commands["antivoid"]
		if antivoidCommand and antivoidCommand[1] then
			antivoidCommand[1]()
		end
	end
end)

cmd.add({"invisfling"}, {"invisfling", "Enables invisible fling (the invis part is patched, try using the god command before using this)"}, function()
	local player = Players.LocalPlayer
	local character = getChar()
	local humanoid = character and character:FindFirstChildWhichIsA("Humanoid")
	if not (player and character and humanoid) then
		DebugNotif("Invisfling failed: missing character", 2)
		return
	end

	humanoid:SetStateEnabled(Enum.HumanoidStateType.Dead, false)

	local proxyModel = InstanceNew("Model")
	proxyModel.Name = "NA_InvisFlingProxy"
	proxyModel.Parent = character

	local torso = InstanceNew("Part")
	torso.Name = "Torso"
	torso.CanCollide = false
	torso.Anchored = true
	torso.Position = Vector3.new(0, 9999, 0)
	torso.Parent = proxyModel

	local head = InstanceNew("Part")
	head.Name = "Head"
	head.CanCollide = false
	head.Anchored = true
	head.Parent = proxyModel

	local proxyHumanoid = InstanceNew("Humanoid")
	proxyHumanoid.Name = "Humanoid"
	proxyHumanoid.Parent = proxyModel

	player.Character = proxyModel
	Wait(3)
	player.Character = character
	Wait(3)

	character = getChar()
	if not character then
		DebugNotif("Invisfling aborted: character missing", 2)
		return
	end

	local activeHumanoid = character:FindFirstChildOfClass("Humanoid")
	if not activeHumanoid then
		activeHumanoid = InstanceNew("Humanoid")
		activeHumanoid.Name = "Humanoid"
		activeHumanoid.Parent = character
	end

	local root = getRoot(character)
	if not root then
		DebugNotif("Invisfling failed: missing root", 2)
		return
	end

	for _, child in ipairs(character:GetChildren()) do
		if child ~= root and child.Name ~= "Humanoid" then
			child:Destroy()
		end
	end

	root.Transparency = 0
	root.Color = Color3.new(1, 1, 1)

	local invisflingStepped
	invisflingStepped = RunService.Stepped:Connect(function()
		local currentChar = getChar()
		local currentRoot = currentChar and getRoot(currentChar)
		if currentRoot then
			currentRoot.CanCollide = false
		else
			invisflingStepped:Disconnect()
		end
	end)

	NAmanage.activateMode("fly")
	workspace.CurrentCamera.CameraSubject = root

	local thrust = InstanceNew("BodyThrust")
	thrust.Parent = root
	thrust.Force = Vector3.new(99999, 99999 * 10, 99999)
	thrust.Location = root.Position
end)

cmd.add({"split"}, {"split", "Destroys waist joint"}, function()
	if not IsR15() then
		DoNotif("This command requires the R15 rig type.", 3, "split")
		return
	end

	local character = getChar()
	if not character then
		DebugNotif("Split failed: no character", 2)
		return
	end

	local upperTorso = getTorso(character)
	local waist = upperTorso and upperTorso:FindFirstChild("Waist")
	if waist then
		waist:Destroy()
		DebugNotif("Waist joint removed.", 2)
	else
		DebugNotif("Split failed: waist joint not found.", 2)
	end
end)
originalFPDH = nil

cmd.add({"antivoid2"}, {"antivoid2", "sets FallenPartsDestroyHeight to -inf"}, function()
	if not originalFPDH then
		originalFPDH = workspace.FallenPartsDestroyHeight
	end

	workspace.FallenPartsDestroyHeight = -9e9
end)

cmd.add({"unantivoid2"}, {"unantivoid2", "reverts FallenPartsDestroyHeight"}, function()
	if originalFPDH ~= nil then
		workspace.FallenPartsDestroyHeight = originalFPDH
		DebugNotif("FallenPartsDestroyHeight reverted to original value | Antivoid2 Disabled",2)
	else
		DebugNotif("Original value was not stored. Cannot revert.",2)
	end
end)

comPart, comHL, comConn, comRadius = nil,nil,nil,nil

cmd.add({"showcom","centerofmass","com"},{"showcom [radiusStuds]","Create a glass sphere with a Highlight at your center of mass"},function(...)
	comRadius = tonumber(({...})[1]) or 0.35
	if comConn then comConn:Disconnect() comConn=nil end
	NAlib.disconnect("com_track")

	local function ensureParts()
		if not comPart or not comPart.Parent then
			if comPart then pcall(function() comPart:Destroy() end) end
			comPart = InstanceNew("Part")
			comPart.Shape = Enum.PartType.Ball
			comPart.Anchored = true
			comPart.CanCollide = false
			comPart.CanQuery = false
			comPart.CanTouch = false
			comPart.Massless = true
			comPart.CastShadow = false
			comPart.Material = Enum.Material.Glass
			comPart.Transparency = 0
			local sz = comRadius*2
			comPart.Size = Vector3.new(sz, sz, sz)
			comPart.Parent = workspace
		end
		if not comHL or not comHL.Parent or comHL.Adornee ~= comPart then
			if comHL then pcall(function() comHL:Destroy() end) end
			comHL = InstanceNew("Highlight")
			comHL.Adornee = comPart
			comHL.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
			comHL.FillTransparency = 0.25
			comHL.OutlineTransparency = 0
			comHL.FillColor = Color3.fromRGB(255, 255, 0)
			comHL.OutlineColor = Color3.fromRGB(255, 255, 0)
			comHL.Parent = comPart
		end
	end

	comConn = RunService.Heartbeat:Connect(function()
		ensureParts()
		local char = getChar()
		local root = char and (getRoot(char) or char:FindFirstChildWhichIsA("BasePart"))
		if root and root:IsDescendantOf(workspace) and comPart and comPart.Parent then
			local pos = root.AssemblyCenterOfMass or root.Position
			comPart.Anchored = true
			comPart.CanCollide = false
			comPart.Material = Enum.Material.Glass
			comPart.Transparency = 0
			local sz = comRadius*2
			if comPart.Size.X ~= sz then comPart.Size = Vector3.new(sz, sz, sz) end
			comPart.CFrame = CFrame.new(pos)
		end
	end)

	NAlib.connect("com_track", comConn)
end,true)

cmd.add({"hidecom","unshowcom","uncom"},{"hidecom","Remove COM tracker"},function()
	NAlib.disconnect("com_track")
	if comConn then comConn:Disconnect() comConn=nil end
	if comHL then pcall(function() comHL:Destroy() end) comHL=nil end
	if comPart then pcall(function() comPart:Destroy() end) comPart=nil end
end)

cmd.add({"droptool"}, {"dropatool", "Drop one of your tools"}, function()
	local backpack = getBp()
	local toolToDrop = nil

	for _, tool in ipairs(getChar():GetChildren()) do
		if tool:IsA("Tool") and NAlib.isProperty(tool, "CanBeDropped") == true then
			toolToDrop = tool
			break
		end
	end

	Wait()

	if backpack and not toolToDrop then
		for _, tool in ipairs(backpack:GetChildren()) do
			if tool:IsA("Tool") and NAlib.isProperty(tool, "CanBeDropped") == true then
				tool.Parent = getChar()
				toolToDrop = tool
				break
			end
		end
	end

	if toolToDrop then
		toolToDrop.Parent = workspace
		DebugNotif("Dropped: "..toolToDrop.Name, 4)
	else
		DebugNotif("No droppable tool found", 4)
	end
end)

cmd.add({"droptools"}, {"dropalltools", "Drop all of your tools"}, function()
	local backpack = getBp()
	local character = getChar()
	if not character then
		return DebugNotif("Character not available", 4)
	end

	local queue = {}
	local function collect(from)
		if not from then return end
		for _, tool in ipairs(from:GetChildren()) do
			if tool:IsA("Tool") and NAlib.isProperty(tool, "CanBeDropped") == true then
				Insert(queue, tool)
			end
		end
	end

	collect(character)
	collect(backpack)

	if #queue == 0 then
		return DebugNotif("No droppable tools found", 4)
	end

	local dropped = 0

	for _, tool in ipairs(queue) do
		if tool and tool.Parent then
			if tool.Parent == backpack then
				tool.Parent = character
				Wait()
			end

			if tool.Parent == character then
				tool.Parent = workspace
				dropped += 1
				Wait(.05)
			end
		end
	end

	if dropped > 0 then
		DebugNotif("Dropped "..dropped.." tool(s)", 4)
	else
		DebugNotif("No droppable tools found", 4)
	end
end)

cmd.add({"notools"},{"notools","Remove your tools"},function()
	for _,tool in pairs(getChar():GetDescendants()) do
		if tool:IsA("Tool") then
			tool:Destroy()
		end
	end
	for _,tool in pairs(getBp():GetDescendants()) do
		if tool:IsA("Tool") then
			tool:Destroy()
		end
	end
end)

-- leg resize sureeee
--[[cmd.add({"breaklayeredclothing","blc"},{"breaklayeredclothing (blc)","Streches your layered clothing"},function()
	Wait();

	DoNotif("Break layered clothing executed,if you havent already equip shirt,jacket,pants and shoes (Layered Clothing ones)")
	local swimming=false
	oldgrav=workspace.Gravity
	workspace.Gravity=0
	local char=getChar()
	local swimDied=function()
		workspace.Gravity=oldgrav
		swimming=false
	end
	Humanoid=char:FindFirstChildWhichIsA("Humanoid")
	gravReset=Humanoid.Died:Connect(swimDied)
	enums=Enum.HumanoidStateType:GetEnumItems()
	table.remove(enums,Discover(enums,Enum.HumanoidStateType.None))
	for i,v in pairs(enums) do
		Humanoid:SetStateEnabled(v,false)
	end
	Humanoid:ChangeState(Enum.HumanoidStateType.Swimming)
	swimbeat=RunService.Heartbeat:Connect(function()
		pcall(function()
			getRoot(char).Velocity=((Humanoid.MoveDirection~=Vector3.new() or UserInputService:IsKeyDown(Enum.KeyCode.Space)) and getRoot(char).Velocity or Vector3.new())
		end)
	end)
	swimming=true
	Clip=false
	Wait(0.1)
	function NoclipLoop()
		if Clip==false and char~=nil then
			for _,child in pairs(char:GetDescendants()) do
				if child:IsA("BasePart") and child.CanCollide==true then
					child.CanCollide=false
				end
			end
		end
	end
	Noclipping=RunService.Stepped:Connect(NoclipLoop)
	loadstring(game:HttpGet('https://raw.githubusercontent.com/ltseverydayyou/Nameless-Admin/main/leg%20resize'))()
end)]]

cmd.add({"fpsbooster","lowgraphics","boostfps","lowg"},{"fpsbooster","Enables maximum-performance low graphics mode, run again to restore"},function()
	local g=getgenv and getgenv() or _G
	if g.NA_FPS_ACTIVE then
		g.NA_FPS_ACTIVE=false
		if g.NA_FPS_UNHOOK then g.NA_FPS_UNHOOK() end
		return
	end

	local w=workspace
	local st=(NAmanage and NAmanage._ensureL and NAmanage._ensureL()) or {safeGet=function(i,p)local ok,v=pcall(function()return i[p]end)return ok and v or nil end,safeSet=function(i,p,v)NAlib.setProperty(i,p,v)end}
	local opt=opt or {hiddenprop=function() end}

	local function setHiddenOrNormal(inst,prop,val)
		local ok=false
		if opt and opt.hiddenprop then ok=pcall(function() opt.hiddenprop(inst,prop,val) end) end
		if not ok then st.safeSet(inst,prop,val) end
	end

	local active=false
	local cons={}
	local watchers=setmetatable({}, {__mode="k"})
	local function connect(sig,fn)local c=sig:Connect(fn);Insert(cons,c);return c end
	local function disconnectAll()
		for _,c in ipairs(cons) do pcall(function() c:Disconnect() end) end
		cons={}
		watchers=setmetatable({}, {__mode="k"})
	end
	local function forceProperty(inst,prop,desired)
		if not inst then return end
		local bucket=watchers[inst]
		if not bucket then
			bucket={}
			watchers[inst]=bucket
		end
		local function apply()
			if not active then return end
			local current=st.safeGet(inst,prop)
			if current~=nil and current~=desired then
				st.safeSet(inst,prop,desired)
			end
		end
		apply()
		if bucket[prop] then return end
		local ok,conn=pcall(function()
			return inst:GetPropertyChangedSignal(prop):Connect(function()
				apply()
			end)
		end)
		if ok and conn then
			bucket[prop]=conn
			Insert(cons,conn)
		end
	end

	local A="NA_FPS_"
	local function remember(inst,prop,val)
		local key=A..prop
		if inst:GetAttribute(key)==nil then
			if typeof(val)=="EnumItem" then inst:SetAttribute(key,val.Name) else inst:SetAttribute(key,val) end
		end
	end
	local function recall(inst,prop) return inst:GetAttribute(A..prop) end
	local function clearAttr(inst,prop) inst:SetAttribute(A..prop,nil) end
	local function isCharacterOrNPC(inst)local a=inst while a do if a:IsA("Model") and a:FindFirstChildOfClass("Humanoid") then return true end a=a.Parent end return false end
	local function isClothingLike(inst) return inst:IsA("Shirt") or inst:IsA("Pants") or inst:IsA("ShirtGraphic") or inst:IsA("Accessory") or inst:IsA("Clothing") or inst:IsA("HumanoidDescription") end

	local originals={quality=nil,lighting={},terrain={},workspace={},postFx={},postFxCam={}}
	local function snapshotEnv()
		if originals.quality==nil then pcall(function() originals.quality=settings().Rendering.QualityLevel end) end
		for _,p in ipairs({"GlobalShadows","FogEnd","Brightness","Ambient","OutdoorAmbient","LightingStyle","Technology"}) do
			if originals.lighting[p]==nil then originals.lighting[p]=st.safeGet(Lighting,p) end
		end
		for _,e in ipairs(Lighting:GetChildren()) do
			if e:IsA("BlurEffect") or e:IsA("SunRaysEffect") or e:IsA("ColorCorrectionEffect") or e:IsA("BloomEffect") or e:IsA("DepthOfFieldEffect") or e:IsA("Atmosphere") then
				if originals.postFx[e]==nil then local en=st.safeGet(e,"Enabled"); originals.postFx[e]=(en==nil) and true or en end
			end
		end
		local cam=w.CurrentCamera
		if cam then
			for _,e in ipairs(cam:GetChildren()) do
				if e:IsA("BlurEffect") or e:IsA("SunRaysEffect") or e:IsA("ColorCorrectionEffect") or e:IsA("BloomEffect") or e:IsA("DepthOfFieldEffect") or e:IsA("Atmosphere") then
					if originals.postFxCam[e]==nil then local en=st.safeGet(e,"Enabled"); originals.postFxCam[e]=(en==nil) and true or en end
				end
			end
		end
		local T=w:FindFirstChildOfClass("Terrain")
		if T then
			for _,p in ipairs({"Decoration","WaterWaveSize","WaterWaveSpeed","WaterReflectance","WaterTransparency"}) do
				if originals.terrain[p]==nil then originals.terrain[p]=st.safeGet(T,p) end
			end
		end
		for _,p in ipairs({"StreamingEnabled","StreamingPauseMode","StreamOutBehavior","TargetRadius"}) do
			if originals.workspace[p]==nil then originals.workspace[p]=st.safeGet(w,p) end
		end
	end

	local function applyEnv()
		pcall(function() settings().Rendering.QualityLevel=Enum.QualityLevel.Level01 end)
		st.safeSet(Lighting,"GlobalShadows",false)
		st.safeSet(Lighting,"FogEnd",math.huge)
		st.safeSet(Lighting,"Brightness",0)
		st.safeSet(Lighting,"Ambient",Color3.new(0.4,0.4,0.4))
		st.safeSet(Lighting,"OutdoorAmbient",Color3.new(0.4,0.4,0.4))
		setHiddenOrNormal(Lighting,"LightingStyle",Enum.LightingStyle.Soft)
		setHiddenOrNormal(Lighting,"Technology",Enum.Technology.Compatibility)
		local T=w:FindFirstChildOfClass("Terrain")
		if T then
			st.safeSet(T,"Decoration",false)
			st.safeSet(T,"WaterWaveSize",0)
			st.safeSet(T,"WaterWaveSpeed",0)
			st.safeSet(T,"WaterReflectance",0)
			st.safeSet(T,"WaterTransparency",0)
		end
		st.safeSet(w,"StreamingEnabled",true)
		pcall(function() w.StreamOutBehavior=Enum.StreamOutBehavior.LowMemory or Enum.StreamOutBehavior.Default end)
		st.safeSet(w,"StreamingPauseMode",Enum.StreamingPauseMode.Default)
		st.safeSet(w,"TargetRadius",96)
		for _,e in ipairs(Lighting:GetChildren()) do if e:IsA("PostEffect") then st.safeSet(e,"Enabled",false) end if e:IsA("Atmosphere") then if st.safeGet(e,"Density")~=nil then st.safeSet(e,"Density",0) end end end
		local cam=w.CurrentCamera
		if cam then for _,e in ipairs(cam:GetChildren()) do if e:IsA("PostEffect") then st.safeSet(e,"Enabled",false) end if e:IsA("Atmosphere") then if st.safeGet(e,"Density")~=nil then st.safeSet(e,"Density",0) end end end end
	end

	local function restoreEnv()
		pcall(function() if originals.quality~=nil then settings().Rendering.QualityLevel=originals.quality end end)
		for p,v in pairs(originals.lighting) do
			if v~=nil then
				if p=="LightingStyle" then
					setHiddenOrNormal(Lighting,p,typeof(v)=="EnumItem" and v or Enum.LightingStyle[v] or Enum.LightingStyle.Soft)
				elseif p=="Technology" then
					setHiddenOrNormal(Lighting,p,typeof(v)=="EnumItem" and v or Enum.Technology[v] or Enum.Technology.Compatibility)
				else
					st.safeSet(Lighting,p,v)
				end
			end
		end
		for e,wasEnabled in pairs(originals.postFx) do if e and e.Parent and st.safeGet(e,"Enabled")~=nil then st.safeSet(e,"Enabled",wasEnabled) end end
		for e,wasEnabled in pairs(originals.postFxCam) do if e and e.Parent and st.safeGet(e,"Enabled")~=nil then st.safeSet(e,"Enabled",wasEnabled) end end
		local T=w:FindFirstChildOfClass("Terrain")
		if T then for p,v in pairs(originals.terrain) do if v~=nil then st.safeSet(T,p,v) end end end
		for p,v in pairs(originals.workspace) do if v~=nil then st.safeSet(w,p,v) end end
	end

	local function optimizeInstance(inst)
		if not active then return end
		if isCharacterOrNPC(inst) then return end
		if isClothingLike(inst) then return end
		if inst:IsA("BasePart") then
			remember(inst,"Material",inst.Material)
			remember(inst,"MaterialVariant",st.safeGet(inst,"MaterialVariant"))
			remember(inst,"Reflectance",inst.Reflectance)
			remember(inst,"CastShadow",inst.CastShadow)
			st.safeSet(inst,"Material",Enum.Material.Plastic)
			st.safeSet(inst,"MaterialVariant","")
			st.safeSet(inst,"Reflectance",0)
			st.safeSet(inst,"CastShadow",false)
			if inst:IsA("MeshPart") then
				if st.safeGet(inst,"TextureID")~=nil then remember(inst,"TextureID",inst.TextureID); st.safeSet(inst,"TextureID","") end
			end
		end
		if inst:IsA("SpecialMesh") then remember(inst,"TextureId",inst.TextureId); st.safeSet(inst,"TextureId","") end
		if inst:IsA("Decal") or inst:IsA("Texture") then remember(inst,"Transparency",inst.Transparency); st.safeSet(inst,"Transparency",1) end
		if inst:IsA("ParticleEmitter") or inst:IsA("Trail") or inst:IsA("Fire") or inst:IsA("Smoke") or inst:IsA("Sparkles") then remember(inst,"Enabled",inst.Enabled); st.safeSet(inst,"Enabled",false) end
		if inst:IsA("Beam") then remember(inst,"Enabled",st.safeGet(inst,"Enabled")); if st.safeGet(inst,"Enabled")~=nil then st.safeSet(inst,"Enabled",false) end end
		if inst:IsA("PointLight") or inst:IsA("SurfaceLight") or inst:IsA("SpotLight") then remember(inst,"Enabled",inst.Enabled); st.safeSet(inst,"Enabled",false) end
		if inst:IsA("SurfaceAppearance") or inst:IsA("Highlight") then remember(inst,"Enabled",st.safeGet(inst,"Enabled")); if st.safeGet(inst,"Enabled")~=nil then st.safeSet(inst,"Enabled",false) end end
		if inst:IsA("PostEffect") then
			local enabledValue=st.safeGet(inst,"Enabled")
			if enabledValue~=nil then remember(inst,"Enabled",enabledValue) end
			forceProperty(inst,"Enabled",false)
		end
		if inst:IsA("Atmosphere") then
			local density=st.safeGet(inst,"Density")
			if density~=nil then remember(inst,"Density",density); forceProperty(inst,"Density",0) end
			local haze=st.safeGet(inst,"Haze")
			if haze~=nil then remember(inst,"Haze",haze); forceProperty(inst,"Haze",0) end
			local glare=st.safeGet(inst,"Glare")
			if glare~=nil then remember(inst,"Glare",glare); forceProperty(inst,"Glare",0) end
		end
		if inst:IsA("Explosion") then remember(inst,"BlastPressure",inst.BlastPressure); remember(inst,"BlastRadius",inst.BlastRadius); st.safeSet(inst,"BlastPressure",1); st.safeSet(inst,"BlastRadius",1) end
	end

	local function restoreInstance(inst)
		if inst:IsA("BasePart") then
			local m=recall(inst,"Material"); if m~=nil then st.safeSet(inst,"Material",Enum.Material[m] or inst.Material) clearAttr(inst,"Material") end
			local mv=recall(inst,"MaterialVariant"); if mv~=nil then st.safeSet(inst,"MaterialVariant",mv) clearAttr(inst,"MaterialVariant") end
			local r=recall(inst,"Reflectance"); if r~=nil then st.safeSet(inst,"Reflectance",r) clearAttr(inst,"Reflectance") end
			local cs=recall(inst,"CastShadow"); if cs~=nil then st.safeSet(inst,"CastShadow",cs) clearAttr(inst,"CastShadow") end
			if inst:IsA("MeshPart") then local tx=recall(inst,"TextureID"); if tx~=nil then st.safeSet(inst,"TextureID",tx) clearAttr(inst,"TextureID") end end
		end
		if inst:IsA("SpecialMesh") then local t=recall(inst,"TextureId"); if t~=nil then st.safeSet(inst,"TextureId",t) clearAttr(inst,"TextureId") end end
		if inst:IsA("Decal") or inst:IsA("Texture") then local t=recall(inst,"Transparency"); if t~=nil then st.safeSet(inst,"Transparency",t) clearAttr(inst,"Transparency") end end
		if inst:IsA("ParticleEmitter") or inst:IsA("Trail") or inst:IsA("Fire") or inst:IsA("Smoke") or inst:IsA("Sparkles") then local e=recall(inst,"Enabled"); if e~=nil then st.safeSet(inst,"Enabled",e) clearAttr(inst,"Enabled") end end
		if inst:IsA("Beam") then local e=recall(inst,"Enabled"); if e~=nil then st.safeSet(inst,"Enabled",e) clearAttr(inst,"Enabled") end end
		if inst:IsA("PointLight") or inst:IsA("SurfaceLight") or inst:IsA("SpotLight") then local e=recall(inst,"Enabled"); if e~=nil then st.safeSet(inst,"Enabled",e) clearAttr(inst,"Enabled") end end
		if inst:IsA("SurfaceAppearance") or inst:IsA("Highlight") then local e=recall(inst,"Enabled"); if e~=nil then st.safeSet(inst,"Enabled",e) clearAttr(inst,"Enabled") end end
		if inst:IsA("PostEffect") then local e=recall(inst,"Enabled"); if e~=nil then st.safeSet(inst,"Enabled",e) clearAttr(inst,"Enabled") end end
		if inst:IsA("Atmosphere") then
			local d=recall(inst,"Density"); if d~=nil then st.safeSet(inst,"Density",d) clearAttr(inst,"Density") end
			local h=recall(inst,"Haze"); if h~=nil then st.safeSet(inst,"Haze",h) clearAttr(inst,"Haze") end
			local g=recall(inst,"Glare"); if g~=nil then st.safeSet(inst,"Glare",g) clearAttr(inst,"Glare") end
		end
		if inst:IsA("Explosion") then local bp=recall(inst,"BlastPressure"); if bp~=nil then st.safeSet(inst,"BlastPressure",bp) clearAttr(inst,"BlastPressure") end local br=recall(inst,"BlastRadius"); if br~=nil then st.safeSet(inst,"BlastRadius",br) clearAttr(inst,"BlastRadius") end end
	end

	local function sweepAll() for _,v in ipairs(w:GetDescendants()) do Defer(function() optimizeInstance(v) end) end end
	local function restoreAll() for _,v in ipairs(w:GetDescendants()) do Defer(function() restoreInstance(v) end) end end

	local function enable()
		if active then return end
		active=true
		snapshotEnv()
		applyEnv()
		for _,v in ipairs(Lighting:GetDescendants()) do Defer(function() optimizeInstance(v) end) end
		sweepAll()
		Insert(cons, connect(w.DescendantAdded,function(v) Defer(function() optimizeInstance(v) end) end))
		Insert(cons, connect(Lighting.DescendantAdded,function(v) Defer(function() optimizeInstance(v) end) end))
		Insert(cons, connect(w:GetPropertyChangedSignal("CurrentCamera"),function()
			local cam=w.CurrentCamera
			if not cam then return end
			for _,e in ipairs(cam:GetChildren()) do Defer(function() optimizeInstance(e) end) end
			Insert(cons, connect(cam.ChildAdded,function(e) Defer(function() optimizeInstance(e) end) end))
		end))
		local cam=w.CurrentCamera
		if cam then
			for _,e in ipairs(cam:GetChildren()) do Defer(function() optimizeInstance(e) end) end
			Insert(cons, connect(cam.ChildAdded,function(e) Defer(function() optimizeInstance(e) end) end))
		end
	end

	local function disable()
		if not active then return end
		active=false
		disconnectAll()
		restoreAll()
		restoreEnv()
	end

	g.NA_FPS_UNHOOK=function() disable() g.NA_FPS_UNHOOK=nil end
	enable()
	g.NA_FPS_ACTIVE=true
end)

cmd.add({"antilag","boostfps"},{"antilag (boostfps)","Low Graphics"},function()
	local sGUI = InstanceNew("ScreenGui")
	NaProtectUI(sGUI)
	sGUI.Name = "AntiLagGUI"
	sGUI.ResetOnSpawn = false

	local frame = InstanceNew("Frame")
	frame.AnchorPoint = Vector2.new(0.5, 0)
	frame.Size = UDim2.new(0.3, 0, 0.5, 0)
	frame.Position = UDim2.new(0.5, 0, 0.35, 0)
	frame.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
	frame.BorderSizePixel = 0
	frame.Parent = sGUI

	local topbar = InstanceNew("Frame")
	topbar.Name = "TopBar"
	topbar.Size = UDim2.new(1, 0, 0, 30)
	topbar.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
	topbar.BorderSizePixel = 0
	topbar.Parent = frame

	local title = InstanceNew("TextLabel")
	title.Text = "AntiLag Settings"
	title.Font = Enum.Font.SourceSansBold
	title.TextSize = 18
	title.TextColor3 = Color3.new(1,1,1)
	title.BackgroundTransparency = 1
	title.Size = UDim2.new(1, -60, 1, 0)
	title.Position = UDim2.new(0, 10, 0, 0)
	title.TextXAlignment = Enum.TextXAlignment.Left
	title.Parent = topbar

	local closeBtn = InstanceNew("TextButton")
	closeBtn.Size = UDim2.new(0, 24, 0, 24)
	closeBtn.Position = UDim2.new(1, -28, 0, 3)
	closeBtn.BackgroundColor3 = Color3.fromRGB(180, 40, 40)
	closeBtn.Text = "X"
	closeBtn.TextColor3 = Color3.new(1, 1, 1)
	closeBtn.Font = Enum.Font.SourceSansBold
	closeBtn.TextSize = 16
	closeBtn.Parent = topbar

	local minimizeBtn = InstanceNew("TextButton")
	minimizeBtn.Size = UDim2.new(0, 24, 0, 24)
	minimizeBtn.Position = UDim2.new(1, -56, 0, 3)
	minimizeBtn.BackgroundColor3 = Color3.fromRGB(100, 100, 100)
	minimizeBtn.Text = "-"
	minimizeBtn.TextColor3 = Color3.new(1, 1, 1)
	minimizeBtn.Font = Enum.Font.SourceSansBold
	minimizeBtn.TextSize = 16
	minimizeBtn.Parent = topbar

	local content = InstanceNew("Frame")
	content.Name = "Content"
	content.Size = UDim2.new(1, 0, 1, -30)
	content.Position = UDim2.new(0, 0, 0, 30)
	content.BackgroundTransparency = 1
	content.Parent = frame

	local scrollingFrame = InstanceNew("ScrollingFrame", content)
	scrollingFrame.Size = UDim2.new(1, 0, 1, -60)
	scrollingFrame.Position = UDim2.new(0, 0, 0, 0)
	scrollingFrame.CanvasSize = UDim2.new(0, 0, 0, 0)
	scrollingFrame.ScrollBarThickness = 6
	scrollingFrame.BackgroundTransparency = 1

	local layout = InstanceNew("UIListLayout", scrollingFrame)
	layout.Padding = UDim.new(0, 5)
	layout.SortOrder = Enum.SortOrder.LayoutOrder

	local padding = InstanceNew("UIPadding", scrollingFrame)
	padding.PaddingTop = UDim.new(0, 10)
	padding.PaddingBottom = UDim.new(0, 10)
	padding.PaddingLeft = UDim.new(0, 10)
	padding.PaddingRight = UDim.new(0, 10)

	local defaultSettings = {
		Players = {
			["Ignore Me"] = true,
			["Ignore Others"] = true
		},
		Meshes = {
			Destroy = false,
			LowDetail = true
		},
		Images = {
			Invisible = true,
			LowDetail = true,
			Destroy = true
		},
		Other = {
			["No Particles"] = true,
			["No Camera Effects"] = true,
			["No Explosions"] = true,
			["No Clothes"] = true,
			["Low Water Graphics"] = true,
			["No Shadows"] = true,
			["Low Rendering"] = true,
			["Low Quality Parts"] = true
		}
	}

	local userSettings = table.clone(defaultSettings)

	local function updateCanvas()
		Wait()
		scrollingFrame.CanvasSize = UDim2.new(0, 0, 0, layout.AbsoluteContentSize.Y + 20)
	end

	local function createSection(sectionName, keys)
		local dropdown = InstanceNew("TextButton")
		dropdown.Size = UDim2.new(1, -10, 0, 32)
		dropdown.BackgroundColor3 = Color3.fromRGB(45, 45, 45)
		dropdown.TextColor3 = Color3.new(1, 1, 1)
		dropdown.Font = Enum.Font.SourceSansBold
		dropdown.TextSize = 20
		dropdown.Text = "▼ "..sectionName
		dropdown.AutoButtonColor = false
		dropdown.Parent = scrollingFrame

		local container = InstanceNew("Frame")
		container.Size = UDim2.new(1, -10, 0, 0)
		container.BackgroundTransparency = 1
		container.ClipsDescendants = true
		container.Parent = scrollingFrame

		local subLayout = InstanceNew("UIListLayout", container)
		subLayout.Padding = UDim.new(0, 4)
		subLayout.SortOrder = Enum.SortOrder.LayoutOrder

		local isOpen = false

		local function updateDropdown()
			container.Size = UDim2.new(1, -10, 0, isOpen and #keys * 36 or 0)
			dropdown.Text = (isOpen and "▲ " or "▼ ")..sectionName
			updateCanvas()
		end

		for _, key in pairs(keys) do
			local btn = InstanceNew("TextButton")
			btn.Size = UDim2.new(1, 0, 0, 32)
			btn.TextColor3 = Color3.new(1, 1, 1)
			btn.Font = Enum.Font.SourceSans
			btn.TextSize = 18
			btn.AutoButtonColor = false
			btn.Text = key..": "..tostring(userSettings[sectionName][key])
			btn.BackgroundColor3 = userSettings[sectionName][key] and Color3.fromRGB(0, 200, 0) or Color3.fromRGB(120, 30, 30)
			btn.Parent = container

			MouseButtonFix(btn,function()
				userSettings[sectionName][key] = not userSettings[sectionName][key]
				btn.Text = key..": "..tostring(userSettings[sectionName][key])
				btn.BackgroundColor3 = userSettings[sectionName][key] and Color3.fromRGB(0, 200, 0) or Color3.fromRGB(120, 30, 30)
			end)
		end

		MouseButtonFix(dropdown,function()
			isOpen = not isOpen
			updateDropdown()
		end)

		updateDropdown()
	end

	for section, data in pairs(userSettings) do
		local keys = {}
		for k in pairs(data) do Insert(keys, k) end
		createSection(section, keys)
	end

	local runBtn = InstanceNew("TextButton")
	runBtn.Size = UDim2.new(1, -20, 0, 45)
	runBtn.Position = UDim2.new(0, 10, 1, -50)
	runBtn.BackgroundColor3 = Color3.fromRGB(0, 170, 0)
	runBtn.TextColor3 = Color3.new(1, 1, 1)
	runBtn.Font = Enum.Font.SourceSansBold
	runBtn.TextSize = 20
	runBtn.Text = "Run AntiLag"
	runBtn.Parent = content

	MouseButtonFix(runBtn,function()
		getgenv().Settings = userSettings
		sGUI:Destroy()
		loadstring(game:HttpGet("https://raw.githubusercontent.com/ltseverydayyou/uuuuuuu/main/low%20detail"))()
	end)

	MouseButtonFix(closeBtn,function()
		sGUI:Destroy()
	end)

	local minimized = false
	MouseButtonFix(minimizeBtn,function()
		minimized = not minimized
		content.Visible = not minimized
		minimizeBtn.Text = minimized and "+" or "-"
	end)
	NAgui.draggerV2(frame)
end)

local annoyLoop = false

cmd.add({"annoy"}, {"annoy <player>", "Annoys the given player"}, function(...)
	if annoyLoop then
		DoNotif("Already annoying someone. Use :unannoy first.", 3)
		return
	end

	annoyLoop = false
	Wait(0.2)
	annoyLoop = true

	local user = ...
	local targets = getPlr(user)

	if #targets == 0 then
		DoNotif("No target found.", 3)
		return
	end

	local target = targets[1]
	if not target.Character or not getRoot(target.Character) then
		DoNotif("Target has no character or root part.", 3)
		annoyLoop = false
		return
	end

	local myChar = getChar()
	local myRoot = myChar and getRoot(myChar)
	local originalCFrame = myRoot and myRoot.CFrame

	if not myRoot then
		DoNotif("Your character has no root part.", 3)
		annoyLoop = false
		return
	end

	math.randomseed(tick())

	repeat
		Wait(0.05)

		local targetChar = target.Character
		local targetRoot = targetChar and getRoot(targetChar)
		myChar = getChar()
		myRoot = myChar and getRoot(myChar)

		if not targetRoot or not myRoot then
			break
		end

		local offset = Vector3.new(math.random(-3,3), math.random(0,2), math.random(-3,3))
		myRoot.CFrame = targetRoot.CFrame + offset

		RunService.RenderStepped:Wait()
	until not annoyLoop

	if myRoot and originalCFrame then
		myRoot.CFrame = originalCFrame
	end
end, true)

cmd.add({"unannoy"}, {"unannoy", "Stops the annoy command"}, function()
	annoyLoop = false
end)

cmd.add({"deleteinvisparts","deleteinvisibleparts","dip"},{"deleteinvisparts (deleteinvisibleparts,dip)","Deletes invisible parts"},function()
	for i,v in pairs(workspace:GetDescendants()) do
		if v:IsA("BasePart") and v.Transparency==1 and v.CanCollide then
			v:Destroy()
		end
	end
end)

local shownParts = {}

cmd.add({"invisibleparts","invisparts"},{"invisibleparts (invisparts)","Shows invisible parts"},function()
	for _, v in ipairs(workspace:GetDescendants()) do
		if v:IsA("BasePart") and v.Transparency == 1 then
			local alreadyShown = false
			for _, p in ipairs(shownParts) do
				if p == v then
					alreadyShown = true
					break
				end
			end
			if not alreadyShown then
				Insert(shownParts, v)
			end
			v.Transparency = 0
		end
	end
end)

cmd.add({"uninvisibleparts","uninvisparts"},{"uninvisibleparts (uninvisparts)","Makes parts affected by invisparts return to normal"},function()
	for _, v in ipairs(shownParts) do
		if v and v:IsA("BasePart") then
			v.Transparency = 1
		end
	end
	table.clear(shownParts)
end)

cmd.add({"datalimit"},{"datalimit <kbps>","Set outgoing bandwidth limit in KBps"},function(value)
	local limit=tonumber(value)
	if not limit then
		DoNotif("Usage: datalimit <number>",2)
		return
	end
	local networkClient=SafeGetService("NetworkClient")
	if not networkClient then
		DoNotif("NetworkClient unavailable",3)
		return
	end
	local ok,err=pcall(function()
		networkClient:SetOutgoingKBPSLimit(limit)
	end)
	if ok then
		DoNotif("Outgoing limit set to "..tostring(limit).." kbps",2)
	else
		DoNotif("Failed to set limit: "..tostring(err),3)
	end
end,true)

cmd.add({"removeads","adblock"},{"removeads (adblock)","Continuously removes billboard advertisements"},function()
	if NAStuff._removeAdsLoop and NAStuff._removeAdsLoop.active then
		DoNotif("Remove Ads already enabled",2)
		return
	end
	local state={active=true}
	NAStuff._removeAdsLoop=state
	DoNotif("Remove Ads enabled",2)
	SpawnCall(function()
		while state.active do
			pcall(function()
				for _,obj in ipairs(workspace:GetDescendants()) do
					if obj:IsA("PackageLink") then
						local parent=obj.Parent
						if parent then
							if parent:FindFirstChild("ADpart") then
								parent:Destroy()
							elseif parent:FindFirstChild("AdGuiAdornee") then
								local grand=parent.Parent
								if grand then
									grand:Destroy()
								else
									parent:Destroy()
								end
							end
						end
					end
				end
			end)
			Wait(0.75)
		end
	end)
end)

cmd.add({"unremoveads","noadblock","disableads"},{"unremoveads (noadblock,disableads)","Stop removing billboard advertisements"},function()
	local state=NAStuff._removeAdsLoop
	if not state or not state.active then
		DoNotif("Remove Ads is not active",2)
		NAStuff._removeAdsLoop=nil
		return
	end
	state.active=false
	NAStuff._removeAdsLoop=nil
	DoNotif("Remove Ads disabled",2)
end)

cmd.add({"replicationlag", "backtrack"}, {"replicationlag (backtrack)", "Set IncomingReplicationLag"}, function(num)
	settings():GetService("NetworkSettings").IncomingReplicationLag = tonumber(num) or 0
end, true)

cmd.add({"sleepon"}, {"sleepon", "Enable AllowSleep"}, function()
	settings():GetService("PhysicsSettings").AllowSleep = true
end)

cmd.add({"unsleepon"}, {"unsleepon", "Disable AllowSleep"}, function()
	settings():GetService("PhysicsSettings").AllowSleep = false
end)

cmd.add({"throttle"}, {"throttle", "Set PhysicsEnvironmentalThrottle (1 = default, 2 = disabled)"}, function(num)
	settings():GetService("PhysicsSettings").PhysicsEnvironmentalThrottle = tonumber(num) or 1
end, true)

cmd.add({"quality","qualitylevel"},{"quality <1-21>","Manage rendering quality settings"},function(...)
	local args = {...}
	local target = args[1]
	local buttons = {}
	for _, ql in ipairs(Enum.QualityLevel:GetEnumItems()) do
		Insert(buttons, {
			Text = ql.Name,
			Callback = function()
				settings().Rendering.QualityLevel = ql
			end
		})
	end
	if target and target ~= "" then
		local key = tostring(target)
		local n = tonumber(key)
		if n then
			n = math.clamp(math.floor(n), 1, 21)
			key = Format("Level%02d", n)
		else
			local l = Lower(key)
			if l == "auto" or l == "automatic" then
				key = "Automatic"
			end
		end
		local found = false
		for _, btn in ipairs(buttons) do
			if Match(Lower(btn.Text), Lower(key)) then
				btn.Callback()
				DebugNotif("Quality set to "..btn.Text, 3)
				found = true
				break
			end
		end
		if not found then
			DebugNotif("No matching quality level for: "..target, 3)
		end
	else
		Window({
			Title = "Rendering Quality Options",
			Buttons = buttons
		})
	end
end)

cmd.add({"logphysics"}, {"logphysics", "Enable Physics Error Logging"}, function()
	settings():GetService("NetworkSettings").PrintPhysicsErrors = true
end)

cmd.add({"nologphysics"}, {"nologphysics", "Disable Physics Error Logging"}, function()
	settings():GetService("NetworkSettings").PrintPhysicsErrors = false
end)

cmd.add({"norender"},{"norender","Disable 3d Rendering to decrease the amount of CPU the client uses"},function()
	RunService:Set3dRenderingEnabled(false)
end)

cmd.add({"render"},{"render","Enable 3d Rendering"},function()
	RunService:Set3dRenderingEnabled(true)
end)

oofing = false

cmd.add({"loopoof"},{"loopoof","Loops everyone's character sounds (everyone can hear)"},function()
	oofing = true
	repeat Wait(0.1)
		for _, player in ipairs(Players:GetPlayers()) do
			local char = player.Character
			local head = getHead(char)
			if head then
				for _, child in ipairs(head:GetChildren()) do
					if child:IsA("Sound") and not child.Playing then
						child.Playing = true
					end
				end
			end
		end
	until not oofing
end)

cmd.add({"unloopoof"},{"unloopoof","Stops the oof chaos"},function()
	oofing = false
end)

cmd.add({"strengthen"},{"strengthen","Makes your character more dense (CustomPhysicalProperties)"},function(...)
	local args={...}
	for _,child in pairs(getChar():GetDescendants()) do
		if child:IsA("BasePart") then
			if args[1] then
				child.CustomPhysicalProperties=PhysicalProperties.new(args[1],0.3,0.5)
			else
				child.CustomPhysicalProperties=PhysicalProperties.new(100,0.3,0.5)
			end
		end
	end
end,true)

cmd.add({"unweaken","unstrengthen"},{"unweaken (unstrengthen)","Sets your characters CustomPhysicalProperties to default"},function()
	for _,child in pairs(getChar():GetDescendants()) do
		if child:IsA("BasePart") then
			child.CustomPhysicalProperties=PhysicalProperties.new(0.7,0.3,0.5)
		end
	end
end)

cmd.add({"weaken"},{"weaken","Makes your character less dense"},function(...)
	local args={...}
	for _,child in pairs(getChar():GetDescendants()) do
		if child:IsA("BasePart") then
			if args[1] then
				child.CustomPhysicalProperties=PhysicalProperties.new(-args[1],0.3,0.5)
			else
				child.CustomPhysicalProperties=PhysicalProperties.new(0,0.3,0.5)
			end
		end
	end
end,true)

cmd.add({"seat"}, {"seat", "Finds a seat and automatically sits on it"}, function()
	local character = getChar()
	local humanoid = getHum()
	local root = character and getRoot(character)

	if not humanoid or not root then
		DoNotif("Your character or humanoid is invalid", 3)
		return
	end

	local seats = {}
	for _, v in ipairs(game:GetDescendants()) do
		if v:IsA("Seat") and not v.Occupant then
			Insert(seats, v)
		end
	end

	if #seats == 0 then
		DebugNotif("No available seats found in the game", 3)
		return
	end

	table.sort(seats, function(a, b)
		return (a.Position - root.Position).Magnitude < (b.Position - root.Position).Magnitude
	end)

	local seat = seats[1]
	if seat then
		seat:Sit(humanoid)
		DebugNotif("Sat in the nearest seat", 2)
	else
		DebugNotif("Failed to sit in a seat", 3)
	end
end)

cmd.add({"vehicleseat", "vseat"}, {"vehicleseat (vseat)", "Sits you in a vehicle seat, useful for trying to find cars in games"}, function()
	local character = getChar()
	local humanoid = getHum()
	local root = character and getRoot(character)

	if not humanoid or not root then
		DoNotif("Your character or humanoid is invalid", 3)
		return
	end

	local vehicleSeats = {}
	for _, v in ipairs(game:GetDescendants()) do
		if v:IsA("VehicleSeat") and not v.Occupant then
			Insert(vehicleSeats, v)
		end
	end

	if #vehicleSeats == 0 then
		DebugNotif("No available VehicleSeats found in the game", 3)
		return
	end

	table.sort(vehicleSeats, function(a, b)
		return (a.Position - root.Position).Magnitude < (b.Position - root.Position).Magnitude
	end)

	local vseat = vehicleSeats[1]
	if vseat then
		vseat:Sit(humanoid)
		DebugNotif("Sat in the nearest VehicleSeat", 2)
	else
		DebugNotif("Failed to sit in a VehicleSeat", 3)
	end
end)
cmd.add({"copytools","ctools"},{"copytools <player> (ctools)","Copies the tools the given player has"},function(...)
	local targets = getPlr(...)
	local lp = Players.LocalPlayer
	if not lp then return end
	local backpack = lp:FindFirstChildOfClass("Backpack")
	if not backpack then return end
	for _,plr in ipairs(targets) do
		local tBackpack = plr:FindFirstChildOfClass("Backpack")
		if tBackpack then
			for _,tool in ipairs(tBackpack:GetChildren()) do
				if tool:IsA("Tool") or tool:IsA("HopperBin") then
					tool:Clone().Parent = backpack
				end
			end
		end
	end
end,true)
cmd.add({"localtime", "yourtime"}, {"localtime (yourtime)", "Shows your current time"}, function()
	local time = os.date("*t")
	local clock = Format("%02d:%02d:%02d", time.hour, time.min, time.sec)
	DoNotif("Your Local Time Is: "..clock)
end)
cmd.add({"localdate", "yourdate"}, {"localdate (yourdate)", "Shows your current date"}, function()
	local time = os.date("*t")
	local dateStr = Format("%02d/%02d/%04d", time.day, time.month, time.year)
	DoNotif("Your Local Date Is: "..dateStr)
end)
cmd.add({"servertime", "svtime"}, {"servertime (svtime)", "Shows the server's current time"}, function()
	local time = os.date("!*t")
	local clock = Format("%02d:%02d:%02d", time.hour, time.min, time.sec)
	DoNotif("Server (UTC) Time Is: "..clock)
end)
cmd.add({"serverdate", "svdate"}, {"serverdate (svdate)", "Shows the server's current date"}, function()
	local time = os.date("!*t")
	local dateStr = Format("%02d/%02d/%04d", time.day, time.month, time.year)
	DoNotif("Server (UTC) Date Is: "..dateStr)
end)
cmd.add({"datetime", "localdatetime"}, {"datetime (localdatetime)", "Shows your full local date and time"}, function()
	local time = os.date("*t")
	local dateTime = Format("%02d/%02d/%04d %02d:%02d:%02d", time.day, time.month, time.year, time.hour, time.min, time.sec)
	DoNotif("Your Local Date & Time: "..dateTime)
end)
cmd.add({"uptime"}, {"uptime", "Shows how long the game/session has been running"}, function()
	local uptime = os.clock() - NASESSIONSTARTEDIDK
	local hours = math.floor(uptime / 3600)
	local minutes = math.floor((uptime % 3600) / 60)
	local seconds = math.floor(uptime % 60)
	local uptimeStr = Format("%02d:%02d:%02d", hours, minutes, seconds)
	DoNotif("Uptime: "..uptimeStr)
end)
cmd.add({"timestamp", "epoch"}, {"timestamp (epoch)", "Shows current Unix timestamp"}, function()
	local timestamp = os.time()
	DoNotif("Current Unix Timestamp: "..timestamp)
end)
cmd.add({"cartornado", "ctornado"}, {"cartornado (ctornado)", "Tornados a car just sit in the car"}, function()
	local Player = Players.LocalPlayer
	local Workspace = workspace

	repeat RunService.RenderStepped:Wait() until Player.Character
	local Character = Player.Character

	local SPart = InstanceNew("Part")
	SPart.Anchored = true
	SPart.CanCollide = true
	SPart.Size = Vector3.new(1, 100, 1)
	SPart.Transparency = 0.4
	SPart.Parent = Workspace

	RunService.Stepped:Connect(function()
		local hum = Character and getHum()
		if hum and Character.PrimaryPart then
			local rayOrigin = Character.PrimaryPart.Position + Character.PrimaryPart.CFrame.LookVector * 6
			local rayDir = Vector3.new(0, -4, 0)
			local ray = Ray.new(rayOrigin, rayDir)
			local part = Workspace:FindPartOnRayWithIgnoreList(ray, {Character})
			if part then
				SPart.CFrame = Character.PrimaryPart.CFrame + Character.PrimaryPart.CFrame.LookVector * 6
			end
		end
	end)

	SPart.Touched:Connect(function(hit)
		if not hit:IsA("Seat") then return end

		local torso = getTorso(Character)
		if not torso then return end

		local hum = getHum()
		if not hum then return end

		local flyv = InstanceNew("BodyVelocity")
		local flyg = InstanceNew("BodyGyro")
		local speed = 50
		local lastSpeed = speed
		local maxSpeed = 100
		local isRunning = false
		local f = 0
		local isFlying = true

		flyv.Parent = torso
		flyv.MaxForce = Vector3.new(math.huge, math.huge, math.huge)

		flyg.Parent = torso
		flyg.MaxTorque = Vector3.new(9e9, 9e9, 9e9)
		flyg.P = 1000
		flyg.D = 50

		hum.PlatformStand = true

		hum.Changed:Connect(function()
			isRunning = hum.MoveDirection.Magnitude > 0
		end)

		SpawnCall(function()
			while isFlying do
				flyg.CFrame = workspace.CurrentCamera.CFrame * CFrame.Angles(-math.rad(f * 50 * speed / maxSpeed), 0, 0)
				flyv.Velocity = workspace.CurrentCamera.CFrame.LookVector * speed
				Wait(0.1)

				if speed < 0 then
					speed = 0
					f = 0
				end

				if isRunning then
					speed = lastSpeed
				else
					if speed ~= 0 then
						lastSpeed = speed
					end
					speed = 0
				end
			end
		end)

		Wait(0.3)
		hit:Sit(hum)
		SPart:Destroy()

		local seat = hum.SeatPart
		if not seat then return end

		local vehicleModel = seat.Parent
		while vehicleModel and not vehicleModel:IsA("Model") do
			vehicleModel = vehicleModel.Parent
		end

		if vehicleModel then
			for _, v in pairs(vehicleModel:GetDescendants()) do
				if v:IsA("BasePart") and v.CanCollide then
					v.CanCollide = false
				end
			end
		end

		Wait(0.2)
		speed = 80

		local spin = InstanceNew("BodyAngularVelocity")
		spin.MaxTorque = Vector3.new(0, math.huge, 0)
		spin.AngularVelocity = Vector3.new(0, 2000, 0)
		spin.Parent = Character.PrimaryPart
	end)
end)

cmd.add({"unspam","unlag","unchatspam","unanimlag","unremotespam"},{"unspam","Stop all attempts to lag/spam"},function()
	NAlib.disconnect("spam")
end)

cmd.add({"UNCTest","UNC"},{"UNCTest (UNC)","Test how many functions your executor supports"},function()
	loadstring(game:HttpGet("https://raw.githubusercontent.com/ltseverydayyou/uuuuuuu/main/UNC%20test"))()
end)

-- game based so bye bye api
--[[cmd.add({"sUNCtest","sUNC"},{"sUNCtest (sUNC)","uses sUNC test that test the functions if they're working"},function()
	getgenv().sUNCDebug = {
		["printcheckpoints"] = false,
		["delaybetweentests"] = 0
	}

	loadstring(game:HttpGet("https://script.sunc.su/"))()
end)]]

cmd.add({"vulnerabilitytest","vulntest"},{"vulnerabilitytest (vulntest)","Test if your executor is Vulnerable"},function()
	loadstring(game:HttpGet("https://raw.githubusercontent.com/ltseverydayyou/uuuuuuu/main/VulnTest.lua"))()
end)

cmd.add({"respawn", "re"}, {"respawn (re)", "Respawn your character"}, function()
	respawn()
end)

cmd.add({"antisit"},{"antisit","Prevents the player from sitting"},function()
	local function noSit(character)
		local humanoid = getPlrHum(character)
		while not humanoid do Wait(.1) humanoid = getPlrHum(character) end
		humanoid.Sit = false
		humanoid:SetStateEnabled(Enum.HumanoidStateType.Seated, false)
	end

	if LocalPlayer.Character then
		noSit(LocalPlayer.Character)
	end

	NAlib.disconnect("antisit_conn")
	NAlib.connect("antisit_conn", LocalPlayer.CharacterAdded:Connect(noSit))

	DebugNotif("Anti sit enabled", 3)
end)

cmd.add({"unantisit"},{"unantisit","Allows the player to sit again"},function()
	local character = LocalPlayer.Character
	local humanoid = getHum()
	while not humanoid do Wait(.1) humanoid = getHum() end
	humanoid.Sit = false
	humanoid:SetStateEnabled(Enum.HumanoidStateType.Seated, true)

	NAlib.disconnect("antisit_conn")
	DebugNotif("Anti sit disabled", 3)
end)

NAmanage.AntiKick_EnsureHook = function()
	if NAStuff.AntiKickHooked then return end
	local getRawMetatable = (debug and debug.getmetatable) or getrawmetatable
	local setReadOnly = setreadonly or (make_writeable and function(t, ro) if ro then make_readonly(t) else make_writeable(t) end end)
	if not getRawMetatable or not setReadOnly or not newcclosure or not hookfunction then return end
	local meta = getRawMetatable(game)
	if not meta then return end
	local player = Players.LocalPlayer
	if not player then return end
	NAStuff.AntiKickOrig.namecall = meta.__namecall
	NAStuff.AntiKickOrig.index = meta.__index
	NAStuff.AntiKickOrig.newindex = meta.__newindex
	for _, Kick in next, { player.Kick, player.kick } do
		if Kick and type(Kick)=="function" then
			local originalKick
			originalKick = hookfunction(Kick, newcclosure(function(self, ...)
				if self==player then
					local msg = tostring((select(1, ...)) or "No message")
					Defer(DebugNotif, "Kick blocked (hook)", 2)
					if NAStuff.AntiKickMode=="error" then
						error("Kick blocked: "..msg, 0)
					else
						return
					end
				end
				return originalKick(self, ...)
			end))
			NAStuff.AntiKickOrig.kicks[Kick] = originalKick
		end
	end
	setReadOnly(meta, false)
	meta.__namecall = newcclosure(function(self, ...)
		local method = getnamecallmethod()
		if self==player and method and method:lower()=="kick" then
			local msg = tostring((select(1, ...)) or "No message")
			Defer(DebugNotif, "Kick blocked (__namecall)", 2)
			if NAStuff.AntiKickMode=="error" then
				error("Kick blocked: "..msg, 0)
			else
				return
			end
		end
		return NAStuff.AntiKickOrig.namecall(self, ...)
	end)
	meta.__index = newcclosure(function(self, key)
		if self==player then
			local k=tostring(key):lower()
			if k:find("kick") or k:find("destroy") then
				Defer(DebugNotif, "Blocked access: "..tostring(key), 2)
				if NAStuff.AntiKickMode=="error" then
					return function() error("Blocked method: "..tostring(key),0) end
				else
					return function() end
				end
			end
		end
		return NAStuff.AntiKickOrig.index(self, key)
	end)
	meta.__newindex = newcclosure(function(self, key, value)
		if self==player then
			local k=tostring(key):lower()
			if k:find("kick") or k:find("destroy") then
				Defer(DebugNotif, "Blocked overwrite: "..tostring(key), 2)
				return
			end
		end
		return NAStuff.AntiKickOrig.newindex(self, key, value)
	end)
	setReadOnly(meta, true)
	NAStuff.AntiKickHooked = true
	Defer(DebugNotif, "Anti-Kick active", 2)
end

NAmanage.AntiTeleport_EnsureHook = function()
	if NAStuff.AntiTeleportHooked then return end
	local getRawMetatable = (debug and debug.getmetatable) or getrawmetatable
	local setReadOnly = setreadonly or (make_writeable and function(t, ro) if ro then make_readonly(t) else make_writeable(t) end end)
	if not getRawMetatable or not setReadOnly or not newcclosure or not hookfunction then return end
	local meta = getRawMetatable(game)
	if not meta then return end
	if not TeleportService then return end
	NAStuff.AntiTeleportOrig.namecall = meta.__namecall
	NAStuff.AntiTeleportOrig.index = meta.__index
	NAStuff.AntiTeleportOrig.newindex = meta.__newindex
	local methods = {"Teleport","TeleportToPlaceInstance","TeleportAsync","TeleportPartyAsync","TeleportToPrivateServer"}
	for _,m in ipairs(methods) do
		local fn = TeleportService[m]
		if typeof(fn)=="function" then
			local orig
			orig = hookfunction(fn, newcclosure(function(self, ...)
				if self==TeleportService then
					Defer(DebugNotif, "Teleport blocked (hook)", 2)
					if NAStuff.AntiTeleportMode=="error" then
						error("Teleport blocked",0)
					else
						return nil
					end
				end
				return orig(self,...)
			end))
			NAStuff.AntiTeleportOrig.funcs[m] = orig
		end
	end
	setReadOnly(meta,false)
	meta.__namecall = newcclosure(function(self, ...)
		local method = getnamecallmethod()
		if self==TeleportService and typeof(method)=="string" and Lower(method):find("teleport") then
			Defer(DebugNotif, "Teleport blocked (__namecall)", 2)
			if NAStuff.AntiTeleportMode=="error" then
				error("Teleport blocked",0)
			else
				return nil
			end
		end
		return NAStuff.AntiTeleportOrig.namecall(self,...)
	end)
	meta.__index = newcclosure(function(self, key)
		if self==TeleportService then
			local k = Lower(tostring(key))
			if k:find("teleport") then
				Defer(DebugNotif, "Blocked access: "..tostring(key), 2)
				if NAStuff.AntiTeleportMode=="error" then
					return function() error("Blocked method: "..tostring(key),0) end
				else
					return function() end
				end
			end
		end
		return NAStuff.AntiTeleportOrig.index(self,key)
	end)
	meta.__newindex = newcclosure(function(self, key, value)
		if self==TeleportService then
			local k = Lower(tostring(key))
			if k:find("teleport") then
				Defer(DebugNotif, "Blocked overwrite: "..tostring(key), 2)
				return
			end
		end
		return NAStuff.AntiTeleportOrig.newindex(self,key,value)
	end)
	setReadOnly(meta,true)
	NAStuff.AntiTeleportHooked = true
	Defer(DebugNotif, "Anti-Teleport active", 2)
end

cmd.add({"antikick","nokick","bypasskick","bk"},{"antikick (nokick, bypasskick, bk)","Bypass Kick on Most Games"},function(mode)
	local m = mode and Lower(tostring(mode)) or nil
	local function apply()
		NAmanage.AntiKick_EnsureHook()
		DebugNotif("Anti-Kick: "..(NAStuff.AntiKickMode=="error" and "Error" or "Fake Success"),2)
	end
	if m=="error" or m=="fail" then
		NAStuff.AntiKickMode = "error"
		apply()
	elseif m=="success" or m=="ok" or m=="fake" then
		NAStuff.AntiKickMode = "fakeok"
		apply()
	else
		Window({
			Title = "Anti-Kick Mode",
			Buttons = {
				{ Text = "Fake Success", Callback = function() NAStuff.AntiKickMode="fakeok"; apply() end },
				{ Text = "Error",        Callback = function() NAStuff.AntiKickMode="error";  apply() end }
			}
		})
	end
end,true)

cmd.add({"antiteleport","noteleport","blocktp"},{"antiteleport (noteleport, blocktp)","Prevents TeleportService from moving you to another place"},function(mode)
	local m = mode and Lower(tostring(mode)) or nil
	local function apply()
		NAmanage.AntiTeleport_EnsureHook()
		DebugNotif("Anti-Teleport: "..(NAStuff.AntiTeleportMode=="error" and "Error" or "Fake Success"),2)
	end
	if m=="error" or m=="fail" then
		NAStuff.AntiTeleportMode = "error"
		apply()
	elseif m=="success" or m=="ok" or m=="fake" then
		NAStuff.AntiTeleportMode = "fakeok"
		apply()
	else
		Window({
			Title = "Anti-Teleport Mode",
			Buttons = {
				{ Text = "Fake Success", Callback = function() NAStuff.AntiTeleportMode="fakeok"; apply() end },
				{ Text = "Error",        Callback = function() NAStuff.AntiTeleportMode="error";  apply() end }
			}
		})
	end
end,true)

cmd.add({"unantikick","unnokick","unbypasskick","unbk"},{"unantikick","Disables Anti-Kick protection"},function()
	local getRawMetatable = (debug and debug.getmetatable) or getrawmetatable
	local setReadOnly = setreadonly or (make_writeable and function(t, ro) if ro then make_readonly(t) else make_writeable(t) end end)
	local meta = getRawMetatable(game)
	if not meta or not NAStuff.AntiKickOrig or not NAStuff.AntiKickOrig.namecall then
		DoNotif("Anti-Kick not active or missing references",3)
		return
	end
	local player = Players.LocalPlayer
	for k,orig in pairs(NAStuff.AntiKickOrig.kicks or {}) do
		pcall(function() hookfunction(k, orig) end)
	end
	setReadOnly(meta,false)
	meta.__namecall = NAStuff.AntiKickOrig.namecall
	meta.__index = NAStuff.AntiKickOrig.index
	meta.__newindex = NAStuff.AntiKickOrig.newindex
	setReadOnly(meta,true)
	NAStuff.AntiKickHooked = false
	DebugNotif("Anti-Kick Disabled",2)
end)

cmd.add({"unantiteleport","unnoteleport","unblocktp"},{"unantiteleport","Disables Anti-Teleport protection"},function()
	local getRawMetatable = (debug and debug.getmetatable) or getrawmetatable
	local setReadOnly = setreadonly or (make_writeable and function(t, ro) if ro then make_readonly(t) else make_writeable(t) end end)
	local meta = getRawMetatable(game)
	if not meta or not NAStuff.AntiTeleportOrig or not NAStuff.AntiTeleportOrig.namecall then
		DoNotif("Anti-Teleport not active or missing references",3)
		return
	end
	for name,orig in pairs(NAStuff.AntiTeleportOrig.funcs or {}) do
		local fn = TeleportService[name]
		if typeof(fn)=="function" and orig then
			pcall(function() hookfunction(fn, orig) end)
		end
	end
	setReadOnly(meta,false)
	meta.__namecall = NAStuff.AntiTeleportOrig.namecall
	meta.__index = NAStuff.AntiTeleportOrig.index
	meta.__newindex = NAStuff.AntiTeleportOrig.newindex
	setReadOnly(meta,true)
	NAStuff.AntiTeleportHooked = false
	DebugNotif("Anti-Teleport Disabled",2)
end)

local ATPC = {
	state = false,
	plr = Players.LocalPlayer,
	lastCF = nil,
	lastT = 0,
	hits = 0,
	MAX_SPEED = 70,
	MAX_STEP_DIST = 8,
	REPEAT = 3,
	LOCK_TIME = 0.1,
	cn = {},
	gui = nil,
	btn = nil
}

ATPC._getFlyMode=function()
	if not NAmanage or not NAmanage._state then return "none" end
	return NAmanage._state.mode or "none"
end

ATPC._flyAllowances=function(dt)
	local m=ATPC._getFlyMode()
	local maxS, maxD=ATPC.MAX_SPEED, ATPC.MAX_STEP_DIST
	if m=="fly" then
		local sp=tonumber(flyVariables.flySpeed) or 1
		local v=sp*50
		maxS=math.max(maxS, v*1.4)
		maxD=math.max(maxD, v*dt*3)
	elseif m=="vfly" then
		local sp=tonumber(flyVariables.vFlySpeed) or 1
		local v=sp*50
		maxS=math.max(maxS, v*1.4)
		maxD=math.max(maxD, v*dt*3)
	elseif m=="cfly" then
		local sp=tonumber(flyVariables.cFlySpeed) or 1
		local step=sp*2
		maxD=math.max(ATPC.MAX_STEP_DIST, step)
		maxS=math.max(ATPC.MAX_SPEED, (maxD/dt)*1.25)
	elseif m=="tfly" then
		local sp=tonumber(flyVariables.TflySpeed) or 1
		local step=sp*2.5
		maxD=math.max(ATPC.MAX_STEP_DIST, step)
		maxS=math.max(ATPC.MAX_SPEED, (maxD/dt)*1.5)
	end
	return maxS, maxD
end

ATPC._isFlyActive=function()
	return FLYING==true and ATPC._getFlyMode()~="none"
end

ATPC._zero = function(char)
	for _,d in ipairs(char:GetDescendants()) do
		if d:IsA("BasePart") then
			d.AssemblyLinearVelocity = Vector3.zero
			d.AssemblyAngularVelocity = Vector3.zero
		end
	end
end

ATPC._bindChar = function(char)
	local r = getRoot(char)
	if not r then return end
	ATPC.lastCF = r.CFrame
	ATPC.lastT = os.clock()
	ATPC.hits = 0
end

ATPC._syncBtn = function()
	if not ATPC.btn then return end
	if ATPC.state then
		ATPC.btn.Text = "UNACFTP"
		ATPC.btn.BackgroundColor3 = Color3.fromRGB(0,170,0)
	else
		ATPC.btn.Text = "ACFTP"
		ATPC.btn.BackgroundColor3 = Color3.fromRGB(170,0,0)
	end
end

ATPC._buildGUI = function()
	if not IsOnMobile then return end
	if ATPC.gui then ATPC.gui:Destroy() ATPC.gui=nil ATPC.btn=nil end
	ATPC.gui = InstanceNew("ScreenGui")
	local b = InstanceNew("TextButton")
	local c = InstanceNew("UICorner")
	local a = InstanceNew("UIAspectRatioConstraint")
	NaProtectUI(ATPC.gui)
	ATPC.gui.ResetOnSpawn = false
	b.Parent = ATPC.gui
	b.BackgroundTransparency = 0.1
	b.Position = UDim2.new(0.9,0,0.4,0)
	b.Size = UDim2.new(0.08,0,0.1,0)
	b.Font = Enum.Font.GothamBold
	b.TextColor3 = Color3.fromRGB(255,255,255)
	b.TextScaled = true
	b.TextWrapped = true
	b.Active = true
	c.CornerRadius = UDim.new(0.2,0)
	c.Parent = b
	a.Parent = b
	a.AspectRatio = 1
	ATPC.btn = b
	ATPC._syncBtn()
	MouseButtonFix(b,function()
		if ATPC.state then ATPC.Disable() else ATPC.Enable() end
	end)
	NAgui.draggerV2(b)
end

ATPC.Enable=function()
	if ATPC.state then return end
	ATPC.state=true
	ATPC._bindChar(ATPC.plr.Character)
	if not ATPC.cn.add then ATPC.cn.add=ATPC.plr.CharacterAdded:Connect(ATPC._bindChar) end
	if not ATPC.cn.hb then
		ATPC.cn.hb=RunService.Heartbeat:Connect(function()
			if not ATPC.state then return end
			local char=ATPC.plr.Character
			if not char then return end
			local r=getRoot(char)
			if not r then return end

			local now=os.clock()
			local dt=math.max(now-(ATPC.lastT or now),1/240)
			local cf=r.CFrame
			if not ATPC.lastCF then ATPC.lastCF,ATPC.lastT=cf,now return end

			local dist=(cf.Position-ATPC.lastCF.Position).Magnitude
			local speed=dist/dt

			local maxS, maxD=ATPC.MAX_SPEED, ATPC.MAX_STEP_DIST
			if ATPC._isFlyActive() then
				local fs, fd=ATPC._flyAllowances(dt)
				maxS, maxD=math.max(maxS,fs), math.max(maxD,fd)
			end

			if dist>maxD or speed>maxS then
				char:PivotTo(ATPC.lastCF)
				ATPC._zero(char)
				ATPC.hits+=1
				if ATPC.hits>=ATPC.REPEAT then
					Defer(function() ATPC._zero(char) end)
					Delay(ATPC.LOCK_TIME,function() ATPC.hits=0 end)
				end
			else
				ATPC.hits=math.max(ATPC.hits-1,0)
				ATPC.lastCF=cf
				ATPC.lastT=now
			end
		end)
	end
	ATPC._syncBtn()
	DebugNotif("Anti CFrame Teleport enabled",1.5)
end

ATPC.Disable = function()
	if not ATPC.state then return end
	ATPC.state = false
	for _,c in pairs(ATPC.cn) do c:Disconnect() end
	ATPC.cn = {}
	ATPC.lastCF, ATPC.lastT, ATPC.hits = nil, 0, 0
	ATPC._syncBtn()
	DebugNotif("Anti CFrame Teleport disabled",1.5)
end

cmd.add({"anticframeteleport","acframetp","acftp"}, {"anticframeteleport (acframetp,acftp)","Prevents client teleports"}, function()
	ATPC.Enable()
	if IsOnMobile then ATPC._buildGUI() end
end)

cmd.add({"unanticframeteleport","unacframetp","unacftp"}, {"unanticframeteleport (unacframetp,unacftp)","Disables Anti CFrame Teleport"}, function()
	ATPC.Disable()
	if ATPC.gui then ATPC.gui:Destroy() ATPC.gui=nil ATPC.btn=nil end
end)

cmd.add({"lay"},{"lay","zzzzzzzz"},function()
	local Human=getHum()
	if not Human then return end
	Human.Sit=true
	Wait(.1)
	Human.RootPart.CFrame=Human.RootPart.CFrame*CFrame.Angles(math.pi*.5,0,0)
	for _,v in ipairs(Human:GetPlayingAnimationTracks()) do
		v:Stop()
	end
end)

cmd.add({"trip"},{"trip","get up NOW"},function()
	getHum():ChangeState(0)
	getRoot(getChar()).Velocity=getRoot(getChar()).CFrame.LookVector*25
end)

cmd.add({"antitrip"}, {"antitrip", "no tripping today bruh"}, function()
	local LocalPlayer=Players.LocalPlayer
	local states={Enum.HumanoidStateType.FallingDown,Enum.HumanoidStateType.Ragdoll,Enum.HumanoidStateType.PlatformStanding}
	shared.__antitrip=shared.__antitrip or {saved={}}
	local STORE=shared.__antitrip
	local function saveAndDisableStates(h)
		local saved={}
		for _,st in ipairs(states) do
			local ok,was=pcall(function() return h:GetStateEnabled(st) end)
			if ok then
				saved[st]=was
				pcall(function() h:SetStateEnabled(st,false) end)
			end
		end
		STORE.saved[h]=saved
	end
	local function recover(hum,root)
		pcall(function() root.AssemblyLinearVelocity=Vector3.zero end)
		pcall(function() hum.PlatformStand=false end)
		pcall(function() hum:ChangeState(Enum.HumanoidStateType.Running) end)
	end
	local function doTRIPPER(char)
		local hum=getPlrHum(char)
		local root=getRoot(char)
		while not (hum and root) do Wait(0.1) hum=getPlrHum(char) root=getRoot(char) end
		saveAndDisableStates(hum)
		NAlib.disconnect("trip_fall")
		NAlib.connect("trip_fall",hum.FallingDown:Connect(function()
			recover(hum,root)
		end))
		NAlib.disconnect("trip_state")
		NAlib.connect("trip_state",hum.StateChanged:Connect(function(_,new)
			if new==Enum.HumanoidStateType.FallingDown or new==Enum.HumanoidStateType.Ragdoll or new==Enum.HumanoidStateType.PlatformStanding then
				recover(hum,root)
			end
		end))
		NAlib.disconnect("trip_step")
		NAlib.connect("trip_step",RunService.RenderStepped:Connect(function()
			local s=hum:GetState()
			if s==Enum.HumanoidStateType.FallingDown or s==Enum.HumanoidStateType.Ragdoll or s==Enum.HumanoidStateType.PlatformStanding then
				recover(hum,root)
			end
		end))
		hum.Destroying:Connect(function() STORE.saved[hum]=nil end)
	end
	if LocalPlayer and LocalPlayer.Character then
		doTRIPPER(LocalPlayer.Character)
	end
	NAlib.disconnect("trip_char")
	NAlib.connect("trip_char",(LocalPlayer and LocalPlayer.CharacterAdded):Connect(function(char)
		doTRIPPER(char)
	end))
	DebugNotif("Antitrip Enabled",2)
end)

cmd.add({"unantitrip"}, {"unantitrip", "tripping allowed now"}, function()
	NAlib.disconnect("trip_fall")
	NAlib.disconnect("trip_state")
	NAlib.disconnect("trip_step")
	NAlib.disconnect("trip_char")
	local STORE=shared.__antitrip
	if STORE and STORE.saved then
		for hum,saved in pairs(STORE.saved) do
			if hum and hum.Parent and saved then
				for st,was in pairs(saved) do
					pcall(function() hum:SetStateEnabled(st,was) end)
				end
			end
		end
		STORE.saved={}
	end
	local char=getChar()
	if char then
		local hum=getPlrHum(char)
		if hum then
			pcall(function() hum.PlatformStand=false end)
		end
	end
	DebugNotif("Antitrip Disabled",2)
end)

cmd.add({"checkrfe"},{"checkrfe","Checks if the game has respect filtering enabled off"},function()
	DoNotif(SafeGetService("SoundService").RespectFilteringEnabled and "Respect Filtering Enabled is on" or "Respect Filtering Enabled is off")
end)

cmd.add({"sit"},{"sit","Sit your player"},function()
	local hum=getHum()
	if hum then
		hum.Sit=true
	end
end)

cmd.add({"oldroblox"},{"oldroblox","Old skybox and studs"},function()
	if Lighting:GetAttribute("NAOldRbx_Enabled") then return end
	Lighting:SetAttribute("NAOldRbx_Enabled", true)

	local studTex = (getcustomasset and getcustomasset(NAfiles.NAASSETSFILEPATH.."/"..NAImageAssets.Stud)) or "rbxassetid://48715260"
	local inletTex = (getcustomasset and getcustomasset(NAfiles.NAASSETSFILEPATH.."/"..NAImageAssets.Inlet)) or "rbxassetid://20299774"
	local skyA = {
		bk = (getcustomasset and getcustomasset(NAfiles.NAASSETSFILEPATH.."/"..NAImageAssets.bk)) or "rbxassetid://161781263",
		dn = (getcustomasset and getcustomasset(NAfiles.NAASSETSFILEPATH.."/"..NAImageAssets.dn)) or "rbxassetid://161781258",
		ft = (getcustomasset and getcustomasset(NAfiles.NAASSETSFILEPATH.."/"..NAImageAssets.ft)) or "rbxassetid://161781261",
		lf = (getcustomasset and getcustomasset(NAfiles.NAASSETSFILEPATH.."/"..NAImageAssets.lf)) or "rbxassetid://161781267",
		rt = (getcustomasset and getcustomasset(NAfiles.NAASSETSFILEPATH.."/"..NAImageAssets.rt)) or "rbxassetid://161781268",
		up = (getcustomasset and getcustomasset(NAfiles.NAASSETSFILEPATH.."/"..NAImageAssets.up)) or "rbxassetid://161781260",
	}

	local function ensureSky()
		local s = Lighting:FindFirstChild("NAOldRobloxSky")
		if s then return s end
		local sky = InstanceNew("Sky")
		sky.Name = "NAOldRobloxSky"
		sky.SkyboxBk = skyA.bk
		sky.SkyboxDn = skyA.dn
		sky.SkyboxFt = skyA.ft
		sky.SkyboxLf = skyA.lf
		sky.SkyboxRt = skyA.rt
		sky.SkyboxUp = skyA.up
		sky.Parent = Lighting
		return sky
	end

	local function applyToPart(v)
		if not v or not v.Parent or not v:IsA("BasePart") then return end
		if v:GetAttribute("NAOldRbx_Applied") then return end
		v:SetAttribute("NAOldRbx_Applied", true)
		if v:GetAttribute("NAOldRbx_OrigMatName") == nil then
			local ok, name = pcall(function() return v.Material.Name end)
			if ok then v:SetAttribute("NAOldRbx_OrigMatName", name) end
		end

		local stud = v:FindFirstChild("NAOldRobloxStud")
		if not stud then
			stud = InstanceNew("Texture")
			stud.Name = "NAOldRobloxStud"
			stud.Parent = v
		end
		stud.Texture = studTex
		stud.Face = Enum.NormalId.Top
		stud.StudsPerTileU = 1
		stud.StudsPerTileV = 1
		stud.Transparency = v.Transparency

		local inlet = v:FindFirstChild("NAOldRobloxInlet")
		if not inlet then
			inlet = InstanceNew("Texture")
			inlet.Name = "NAOldRobloxInlet"
			inlet.Parent = v
		end
		inlet.Texture = inletTex
		inlet.Face = Enum.NormalId.Bottom
		inlet.StudsPerTileU = 1
		inlet.StudsPerTileV = 1
		inlet.Transparency = v.Transparency

		v.Material = Enum.Material.Plastic
	end

	Lighting:SetAttribute("NAOldRbx_PrevClockTime", Lighting.ClockTime)
	Lighting:SetAttribute("NAOldRbx_PrevGlobalShadows", Lighting.GlobalShadows)
	local ok,outlines = pcall(function() return Lighting.Outlines end)
	if ok then Lighting:SetAttribute("NAOldRbx_HadOutlines", true) Lighting:SetAttribute("NAOldRbx_PrevOutlines", outlines) end

	local stash = workspace:FindFirstChild("NAOldRbx_SkyStash") or InstanceNew("Folder")
	stash.Name = "NAOldRbx_SkyStash"
	stash.Parent = workspace
	for _,v in ipairs(Lighting:GetChildren()) do
		if v:IsA("Sky") then
			local c = v:Clone()
			c.Parent = stash
			v:Destroy()
		end
	end

	Lighting.ClockTime = 12
	pcall(function() Lighting.GlobalShadows = false end)
	pcall(function() Lighting.Outlines = false end)
	ensureSky()

	local RS = SafeGetService("RunService")

	local q = {head = 1, tail = 0, data = {}}
	local function qpush(x) q.tail += 1; q.data[q.tail] = x end
	local function qpop() local i = q.head; if i > q.tail then return nil end; local x = q.data[i]; q.data[i] = nil; q.head = i + 1; return x end
	for _,child in ipairs(workspace:GetChildren()) do qpush(child) end

	NAlib.disconnect("oldrbx_tick")
	NAlib.connect("oldrbx_tick", RS.Heartbeat:Connect(function()
		if not Lighting:GetAttribute("NAOldRbx_Enabled") then return end
		local budgetNodes = 200
		local i = 0
		while i < budgetNodes do
			local node = qpop()
			if not node then break end
			if node.Parent then
				if node:IsA("BasePart") then
					applyToPart(node)
					i += 1
				end
				for _,c in ipairs(node:GetChildren()) do
					qpush(c)
				end
			end
		end
	end))

	NAlib.disconnect("oldrbx_desc")
	NAlib.connect("oldrbx_desc", workspace.DescendantAdded:Connect(function(obj)
		if not Lighting:GetAttribute("NAOldRbx_Enabled") then return end
		if obj:IsA("BasePart") then
			qpush(obj)
		end
	end))

	NAlib.disconnect("oldrbx_skywatch")
	NAlib.connect("oldrbx_skywatch", Lighting.ChildAdded:Connect(function(obj)
		if not Lighting:GetAttribute("NAOldRbx_Enabled") then return end
		if obj:IsA("Sky") and obj.Name ~= "NAOldRobloxSky" then
			local c = obj:Clone()
			c.Parent = stash
			obj:Destroy()
			ensureSky()
		end
	end))

	NAlib.disconnect("oldrbx_skyguard")
	NAlib.connect("oldrbx_skyguard", Lighting.ChildRemoved:Connect(function(obj)
		if not Lighting:GetAttribute("NAOldRbx_Enabled") then return end
		if obj:IsA("Sky") and not Lighting:FindFirstChild("NAOldRobloxSky") then
			ensureSky()
		end
	end))
end)

cmd.add({"unoldroblox"},{"unoldroblox","Restore skybox and studs"},function()
	if not Lighting:GetAttribute("NAOldRbx_Enabled") then return end

	NAlib.disconnect("oldrbx_desc")
	NAlib.disconnect("oldrbx_skywatch")
	NAlib.disconnect("oldrbx_skyguard")
	NAlib.disconnect("oldrbx_tick")

	local RS = SafeGetService("RunService")

	local rq = {head = 1, tail = 0, data = {}}
	local function rpush(x) rq.tail += 1; rq.data[rq.tail] = x end
	local function rpop() local i = rq.head; if i > rq.tail then return nil end; local x = rq.data[i]; rq.data[i] = nil; rq.head = i + 1; return x end
	for _,child in ipairs(workspace:GetChildren()) do rpush(child) end

	NAlib.disconnect("oldrbx_untick")
	NAlib.connect("oldrbx_untick", RS.Heartbeat:Connect(function()
		local budgetNodes = 200
		local i = 0
		while i < budgetNodes do
			local node = rpop()
			if not node then break end
			if node.Parent then
				if node:IsA("BasePart") and node:GetAttribute("NAOldRbx_Applied") then
					local a = node:FindFirstChild("NAOldRobloxStud"); if a then a:Destroy() end
					local b = node:FindFirstChild("NAOldRobloxInlet"); if b then b:Destroy() end
					local matName = node:GetAttribute("NAOldRbx_OrigMatName")
					if typeof(matName) == "string" then
						local mat = Enum.Material[matName]
						if mat then pcall(function() node.Material = mat end) end
					end
					node:SetAttribute("NAOldRbx_Applied", nil)
					node:SetAttribute("NAOldRbx_OrigMatName", nil)
					i += 1
				end
				for _,c in ipairs(node:GetChildren()) do
					rpush(c)
				end
			end
		end

		if rq.head > rq.tail then
			NAlib.disconnect("oldrbx_untick")

			for _,v in ipairs(Lighting:GetChildren()) do
				if v:IsA("Sky") and v.Name == "NAOldRobloxSky" then
					v:Destroy()
				end
			end
			local stash = workspace:FindFirstChild("NAOldRbx_SkyStash")
			if stash then
				for _,c in ipairs(stash:GetChildren()) do
					if c:IsA("Sky") then
						c.Parent = Lighting
					end
				end
				stash:Destroy()
			end

			local prevClock = Lighting:GetAttribute("NAOldRbx_PrevClockTime")
			local prevShadows = Lighting:GetAttribute("NAOldRbx_PrevGlobalShadows")
			if typeof(prevClock) == "number" then pcall(function() Lighting.ClockTime = prevClock end) end
			if typeof(prevShadows) == "boolean" then pcall(function() Lighting.GlobalShadows = prevShadows end) end
			if Lighting:GetAttribute("NAOldRbx_HadOutlines") then
				local prevOut = Lighting:GetAttribute("NAOldRbx_PrevOutlines")
				pcall(function() Lighting.Outlines = prevOut end)
			end

			Lighting:SetAttribute("NAOldRbx_Enabled", nil)
			Lighting:SetAttribute("NAOldRbx_PrevClockTime", nil)
			Lighting:SetAttribute("NAOldRbx_PrevGlobalShadows", nil)
			Lighting:SetAttribute("NAOldRbx_HadOutlines", nil)
			Lighting:SetAttribute("NAOldRbx_PrevOutlines", nil)
		end
	end))
end)

cmd.add({"f3x","fex"},{"f3x (fex)","F3X for client"},function()
	loadstring(game:GetObjects("rbxassetid://6695644299")[1].Source)()
end)

cmd.add({"harked","comet"},{"harked (comet)","Executes Comet which is like harked"},function()
	loadstring(game:HttpGet("https://raw.githubusercontent.com/ltseverydayyou/Nameless-Admin/main/comet"))();
end)

cmd.add({"triggerbot", "tbot"}, {"triggerbot (tbot)", "Executes a script that automatically clicks the mouse when the mouse is on a player"}, function()
	local ToggleKey = Enum.KeyCode.Z
	local FieldOfView = 10

	local UIS = UserInputService
	local Camera = workspace.CurrentCamera

	local Player = Players.LocalPlayer
	local Mouse = Player:GetMouse()
	local Toggled = false
	local Mode = "FFA"
	local LastMode = nil

	local GUI = InstanceNew("ScreenGui")
	local On = InstanceNew("TextLabel")
	local uicorner = InstanceNew("UICorner")
	NaProtectUI(GUI)
	On.Parent = GUI
	On.BackgroundColor3 = Color3.fromRGB(12, 4, 20)
	On.BackgroundTransparency = 0.14
	On.BorderSizePixel = 0
	On.Position = UDim2.new(0.88, 0, 0.33, 0)
	On.Size = UDim2.new(0, 160, 0, 20)
	On.Font = Enum.Font.SourceSans
	On.Text = "TriggerBot On: false (Key: Q)"
	On.TextColor3 = Color3.new(1, 1, 1)
	On.TextScaled = true
	On.TextSize = 14
	On.TextWrapped = true
	uicorner.Parent = On

	local function IsInFieldOfView(target)
		local targetPosition = target.Position
		local screenPoint, onScreen = Camera:WorldToScreenPoint(targetPosition)
		if onScreen then
			local mousePosition = Vector2.new(Mouse.X, Mouse.Y)
			local targetScreenPosition = Vector2.new(screenPoint.X, screenPoint.Y)
			local distance = (mousePosition - targetScreenPosition).Magnitude
			return distance <= FieldOfView
		end
		return false
	end

	local function IsEnemy(otherPlayer)
		if Mode == "FFA" then
			return true
		else
			return otherPlayer.Team ~= nil and Player.Team ~= nil and otherPlayer.Team ~= Player.Team
		end
	end

	local function GetClosestPlayer()
		for _, otherPlayer in pairs(Players:GetPlayers()) do
			if otherPlayer ~= Player and IsEnemy(otherPlayer) and otherPlayer.Character then
				for _, part in pairs(otherPlayer.Character:GetChildren()) do
					if part:IsA("BasePart") and IsInFieldOfView(part) then
						return otherPlayer
					end
				end
			end
		end
		return nil
	end

	local function Click()
		mouse1click()
	end

	local function CheckMode()
		if #Players:GetPlayers() > 0 and Players.LocalPlayer.Team == nil then
			Mode = "FFA"
		else
			Mode = "Team"
		end

		if Mode ~= LastMode then
			DoNotif("Mode changed to: "..Mode)
			LastMode = Mode
		end
	end

	UIS.InputBegan:Connect(function(input, processed)
		if not processed and input.KeyCode == ToggleKey then
			Toggled = not Toggled
			On.Text = "TriggerBot On: "..tostring(Toggled).." (Key: "..ToggleKey.Name..")"
		end
	end)

	RunService.RenderStepped:Connect(function()
		CheckMode()
		if Toggled then
			local targetPlayer = GetClosestPlayer()
			if getPlrHum(targetPlayer) then
				local humanoid = getPlrHum(targetPlayer)
				if humanoid.Health > 0 then
					Click()
				end
			end
		end
	end)

	On.Text = "TriggerBot On: "..tostring(Toggled).." (Key: "..ToggleKey.Name..")"

	DebugNotif("Advanced Trigger Bot Loaded")
end)

stationaryRespawn = false
needsRespawning = false
hasPosition = false
spawnPosition = CFrame.new()

cmd.add({"setspawn", "spawnpoint", "ss"}, {"setspawn (spawnpoint, ss)", "Sets your spawn point to the current character's position"}, function()
	if NAlib.isConnected("spawnCONNECTION") and NAlib.isConnected("spawnCHARCON") then
		return DoNotif("spawn point is already running", 3)
	end

	DebugNotif("Spawn has been set")
	stationaryRespawn = true

	function handleRespawn()
		if stationaryRespawn and getHum() and getHum().Health == 0 then
			if not hasPosition and (getChar() and getRoot(getChar())) then
				spawnPosition = getRoot(getChar()).CFrame
				hasPosition = true
			end
			needsRespawning = true
		end

		if needsRespawning then
			if getChar() and getRoot(getChar()) then
				getRoot(getChar()).CFrame = spawnPosition
			end
		end
	end

	NAlib.connect("spawnCONNECTION", RunService.RenderStepped:Connect(handleRespawn))

	NAlib.connect("spawnCHARCON", LocalPlayer.CharacterAdded:Connect(function()
		Wait(1)
		needsRespawning = false
		hasPosition = false
	end))
end)

cmd.add({"disablespawn", "unsetspawn", "ds"}, {"disablespawn (unsetspawn, ds)", "Disables the previously set spawn point"}, function()
	DebugNotif("Spawn point has been disabled")
	NAlib.disconnect("spawnCONNECTION")
	NAlib.disconnect("spawnCHARCON")
	stationaryRespawn = false
	needsRespawning = false
	hasPosition = false
	spawnPosition = CFrame.new()
end)

cmd.add({"flashback", "deathpos", "deathtp"}, {"flashback (deathpos, deathtp)", "Teleports you to your last death point"}, function()
	if deathCFrame then
		local character = getChar()
		if character and getRoot(character) then
			getRoot(character).CFrame = deathCFrame
		else
			DebugNotif("Could not teleport, root is missing", 3)
		end
	else
		DebugNotif("No available death location to teleport to! You need to die first", 3)
	end
end)

cmd.add({"tospawn", "ts"}, {"tospawn (ts)", "Teleports you to a SpawnLocation"}, function()
	local character = getChar()
	if not character then
		return DebugNotif("Character not found", 3)
	end
	local root = getRoot(character)
	if not root then
		return DebugNotif("Root not found", 3)
	end
	local closestSpawn = nil
	local shortestDistance = math.huge
	local rootPosition = root.Position
	for _, descendant in ipairs(workspace:GetDescendants()) do
		if descendant:IsA("SpawnLocation") then
			local distance = (descendant.Position - rootPosition).Magnitude
			if distance < shortestDistance then
				shortestDistance = distance
				closestSpawn = descendant
			end
		end
	end
	if not closestSpawn then
		return DebugNotif("No SpawnLocation found in workspace", 3)
	end
	root.CFrame = closestSpawn.CFrame * CFrame.new(0, 5, 0)
end)

cmd.add({"hamster"}, {"hamster <number>", "Hamster ball"}, function(...)
	local Camera = workspace.CurrentCamera

	local SPEED_MULTIPLIER = (...) or 30
	local JUMP_POWER = 60
	local JUMP_GAP = 0.3

	local character = SafeGetService("Players").LocalPlayer.Character

	for i, v in ipairs(character:GetDescendants()) do
		if v:IsA("BasePart") then
			v.CanCollide = false
		end
	end

	local ball = getRoot(character)
	ball.Shape = Enum.PartType.Ball
	ball.Size = Vector3.new(5, 5, 5)
	local humanoid = getHum()

	local params = RaycastParams.new()
	params.FilterType = Enum.RaycastFilterType.Blacklist
	params.FilterDescendantsInstances = {character}

	NAlib.connect("hamster_render", RunService.RenderStepped:Connect(function(delta)
		ball.CanCollide = true
		humanoid.PlatformStand = true
		if UserInputService:GetFocusedTextBox() then return end

		local moveVec = GetCustomMoveVector()

		if moveVec.Magnitude > 0 then
			local right = Camera.CFrame.RightVector
			local forward = Camera.CFrame.LookVector
			ball.RotVelocity = ball.RotVelocity + (right * moveVec.Z * delta * SPEED_MULTIPLIER)
			ball.RotVelocity = ball.RotVelocity + (forward * moveVec.X * delta * SPEED_MULTIPLIER)
		end
	end))

	UserInputService.JumpRequest:Connect(function()
		local result = workspace:Raycast(
			ball.Position,
			Vector3.new(0, -((ball.Size.Y / 2) + JUMP_GAP), 0),
			params
		)
		if result then
			ball.Velocity = ball.Velocity + Vector3.new(0, JUMP_POWER, 0)
		end
	end)

	humanoid.Died:Connect(function()
		NAlib.disconnect("hamster_render")
	end)

	Camera.CameraSubject = ball
end, true)

cmd.add({"antiafk","noafk"},{"antiafk (noafk)","Prevents you from being kicked for being AFK"},function()
	if NAlib.isConnected("antiAFK") or NAlib.isConnected("antiAFK_scan") then
		return DebugNotif("Anti AFK is already enabled")
	end

	local GETCONS = getconnections or get_signal_cons or (syn and syn.getconnections)
	local rng = Random.new()
	local KEY = Enum.KeyCode.F15

	local function antiAFKHandler()
		if not GETCONS then
			local VIM = SafeGetService("VirtualInputManager")
			if not VIM then return end
			VIM:SendKeyEvent(true, KEY, false, game)
			Wait(rng:NextNumber(0.04, 0.08))
			VIM:SendKeyEvent(false, KEY, false, game)
			Wait(rng:NextNumber(55, 75))
		end
	end

	if GETCONS then
		local myConn = Players.LocalPlayer.Idled:Connect(antiAFKHandler)
		NAlib.connect("antiAFK", myConn)
		local function nukeOtherIdled()
			local ok, conns = pcall(GETCONS, Players.LocalPlayer.Idled)
			if not ok or type(conns) ~= "table" then return end
			for _, c in ipairs(conns) do
				local f
				pcall(function() f = c.Function end)
				if f ~= antiAFKHandler then
					if c and c.Disable then pcall(function() c:Disable() end) end
					if c and c.Disconnect then pcall(function() c:Disconnect() end) end
				end
			end
		end
		nukeOtherIdled()
		--[[local acc = 0
		local scanConn = RunService.Heartbeat:Connect(function(dt)
			acc += dt
			if acc >= 2 + rng:NextNumber(0, 0.75) then
				acc = 0
				nukeOtherIdled()
			end
		end)]]
		NAlib.connect("antiAFK_scan", scanConn)
		DebugNotif("Anti AFK enabled")
	else
		local function enable()
			local myConn = Players.LocalPlayer.Idled:Connect(antiAFKHandler)
			NAlib.connect("antiAFK", myConn)
			SpawnCall(antiAFKHandler)
			DebugNotif("Anti AFK enabled")
		end
		Window({
			Title = "This Anti AFK uses VirtualInputManager key events and may be detected in some games.\nEnable anyway?",
			Buttons = {
				{ Text = "Enable Anyway", Callback = enable },
				{ Text = "Cancel", Callback = function() DebugNotif("Anti AFK cancelled") end }
			}
		})
	end
end)

cmd.add({"unantiafk","unnoafk"},{"unantiafk (unnoafk)","Allows you to be kicked for being AFK"},function()
	local was = false
	if NAlib.isConnected("antiAFK") then
		NAlib.disconnect("antiAFK"); was = true
	end
	if NAlib.isConnected("antiAFK_scan") then
		NAlib.disconnect("antiAFK_scan"); was = true
	end
	if was then
		DebugNotif("Anti AFK has been disabled")
	else
		DebugNotif("Anti AFK is already disabled")
	end
end)

local tpUI
local tpTools = {}

NAmanage.clearAllTP = function()
	if tpUI then
		tpUI:Destroy()
		tpUI = nil
	end
	for _, t in ipairs(tpTools) do
		t:Destroy()
	end
	tpTools = {}
	NAlib.disconnect("tp_down")
	NAlib.disconnect("tp_up")
end

NAmanage.makeClickTweenUI = function()
	NAmanage.clearAllTP()
	local TweenService = SafeGetService("TweenService")
	local player = Players.LocalPlayer
	local mouse = player:GetMouse()

	tpUI = InstanceNew("ScreenGui")
	NaProtectUI(tpUI)

	local clickTpButton = InstanceNew("TextButton")
	clickTpButton.Size = UDim2.new(0,130,0,40)
	clickTpButton.AnchorPoint = Vector2.new(0.5,0)
	clickTpButton.Position = UDim2.new(0.45,0,0.1,0)
	clickTpButton.Text = "Enable Click TP"
	clickTpButton.TextColor3 = Color3.fromRGB(255,255,255)
	clickTpButton.BackgroundColor3 = Color3.fromRGB(50,50,50)
	clickTpButton.BorderSizePixel = 0
	clickTpButton.Parent = tpUI

	local tweenTpButton = clickTpButton:Clone()
	tweenTpButton.Position = UDim2.new(0.55,0,0.1,0)
	tweenTpButton.Text = "Enable Tween TP"
	tweenTpButton.Parent = tpUI

	InstanceNew("UICorner", clickTpButton)
	InstanceNew("UICorner", tweenTpButton)

	local clickEnabled = false
	local tweenEnabled = false
	local initialPos
	local dragThreshold = 10
	local ctCFVal

	MouseButtonFix(clickTpButton, function()
		clickEnabled = not clickEnabled
		tweenEnabled = false
		if ctCFVal then
			ctCFVal:Destroy()
			ctCFVal = nil
		end
		clickTpButton.Text = clickEnabled and "Disable Click TP" or "Enable Click TP"
		tweenTpButton.Text = "Enable Tween TP"
	end)

	MouseButtonFix(tweenTpButton, function()
		tweenEnabled = not tweenEnabled
		clickEnabled = false
		if not tweenEnabled and ctCFVal then
			ctCFVal:Destroy()
			ctCFVal = nil
		end
		tweenTpButton.Text = tweenEnabled and "Disable Tween TP" or "Enable Tween TP"
		clickTpButton.Text = "Enable Click TP"
	end)

	NAlib.connect("tp_down", mouse.Button1Down:Connect(function()
		initialPos = Vector2.new(mouse.X, mouse.Y)
	end))

	NAlib.connect("tp_up", mouse.Button1Up:Connect(function()
		if not initialPos then return end
		local currentPos = Vector2.new(mouse.X, mouse.Y)
		if (currentPos - initialPos).Magnitude <= dragThreshold then
			local target = mouse.Hit + Vector3.new(0,2.5,0)
			local char = player.Character
			if clickEnabled then
				char:PivotTo(CFrame.new(target.p))
			elseif tweenEnabled then
				if ctCFVal then
					ctCFVal:Destroy()
					ctCFVal = nil
				end
				local cfVal = InstanceNew("CFrameValue")
				ctCFVal = cfVal
				cfVal.Value = char:GetPivot()
				cfVal.Changed:Connect(function(newCF)
					char:PivotTo(newCF)
				end)
				local tw = TweenService:Create(cfVal, TweenInfo.new(NAmanage.resolveTweenDuration(), Enum.EasingStyle.Quad, Enum.EasingDirection.Out),{Value=CFrame.new(target.p)})
				tw:Play()
				tw.Completed:Connect(function()
					if cfVal then
						cfVal:Destroy()
						if ctCFVal == cfVal then
							ctCFVal = nil
						end
					end
				end)
			end
		end
		initialPos = nil
	end))

	NAgui.draggerV2(clickTpButton)
	NAgui.draggerV2(tweenTpButton)
end

NAmanage.makeClickTweenTools = function()
	NAmanage.clearAllTP()
	local TweenService = SafeGetService("TweenService")
	local player = Players.LocalPlayer

	local function newTool(name, tween)
		local tool = InstanceNew("Tool")
		tool.Name = name
		tool.RequiresHandle = false
		tool.CanBeDropped = false
		tool.Parent = player.Backpack
		tool.Activated:Connect(function()
			local mouse = player:GetMouse()
			local target = mouse.Hit + Vector3.new(0,2.5,0)
			local char = player.Character
			if tween then
				local cfVal = InstanceNew("CFrameValue")
				cfVal.Value = char:GetPivot()
				cfVal.Changed:Connect(function(newCF)
					char:PivotTo(newCF)
				end)
				local tw = TweenService:Create(cfVal, TweenInfo.new(NAmanage.resolveTweenDuration(), Enum.EasingStyle.Quad, Enum.EasingDirection.Out),{Value=CFrame.new(target.p)})
				tw:Play()
				tw.Completed:Connect(function()
					cfVal:Destroy()
				end)
			else
				char:PivotTo(CFrame.new(target.p))
			end
		end)
		Insert(tpTools, tool)
	end

	newTool("Click TP", false)
	newTool("Tween TP", true)
end

cmd.add({"clicktp","tptool"},{"clicktp (tptool)","Teleport where your mouse is"},function()
	Window({
		Title = "Choose Teleport Mode",
		Description = "Would you like to use on-screen buttons, or equipable Tools in your Backpack?",
		Buttons = {
			{Text="UI Buttons",Callback=NAmanage.makeClickTweenUI},
			{Text="Backpack Tools",Callback=NAmanage.makeClickTweenTools}
		}
	})
end)

cmd.add({"unclicktp","untptool"},{"unclicktp (untptool)","Remove teleport buttons or tools"},function()
	NAmanage.clearAllTP()
end)

cmd.add({"olddex"},{"olddex","Using this you can see the parts / guis / scripts etc with this. A really good and helpful script."},function()
	loadstring(game:HttpGet("https://raw.githubusercontent.com/ltseverydayyou/uuuuuuu/refs/heads/main/DexByMoonMobile"))()
end)

cmd.add({"dex"},{"dex","Better version of dex"},function()
	loadstring(game:HttpGet("https://raw.githubusercontent.com/ltseverydayyou/uuuuuuu/refs/heads/main/DexPlusBackup.luau"))()
end)

cmd.add({"minimap"},{"minimap","just a minimap lol"},function()
	loadstring(game:HttpGet("https://raw.githubusercontent.com/ltseverydayyou/uuuuuuu/refs/heads/main/minimap.luau"))()
end)

cmd.add({"animationplayer","animplayer", "aplayer","animp"},{"animationplayer","dropdown menu with all the animations the game has to be played"},function()
	loadstring(game:HttpGet("https://raw.githubusercontent.com/ltseverydayyou/uuuuuuu/refs/heads/main/AnimPlayer.luau"))();
end)

cmd.add({"Decompiler"},{"Decompiler","Allows you to decompile LocalScript/ModuleScript's using konstant"},function()
	Spawn(function()
		assert(getscriptbytecode, "Exploit not supported.")

		local API: string = "http://api.plusgiant5.com/"

		local last_call = 0
		function call(konstantType: string, scriptPath: Script | ModuleScript | LocalScript): string
			local success: boolean, bytecode: string = NACaller(getscriptbytecode, scriptPath)

			if (not success) then
				return
			end

			local time_elapsed = os.clock() - last_call
			if time_elapsed <= .5 then
				Wait(.5 - time_elapsed)
			end
			local httpResult = opt.NAREQUEST({
				Url = API..konstantType,
				Body = bytecode,
				Method = "POST",
				Headers = {
					["Content-Type"] = "text/plain"
				},
			})
			last_call = os.clock()

			if (httpResult.StatusCode ~= 200) then
				return
			else
				return httpResult.Body
			end
		end

		function decompile(scriptPath: Script | ModuleScript | LocalScript): string
			return call("/konstant/decompile", scriptPath)
		end

		function disassemble(scriptPath: Script | ModuleScript | LocalScript): string
			return call("/konstant/disassemble", scriptPath)
		end

		getgenv().decompile = decompile
		getgenv().disassemble = disassemble

		-- by lovrewe
	end)
	--loadstring(game:HttpGet("https://raw.githubusercontent.com/ltseverydayyou/uuuuuuu/refs/heads/main/WompWomp.lua"))()
end)

cmd.add({"getidfromusername","gidu"},{"getidfromusername (gidu)","Copy a user's UserId by Username"}, function(thingy)
	local s,idd=NACaller(function()
		return Players:GetUserIdFromNameAsync(tostring(thingy))
	end)

	if not s then return DoNotif("err: "..tostring(idd)) end

	if not setclipboard then return DoNotif("no setclipboard") end
	setclipboard(tostring(idd))

	DebugNotif("Copied "..tostring(thingy).."'s UserId: "..tostring(idd))
end,true)

cmd.add({"getuserfromid","guid"},{"getuserfromid (guid)","Copy a user's Username by ID"}, function(thingy)
	local s,naem=NACaller(function()
		return Players:GetNameFromUserIdAsync(thingy)
	end)

	if not s then return DoNotif("err: "..tostring(naem)) end

	if not setclipboard then return DoNotif("no setclipboard") end
	setclipboard(tostring(naem))

	DebugNotif("Copied "..tostring(naem).."'s Username with ID of "..tostring(thingy))
end,true)

cmd.add({"ownerid"},{"ownerid","masks you as the game owner's ID and Username"},function()
	local ownerUserId, ownerName
	if game.CreatorType == Enum.CreatorType.User then
		ownerUserId = game.CreatorId
	elseif game.CreatorType == Enum.CreatorType.Group then
		local ok, info = pcall(function() return SafeGetService("GroupService"):GetGroupInfoAsync(game.CreatorId) end)
		if ok and info then
			if info.Owner and info.Owner.Id then ownerUserId = info.Owner.Id end
			if not ownerUserId and info.OwnerId then ownerUserId = info.OwnerId end
		end
	end
	if not ownerUserId then DebugNotif("Owner not found",3) return end
	local ok2, nameOrErr = pcall(function() return Players:GetNameFromUserIdAsync(ownerUserId) end)
	if ok2 and nameOrErr and nameOrErr ~= "" then ownerName = nameOrErr else ownerName = "unknown" end
	opt.hiddenprop(LocalPlayer, "UserId", ownerUserId)
	opt.hiddenprop(LocalPlayer, "Name", ownerName)
end)

cmd.add({"userid"},{"userid","changes your UserId to any ID you enter"},function(...)
	local arg = ({...})[1]
	if not arg or arg == "" then
		DebugNotif("usage: userid <userId|username>",3)
		return nil
	end
	local text = tostring(arg):gsub("^%s+",""):gsub("%s+$","")
	local resolvedId

	local asNum = tonumber(text)
	if asNum then
		if asNum < 1 or asNum ~= math.floor(asNum) then
			DebugNotif("invalid userId",3)
			return nil
		end
		local ok, _ = pcall(function() return Players:GetNameFromUserIdAsync(asNum) end)
		if not ok then
			DebugNotif("invalid userId (not found)",3)
			return nil
		end
		resolvedId = asNum
	else
		local uname = text:gsub("^@","")
		local ok, uid = pcall(function() return Players:GetUserIdFromNameAsync(uname) end)
		if not ok or not uid then
			DebugNotif("invalid username",3)
			return nil
		end
		local ok2, _ = pcall(function() return Players:GetNameFromUserIdAsync(uid) end)
		if not ok2 then
			DebugNotif("resolved user invalid",3)
			return nil
		end
		resolvedId = uid
	end

	if resolvedId then
		opt.hiddenprop(LocalPlayer, "UserId", resolvedId)
		return resolvedId
	end

	return nil
end)

cmd.add({"username","name"},{"username","changes your Username to any name you enter"},function(...)
	local arg = ({...})[1]
	if not arg or arg == "" then
		return DebugNotif("missing argument",3)
	end
	opt.hiddenprop(LocalPlayer, "Name", arg)
end)

cmd.add({"synapsedex","sdex"},{"synapsedex (sdex)","Loads SynapseX's dex explorer"},function()
	local rng=Random.new()

	local charset={}
	for i=48,57 do Insert(charset,string.char(i)) end
	for i=65,90 do Insert(charset,string.char(i)) end
	for i=97,122 do Insert(charset,string.char(i)) end
	function RandomCharacters(length)
		if length>0 then
			return RandomCharacters(length-1)..charset[rng:NextInteger(1,#charset)]
		else
			return ""
		end
	end

	local Dex=game:GetObjects("rbxassetid://9553291002")[1]
	Dex.Name=RandomCharacters(rng:NextInteger(5,20))
	NaProtectUI(Dex)

	function Load(Obj,Url)
		function GiveOwnGlobals(Func,Script)
			local Fenv={}
			local RealFenv={script=Script}
			local FenvMt={}
			FenvMt.__index=function(a,b)
				if RealFenv[b]==nil then
					return getfenv()[b]
				else
					return RealFenv[b]
				end
			end
			FenvMt.__newindex=function(a,b,c)
				if RealFenv[b]==nil then
					getfenv()[b]=c
				else
					RealFenv[b]=c
				end
			end
			setmetatable(Fenv,FenvMt)
			setfenv(Func,Fenv)
			return Func
		end

		function LoadScripts(Script)
			if Script.ClassName=="Script" or Script.ClassName=="LocalScript" then
				Spawn(function()
					GiveOwnGlobals(loadstring(Script.Source,"="..Script:GetFullName()),Script)()
				end)
			end
			for i,v in pairs(Script:GetChildren()) do
				LoadScripts(v)
			end
		end

		LoadScripts(Obj)
	end

	Load(Dex)
end)

cmd.add({"antifling"},{"antifling","makes other players non-collidable with you"},function()
	NAlib.disconnect("antifling")
	NAlib.disconnect("antifling_players")
	NAStuff._afTracked = NAStuff._afTracked or setmetatable({}, {__mode="k"})
	NAStuff._afOrigCan = NAStuff._afOrigCan or setmetatable({}, {__mode="k"})
	NAStuff._afSignals = NAStuff._afSignals or setmetatable({}, {__mode="k"})
	local tracked, orig, sigs = NAStuff._afTracked, NAStuff._afOrigCan, NAStuff._afSignals
	local lp = Players.LocalPlayer

	local apply = function(p)
		if not (p and p:IsA("BasePart")) or tracked[p] then return end
		if orig[p] == nil then orig[p] = NAlib.isProperty(p,"CanCollide") end
		if NAlib.isProperty(p,"CanCollide") ~= false then NAlib.setProperty(p,"CanCollide", false) end
		tracked[p] = true
		if not sigs[p] then
			local c = p:GetPropertyChangedSignal("CanCollide"):Connect(function()
				if NAlib.isProperty(p,"CanCollide") ~= false then NAlib.setProperty(p,"CanCollide", false) end
			end)
			sigs[p] = c
			NAlib.connect("antifling", c)
		end
	end

	local seedChar = function(char)
		if not char then return end
		for _,d in ipairs(char:GetDescendants()) do
			if d:IsA("BasePart") then apply(d) end
		end
		NAlib.connect("antifling", char.DescendantAdded:Connect(function(inst)
			if inst:IsA("BasePart") then apply(inst) end
		end))
		NAlib.connect("antifling", char.DescendantRemoving:Connect(function(inst)
			if tracked[inst] then
				if sigs[inst] then sigs[inst]:Disconnect(); sigs[inst] = nil end
				tracked[inst] = nil
				orig[inst] = nil
			end
		end))
	end

	local hookOther = function(plr)
		if plr == lp then return end
		if plr.Character then seedChar(plr.Character) end
		NAlib.connect("antifling_players", plr.CharacterAdded:Connect(seedChar))
		NAlib.connect("antifling_players", plr.CharacterRemoving:Connect(function(char)
			for _,d in ipairs(char:GetDescendants()) do
				if tracked[d] then
					if sigs[d] then sigs[d]:Disconnect(); sigs[d] = nil end
					tracked[d] = nil
					orig[d] = nil
				end
			end
		end))
	end

	for _,pl in ipairs(Players:GetPlayers()) do hookOther(pl) end
	NAlib.connect("antifling_players", Players.PlayerAdded:Connect(hookOther))
	NAlib.connect("antifling_players", Players.PlayerRemoving:Connect(function(pl)
		if pl == lp then return end
		local char = pl.Character
		if not char then return end
		for _,d in ipairs(char:GetDescendants()) do
			if tracked[d] then
				if sigs[d] then sigs[d]:Disconnect(); sigs[d] = nil end
				tracked[d] = nil
				orig[d] = nil
			end
		end
	end))

	NAlib.connect("antifling", RunService.Stepped:Connect(function()
		for p in pairs(tracked) do
			if typeof(p)=="Instance" and p:IsA("BasePart") and p.Parent then
				if p.CanCollide ~= false then NAlib.setProperty(p,"CanCollide", false) end
			end
		end
	end))

	DebugNotif("Antifling Enabled")
end)

cmd.add({"unantifling"},{"unantifling","restores collision for other players"},function()
	NAlib.disconnect("antifling")
	NAlib.disconnect("antifling_players")
	local tracked = NAStuff._afTracked or {}
	local orig = NAStuff._afOrigCan or {}
	local sigs = NAStuff._afSignals or {}
	for p in pairs(tracked) do
		if typeof(p)=="Instance" and p:IsA("BasePart") then
			local v = orig[p]; if v == nil then v = true end
			NAlib.setProperty(p,"CanCollide", v)
		end
	end
	for _,c in pairs(sigs) do if c then c:Disconnect() end end
	for k in pairs(sigs) do sigs[k]=nil end
	for k in pairs(tracked) do tracked[k]=nil end
	for k in pairs(orig) do orig[k]=nil end
	DebugNotif("Antifling Disabled")
end)

cmd.add({"gravitygun"},{"gravitygun","Probably the best gravity gun script thats fe"},function()
	Wait();
	DoNotif("Wait a few seconds for it to load",2.5)
	loadstring(game:HttpGet("https://raw.githubusercontent.com/ltseverydayyou/Nameless-Admin/main/gravity%20gun"))()
end)

cmd.add({"lockws","lockworkspace"},{"lockws (lockworkspace)","Locks the whole workspace"},function()
	for _, inst in ipairs(workspace:GetDescendants()) do
		if NAlib.isProperty(inst, "Locked") ~= nil then
			NAlib.setProperty(inst, "Locked", true)
		end
	end
end)

cmd.add({"unlockws","unlockworkspace"},{"unlockws (unlockworkspace)","Unlocks everything in Workspace"},function()
	for _, inst in ipairs(workspace:GetDescendants()) do
		if NAlib.isProperty(inst, "Locked") ~= nil then
			NAlib.setProperty(inst, "Locked", false)
		end
	end
end)

vspeedBTN = nil

cmd.add({"vehiclespeed", "vspeed"}, {"vehiclespeed <amount> (vspeed)", "Change the vehicle speed"}, function(amount)
	NAlib.disconnect("vehicleloopspeed")

	if vspeedBTN then
		vspeedBTN:Destroy()
		vspeedBTN = nil
	end

	local intens = tonumber(amount) or 1

	NAlib.connect("vehicleloopspeed", RunService.Stepped:Connect(function()
		local subject = workspace.CurrentCamera.CameraSubject
		if subject and subject:IsA("Humanoid") and subject.SeatPart then
			subject.SeatPart:ApplyImpulse(subject.SeatPart.CFrame.LookVector * Vector3.new(intens, 0, intens))
		elseif subject and subject:IsA("BasePart") then
			subject:ApplyImpulse(subject.CFrame.LookVector * Vector3.new(intens, 0, intens))
		end
	end))

	DebugNotif("Vehicle speed set to "..intens)

	Wait()

	vspeedBTN = InstanceNew("ScreenGui")
	local btn = InstanceNew("TextButton")
	local speedBox = InstanceNew("TextBox")
	local toggleBtn = InstanceNew("TextButton")
	local corner = InstanceNew("UICorner")
	local corner2 = InstanceNew("UICorner")
	local corner3 = InstanceNew("UICorner")
	local aspect = InstanceNew("UIAspectRatioConstraint")
	local vstopBtn = InstanceNew("TextButton")
	local vstopCorner = InstanceNew("UICorner")

	NaProtectUI(vspeedBTN)

	btn.Parent = vspeedBTN
	btn.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
	btn.BackgroundTransparency = 0.1
	btn.Position = UDim2.new(0.9, 0, 0.4, 0)
	btn.Size = UDim2.new(0.08, 0, 0.1, 0)
	btn.Font = Enum.Font.GothamBold
	btn.Text = "vSpeed"
	btn.TextColor3 = Color3.fromRGB(255, 255, 255)
	btn.TextScaled = true
	btn.TextWrapped = true
	btn.Active = true

	corner.CornerRadius = UDim.new(0.2, 0)
	corner.Parent = btn

	aspect.Parent = btn
	aspect.AspectRatio = 1.0

	speedBox.Parent = vspeedBTN
	speedBox.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
	speedBox.BackgroundTransparency = 0.1
	speedBox.AnchorPoint = Vector2.new(0.5, 0)
	speedBox.Position = UDim2.new(0.5, 0, 0, 10)
	speedBox.Size = UDim2.new(0, 75, 0, 35)
	speedBox.Font = Enum.Font.GothamBold
	speedBox.Text = tostring(intens)
	speedBox.TextColor3 = Color3.fromRGB(255, 255, 255)
	speedBox.TextSize = 18
	speedBox.TextWrapped = true
	speedBox.ClearTextOnFocus = false
	speedBox.PlaceholderText = "Speed"
	speedBox.Visible = false

	corner2.CornerRadius = UDim.new(0.2, 0)
	corner2.Parent = speedBox

	toggleBtn.Parent = btn
	toggleBtn.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
	toggleBtn.BackgroundTransparency = 0.1
	toggleBtn.Position = UDim2.new(0.8, 0, -0.1, 0)
	toggleBtn.Size = UDim2.new(0.4, 0, 0.4, 0)
	toggleBtn.Font = Enum.Font.SourceSans
	toggleBtn.Text = "+"
	toggleBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
	toggleBtn.TextScaled = true
	toggleBtn.TextWrapped = true
	toggleBtn.Active = true
	toggleBtn.AutoButtonColor = true

	corner3.CornerRadius = UDim.new(1, 0)
	corner3.Parent = toggleBtn

	vstopBtn.Parent = vspeedBTN
	vstopBtn.BackgroundColor3 = Color3.fromRGB(80, 80, 80)
	vstopBtn.BackgroundTransparency = 0.1
	vstopBtn.Position = UDim2.new(0.9, 0, 0.52, 0)
	vstopBtn.Size = UDim2.new(0.08, 0, 0.1, 0)
	vstopBtn.Font = Enum.Font.GothamBold
	vstopBtn.Text = "vSTOP"
	vstopBtn.TextColor3 = Color3.new(1, 1, 1)
	vstopBtn.TextScaled = true
	vstopBtn.TextWrapped = true
	vstopBtn.Active = true
	vstopBtn.AutoButtonColor = true

	vstopCorner.CornerRadius = UDim.new(0.2, 0)
	vstopCorner.Parent = vstopBtn

	MouseButtonFix(toggleBtn, function()
		speedBox.Visible = not speedBox.Visible
		toggleBtn.Text = speedBox.Visible and "-" or "+"
	end)

	local vSpeedOn = true
	btn.Text = "vSpeed ON"
	btn.BackgroundColor3 = Color3.fromRGB(0, 170, 0)

	MouseButtonFix(btn, function()
		vSpeedOn = not vSpeedOn

		if vSpeedOn then
			local newIntens = tonumber(speedBox.Text) or 1
			intens = newIntens

			NAlib.disconnect("vehicleloopspeed")
			NAlib.connect("vehicleloopspeed", RunService.Stepped:Connect(function()
				local subject = workspace.CurrentCamera.CameraSubject
				if subject and subject:IsA("Humanoid") and subject.SeatPart then
					subject.SeatPart:ApplyImpulse(subject.SeatPart.CFrame.LookVector * Vector3.new(intens, 0, intens))
				elseif subject and subject:IsA("BasePart") then
					subject:ApplyImpulse(subject.CFrame.LookVector * Vector3.new(intens, 0, intens))
				end
			end))

			btn.Text = "vSpeed ON"
			btn.BackgroundColor3 = Color3.fromRGB(0, 170, 0)
		else
			NAlib.disconnect("vehicleloopspeed")

			local subject = workspace.CurrentCamera.CameraSubject
			if subject then
				local root
				if subject:IsA("Humanoid") and subject.SeatPart then
					root = subject.SeatPart
				elseif subject:IsA("BasePart") then
					root = subject
				end

				if root then
					SpawnCall(function()
						for i = 1, 10 do
							if root:IsDescendantOf(game) then
								root.AssemblyLinearVelocity=root.AssemblyLinearVelocity * .8
								root.AssemblyAngularVelocity=root.AssemblyAngularVelocity * .8
								Wait(0.05)
							end
						end
					end)
				end
			end

			btn.Text = "vSpeed"
			btn.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
		end
	end)

	MouseButtonFix(vstopBtn, function()
		local subject = workspace.CurrentCamera.CameraSubject
		if subject then
			local root
			if subject:IsA("Humanoid") and subject.SeatPart then
				root = subject.SeatPart
			elseif subject:IsA("BasePart") then
				root = subject
			end

			if root then
				local model = root:FindFirstAncestorOfClass("Model")
				if model then
					for _, part in ipairs(model:GetDescendants()) do
						if part:IsA("BasePart") then
							part.AssemblyLinearVelocity = Vector3.zero
							part.AssemblyAngularVelocity = Vector3.zero
						end
						if part:IsA("VehicleSeat") then
							part.Throttle = 0
							part.Steer = 0
						end
					end
				else
					root.AssemblyLinearVelocity = Vector3.zero
					root.AssemblyAngularVelocity = Vector3.zero
				end
			end
		end
	end)

	speedBox.FocusLost:Connect(function()
		if not vSpeedOn then return end
		local newIntens = tonumber(speedBox.Text) or 1
		intens = newIntens

		NAlib.disconnect("vehicleloopspeed")
		NAlib.connect("vehicleloopspeed", RunService.Stepped:Connect(function()
			local subject = workspace.CurrentCamera.CameraSubject
			if subject and subject:IsA("Humanoid") and subject.SeatPart then
				subject.SeatPart:ApplyImpulse(subject.SeatPart.CFrame.LookVector * Vector3.new(intens, 0, intens))
			elseif subject and subject:IsA("BasePart") then
				subject:ApplyImpulse(subject.CFrame.LookVector * Vector3.new(intens, 0, intens))
			end
		end))

		DebugNotif("vSpeed updated to "..intens, 2)
	end)

	NAgui.draggerV2(btn)
	NAgui.draggerV2(speedBox)
	NAgui.draggerV2(vstopBtn)
end, true)

cmd.add({"unvehiclespeed", "unvspeed"}, {"unvehiclespeed (unvspeed)", "Stops the vehiclespeed command"}, function()
	NAlib.disconnect("vehicleloopspeed")

	if vspeedBTN then
		vspeedBTN:Destroy()
		vspeedBTN = nil
	end

	local subject = workspace.CurrentCamera.CameraSubject
	if subject then
		local root
		if subject:IsA("Humanoid") and subject.SeatPart then
			root = subject.SeatPart
		elseif subject:IsA("BasePart") then
			root = subject
		end

		if root then
			local model = root:FindFirstAncestorOfClass("Model")
			if model then
				for _, part in ipairs(model:GetDescendants()) do
					if part:IsA("BasePart") then
						part.AssemblyLinearVelocity = Vector3.zero
						part.AssemblyAngularVelocity = Vector3.zero
					end
					if part:IsA("VehicleSeat") then
						part.Throttle = 0
						part.Steer = 0
					end
				end
			else
				root.AssemblyLinearVelocity = Vector3.zero
				root.AssemblyAngularVelocity = Vector3.zero
			end
		end
	end

	DebugNotif("Vehicle speed disabled")
end)

local active=false
local players=Players
local camera=workspace.CurrentCamera

local uis=UserInputService

local active=false
function UpdateAutoRotate(BOOL)
	humanoid.AutoRotate=BOOL
end

local GameSettings = UserSettings():GetService("UserGameSettings")

local OriginalRotationType = nil
local ShiftLockEnabled = false

function EnableShiftLock()
	if ShiftLockEnabled then return end

	local success, currentRotation = NACaller(function()
		return GameSettings.RotationType
	end)

	if success then
		OriginalRotationType = currentRotation
	end

	NAlib.connect("shiftlock_loop", RunService.RenderStepped:Connect(function()
		NACaller(function()
			GameSettings.RotationType = Enum.RotationType.CameraRelative
		end)
	end))

	ShiftLockEnabled = true
	DebugNotif("ShiftLock Enabled", 2)
end

function DisableShiftLock()
	if not ShiftLockEnabled then return end

	NAlib.disconnect("shiftlock_loop")

	NACaller(function()
		GameSettings.RotationType = OriginalRotationType or Enum.RotationType.MovementRelative
	end)

	ShiftLockEnabled = false
	DebugNotif("ShiftLock Disabled", 2)
end

cmd.add({"shiftlock","sl"}, {"shiftlock (sl)", "Toggles shiftlock"}, function()
	if IsOnMobile then
		loadstring(game:HttpGet("https://raw.githubusercontent.com/ltseverydayyou/uuuuuuu/refs/heads/main/shiftlock"))()
	else
		EnableShiftLock()
	end
end)

cmd.add({"unshiftlock","unsl"}, {"unshiftlock (unsl)", "Disables shiftlock"}, function()
	if IsOnPC then
		DisableShiftLock()
	end
end)

-- if you're reading this use the command 'cmdloop enable' to enable the command loop
-- example 'cmdloop enable shiftlock hidden' (hides notification to display) or set hidden to just anything as long as argument 2 is not empty 💀

cmd.add({"enable"}, {"enable", "Enables a specific CoreGui"}, function(...)
	local args = {...}
	local enableName = args[1]
	local hiddenNotif = args[2]
	local buttons = {}

	for _, coreGuiType in ipairs(Enum.CoreGuiType:GetEnumItems()) do
		Insert(buttons, {
			Text = coreGuiType.Name,
			Callback = function()
				StarterGui:SetCoreGuiEnabled(coreGuiType, true)
				if coreGuiType == Enum.CoreGuiType.Chat or coreGuiType == Enum.CoreGuiType.All then
					NAStuff.ChatSettings.coreGuiChat = true
					NAmanage.SaveTextChatSettings()
					NAmanage.ApplyTextChatSettings()
				end
			end
		})
	end

	Insert(buttons, {
		Text = "Shiftlock",
		Callback = function()
			LocalPlayer.DevEnableMouseLock = true
		end
	})

	Insert(buttons, {
		Text = "Reset",
		Callback = function()
			StarterGui:SetCore("ResetButtonCallback", true)
		end
	})

	if enableName and enableName ~= "" then
		local found = false
		for _, button in ipairs(buttons) do
			if Match(button.Text:lower(), enableName:lower()) then
				button.Callback()
				if not hiddenNotif then
					DebugNotif("CoreGui Enabled: "..button.Text.." has been enabled.", 3)
				end
				found = true
				break
			end
		end
		if not found then
			DebugNotif("No matching CoreGui element found for: "..enableName, 3)
		end
	else
		Window({
			Title = "Enable a Specific Core Gui Element",
			Buttons = buttons
		})
	end
end, true)

cmd.add({"disable"}, {"disable", "Disables a specific CoreGui"}, function(...)
	local args = {...}
	local disableName = args[1]
	local hiddenNotif = args[2] -- scuffed way lmao
	local buttons = {}

	for _, coreGuiType in ipairs(Enum.CoreGuiType:GetEnumItems()) do
		Insert(buttons, {
			Text = coreGuiType.Name,
			Callback = function()
				StarterGui:SetCoreGuiEnabled(coreGuiType, false)
			end
		})
	end

	Insert(buttons, {
		Text = "Shiftlock",
		Callback = function()
			LocalPlayer.DevEnableMouseLock = false
		end
	})

	Insert(buttons, {
		Text = "Reset",
		Callback = function()
			StarterGui:SetCore("ResetButtonCallback", false)
		end
	})

	if disableName and disableName ~= "" then
		local found = false
		for _, button in ipairs(buttons) do
			if Match(button.Text:lower(), disableName:lower()) then
				button.Callback()
				if not hiddenNotif then
					DebugNotif("CoreGui Disabled: "..button.Text.." has been disabled.", 3)
				end
				found = true
				break
			end
		end
		if not found then
			DebugNotif("No matching CoreGui element found for: "..disableName, 3)
		end
	else
		Window({
			Title = "Disable a Specific Core Gui Element",
			Buttons = buttons
		})
	end
end,true)

cmd.add({"reverb","reverbcontrol"},{"reverb (reverbcontrol)","Manage sound reverb settings"},function(...)
	local args = {...}
	local target = args[1]
	local buttons = {}
	for _, rt in ipairs(Enum.ReverbType:GetEnumItems()) do
		Insert(buttons, {
			Text = rt.Name,
			Callback = function()
				SafeGetService("SoundService").AmbientReverb = rt
			end
		})
	end
	if target and target ~= "" then
		local found = false
		for _, btn in ipairs(buttons) do
			if Match(Lower(btn.Text), Lower(target)) then
				btn.Callback()
				DebugNotif("Reverb set to "..btn.Text, 3)
				found = true
				break
			end
		end
		if not found then
			DebugNotif("No matching reverb type for: "..target, 3)
		end
	else
		Window({
			Title = "Sound Reverb Options",
			Buttons = buttons
		})
	end
end)

cmd.add({"cam","camera","cameratype"},{"cam (camera, cameratype)","Manage camera type settings"},function(...)
	local args = {...}
	local target = args[1]
	local buttons = {}
	for _, ct in ipairs(Enum.CameraType:GetEnumItems()) do
		Insert(buttons, {
			Text = ct.Name,
			Callback = function()
				workspace.CurrentCamera.CameraType = ct
			end
		})
	end
	if target and target ~= "" then
		local found = false
		for _, btn in ipairs(buttons) do
			if Match(Lower(btn.Text), Lower(target)) then
				btn.Callback()
				DebugNotif("Camera type set to "..btn.Text, 3)
				found = true
				break
			end
		end
		if not found then
			DebugNotif("No matching camera type for: "..target, 3)
		end
	else
		Window({
			Title = "Camera Type Options",
			Buttons = buttons
		})
	end
end)

alignmentButtonsGui = nil

cmd.add({"alignmentkeys","alignkeys","ak"},{"alignmentkeys","Enable alignment keys"}, function()
	local function onInput(input, gameProcessed)
		if gameProcessed then return end
		if input.KeyCode == Enum.KeyCode.Comma and workspace.CurrentCamera then
			workspace.CurrentCamera:PanUnits(-1)
		elseif input.KeyCode == Enum.KeyCode.Period and workspace.CurrentCamera then
			workspace.CurrentCamera:PanUnits(1)
		end
	end
	if not NAlib.isConnected("align_input") then
		NAlib.connect("align_input", UserInputService.InputBegan:Connect(onInput))
	end
	if IsOnMobile and not alignmentButtonsGui then
		alignmentButtonsGui = InstanceNew("ScreenGui")
		alignmentButtonsGui.Name = "AlignButtons"
		alignmentButtonsGui.ResetOnSpawn = false
		NaProtectUI(alignmentButtonsGui)

		local btnSize = UDim2.new(0.1, 0, 0.1, 0)

		local leftButton = InstanceNew("TextButton")
		leftButton.Name = "PanLeft"
		leftButton.Text = "<"
		leftButton.TextScaled = true
		leftButton.Size = btnSize
		leftButton.Position = UDim2.new(0.45, 0, 0.05, 0)
		leftButton.AnchorPoint = Vector2.new(0.5, 0.5)
		leftButton.BackgroundColor3 = Color3.new(0, 0, 0)
		leftButton.BorderSizePixel = 0
		leftButton.TextColor3 = Color3.new(1, 1, 1)
		leftButton.Parent = alignmentButtonsGui

		local leftUICorner = InstanceNew("UICorner")
		leftUICorner.CornerRadius = UDim.new(1, 0)
		leftUICorner.Parent = leftButton

		local rightButton = InstanceNew("TextButton")
		rightButton.Name = "PanRight"
		rightButton.Text = ">"
		rightButton.TextScaled = true
		rightButton.Size = btnSize
		rightButton.Position = UDim2.new(0.55, 0, 0.05, 0)
		rightButton.AnchorPoint = Vector2.new(0.5, 0.5)
		rightButton.BackgroundColor3 = Color3.new(0, 0, 0)
		rightButton.BorderSizePixel = 0
		rightButton.TextColor3 = Color3.new(1, 1, 1)
		rightButton.Parent = alignmentButtonsGui

		local rightUICorner = InstanceNew("UICorner")
		rightUICorner.CornerRadius = UDim.new(1, 0)
		rightUICorner.Parent = rightButton

		NAgui.draggerV2(leftButton)
		NAgui.draggerV2(rightButton)

		NAlib.connect("align_mobile_left", MouseButtonFix(leftButton,function()
			if workspace.CurrentCamera then
				workspace.CurrentCamera:PanUnits(-1)
			end
		end))
		NAlib.connect("align_mobile_right", MouseButtonFix(rightButton,function()
			if workspace.CurrentCamera then
				workspace.CurrentCamera:PanUnits(1)
			end
		end))
	end
end)

cmd.add({"disablealignmentkeys","disablealignkeys","dak"},{"disablealignmentkeys","Disable alignment keys"}, function()
	NAlib.disconnect("align_input")
	if IsOnMobile and alignmentButtonsGui then
		NAlib.disconnect("align_mobile_left")
		NAlib.disconnect("align_mobile_right")
		alignmentButtonsGui:Destroy()
		alignmentButtonsGui = nil
		mobileLeftConn = nil
		mobileRightConn = nil
	end
end)

cmd.add({"esp"}, {"esp","locate where the players are"}, function()
	ESPenabled = true
	chamsEnabled = false
	ESPAutoTrackAll = true
	for _, player in pairs(Players:GetPlayers()) do
		if player ~= Players.LocalPlayer then
			NAmanage.ESP_Add(player, true)
		end
	end
end)

cmd.add({"chams"}, {"chams","ESP but without the text :shock:"}, function()
	ESPenabled = true
	chamsEnabled = true
	ESPAutoTrackAll = true
	for _, player in pairs(Players:GetPlayers()) do
		if player ~= Players.LocalPlayer then
			NAmanage.ESP_Add(player, true)
		end
	end
end)

cmd.add({"locate"}, {"locate <username1> <username2> etc (optional)", "locate where the specified player(s) are"}, function(...)
	ESPenabled = true
	chamsEnabled = false
	local tokens = {...}
	local providedArgCount = select("#", ...)
	if providedArgCount == 0 then tokens = {"all"} end
	local shouldAuto = (providedArgCount == 0)
	if not shouldAuto then
		for _, token in ipairs(tokens) do
			local lower = tostring(token):lower()
			if lower == "all" or lower == "others" then
				shouldAuto = true
				break
			end
		end
	end
	ESPAutoTrackAll = shouldAuto
	for _, token in ipairs(tokens) do
		for _, target in ipairs(getPlr(token)) do
			if target and target ~= Players.LocalPlayer then
				NAmanage.ESP_Add(target, true)
			end
		end
	end
end, true)

NPC_SCAN_KEY = "npc_esp_scan"
getgenv().npcESPList = {}

cmd.add({"npcesp","espnpc"},{"npcesp (espnpc)","locate where the npcs are"},function()
	ESPenabled = true
	chamsEnabled = false
	ESPAutoTrackAll = false
	getgenv().npcESPList = {}
	if not NAlib.isConnected(NPC_SCAN_KEY) then
		local acc = 0
		NAlib.connect(NPC_SCAN_KEY, RunService.Heartbeat:Connect(function(dt)
			acc = acc + dt
			if acc < 0.6 then return end
			acc = 0
			local found = {}
			for _, inst in ipairs(workspace:GetDescendants()) do
				if inst:IsA("Model") and CheckIfNPC(inst) then
					found[inst] = true
					if not getgenv().npcESPList[inst] then
						getgenv().npcESPList[inst] = true
						NAmanage.ESP_Add(inst, false)
					end
				end
			end
			for inst in pairs(getgenv().npcESPList) do
				if not found[inst] then
					getgenv().npcESPList[inst] = nil
					NAmanage.ESP_Disconnect(inst)
				end
			end
		end))
	end
	NAmanage.ESP_StartGlobal()
end)

cmd.add({"unnpcesp","unespnpc"},{"unnpcesp (unespnpc)","stop locating npcs"},function()
	ESPenabled = false
	chamsEnabled = false
	ESPAutoTrackAll = false
	if NAlib.isConnected(NPC_SCAN_KEY) then
		NAlib.disconnect(NPC_SCAN_KEY)
	end
	for inst in pairs(getgenv().npcESPList) do
		NAmanage.ESP_Disconnect(inst)
	end
	getgenv().npcESPList = {}
end)

cmd.add({"unesp","unchams"},{"unesp (unchams)","Disables esp/chams"},function()
	ESPenabled = false
	chamsEnabled = false
	ESPAutoTrackAll = false
	if NAlib.isConnected(NPC_SCAN_KEY) then
		NAlib.disconnect(NPC_SCAN_KEY)
	end
	for _, plr in ipairs(Players:GetPlayers()) do
		NAlib.disconnect("esp_charAdded_plr_"..tostring(plr.UserId))
	end
	NAmanage.ESP_ClearAll()
	NAmanage.ESP_StopGlobal()
end)

cmd.add({"unlocate"},{"unlocate <username1> <username2>"},function(...)
	for _, name in ipairs({...}) do
		for _, plr in ipairs(getPlr(name)) do
			NAmanage.ESP_Disconnect(plr)
		end
	end
end, true)

cmd.add({"crash"},{"crash","crashes ur client lol (why would you even use this tho)"},function()
	while true do end
end)

VVVVVVVVVVVCARRR = {}

cmd.add({"vehiclenoclip", "vnoclip"}, {"vehiclenoclip (vnoclip)", "Disables vehicle collision"}, function()
	VVVVVVVVVVVCARRR = {}

	local hum = getHum()
	if not hum then return DoNotif("no humanoid found",2) end
	local seat = hum and hum.SeatPart

	local model = seat.Parent
	while model and not model:IsA("Model") do
		model = model.Parent
	end

	Wait(0.1)
	cmd.run({"noclip"})

	for _, pp in ipairs(model:GetDescendants()) do
		if pp:IsA("BasePart") and pp.CanCollide then
			Insert(VVVVVVVVVVVCARRR, pp)
			pp.CanCollide = false
		end
	end
end)

cmd.add({"vehicleclip", "vclip", "unvnoclip", "unvehiclenoclip"}, {"vehicleclip (vclip, unvnoclip, unvehiclenoclip)", "Enables vehicle collision"}, function()
	cmd.run({"clip"})

	for _, pppp in ipairs(VVVVVVVVVVVCARRR) do
		if pppp and pppp:IsA("BasePart") then
			pppp.CanCollide = true
		end
	end

	VVVVVVVVVVVCARRR = {}
end)

cmd.add({"handlekill", "hkill"}, {"handlekill <player> (hkill)", "Kills a player using a tool that deals damage on touch"}, function(...)
	local LocalPlayer = Players.LocalPlayer

	if not firetouchinterest then
		return DoNotif('Your exploit does not support firetouchinterest to run this command')
	end

	local function zeTOOL()
		local character = LocalPlayer.Character
		if not character then return nil, nil end
		local tool = character:FindFirstChildWhichIsA("Tool")
		if not tool then return nil, nil end
		local handle = tool:FindFirstChild("Handle")
		return tool, handle
	end

	local Tool, Handle = zeTOOL()
	if not Tool or not Handle then
		return DoNotif('You need to hold a "Tool" that does damage on touch')
	end

	local username = ...
	local targets = getPlr(username)
	if #targets == 0 then
		return DoNotif("No target found",2)
	end

	for _, targetPlayer in ipairs(targets) do
		SpawnCall(function()
			while Tool and getPlrChar(LocalPlayer) and getPlrChar(targetPlayer) and Tool.Parent == LocalPlayer.Character do
				local humanoid = getPlrHum(targetPlayer)
				if not humanoid or humanoid.Health <= 0 then
					break
				end

				for _, part in ipairs(getPlrChar(targetPlayer):GetChildren()) do
					if part:IsA("BasePart") then
						firetouchinterest(Handle, part, 0)
						Wait()
						firetouchinterest(Handle, part, 1)
					end
				end

				RunService.Stepped:Wait()
			end
		end)
	end
end, true)

cmd.add({"creep"}, {"creep <player>", "Teleports from a player behind them and under the floor to the top"}, function(...)
	local username = ...
	local targets = getPlr(username)
	if #targets == 0 then
		DoNotif("No target found.", 3)
		return
	end

	local target = targets[1]
	local character = getChar()
	if not character then
		DoNotif("Your character is invalid.", 3)
		return
	end

	local root = getRoot(character)
	if not root then
		DoNotif("Your character's root is invalid.", 3)
		return
	end

	if not target.Character or not getPlrHum(target) or not getPlrHum(target).RootPart then
		DoNotif("Target's character is invalid.", 3)
		return
	end

	root.CFrame = getPlrHum(target).RootPart.CFrame * CFrame.new(0, -10, 4)
	Wait()

	if NAlib.isConnected("noclip") then
		NAlib.disconnect("noclip")
	end

	NAlib.connect("noclip", RunService.Stepped:Connect(function()
		local char = getChar()
		if not char then return end
		for _, part in ipairs(char:GetDescendants()) do
			if part:IsA("BasePart") then
				part.CanCollide = false
			end
		end
	end))
	Wait()

	root.Anchored = true
	Wait()

	local tweenService = TweenService
	local tweenInfo = TweenInfo.new(1000, Enum.EasingStyle.Linear)
	local tween = tweenService:Create(root, tweenInfo, {CFrame = CFrame.new(0, 10000, 0)})
	tween:Play()
	Wait(1.5)
	tween:Pause()

	root.Anchored = false
	Wait()

	NAlib.disconnect("noclip")
end, true)

cmd.add({"netless","net"},{"netless (net)","Executes netless which makes scripts more stable"},function()
	for i,v in next,getChar():GetDescendants() do
		if v:IsA("BasePart") and v.Name~="HumanoidRootPart" then
			RunService.Stepped:Connect(function()
				v.Velocity=Vector3.new(-30,0,0)
			end)
		end
	end

	Wait();

	DebugNotif("Netless has been activated,re-run this script if you die")
end)

cmd.add({"reset","die"},{"reset (die)","Makes your health be 0"},function()
	getHum():ChangeState(Enum.HumanoidStateType.Dead)
	getHum().Health=0
end)

cmd.add({"runanim", "playanim", "anim"}, {"runanim <id> [speed] (playanim,anim)", "Plays an animation by ID with optional speed multiplier"}, function(id, speed)
	local hum = getHum()
	if not hum then return end
	id = tostring(id)
	speed = tonumber(speed) or 1
	local animator = hum:FindFirstChildOfClass("Animator") or InstanceNew("Animator", hum)
	local anim = InstanceNew("Animation")
	anim.AnimationId = "rbxassetid://"..id
	local track = animator:LoadAnimation(anim)
	track:Play()
	track:AdjustSpeed(speed)
	Delay(track.Length / speed, function()
		track:Stop()
		track:Destroy()
		anim:Destroy()
	end)
end, true)

local storedAnims = {}
builderAnim = nil

cmd.add({"animbuilder","abuilder"},{"animbuilder (abuilder)","Opens animation builder GUI"},function()
	if builderAnim then NACaller(function() builderAnim:Destroy() end) builderAnim = nil end
	local p = Players.LocalPlayer

	local function getData()
		local hum = getHum()
		if not hum then return end
		local animate = hum.Parent:FindFirstChild("Animate")
		if not animate then return end
		return hum, animate
	end

	local uid = p.UserId
	if not storedAnims[uid] then
		local _, animate0 = getData()
		if not animate0 then return end
		local store = {}
		for _, v in pairs(animate0:GetChildren()) do
			if v:IsA("StringValue") then
				local a = v:FindFirstChildWhichIsA("Animation")
				if a then store[v.Name:lower()] = a.AnimationId end
			end
		end
		storedAnims[uid] = store
	end

	builderAnim = InstanceNew("ScreenGui")
	NaProtectUI(builderAnim)
	builderAnim.Name = "AnimationBuilder"

	local main = InstanceNew("Frame", builderAnim)
	main.Size = UDim2.new(0.46,0,0.56,0)
	main.Position = UDim2.new(0.27,0,0.22,0)
	main.BackgroundColor3 = Color3.fromRGB(28,28,32)
	main.BackgroundTransparency = 0.08
	main.BorderSizePixel = 0
	main.ClipsDescendants = true
	InstanceNew("UICorner", main).CornerRadius = UDim.new(0, 14)
	local mainStroke = InstanceNew("UIStroke", main)
	mainStroke.Color = Color3.fromRGB(60,60,65)
	mainStroke.Thickness = 1
	mainStroke.Transparency = 0.2

	local headerH = 56
	local header = InstanceNew("Frame", main)
	header.Size = UDim2.new(1,0,0,headerH)
	header.BackgroundColor3 = Color3.fromRGB(24,24,26)
	header.BackgroundTransparency = 0.12
	InstanceNew("UICorner", header).CornerRadius = UDim.new(0, 14)
	local headerPad = InstanceNew("UIPadding", header)
	headerPad.PaddingLeft = UDim.new(0, 10)
	headerPad.PaddingRight = UDim.new(0, 10)

	local row = InstanceNew("Frame", header)
	row.BackgroundTransparency = 1
	row.Size = UDim2.new(1,0,1,0)
	local rowLayout = InstanceNew("UIListLayout", row)
	rowLayout.FillDirection = Enum.FillDirection.Horizontal
	rowLayout.HorizontalAlignment = Enum.HorizontalAlignment.Left
	rowLayout.VerticalAlignment = Enum.VerticalAlignment.Center
	rowLayout.Padding = UDim.new(0,8)

	local title = InstanceNew("TextLabel", row)
	title.Size = UDim2.new(0.8, 0, 1, 0)
	title.BackgroundTransparency = 1
	title.Text = "Animation Builder"
	title.TextColor3 = Color3.fromRGB(240,240,240)
	title.Font = Enum.Font.GothamBold
	title.TextScaled = true
	do local ts = InstanceNew("UITextSizeConstraint", title) ts.MinTextSize = 12 ts.MaxTextSize = 20 end
	title.TextXAlignment = Enum.TextXAlignment.Left

	local closeBtn = InstanceNew("TextButton", row)
	closeBtn.Size = UDim2.new(0.2, 0, 0.82, 0)
	closeBtn.BackgroundTransparency = 1
	closeBtn.Text = "X"
	closeBtn.TextColor3 = Color3.fromRGB(255, 90, 90)
	closeBtn.Font = Enum.Font.Gotham
	closeBtn.TextScaled = true
	do local ts = InstanceNew("UITextSizeConstraint", closeBtn) ts.MinTextSize = 12 ts.MaxTextSize = 22 end

	local body = InstanceNew("Frame", main)
	body.BackgroundTransparency = 1
	body.Size = UDim2.new(1,0,1,-headerH-58)
	body.Position = UDim2.new(0,0,0,headerH)

	local scroll = InstanceNew("ScrollingFrame", body)
	scroll.Size = UDim2.new(1,0,1,0)
	scroll.BackgroundTransparency = 1
	scroll.ScrollBarThickness = 6
	scroll.AutomaticCanvasSize = Enum.AutomaticSize.Y
	scroll.CanvasSize = UDim2.new(0,0,0,0)
	local pad = InstanceNew("UIPadding", scroll)
	pad.PaddingLeft = UDim.new(0,10)
	pad.PaddingRight = UDim.new(0,10)
	pad.PaddingTop = UDim.new(0,10)
	pad.PaddingBottom = UDim.new(0,10)
	local list = InstanceNew("UIListLayout", scroll)
	list.Padding = UDim.new(0, 8)
	list.SortOrder = Enum.SortOrder.LayoutOrder

	local footer = InstanceNew("Frame", main)
	footer.Size = UDim2.new(1,0,0,50)
	footer.Position = UDim2.new(0,0,1,-50)
	footer.BackgroundTransparency = 1
	local footerPad = InstanceNew("UIPadding", footer)
	footerPad.PaddingLeft = UDim.new(0,10)
	footerPad.PaddingRight = UDim.new(0,10)
	footerPad.PaddingBottom = UDim.new(0,8)
	local footerRow = InstanceNew("Frame", footer)
	footerRow.BackgroundTransparency = 1
	footerRow.Size = UDim2.new(1,0,1,0)
	local fl = InstanceNew("UIListLayout", footerRow)
	fl.FillDirection = Enum.FillDirection.Horizontal
	fl.HorizontalAlignment = Enum.HorizontalAlignment.Center
	fl.VerticalAlignment = Enum.VerticalAlignment.Center
	fl.Padding = UDim.new(0,10)

	local save = InstanceNew("TextButton", footerRow)
	save.Size = UDim2.new(0.48,0,1,0)
	save.BackgroundColor3 = Color3.fromRGB(60,140,80)
	save.BackgroundTransparency = 0.1
	save.Text = "💾 Save"
	save.TextColor3 = Color3.new(1,1,1)
	save.Font = Enum.Font.GothamSemibold
	save.TextScaled = true
	do InstanceNew("UICorner", save).CornerRadius = UDim.new(0,10) end
	do local ts = InstanceNew("UITextSizeConstraint", save) ts.MinTextSize = 12 ts.MaxTextSize = 20 end

	local revert = InstanceNew("TextButton", footerRow)
	revert.Size = UDim2.new(0.48,0,1,0)
	revert.BackgroundColor3 = Color3.fromRGB(160,80,80)
	revert.BackgroundTransparency = 0.1
	revert.Text = "↩️ Revert"
	revert.TextColor3 = Color3.new(1,1,1)
	revert.Font = Enum.Font.GothamSemibold
	revert.TextScaled = true
	do InstanceNew("UICorner", revert).CornerRadius = UDim.new(0,10) end
	do local ts = InstanceNew("UITextSizeConstraint", revert) ts.MinTextSize = 12 ts.MaxTextSize = 20 end

	local states = {"Idle","Walk","Run","Jump","Fall","Climb","Swim","Sit"}
	local inputs = {}

	local function makeRow(name)
		local r = InstanceNew("Frame", scroll)
		r.Size = UDim2.new(1,0,0,54)
		r.BackgroundColor3 = Color3.fromRGB(36,36,40)
		r.BackgroundTransparency = 0.12
		InstanceNew("UICorner", r).CornerRadius = UDim.new(0,10)
		local rs = InstanceNew("UIStroke", r)
		rs.Color = Color3.fromRGB(60,60,65)
		rs.Thickness = 1
		rs.Transparency = 0.2

		local inner = InstanceNew("Frame", r)
		inner.BackgroundTransparency = 1
		inner.Size = UDim2.new(1,-16,1,-12)
		inner.Position = UDim2.new(0,8,0,6)

		local hl = InstanceNew("UIListLayout", inner)
		hl.FillDirection = Enum.FillDirection.Horizontal
		hl.HorizontalAlignment = Enum.HorizontalAlignment.Left
		hl.VerticalAlignment = Enum.VerticalAlignment.Center
		hl.Padding = UDim.new(0,8)

		local label = InstanceNew("TextLabel", inner)
		label.Size = UDim2.new(0.28,0,1,0)
		label.BackgroundTransparency = 1
		label.Text = name
		label.TextColor3 = Color3.new(1,1,1)
		label.Font = Enum.Font.GothamSemibold
		label.TextXAlignment = Enum.TextXAlignment.Left
		label.TextScaled = true
		do local ts = InstanceNew("UITextSizeConstraint", label) ts.MinTextSize = 12 ts.MaxTextSize = 18 end

		local boxHolder = InstanceNew("Frame", inner)
		boxHolder.Size = UDim2.new(0.72,0,1,0)
		boxHolder.BackgroundTransparency = 1

		local box = InstanceNew("TextBox", boxHolder)
		box.AnchorPoint = Vector2.new(0.5,0.5)
		box.Position = UDim2.new(0.5,0,0.5,0)
		box.Size = UDim2.new(1,0,1,0)
		box.Text = ""
		box.PlaceholderText = "rbxassetid (numbers only)"
		box.ClearTextOnFocus = false
		box.TextColor3 = Color3.new(1,1,1)
		box.BackgroundColor3 = Color3.fromRGB(50,50,55)
		box.BackgroundTransparency = 0.15
		box.Font = Enum.Font.Gotham
		box.TextScaled = true
		do InstanceNew("UICorner", box).CornerRadius = UDim.new(0,8) end
		do local ts = InstanceNew("UITextSizeConstraint", box) ts.MinTextSize = 11 ts.MaxTextSize = 18 end

		box:GetPropertyChangedSignal("Text"):Connect(function()
			local clean = box.Text:gsub("%D","")
			if box.Text ~= clean then box.Text = clean end
		end)

		inputs[Lower(name)] = box
	end

	for _, n in ipairs(states) do makeRow(n) end

	local function applyAnims(mode)
		local _, animate = getData()
		if not animate then DoNotif("No Animate object found") return end
		for _, k in ipairs(states) do
			local key = Lower(k)
			local sv = animate:FindFirstChild(key)
			if sv and sv:IsA("StringValue") then
				local anim = sv:FindFirstChildWhichIsA("Animation")
				if anim then
					if mode == "save" then
						local id = tonumber(inputs[key].Text)
						if id then
							anim.AnimationId = "rbxassetid://"..id
						end
					else
						local raw = storedAnims[uid] and storedAnims[uid][key]
						if raw then
							anim.AnimationId = raw
							local num = raw:match("%d+")
							if num then inputs[key].Text = num end
						end
					end
				end
			end
		end
		if mode == "save" then DoNotif("Saved animations") else DoNotif("Reverted animations") end
	end

	local function prefill()
		for _, k in ipairs(states) do
			local key = Lower(k)
			local raw = storedAnims[uid] and storedAnims[uid][key]
			if raw then
				local num = raw:match("%d+")
				if num then inputs[key].Text = num end
			else
				inputs[key].Text = ""
			end
		end
	end
	prefill()

	closeBtn.MouseButton1Click:Connect(function()
		local t = TweenService:Create(main, TweenInfo.new(0.25, Enum.EasingStyle.Quint, Enum.EasingDirection.InOut), {
			Size = UDim2.new(0.02,0,0.02,0),
			Position = UDim2.new(0.99,0,0.01,0)
		})
		t:Play(); t.Completed:Wait()
		NACaller(function() builderAnim:Destroy() end)
		builderAnim = nil
	end)

	save.MouseButton1Click:Connect(function() applyAnims("save") end)
	revert.MouseButton1Click:Connect(function() applyAnims("revert") end)

	NAgui.dragger(main, header)
end)

cmd.add({"setkiller", "killeranim"}, {"setkiller (killeranim)", "Sets killer animation set"}, function()
	if not IsR6() then DoNotif("command requires R6") return end
	local hum = getHum()
	if not hum then return end

	local animate = hum.Parent:FindFirstChild("Animate")
	if not animate then return end

	if not storedAnims[hum] then
		local store = {}
		for _, obj in pairs(animate:GetChildren()) do
			if obj:IsA("StringValue") then
				local anim = obj:FindFirstChildWhichIsA("Animation")
				if anim then
					store[obj.Name] = anim.AnimationId
				end
			end
		end
		storedAnims[hum] = store
	end

	local function setAnim(name, id)
		local obj = animate:FindFirstChild(name)
		if obj and obj:IsA("StringValue") then
			local anim = obj:FindFirstChildWhichIsA("Animation")
			if anim then
				anim.AnimationId = "rbxassetid://"..tostring(id)
			end
		end
	end

	setAnim("walk", 252557606)
	setAnim("run", 252557606)
	setAnim("jump", 165167557)
	setAnim("fall", 97170520)
end)

cmd.add({"setpsycho", "psychoanim"}, {"setpsycho (psychoanim)", "Sets psycho animation set"}, function()
	if not IsR6() then DoNotif("command requires R6") return end
	local hum = getHum()
	if not hum then return end

	local animate = hum.Parent:FindFirstChild("Animate")
	if not animate then return end

	if not storedAnims[hum] then
		local store = {}
		for _, obj in pairs(animate:GetChildren()) do
			if obj:IsA("StringValue") then
				local anim = obj:FindFirstChildWhichIsA("Animation")
				if anim then
					store[obj.Name] = anim.AnimationId
				end
			end
		end
		storedAnims[hum] = store
	end

	local function setAnim(name, id)
		local obj = animate:FindFirstChild(name)
		if obj and obj:IsA("StringValue") then
			local anim = obj:FindFirstChildWhichIsA("Animation")
			if anim then
				anim.AnimationId = "rbxassetid://"..tostring(id)
			end
		end
	end

	setAnim("idle", 33796059)
	setAnim("walk", 95415492)
	setAnim("run", 95415492)
	setAnim("jump", 165167557)
	setAnim("fall", 97170520)

	local animator = hum:FindFirstChildOfClass("Animator")
	if not animator then return end

	SpawnCall(function()
		while hum and hum.Parent and hum.Health > 0 do
			for _, track in pairs(animator:GetPlayingAnimationTracks()) do
				if track.Animation.AnimationId == "rbxassetid://33796059" and track.Speed < 50 then
					track:AdjustSpeed(50)
				end
			end
			Wait(0.2)
		end
	end)
end)

cmd.add({"resetanims", "defaultanims", "animsreset"}, {"resetanims (defaultanims,animsreset)", "Restores your previous animations"}, function()
	if not IsR6() then DoNotif("command requires R6") return end
	local hum = getHum()
	if not hum then return end

	local animate = hum.Parent:FindFirstChild("Animate")
	if not animate then return end

	local store = storedAnims[hum]
	if not store then return end

	for name, id in pairs(store) do
		local obj = animate:FindFirstChild(name)
		if obj and obj:IsA("StringValue") then
			local anim = obj:FindFirstChildWhichIsA("Animation")
			if anim then
				anim.AnimationId = id
			end
		end
	end

	storedAnims[hum] = nil
end)

cmd.add({"animcopycore","animcopy","copyanim","copyan"}, {"animcopycore <target>","Copy core animations from target"}, function(targetArg)
	if not targetArg or targetArg == "" then return end
	local targets = getPlr(targetArg)
	local target = targets and targets[1]
	if not target then return end
	local myChar = getChar()
	local targetChar = getPlrChar(target)
	if not (myChar and targetChar) then return end
	local myHum = getPlrHum(myChar)
	local targetHum = getPlrHum(targetChar)
	if not (myHum and targetHum) then return end
	local myAnimate = myChar:FindFirstChild("Animate")
	local targetAnimate = targetChar:FindFirstChild("Animate")
	if not (myAnimate and targetAnimate) then return end
	local function mapAnims(root)
		local t = {}
		for _, inst in ipairs(root:GetDescendants()) do
			if inst:IsA("Animation") then
				local k = Lower(((inst.Parent and inst.Parent.Name) or "root").."|"..inst.Name)
				t[k] = inst
			end
		end
		return t
	end
	local function refresh(hum)
		local char = hum and hum.Parent
		local animScr = char and char:FindFirstChild("Animate")
		if animScr and NAlib.isProperty(animScr, "Disabled") ~= nil then
			animScr.Disabled = true
			animScr.Disabled = false
		else
			pcall(function() hum:ChangeState(Enum.HumanoidStateType.Jumping) end)
		end
	end
	local function captureDefaults()
		if NAStuff.SavedDefaultMap then return end
		if not myAnimate then return end
		NAStuff.SavedDefaultMap = {}
		for _, a in ipairs(myAnimate:GetDescendants()) do
			if a:IsA("Animation") then
				local parentName = Lower((a.Parent and a.Parent.Name) or "root")
				if NAStuff.CORE_FOLDERS[parentName] then
					local key = Lower(parentName.."|"..a.Name)
					NAStuff.SavedDefaultMap[key] = a.AnimationId
				end
			end
		end
	end
	captureDefaults()
	local src = mapAnims(targetAnimate)
	local dst = mapAnims(myAnimate)
	for key, dstAnim in pairs(dst) do
		local folder = Match(key, "([^|]+)|")
		if NAStuff.CORE_FOLDERS[folder or ""] then
			local srcAnim = src[key]
			if srcAnim and srcAnim.AnimationId ~= "" and dstAnim.AnimationId ~= srcAnim.AnimationId then
				dstAnim.AnimationId = srcAnim.AnimationId
			end
		end
	end
	refresh(myHum)
end)

cmd.add({"syncanim","animsync"}, {"syncanim <target>","Mirror target animations (live)"}, function(targetArg)
	if not targetArg or targetArg == "" then return end
	local targets = getPlr(targetArg)
	local target = targets and targets[1]
	if not target then return end

	local myChar = getChar()
	local targetChar = getPlrChar(target)
	if not (myChar and targetChar) then return end

	local myHum = getPlrHum(myChar)
	local targetHum = getPlrHum(targetChar)
	if not (myHum and targetHum) then return end
	if myHum.RigType ~= targetHum.RigType then return end

	local function getAnimator(hum, create)
		if not hum then return nil end
		local a = hum:FindFirstChildOfClass("Animator")
		if a then return a end
		if create then return InstanceNew("Animator", hum) end
	end

	local myAnimator = getAnimator(myHum, true)
	local targetAnimator = getAnimator(targetHum, false)
	if not targetAnimator then return end

	NAlib.disconnect(NAStuff.SYNC_TAG)

	local myAnimate = myChar:FindFirstChild("Animate")
	if myAnimate and NAlib.isProperty(myAnimate, "Disabled") ~= nil then
		NAStuff.Sync_AnimatePrevDisabled = myAnimate.Disabled
		myAnimate.Disabled = true
	end

	for _, tr in ipairs(myAnimator:GetPlayingAnimationTracks()) do pcall(function() tr:Stop(0) end) end

	local active = {}
	local inverse = {}
	local stopped = false

	local function reactivateDefaults()
		local anim = myChar and myChar:FindFirstChild("Animate")
		if anim and NAlib.isProperty(anim, "Disabled") ~= nil then
			anim.Disabled = false
			anim.Disabled = true
			anim.Disabled = false
		end
		pcall(function() myHum:ChangeState(Enum.HumanoidStateType.Jumping) end)
	end

	local function stopAndRestore()
		if stopped then return end
		stopped = true
		for _, tr in ipairs(myAnimator:GetPlayingAnimationTracks()) do pcall(function() tr:Stop(0) end) end
		if myAnimate and NAlib.isProperty(myAnimate, "Disabled") ~= nil then
			myAnimate.Disabled = false
		end
		reactivateDefaults()
		NAStuff.Sync_AnimatePrevDisabled = nil
		NAlib.disconnect(NAStuff.SYNC_TAG)
	end

	local function allowOnlyMirrored()
		table.clear(inverse)
		for _, mt in pairs(active) do inverse[mt] = true end
		for _, tr in ipairs(myAnimator:GetPlayingAnimationTracks()) do
			if not inverse[tr] then pcall(function() tr:Stop(0) end) end
		end
		if myAnimate and NAlib.isProperty(myAnimate, "Disabled") ~= nil and not myAnimate.Disabled then
			myAnimate.Disabled = true
		end
	end

	local function mirrorTrack(tTrack)
		if not tTrack or not tTrack.Animation or tTrack.Animation.AnimationId == "" then return end
		local mt = active[tTrack]
		if mt and mt.IsPlaying then return end
		for _, tr in ipairs(myAnimator:GetPlayingAnimationTracks()) do pcall(function() tr:Stop(0) end) end
		local animClone = InstanceNew("Animation")
		animClone.AnimationId = tTrack.Animation.AnimationId
		mt = myAnimator:LoadAnimation(animClone)
		active[tTrack] = mt
		pcall(function()
			mt.Looped = tTrack.Looped
			mt:Play(0, 1, (type(tTrack.Speed)=="number" and tTrack.Speed) or 1)
			pcall(function() mt.TimePosition = tTrack.TimePosition end)
			mt:AdjustWeight(1)
		end)
		NAlib.connect(NAStuff.SYNC_TAG, tTrack.Stopped:Connect(function()
			local mine = active[tTrack]
			if mine then pcall(function() mine:Stop(0) end) active[tTrack] = nil end
		end))
	end

	for _, tTrack in ipairs(targetAnimator:GetPlayingAnimationTracks()) do
		mirrorTrack(tTrack)
	end
	allowOnlyMirrored()

	NAlib.connect(NAStuff.SYNC_TAG, targetHum.AnimationPlayed:Connect(function(tTrack)
		mirrorTrack(tTrack)
		allowOnlyMirrored()
	end))

	NAlib.connect(NAStuff.SYNC_TAG, RunService.Heartbeat:Connect(function()
		if stopped then return end
		allowOnlyMirrored()
		for tTrack, myTrack in pairs(active) do
			if not tTrack or not myTrack then
				active[tTrack] = nil
			else
				if not tTrack.IsPlaying then
					pcall(function() myTrack:Stop(0) end)
					active[tTrack] = nil
				else
					pcall(function()
						if type(tTrack.Speed) == "number" then myTrack:AdjustSpeed(tTrack.Speed) end
						if math.abs(myTrack.TimePosition - tTrack.TimePosition) > 0.15 then
							myTrack.TimePosition = tTrack.TimePosition
						end
						if myTrack.Looped ~= tTrack.Looped then myTrack.Looped = tTrack.Looped end
						myTrack:AdjustWeight(1)
					end)
				end
			end
		end
	end))

	NAlib.connect(NAStuff.SYNC_TAG, myChar.AncestryChanged:Connect(function() stopAndRestore() end))
	NAlib.connect(NAStuff.SYNC_TAG, targetChar.AncestryChanged:Connect(function() stopAndRestore() end))

	if typeof(target) == "Instance" and target:IsA("Player") then
		NAlib.connect(NAStuff.SYNC_TAG, Players.PlayerRemoving:Connect(function(plr)
			if plr == target then
				stopAndRestore()
			end
		end))
	end
end)

cmd.add({"syncstop","stopsync","syncend","endsync","syncoff"}, {"syncstop","Stop live sync and restore defaults"}, function()
	NAlib.disconnect(NAStuff.SYNC_TAG)
	local myChar = getChar()
	local myHum = getPlrHum(myChar)
	if myHum then
		local myAnimator = myHum:FindFirstChildOfClass("Animator")
		if myAnimator then
			for _, tr in ipairs(myAnimator:GetPlayingAnimationTracks()) do pcall(function() tr:Stop(0) end) end
		end
	end
	local myAnimate = myChar and myChar:FindFirstChild("Animate")
	if myAnimate and NAlib.isProperty(myAnimate, "Disabled") ~= nil then
		myAnimate.Disabled = false
		myAnimate.Disabled = true
		myAnimate.Disabled = false
	end
	NAStuff.Sync_AnimatePrevDisabled = nil
	pcall(function() myHum:ChangeState(Enum.HumanoidStateType.Jumping) end)
end)

cmd.add({"animresetcore","animreset","resetanim","resetan"}, {"animresetcore","Reset core animations to saved"}, function()
	local myChar = getChar()
	local myHum = getPlrHum(myChar)
	local myAnimate = myChar and myChar:FindFirstChild("Animate")
	if not (myHum and myAnimate and NAStuff.SavedDefaultMap) then return end
	local function mapAnims(root)
		local t = {}
		for _, inst in ipairs(root:GetDescendants()) do
			if inst:IsA("Animation") then
				local k = Lower(((inst.Parent and inst.Parent.Name) or "root").."|"..inst.Name)
				t[k] = inst
			end
		end
		return t
	end
	local function refresh(hum)
		local char = hum and hum.Parent
		local animScr = char and char:FindFirstChild("Animate")
		if animScr and NAlib.isProperty(animScr, "Disabled") ~= nil then
			animScr.Disabled = true
			animScr.Disabled = false
		else
			pcall(function() hum:ChangeState(Enum.HumanoidStateType.Jumping) end)
		end
	end
	local dst = mapAnims(myAnimate)
	for key, id in pairs(NAStuff.SavedDefaultMap) do
		local dstAnim = dst[key]
		if dstAnim and dstAnim.AnimationId ~= id then
			dstAnim.AnimationId = id
		end
	end
	refresh(myHum)
end)

cmd.add({"unsyncreset","unsync","unsres","unsr"}, {"unsyncreset","Stop sync and reset saved"}, function()
	NAlib.disconnect(NAStuff.SYNC_TAG)
	local myChar = getChar()
	local myHum = getPlrHum(myChar)
	if myHum then
		local myAnimator = myHum:FindFirstChildOfClass("Animator")
		if myAnimator then
			for _, tr in ipairs(myAnimator:GetPlayingAnimationTracks()) do pcall(function() tr:Stop(0) end) end
		end
	end
	local myAnimate = myChar and myChar:FindFirstChild("Animate")
	if myAnimate and NAlib.isProperty(myAnimate, "Disabled") ~= nil then
		if NAStuff.Sync_AnimatePrevDisabled ~= nil then
			myAnimate.Disabled = NAStuff.Sync_AnimatePrevDisabled
		else
			myAnimate.Disabled = false
		end
		NAStuff.Sync_AnimatePrevDisabled = nil
	end
	if not (myHum and myAnimate and NAStuff.SavedDefaultMap) then return end
	local function mapAnims(root)
		local t = {}
		for _, inst in ipairs(root:GetDescendants()) do
			if inst:IsA("Animation") then
				local k = Lower(((inst.Parent and inst.Parent.Name) or "root").."|"..inst.Name)
				t[k] = inst
			end
		end
		return t
	end
	local function refresh(hum)
		local char = hum and hum.Parent
		local animScr = char and char:FindFirstChild("Animate")
		if animScr and NAlib.isProperty(animScr, "Disabled") ~= nil then
			animScr.Disabled = true
			animScr.Disabled = false
		else
			pcall(function() hum:ChangeState(Enum.HumanoidStateType.Jumping) end)
		end
	end
	local dst = mapAnims(myAnimate)
	for key, id in pairs(NAStuff.SavedDefaultMap) do
		local dstAnim = dst[key]
		if dstAnim and dstAnim.AnimationId ~= id then
			dstAnim.AnimationId = id
		end
	end
	refresh(myHum)
end)

cmd.add({"mimic","mirror","mclone","mcopy","mimi"}, {"mimic <target> [delay]","Clone target movement with optional delay"}, function(targetArg, delayArg)
	if not targetArg or targetArg == "" then return end
	local delay = tonumber(delayArg) or 0
	if delay < 0 then delay = 0 end

	local targets = getPlr(targetArg)
	local target = targets and targets[1]
	if not target then return end

	local myChar = getChar()
	local targetChar = getPlrChar(target)
	if not (myChar and targetChar) then return end

	local myHum = getPlrHum(myChar)
	local targetHum = getPlrHum(targetChar)
	if not (myHum and targetHum) then return end
	if myHum.RigType ~= targetHum.RigType then return end

	NAlib.disconnect(NAStuff.MIMIC_TAG)

	local myAnimator = myHum:FindFirstChildOfClass("Animator") or InstanceNew("Animator", myHum)
	for _, tr in ipairs(myAnimator:GetPlayingAnimationTracks()) do pcall(function() tr:Stop(0) end) end

	local myAnimate = myChar:FindFirstChild("Animate")
	if myAnimate and NAlib.isProperty(myAnimate, "Disabled") ~= nil then
		NAStuff.Mimic_AnimatePrevDisabled = myAnimate.Disabled
		myAnimate.Disabled = true
	end

	local targetAnimator = targetHum:FindFirstChildOfClass("Animator")
	if not targetAnimator then return end

	local myRoot = getRoot(myChar)
	local targetRoot = getRoot(targetChar)
	if not (myRoot and targetRoot) then return end

	local prevAutoRotate = myHum.AutoRotate
	myHum.AutoRotate = false

	local function now() return os.clock() end

	local events, evHead = {}, 1
	local slots = {}
	local inverse = {}

	local function addEvent(e) events[#events+1] = e end
	local function newId() NAStuff.mimic_uid += 1 return NAStuff.mimic_uid end

	local function stopAndRestore()
		for _, s in pairs(slots) do
			if s.mt then pcall(function() s.mt:Stop(0) end) end
		end
		for _, tr in ipairs(myAnimator:GetPlayingAnimationTracks()) do pcall(function() tr:Stop(0) end) end
		myHum.AutoRotate = prevAutoRotate
		local a = myChar and myChar:FindFirstChild("Animate")
		if a and NAlib.isProperty(a, "Disabled") ~= nil then
			if NAStuff.Mimic_AnimatePrevDisabled ~= nil then a.Disabled = NAStuff.Mimic_AnimatePrevDisabled else a.Disabled = false end
			a.Disabled = true; a.Disabled = false
		end
		NAStuff.Mimic_AnimatePrevDisabled = nil
		events, evHead, slots = {}, 1, {}
		table.clear(inverse)
		NAlib.disconnect(NAStuff.MIMIC_TAG)
	end

	local function allowOnlyMirrored()
		table.clear(inverse)
		for _, s in pairs(slots) do if s.alive and s.mt and s.mt.IsPlaying then inverse[s.mt] = true end end
		for _, tr in ipairs(myAnimator:GetPlayingAnimationTracks()) do
			if not inverse[tr] then pcall(function() tr:Stop(0) end) end
		end
		if myAnimate and NAlib.isProperty(myAnimate, "Disabled") ~= nil and not myAnimate.Disabled then
			myAnimate.Disabled = true
		end
	end

	local function scheduleTrackStart(tt, tStamp)
		if not tt or not tt.Animation or tt.Animation.AnimationId == "" then return end
		local spd = (type(tt.Speed) == "number" and tt.Speed) or 1
		local baseTP = tt.TimePosition or 0
		addEvent({t = tStamp + delay, kind = "start", track = tt, animId = tt.Animation.AnimationId, speed = spd, baseTP = baseTP, looped = tt.Looped})
		NAlib.connect(NAStuff.MIMIC_TAG, tt:GetPropertyChangedSignal("Speed"):Connect(function()
			local s = (type(tt.Speed) == "number" and tt.Speed) or 1
			addEvent({t = now() + delay, kind = "speed", track = tt, speed = s})
		end))
		NAlib.connect(NAStuff.MIMIC_TAG, tt.Stopped:Connect(function()
			addEvent({t = now() + delay, kind = "stop", track = tt})
		end))
	end

	if delay == 0 then
		for _, tt in ipairs(targetAnimator:GetPlayingAnimationTracks()) do
			scheduleTrackStart(tt, now())
		end
	else
		for _, tt in ipairs(targetAnimator:GetPlayingAnimationTracks()) do
			local spd = (type(tt.Speed) == "number" and tt.Speed) or 1
			local inferredStart = now() - (tt.TimePosition or 0)/math.max(spd, 1e-6)
			addEvent({t = inferredStart + delay, kind = "start", track = tt, animId = tt.Animation.AnimationId, speed = spd, baseTP = 0, looped = tt.Looped})
			NAlib.connect(NAStuff.MIMIC_TAG, tt:GetPropertyChangedSignal("Speed"):Connect(function()
				local s = (type(tt.Speed) == "number" and tt.Speed) or 1
				addEvent({t = now() + delay, kind = "speed", track = tt, speed = s})
			end))
			NAlib.connect(NAStuff.MIMIC_TAG, tt.Stopped:Connect(function()
				addEvent({t = now() + delay, kind = "stop", track = tt})
			end))
		end
	end

	NAlib.connect(NAStuff.MIMIC_TAG, targetHum.AnimationPlayed:Connect(function(tt)
		scheduleTrackStart(tt, now())
	end))

	NAlib.connect(NAStuff.MIMIC_TAG, targetChar.ChildAdded:Connect(function(child)
		if child:IsA("Tool") then
			local bp = getBp()
			if bp then
				local match = bp:FindFirstChild(child.Name)
				if match and match:IsA("Tool") then pcall(function() myHum:EquipTool(match) end) end
			end
		end
	end))
	NAlib.connect(NAStuff.MIMIC_TAG, targetChar.ChildRemoved:Connect(function(child)
		if child:IsA("Tool") then pcall(function() myHum:UnequipTools() end) end
	end))

	local poseQ, poseHead = {}, 1
	local lastLook = Vector3.new(0,0,-1)

	NAlib.connect(NAStuff.MIMIC_TAG, RunService.Heartbeat:Connect(function()
		if not (targetChar and targetChar.Parent and targetRoot and targetRoot.Parent) then stopAndRestore() return end
		if not (myChar and myChar.Parent and myRoot and myRoot.Parent) then stopAndRestore() return end

		local lv = targetRoot.CFrame.LookVector
		local flat = Vector3.new(lv.X, 0, lv.Z)
		if flat.Magnitude >= 1e-4 then lastLook = flat.Unit end
		Insert(poseQ, {t = now(), pos = targetRoot.Position, look = lastLook, vel = targetRoot.AssemblyLinearVelocity, angY = targetRoot.AssemblyAngularVelocity.Y})
		local cutoff = now() - delay
		local snap
		while poseHead <= #poseQ and poseQ[poseHead].t <= cutoff do snap = poseQ[poseHead]; poseHead += 1 end
		if snap then
			local cf = CFrame.lookAt(snap.pos, snap.pos + snap.look)
			pcall(function()
				myRoot.CFrame = cf
				myRoot.AssemblyLinearVelocity = snap.vel
				myRoot.AssemblyAngularVelocity = Vector3.new(0, snap.angY, 0)
			end)
			if poseHead > 64 then
				local newBuf = {}
				for i = poseHead, #poseQ do newBuf[#newBuf+1] = poseQ[i] end
				poseQ, poseHead = newBuf, 1
			end
		end

		while evHead <= #events and events[evHead].t <= now() do
			local e = events[evHead]; evHead += 1
			if e.kind == "start" then
				if e.animId and e.animId ~= "" then
					local id = newId()
					local a = InstanceNew("Animation"); a.AnimationId = e.animId
					local mt = myAnimator:LoadAnimation(a)
					pcall(function() mt:Play(0, 1, 1) end)
					pcall(function() mt:AdjustSpeed(0) end)
					pcall(function() mt.TimePosition = e.baseTP or 0 end)
					slots[id] = {
						mt = mt,
						looped = e.looped and true or false,
						len = mt.Length or 0,
						baseTP = e.baseTP or 0,
						startLocal = e.t,
						segments = { {t = e.t, speed = e.speed or 1} },
						track = e.track,
						alive = true,
					}
				end
			elseif e.kind == "speed" then
				for _, s in pairs(slots) do
					if s.alive and s.track == e.track then
						Insert(s.segments, {t = e.t, speed = e.speed or 1})
					end
				end
			elseif e.kind == "stop" then
				for id, s in pairs(slots) do
					if s.alive and s.track == e.track then
						if s.mt then pcall(function() s.mt:Stop(0) end) end
						s.alive = false
						slots[id] = nil
					end
				end
			end
		end
		if evHead > 128 then
			local ne = {}
			for i = evHead, #events do ne[#ne+1] = events[i] end
			events, evHead = ne, 1
		end

		for id, s in pairs(slots) do
			if not s.alive or not s.mt then slots[id] = nil
			else
				if s.len == 0 then s.len = s.mt.Length or 0 end
				local tnow = now()
				local tp = s.baseTP
				for i = 1, #s.segments do
					local st = s.segments[i].t
					local sp = s.segments[i].speed or 1
					local en = (i < #s.segments) and s.segments[i+1].t or tnow
					if en > st then tp = tp + (en - st) * sp end
				end
				if s.looped and s.len and s.len > 0 then
					tp = tp % s.len
				elseif s.len and s.len > 0 then
					if tp > s.len - 1/30 then tp = s.len - 1/30 end
					if tp < 0 then tp = 0 end
				end
				pcall(function()
					if math.abs((s.mt.TimePosition or 0) - tp) > 0.02 then s.mt.TimePosition = tp end
				end)
			end
		end

		allowOnlyMirrored()
	end))

	NAlib.connect(NAStuff.MIMIC_TAG, myChar.AncestryChanged:Connect(function() stopAndRestore() end))
	NAlib.connect(NAStuff.MIMIC_TAG, targetChar.AncestryChanged:Connect(function() stopAndRestore() end))
	if typeof(target) == "Instance" and target:IsA("Player") then
		NAlib.connect(NAStuff.MIMIC_TAG, Players.PlayerRemoving:Connect(function(plr)
			if plr == target then stopAndRestore() end
		end))
	end
end)

cmd.add({"mstop","moff","stopmimic","mend"}, {"mstop","Stop mimic and restore defaults"}, function()
	NAlib.disconnect(NAStuff.MIMIC_TAG)
	local myChar = getChar()
	local myHum = getPlrHum(myChar)
	local myAnimator = myHum and myHum:FindFirstChildOfClass("Animator")
	if myAnimator then for _, tr in ipairs(myAnimator:GetPlayingAnimationTracks()) do pcall(function() tr:Stop(0) end) end end
	if myHum then myHum.AutoRotate = true end
	local a = myChar and myChar:FindFirstChild("Animate")
	if a and NAlib.isProperty(a, "Disabled") ~= nil then
		if NAStuff.Mimic_AnimatePrevDisabled ~= nil then a.Disabled = NAStuff.Mimic_AnimatePrevDisabled else a.Disabled = false end
		a.Disabled = true; a.Disabled = false
	end
	NAStuff.Mimic_AnimatePrevDisabled = nil
end)

cmd.add({"bubblechat","bchat"},{"bubblechat (bchat)","Enables BubbleChat"},function()
	NAStuff.ChatSettings.bubbles.enabled = true
	NAmanage.SaveTextChatSettings()
	NAmanage.ApplyTextChatSettings()
end)

cmd.add({"unbubblechat","unbchat"},{"unbubblechat (unbchat)","Disabled BubbleChat"},function()
	NAStuff.ChatSettings.bubbles.enabled = false
	NAmanage.SaveTextChatSettings()
	NAmanage.ApplyTextChatSettings()
end)

cmd.add({"hideicon","iconhide"},{"hideicon","Hides the NA icon"},function()
	if NAmanage.IconSetInvisible then
		NAmanage.IconSetInvisible(true)
	end
end)

cmd.add({"showicon","iconshow"},{"showicon","Shows the NA icon"},function()
	if NAmanage.IconSetInvisible then
		NAmanage.IconSetInvisible(false)
	end
end)

cmd.add({"lockiconposition","lockicon"},{"lockiconposition","Locks the NA icon's position (can't be dragged)"},function()
	if NAgui.setIconLocked then
		NAgui.setIconLocked(true)
	end
end)

cmd.add({"unlockiconposition","unlockicon"},{"unlockiconposition","Unlocks the NA icon's position (can be dragged again)"},function()
	if NAgui.setIconLocked then
		NAgui.setIconLocked(false)
	end
end)

cmd.add({"saveinstance","savegame"},{"saveinstance (savegame)","if it bugs out try removing stuff from your AutoExec folder"},function()
	--saveinstance({})
	if saveinstance then saveinstance() return end
	local Params={
		RepoURL="https://raw.githubusercontent.com/luau/SynSaveInstance/main/",
		SSI="saveinstance",
	}
	local synsaveinstance=loadstring(game:HttpGet(Params.RepoURL..Params.SSI..".luau",true),Params.SSI)()
	local Options={}
	if identifyexecutor()=="Fluxus" then
		Options={ IgnoreSpecialProperties=true }
	end
	synsaveinstance(Options)
end)

cmd.add({"admin","whitelist"},{"admin <player>","Whitelist the user to have access to *your* client-side commands, anything they type runs on *you*, not on themselves"},function(...)
	function ChatMessage(Message,Whisper)
		NAlib.LocalPlayerChat(Message,Whisper or "All")
	end
	local Player=getPlr(...)
	for _, plr in next, Player do
		if plr~=nil and not Admin[plr.UserId] then
			Admin[plr.UserId]={plr=plr}
			ChatMessage("["..adminName.."] You've got admin. Prefix: ';'",plr.Name)
			Wait(0.2)
			DoNotif(nameChecker(plr).." has now been whitelisted to use commands",15)
		else
			DoNotif("No player found")
		end
	end
end,true)

cmd.add({"unadmin"},{"unadmin <player>","removes someone from being admin"},function(...)
	function ChatMessage(Message,Whisper)
		NAlib.LocalPlayerChat(Message,Whisper or "All")
	end
	local Player=getPlr(...)
	for _, plr in next, Player do
		if plr~=nil and Admin[plr.UserId] then
			Admin[plr.UserId]=nil
			ChatMessage("You can no longer use commands",plr.Name)
			DoNotif(nameChecker(plr).." is no longer an admin",15)
		else
			DoNotif("Player not found")
		end
	end
end,true)

cmd.add({"partname","partpath","partgrabber"},{"partname (partpath,partgrabber)","gives a ui and allows you click on a part to grab it's path"},function()
	loadstring(game:HttpGet("https://raw.githubusercontent.com/ltseverydayyou/Nameless-Admin/main/PartGrabber.lua"))()
end)

-- patched (womp)
--[[cmd.add({"backdoor","backdoorscan"},{"backdoor (backdoorscan)","Scans for any backdoors using FraktureSS"},function()
	loadstring(game:HttpGet("https://raw.githubusercontent.com/ltseverydayyou/uuuuuuu/main/Frakture"))()
end)]]

cmd.add({"jobid"},{"jobid","Copies your job id"},function()
	if setclipboard then
		setclipboard(tostring(JobId))
		Wait();

		DebugNotif("Copied your jobid ("..JobId..")")
	else
		DoNotif("Your executor does not support setclipboard")
	end
end)

cmd.add({"joinjobid","joinjid","jjobid","jjid"},{"joinjobid <jobid> (joinjid,jjobid,jjid)","Joins the job id you put in"},function(...)
	zeId={...}
	id=zeId[1]
	TeleportService:TeleportToPlaceInstance(PlaceId,id)
end,true)

cmd.add({"serverhop","shop"},{"serverhop (shop)","serverhop"},function()
	Wait();

	DebugNotif("Searching")
	local Number=0
	local SomeSRVS={}
	local found=0
	for _,v in ipairs(HttpService:JSONDecode(game:HttpGetAsync("https://games.roblox.com/v1/games/"..PlaceId.."/servers/Public?sortOrder=Asc&limit=100")).data) do
		if type(v)=="table" and v.maxPlayers>v.playing and v.id~=JobId then
			if v.playing>Number then
				Number=v.playing
				SomeSRVS[1]=v.id
				found=v.playing
			end
		end
	end
	if #SomeSRVS>0 then
		DebugNotif("serverhopping | Player Count: "..found)
		TeleportService:TeleportToPlaceInstance(PlaceId,SomeSRVS[1])
	end
end)

cmd.add({"smallserverhop","sshop"},{"smallserverhop (sshop)","serverhop to a small server"},function()
	Wait();

	DebugNotif("Searching")

	local Number=math.huge
	local SomeSRVS={}
	local found=0

	for _,v in ipairs(HttpService:JSONDecode(game:HttpGetAsync("https://games.roblox.com/v1/games/"..PlaceId.."/servers/Public?sortOrder=Asc&limit=100")).data) do
		if type(v)=="table" and v.maxPlayers>v.playing and v.id~=JobId then
			if v.playing<Number then
				Number=v.playing
				SomeSRVS[1]=v.id
				found=v.playing
			end
		end
	end

	if #SomeSRVS>0 then
		DebugNotif("serverhopping | Player Count: "..found)
		TeleportService:TeleportToPlaceInstance(PlaceId,SomeSRVS[1])
	end
end)

cmd.add({"pingserverhop","pshop"},{"pingserverhop (pshop)","serverhop to a server with the best ping"},function()
	Wait();

	DebugNotif("Searching for server with best ping")

	local Servers = JSONDecode(HttpService, game:HttpGetAsync("https://games.roblox.com/v1/games/"..PlaceId.."/servers/Public?sortOrder=Asc&limit=100")).data
	local BestPing = math.huge
	local BestJobId = nil

	if Servers and #Servers > 0 then
		for _, Server in next, Servers do
			if type(Server) == "table" and Server.id ~= JobId then
				local ping = Server.ping
				if ping and ping < BestPing then
					BestPing = ping
					BestJobId = Server.id
				end
			end
		end
	end

	if BestJobId then
		DebugNotif(Format("Serverhopping to server with ping: %s ms", tostring(BestPing)))
		TeleportService:TeleportToPlaceInstance(PlaceId, BestJobId)
	else
		DebugNotif("No better server found")
	end
end)

cmd.add({"autorejoin", "autorj"}, {"autorejoin (autorj)", "Rejoins the server if you get kicked / disconnected"}, function()
	NAlib.disconnect("autorejoin")

	local function handleRejoin()
		if #Players:GetPlayers() <= 1 then
			Players.LocalPlayer:Kick("Rejoining...")
			Wait(.05)
			TeleportService:Teleport(PlaceId, Players.LocalPlayer)
		else
			TeleportService:TeleportToPlaceInstance(PlaceId, JobId, Players.LocalPlayer)
		end
	end

	local guiService = SafeGetService("GuiService")
	NAlib.connect("autorejoin", guiService.ErrorMessageChanged:Connect(handleRejoin))

	DebugNotif("Auto Rejoin is now enabled!")
end)

cmd.add({"unautorejoin", "unautorj"}, {"unautorejoin (unautorj)", "Disables auto rejoin command"}, function()
	if NAlib.isConnected("autorejoin") then
		NAlib.disconnect("autorejoin")
		DebugNotif("Auto Rejoin is now disabled!")
	else
		DebugNotif("Auto Rejoin is already disabled!")
	end
end)

cmd.add({"functionspy"},{"functionspy","Check console"},function()
	local toLog={
		debug.getconstants;
		getconstants;
		debug.getconstant;
		getconstant;
		debug.setconstant;
		setconstant;
		debug.getupvalues;
		debug.getupvalue;
		getupvalues;
		getupvalue;
		debug.setupvalue;
		setupvalue;
		getsenv;
		getreg;
		getgc;
		getconnections;
		firesignal;
		fireclickdetector;
		fireproximityprompt;
		firetouchinterest;
		gethiddenproperty;
		sethiddenproperty;
		hookmetamethod;
		setnamecallmethod;
		getrawmetatable;
		setrawmetatable;
		setreadonly;
		isreadonly;
		debug.setmetatable;
	}

	local FunctionSpy=InstanceNew("ScreenGui")
	local Main=InstanceNew("Frame")
	local LeftPanel=InstanceNew("ScrollingFrame")
	local UIListLayout=InstanceNew("UIListLayout")
	local example=InstanceNew("TextButton")
	local name=InstanceNew("TextLabel")
	local UIPadding=InstanceNew("UIPadding")
	local FakeTitle=InstanceNew("TextButton")
	local Title=InstanceNew("TextLabel")
	local clear=InstanceNew("ImageButton")
	local RightPanel=InstanceNew("ScrollingFrame")
	local output=InstanceNew("TextLabel")
	local clear_2=InstanceNew("TextButton")
	local copy=InstanceNew("TextButton")

	NaProtectUI(FunctionSpy)
	FunctionSpy.Name="FunctionSpy"
	FunctionSpy.ZIndexBehavior=Enum.ZIndexBehavior.Sibling

	Main.Name="Main"
	Main.Parent=FunctionSpy
	Main.BackgroundColor3=Color3.fromRGB(33,33,33)
	Main.BorderSizePixel=0
	Main.Position=UDim2.new(0,10,0,36)
	Main.Size=UDim2.new(0,536,0,328)

	LeftPanel.Name="LeftPanel"
	LeftPanel.Parent=Main
	LeftPanel.Active=true
	LeftPanel.BackgroundColor3=Color3.fromRGB(45,45,45)
	LeftPanel.BorderSizePixel=0
	LeftPanel.Size=UDim2.new(0.349999994,0,1,0)
	LeftPanel.CanvasSize=UDim2.new(0,0,0,0)
	LeftPanel.HorizontalScrollBarInset=Enum.ScrollBarInset.ScrollBar
	LeftPanel.ScrollBarThickness=3

	UIListLayout.Parent=LeftPanel
	UIListLayout.SortOrder=Enum.SortOrder.LayoutOrder
	UIListLayout.Padding=UDim.new(0,7)

	example.Name="example"
	example.Parent=LeftPanel
	example.BackgroundColor3=Color3.fromRGB(31,31,31)
	example.BorderSizePixel=0
	example.Position=UDim2.new(4.39481269e-08,0,0,0)
	example.Size=UDim2.new(0,163,0,19)
	example.Visible=false
	example.Font=Enum.Font.SourceSans
	example.Text=""
	example.TextColor3=Color3.fromRGB(0,0,0)
	example.TextSize=14.000
	example.TextXAlignment=Enum.TextXAlignment.Left

	name.Name="name"
	name.Parent=example
	name.BackgroundColor3=Color3.fromRGB(255,255,255)
	name.BackgroundTransparency=1.000
	name.BorderSizePixel=0
	name.Position=UDim2.new(0,10,0,0)
	name.Size=UDim2.new(1,-10,1,0)
	name.Font=Enum.Font.SourceSans
	name.TextColor3=Color3.fromRGB(255,255,255)
	name.TextSize=14.000
	name.TextXAlignment=Enum.TextXAlignment.Left

	UIPadding.Parent=LeftPanel
	UIPadding.PaddingBottom=UDim.new(0,7)
	UIPadding.PaddingLeft=UDim.new(0,7)
	UIPadding.PaddingRight=UDim.new(0,7)
	UIPadding.PaddingTop=UDim.new(0,7)

	FakeTitle.Name="FakeTitle"
	FakeTitle.Parent=Main
	FakeTitle.BackgroundColor3=Color3.fromRGB(40,40,40)
	FakeTitle.BorderSizePixel=0
	FakeTitle.Position=UDim2.new(0,225,0,-26)
	FakeTitle.Size=UDim2.new(0.166044772,0,0,26)
	FakeTitle.Font=Enum.Font.GothamMedium
	FakeTitle.Text="FunctionSpy"
	FakeTitle.TextColor3=Color3.fromRGB(255,255,255)
	FakeTitle.TextSize=14.000

	Title.Name="Title"
	Title.Parent=Main
	Title.BackgroundColor3=Color3.fromRGB(40,40,40)
	Title.BorderSizePixel=0
	Title.Position=UDim2.new(0,0,0,-26)
	Title.Size=UDim2.new(1,0,0,26)
	Title.Font=Enum.Font.GothamMedium
	Title.Text="FunctionSpy"
	Title.TextColor3=Color3.fromRGB(255,255,255)
	Title.TextSize=14.000
	Title.TextWrapped=true

	clear.Name="clear"
	clear.Parent=Title
	clear.BackgroundTransparency=1.000
	clear.Position=UDim2.new(1,-28,0,2)
	clear.Size=UDim2.new(0,24,0,24)
	clear.ZIndex=2
	clear.Image=getcustomasset and getcustomasset(NAfiles.NAASSETSFILEPATH.."/"..NAImageAssets.Sheet) or "rbxassetid://3926305904"
	clear.ImageRectOffset=Vector2.new(924,724)
	clear.ImageRectSize=Vector2.new(36,36)

	RightPanel.Name="RightPanel"
	RightPanel.Parent=Main
	RightPanel.Active=true
	RightPanel.BackgroundColor3=Color3.fromRGB(35,35,35)
	RightPanel.BorderSizePixel=0
	RightPanel.Position=UDim2.new(0.349999994,0,0,0)
	RightPanel.Size=UDim2.new(0.649999976,0,1,0)
	RightPanel.CanvasSize=UDim2.new(0,0,0,0)
	RightPanel.HorizontalScrollBarInset=Enum.ScrollBarInset.ScrollBar
	RightPanel.ScrollBarThickness=3

	output.Name="output"
	output.Parent=RightPanel
	output.BackgroundColor3=Color3.fromRGB(255,255,255)
	output.BackgroundTransparency=1.000
	output.BorderColor3=Color3.fromRGB(27,42,53)
	output.BorderSizePixel=0
	output.Position=UDim2.new(0,10,0,10)
	output.Size=UDim2.new(1,-10,0.75,-10)
	output.Font=Enum.Font.GothamMedium
	output.Text=""
	output.TextColor3=Color3.fromRGB(255,255,255)
	output.TextSize=14.000
	output.TextXAlignment=Enum.TextXAlignment.Left
	output.TextYAlignment=Enum.TextYAlignment.Top

	clear_2.Name="clear"
	clear_2.Parent=RightPanel
	clear_2.BackgroundColor3=Color3.fromRGB(30,30,30)
	clear_2.BorderSizePixel=0
	clear_2.Position=UDim2.new(0.0631457642,0,0.826219559,0)
	clear_2.Size=UDim2.new(0,140,0,33)
	clear_2.Font=Enum.Font.SourceSans
	clear_2.Text="Clear logs"
	clear_2.TextColor3=Color3.fromRGB(255,255,255)
	clear_2.TextSize=14.000

	copy.Name="copy"
	copy.Parent=RightPanel
	copy.BackgroundColor3=Color3.fromRGB(30,30,30)
	copy.BorderSizePixel=0
	copy.Position=UDim2.new(0.545350134,0,0.826219559,0)
	copy.Size=UDim2.new(0,140,0,33)
	copy.Font=Enum.Font.SourceSans
	copy.Text="Copy info"
	copy.TextColor3=Color3.fromRGB(255,255,255)
	copy.TextSize=14.000

	--Scripts:

	function AKIHDI_fake_script()
		_G.functionspy={
			instance=Main.Parent;
			logging=true;
			connections={};
		}

		_G.functionspy.shutdown=function()
			for i,v in pairs(_G.functionspy.connections) do
				v:Disconnect()
			end
			_G.functionspy.connections={}
			_G.functionspy=nil
			Main.Parent:Destroy()
		end

		local connections={}

		local currentInfo=nil

		function log(name,text)
			local btn=Main.LeftPanel.example:Clone()
			btn.Parent=Main.LeftPanel
			btn.Name=name
			btn.name.Text=name
			btn.Visible=true
			Insert(connections,btn.MouseButton1Click:Connect(function()
				Main.RightPanel.output.Text=text
				currentInfo=text
			end))
		end

		Main.RightPanel.copy.MouseButton1Click:Connect(function()
			if currentInfo~=nil then
				setclipboard(tostring(currentInfo))
			end
		end)

		Main.RightPanel.clear.MouseButton1Click:Connect(function()
			for i,v in pairs(connections) do
				v:Disconnect()
			end
			for i,v in pairs(Main.LeftPanel:GetDescendants()) do
				if v:IsA("TextButton") and v.Visible==true then
					v:Destroy()
				end
			end
			Main.RightPanel.output.Text=""
			currentInfo=nil
		end)

		local hooked={}
		local Seralize=loadstring(game:HttpGet('https://api.irisapp.ca/Scripts/SeralizeTable.lua',true))()
		for i,v in next,toLog do
			if type(v)=="string" then
				local suc,err=NACaller(function()
					local func=loadstring("return "..v)()
					hooked[i]=hookfunction(func,function(...)
						local args={...}
						if _G.functionspy then
							NACaller(function()
								out=""
								out=out..(v..",Args-> {")..("\n"):format()
								for l,k in pairs(args) do
									if type(k)=="function" then
										out=out..("    ["..tostring(l).."] "..tostring(k)..",Type-> "..type(k)..",Name-> "..getinfo(k).name)..("\n"):format()
									elseif type(k)=="table" then
										out=out..("    ["..tostring(l).."] "..tostring(k)..",Type-> "..type(k)..",Data-> "..Seralize(k))..("\n"):format()
									elseif type(k)=="boolean" then
										out=out..("    ["..tostring(l).."] Value-> "..tostring(k).."-> "..type(k))..("\n"):format()
									elseif type(k)=="nil" then
										out=out..("    ["..tostring(l).."] null")..("\n"):format()
									elseif type(k)=="number" then
										out=out..("    ["..tostring(l).."] Value-> "..tostring(k)..",Type-> "..type(k))..("\n"):format()
									else
										out=out..("    ["..tostring(l).."] Value-> "..tostring(k)..",Type-> "..type(k))..("\n"):format()
									end
								end
								out=out..("},Result-> "..tostring(nil))..("\n"):format()
								if _G.functionspy.logging==true then
									log(v,out)
								end
							end)
						end
						return hooked[i](...)
					end)
				end)
				if not suc then
					warn("Something went wrong while hooking "..v..". Error: "..err)
				end
			elseif type(v)=="function" then
				local suc,err=NACaller(function()
					hooked[i]=hookfunction(v,function(...)
						local args={...}
						if _G.functionspy then
							NACaller(function() 
								out=""
								out=out..(getinfo(v).name..",Args-> {")..("\n"):format()
								for l,k in pairs(args) do
									if type(k)=="function" then
										out=out..("    ["..tostring(l).."] "..tostring(k)..",Type-> "..type(k)..",Name-> "..getinfo(k).name)..("\n"):format()
									elseif type(k)=="table" then
										out=out..("    ["..tostring(l).."] "..tostring(k)..",Type-> "..type(k)..",Data-> "..Seralize(k))..("\n"):format()
									elseif type(k)=="boolean" then
										out=out..("    ["..tostring(l).."] Value-> "..tostring(k).."-> "..type(k))..("\n"):format()
									elseif type(k)=="nil" then
										out=out..("    ["..tostring(l).."] null")..("\n"):format()
									elseif type(k)=="number" then
										out=out..("    ["..tostring(l).."] Value-> "..tostring(k)..",Type-> "..type(k))..("\n"):format()
									else
										out=out..("    ["..tostring(l).."] Value-> "..tostring(k)..",Type-> "..type(k))..("\n"):format()
									end
								end
								out=out..("},Result-> "..tostring(nil))..("\n"):format()
								if _G.functionspy.logging==true then
									log(getinfo(v).name,out)
								end
							end)
						end
						return hooked[i](...)
					end)
				end)
				if not suc then
					warn("Something went wrong while hooking "..getinfo(v).name..". Error: "..err)
				end
			end
		end

	end
	coroutine.wrap(AKIHDI_fake_script)()
	function KVVJTK_fake_script()
		local UIS=UserInputService
		local frame=FakeTitle.Parent
		local dragToggle=nil
		local dragSpeed=0.25
		local dragStart=nil
		local startPos=nil

		function updateInput(input)
			local delta=input.Position-dragStart
			local position=UDim2.new(startPos.X.Scale,startPos.X.Offset+delta.X,
				startPos.Y.Scale,startPos.Y.Offset+delta.Y)
			TweenService:Create(frame,TweenInfo.new(dragSpeed),{Position=position}):Play()
		end

		Insert(_G.functionspy.connections,frame.Title.InputBegan:Connect(function(input)
			if (input.UserInputType==Enum.UserInputType.MouseButton1 or input.UserInputType==Enum.UserInputType.Touch) then 
				dragToggle=true
				dragStart=input.Position
				startPos=frame.Position
				input.Changed:Connect(function()
					if input.UserInputState==Enum.UserInputState.End then
						dragToggle=false
					end
				end)
			end
		end))

		Insert(_G.functionspy.connections,UIS.InputChanged:Connect(function(input)
			if input.UserInputType==Enum.UserInputType.MouseMovement or input.UserInputType==Enum.UserInputType.Touch then
				if dragToggle then
					updateInput(input)
				end
			end
		end))

	end
	coroutine.wrap(KVVJTK_fake_script)()
	function BIPVKVC_fake_script()
		local script=InstanceNew('LocalScript',FakeTitle)

		Insert(_G.functionspy.connections,FakeTitle.MouseEnter:Connect(function()
			if _G.functionspy.logging==true then
				TweenService:Create(FakeTitle.Parent.Title,TweenInfo.new(0.3),{TextColor3=Color3.new(0,1,0)}):Play()
			elseif _G.functionspy.logging==false then
				TweenService:Create(FakeTitle.Parent.Title,TweenInfo.new(0.3),{TextColor3=Color3.new(1,0,0)}):Play()
			end
		end))

		Insert(_G.functionspy.connections,FakeTitle.MouseMoved:Connect(function()
			if _G.functionspy.logging==true then
				TweenService:Create(FakeTitle.Parent.Title,TweenInfo.new(0.3),{TextColor3=Color3.new(0,1,0)}):Play()
			elseif _G.functionspy.logging==false then
				TweenService:Create(FakeTitle.Parent.Title,TweenInfo.new(0.3),{TextColor3=Color3.new(1,0,0)}):Play()
			end
		end))

		Insert(_G.functionspy.connections,FakeTitle.MouseButton1Click:Connect(function()
			_G.functionspy.logging=not _G.functionspy.logging
			if _G.functionspy.logging==true then
				TweenService:Create(FakeTitle.Parent.Title,TweenInfo.new(0.3),{TextColor3=Color3.new(0,1,0)}):Play()
			elseif _G.functionspy.logging==false then
				TweenService:Create(FakeTitle.Parent.Title,TweenInfo.new(0.3),{TextColor3=Color3.new(1,0,0)}):Play()
			end
		end))

		Insert(_G.functionspy.connections,FakeTitle.MouseLeave:Connect(function()
			TweenService:Create(FakeTitle.Parent.Title,TweenInfo.new(0.3),{TextColor3=Color3.new(1,1,1)}):Play()
		end))
	end
	coroutine.wrap(BIPVKVC_fake_script)()
	function PRML_fake_script()
		clear.MouseButton1Click:Connect(function()
			_G.functionspy.shutdown()
		end)
	end
	coroutine.wrap(PRML_fake_script)()
end)

cmd.add({"fly"},{"fly [speed]","Enable flight"},function(...)
	local arg=(...) or nil
	flyVariables.flySpeed=tonumber(arg) or flyVariables.flySpeed or 1
	NAmanage.connectFlyKey()
	NAmanage.activateMode("fly")
	if not IsOnMobile then
		Wait()
		DebugNotif("Fly enabled. Press '"..string.upper(flyVariables.toggleKey).."' to fly/unfly.")
	end
end,true)

cmd.add({"unfly"},{"unfly","Disable flight"},function()
	NAmanage.deactivateMode("fly")
end)

cmd.add({"cframefly","cfly"},{"cframefly [speed] (cfly)","Enable CFrame-based flight"},function(...)
	local arg=(...) or nil
	flyVariables.cFlySpeed=tonumber(arg) or flyVariables.cFlySpeed or 1
	flyVariables.flySpeed=flyVariables.cFlySpeed
	NAmanage.connectCFlyKey()
	NAmanage.activateMode("cfly")
	if not IsOnMobile then
		Wait()
		DebugNotif("CFrame Fly enabled. Press '"..string.upper(flyVariables.cToggleKey).."' to cfly/uncfly.")
	end
end,true)

cmd.add({"uncframefly","uncfly"},{"uncfly","Disable CFrame-based flight"},function()
	NAmanage.deactivateMode("cfly")
end)

--[[if IsOnPC then
	cmd.add({"cflybind", "cframeflybind", "bindcfly"}, {"cflybind [key] (cframeflybind, bindcfly)", "Set custom keybind for CFrame fly"}, function(...)
		local newKey = (...) or ""
		newKey = newKey:lower()
		if newKey == "" then
			DoNotif("Please provide a keybind.")
			return
		end

		flyVariables.cToggleKey = newKey

		if flyVariables.cKeybindConn then
			flyVariables.cKeybindConn:Disconnect()
			flyVariables.cKeybindConn = nil
		end

		connectCFlyKey()
		DoNotif("CFrame fly keybind set to '"..flyVariables.cToggleKey:upper().."'")
	end,true)
end]]

cmd.add({"tfly","tweenfly"},{"tfly [speed] (tweenfly)","Enables smooth flying"},function(...)
	local arg=(...) or nil
	flyVariables.TflySpeed=tonumber(arg) or flyVariables.TflySpeed or 1
	NAmanage.connectTFlyKey()
	NAmanage.activateMode("tfly")
	if not IsOnMobile then
		Wait()
		DebugNotif("TFly enabled. Press '"..string.upper(flyVariables.tflyToggleKey).."' to tfly/untfly.")
	end
end,true)

cmd.add({"untfly","untweenfly"},{"untfly","Disables tween flying"},function()
	NAmanage.deactivateMode("tfly")
end)

--[[if IsOnPC then
	cmd.add({"tflykeybind", "bindtfly", "tflybind"}, {"tflykeybind [key] (bindtfly, tflybind)", "Set keybind for tfly toggle"}, function(...)
		local key = (...) or ""
		if key == "" then
			DoNotif("Please provide a key.")
			return
		end
		flyVariables.tflyToggleKey = key:lower()
		if flyVariables.tflyKeyConn then flyVariables.tflyKeyConn:Disconnect() end
		flyVariables.tflyKeyConn = mouse.KeyDown:Connect(function(k)
			if k:lower() == flyVariables.tflyToggleKey then
				toggleTFly()
			end
		end)
		DoNotif("TFly keybind set to '"..flyVariables.tflyToggleKey:upper().."'")
	end, true)
end]]

-- idk what i am doing lol (bored af :P)

cmd.add({"noclip","nclip","nc"},{"noclip","Disable your player's collision"},function()
	NAlib.disconnect("noclip")
	NAlib.disconnect("noclip_char")
	NAStuff._noclipTracked = NAStuff._noclipTracked or setmetatable({}, {__mode="k"})
	NAStuff._noclipOrigCan = NAStuff._noclipOrigCan or setmetatable({}, {__mode="k"})
	NAStuff._noclipOrigGrp = NAStuff._noclipOrigGrp or setmetatable({}, {__mode="k"})
	NAStuff._noclipSignals = NAStuff._noclipSignals or setmetatable({}, {__mode="k"})
	NAStuff._noclipGroup = "NA_NoClip"
	local tracked, origCan, origGrp, signals = NAStuff._noclipTracked, NAStuff._noclipOrigCan, NAStuff._noclipOrigGrp, NAStuff._noclipSignals
	local lp = Players.LocalPlayer
	local enforce = function(p)
		if p and p:IsA("BasePart") then
			if origCan[p] == nil then origCan[p] = NAlib.isProperty(p,"CanCollide") end
			if origGrp[p] == nil then origGrp[p] = (p.CollisionGroup or "Default") end
			if p.CollisionGroup ~= NAStuff._noclipGroup then pcall(function() p.CollisionGroup = NAStuff._noclipGroup end) end
			if NAlib.isProperty(p,"CanCollide") ~= false then NAlib.setProperty(p,"CanCollide", false) end
			if not signals[p] then
				local c = p:GetPropertyChangedSignal("CanCollide"):Connect(function()
					if NAlib.isProperty(p,"CanCollide") ~= false then NAlib.setProperty(p,"CanCollide", false) end
				end)
				signals[p] = {c}
				NAlib.connect("noclip", c)
			end
			tracked[p] = true
		end
	end
	local seed = function(char)
		if not char then return end
		for _,d in ipairs(char:GetDescendants()) do
			if d:IsA("BasePart") then enforce(d) end
		end
		NAlib.connect("noclip", char.DescendantAdded:Connect(function(inst)
			if inst:IsA("BasePart") then enforce(inst) end
		end))
		NAlib.connect("noclip", char.DescendantRemoving:Connect(function(inst)
			if signals[inst] then for _,c in ipairs(signals[inst]) do if c then c:Disconnect() end end signals[inst]=nil end
			tracked[inst] = nil
			origCan[inst] = nil
			origGrp[inst] = nil
		end))
	end
	if lp.Character then seed(lp.Character) end
	NAlib.connect("noclip_char", lp.CharacterAdded:Connect(function(char)
		for _,arr in pairs(signals) do if arr then for _,c in ipairs(arr) do if c then c:Disconnect() end end end end
		for k in pairs(signals) do signals[k]=nil end
		for k in pairs(tracked) do tracked[k]=nil end
		for k in pairs(origCan) do origCan[k]=nil end
		for k in pairs(origGrp) do origGrp[k]=nil end
		Wait(); seed(char)
	end))
	NAlib.connect("noclip_char", lp.CharacterRemoving:Connect(function()
		for _,arr in pairs(signals) do if arr then for _,c in ipairs(arr) do if c then c:Disconnect() end end end end
		for k in pairs(signals) do signals[k]=nil end
		for k in pairs(tracked) do tracked[k]=nil end
		for k in pairs(origCan) do origCan[k]=nil end
		for k in pairs(origGrp) do origGrp[k]=nil end
	end))
	NAlib.connect("noclip", RunService.Stepped:Connect(function()
		local char = lp.Character
		if not char then return end
		for p in pairs(tracked) do
			if typeof(p)=="Instance" and p:IsA("BasePart") and p:IsDescendantOf(char) then
				if p.CollisionGroup ~= NAStuff._noclipGroup then pcall(function() p.CollisionGroup = NAStuff._noclipGroup end) end
				if p.CanCollide ~= false then NAlib.setProperty(p,"CanCollide", false) end
			end
		end
	end))
end)

cmd.add({"clip"},{"clip","Enable your player's collision"},function()
	local tracked = NAStuff._noclipTracked or {}
	local origCan = NAStuff._noclipOrigCan or {}
	local origGrp = NAStuff._noclipOrigGrp or {}
	local signals = NAStuff._noclipSignals or {}
	NAlib.disconnect("noclip")
	NAlib.disconnect("noclip_char")
	for _,arr in pairs(signals) do if arr then for _,c in ipairs(arr) do if c then c:Disconnect() end end end end
	for p in pairs(tracked) do
		if typeof(p)=="Instance" and p:IsA("BasePart") then
			local v = origCan[p]; if v == nil then v = true end
			NAlib.setProperty(p,"CanCollide", v)
			local g = origGrp[p]; if g == nil then g = "Default" end
			pcall(function() p.CollisionGroup = g end)
		end
	end
	for k in pairs(signals) do signals[k]=nil end
	for k in pairs(tracked) do tracked[k]=nil end
	for k in pairs(origCan) do origCan[k]=nil end
	for k in pairs(origGrp) do origGrp[k]=nil end
end)

cmd.add({"antianchor","aa"},{"antianchor","Prevent your parts from being anchored"},function()
	NAlib.disconnect("antianchor")
	NAlib.disconnect("antianchor_char")
	NAStuff._aaTracked = NAStuff._aaTracked or setmetatable({}, {__mode="k"})
	NAStuff._aaOrig = NAStuff._aaOrig or setmetatable({}, {__mode="k"})
	NAStuff._aaSignals = NAStuff._aaSignals or setmetatable({}, {__mode="k"})
	local tracked, orig, signals = NAStuff._aaTracked, NAStuff._aaOrig, NAStuff._aaSignals
	local lp = Players.LocalPlayer
	local enforce = function(p)
		if not (p and p:IsA("BasePart")) then return end
		if orig[p] == nil then orig[p] = NAlib.isProperty(p,"Anchored") end
		tracked[p] = true
		if NAlib.isProperty(p,"Anchored") ~= false then NAlib.setProperty(p,"Anchored", false) end
		if not signals[p] then
			local c = p:GetPropertyChangedSignal("Anchored"):Connect(function()
				if NAlib.isProperty(p,"Anchored") ~= false then NAlib.setProperty(p,"Anchored", false) end
			end)
			signals[p] = c
			NAlib.connect("antianchor", c)
		end
	end
	local seed = function(char)
		if not char then return end
		for _,d in ipairs(char:GetDescendants()) do
			if d:IsA("BasePart") then enforce(d) end
		end
		NAlib.connect("antianchor", char.DescendantAdded:Connect(function(inst)
			if inst:IsA("BasePart") then enforce(inst) end
		end))
		NAlib.connect("antianchor", char.DescendantRemoving:Connect(function(inst)
			if signals[inst] then signals[inst]:Disconnect(); signals[inst] = nil end
			tracked[inst] = nil
			orig[inst] = nil
		end))
	end
	if lp.Character then seed(lp.Character) end
	NAlib.connect("antianchor_char", lp.CharacterAdded:Connect(function(char)
		for _,c in pairs(signals) do if c then c:Disconnect() end end
		for k in pairs(signals) do signals[k]=nil end
		for k in pairs(tracked) do tracked[k]=nil end
		for k in pairs(orig) do orig[k]=nil end
		Wait(); seed(char)
	end))
	NAlib.connect("antianchor_char", lp.CharacterRemoving:Connect(function()
		for _,c in pairs(signals) do if c then c:Disconnect() end end
		for k in pairs(signals) do signals[k]=nil end
		for k in pairs(tracked) do tracked[k]=nil end
		for k in pairs(orig) do orig[k]=nil end
	end))
	NAlib.connect("antianchor", RunService.Stepped:Connect(function()
		local char = lp.Character
		if not char then return end
		for p in pairs(tracked) do
			if typeof(p)=="Instance" and p:IsA("BasePart") and p:IsDescendantOf(char) then
				if p.Anchored ~= false then NAlib.setProperty(p,"Anchored", false) end
			end
		end
	end))
end)

cmd.add({"unantianchor","unaa"},{"unantianchor","Allow your parts to be anchored"},function()
	local tracked = NAStuff._aaTracked or {}
	local orig = NAStuff._aaOrig or {}
	local signals = NAStuff._aaSignals or {}
	NAlib.disconnect("antianchor")
	NAlib.disconnect("antianchor_char")
	for _,c in pairs(signals) do if c then c:Disconnect() end end
	for p in pairs(tracked) do
		if typeof(p)=="Instance" and p:IsA("BasePart") then
			local v = orig[p]; if v == nil then v = false end
			NAlib.setProperty(p,"Anchored", v)
		end
	end
	for k in pairs(signals) do signals[k]=nil end
	for k in pairs(tracked) do tracked[k]=nil end
	for k in pairs(orig) do orig[k]=nil end
end)

originalPos = nil
platformPart = nil
activationTime = nil

cmd.add({"antibang"}, {"antibang", "prevents users to bang you (still WORK IN PROGRESS)"}, function()
	NAlib.disconnect("antibang_loop")

	local root = getRoot(LocalPlayer.Character)
	if not root then return end

	originalPos = root.CFrame
	local orgHeight = workspace.FallenPartsDestroyHeight
	local anims = {"rbxassetid://5918726674", "rbxassetid://148840371", "rbxassetid://698251653", "rbxassetid://72042024", "rbxassetid://189854234", "rbxassetid://106772613", "rbxassetid://10714360343", "rbxassetid://95383980"}
	local inVoid = false
	local targetPlayer = nil
	local toldNotif = false
	local activationTime = nil

	LocalPlayer.CharacterAdded:Connect(function(char)
		Wait(1)
		root = getRoot(char)
	end)

	NAlib.connect("antibang_loop", RunService.Stepped:Connect(function()
		for _, p in pairs(SafeGetService("Players"):GetPlayers()) do
			if p ~= LocalPlayer and p.Character and getRoot(p.Character) then
				if (getRoot(p.Character).Position - root.Position).Magnitude <= 10 then
					local tracks = getPlrHum(p):GetPlayingAnimationTracks()
					for _, t in pairs(tracks) do
						if Discover(anims, t.Animation.AnimationId) then
							if not inVoid then
								inVoid = true
								activationTime = tick()
								targetPlayer = p
								workspace.FallenPartsDestroyHeight = 0/1/0
								platformPart = InstanceNew("Part")
								platformPart.Size = Vector3.new(9999, 1, 9999)
								platformPart.Anchored = true
								platformPart.CanCollide = true
								platformPart.Transparency = 1
								platformPart.Position = Vector3.new(0, orgHeight - 30, 0)
								platformPart.Parent = workspace
								root.CFrame = CFrame.new(Vector3.new(0, orgHeight - 25, 0))
								if not toldNotif then
									toldNotif = true
									DebugNotif("Antibang activated | Target: "..nameChecker(targetPlayer), 2)
								end
							end
						end
					end
				end
			end
		end

		if inVoid then
			if (not targetPlayer or not targetPlayer.Character or not getPlrHum(targetPlayer) or getPlrHum(targetPlayer).Health <= 0)
				or (activationTime and tick() - activationTime >= 10) then
				inVoid = false
				targetPlayer = nil
				root.CFrame = originalPos
				root.Anchored = true
				Wait()
				root.Anchored = false
				workspace.FallenPartsDestroyHeight = orgHeight
				if platformPart then
					platformPart:Destroy()
					platformPart = nil
				end
				if toldNotif then
					toldNotif = false
					if activationTime and tick() - activationTime >= 10 then
						DebugNotif("Antibang deactivated (timeout)", 2)
					else
						DebugNotif("Antibang deactivated", 2)
					end
				end
			end
		end
	end))

	DebugNotif("Antibang Enabled", 3)
end)

cmd.add({"unantibang"}, {"unantibang", "disables antibang"}, function()
	NAlib.disconnect("antibang_loop")
	if platformPart then
		platformPart:Destroy()
		platformPart = nil
	end
	DebugNotif("Antibang Disabled", 3)
end)

cmd.add({"orbit"}, {"orbit <player> <distance>", "Orbit around a player"}, function(p, d)
	NAlib.disconnect("orbit")
	local targets = getPlr(p)
	if #targets == 0 then return end
	local target = targets[1]
	local tchar = target.Character
	local char = getChar()
	if not tchar or not char then return end
	local thrp = getRoot(tchar)
	local hrp = getRoot(char)
	if not thrp or not hrp then return end
	local dist = tonumber(d) or 4
	local sineX, sineZ = 0, math.pi / 2
	NAlib.connect("orbit", RunService.Stepped:Connect(function()
		if not (thrp.Parent and hrp.Parent) then
			NAlib.disconnect("orbit")
			return
		end
		sineX, sineZ = sineX + 0.05, sineZ + 0.05
		local sinX, sinZ = math.sin(sineX), math.sin(sineZ)
		hrp.Velocity = Vector3.zero
		hrp.CFrame = CFrame.new(sinX * dist, 0, sinZ * dist) * (hrp.CFrame - hrp.CFrame.p) + thrp.CFrame.p
	end))
end, true)

cmd.add({"uporbit"}, {"uporbit <player> <distance>", "Orbit around a player on the Y axis"}, function(p, d)
	NAlib.disconnect("orbit")
	local targets = getPlr(p)
	if #targets == 0 then return end
	local target = targets[1]
	local tchar = target.Character
	local char = getChar()
	if not tchar or not char then return end
	local thrp = getRoot(tchar)
	local hrp = getRoot(char)
	if not thrp or not hrp then return end
	local dist = tonumber(d) or 4
	local sineX, sineY = 0, math.pi / 2
	NAlib.connect("orbit", RunService.Stepped:Connect(function()
		if not (thrp.Parent and hrp.Parent) then
			NAlib.disconnect("orbit")
			return
		end
		sineX, sineY = sineX + 0.05, sineY + 0.05
		local sinX, sinY = math.sin(sineX), math.sin(sineY)
		hrp.Velocity = Vector3.zero
		hrp.CFrame = CFrame.new(sinX * dist, sinY * dist, 0) * (hrp.CFrame - hrp.CFrame.p) + thrp.CFrame.p
	end))
end, true)

cmd.add({"unorbit"}, {"unorbit", "Stop orbiting"}, function()
	NAlib.disconnect("orbit")
end)

-- unavailable and under maintance
--[[cmd.add({"serverfreeze", "freezewalk"}, {"serverfreeze (freezewalk)", "Freezes your character on the server while keeping your client moving"}, function()
	local character = getChar()
	local humanoid = character and getHum(character)
	if not character or not humanoid then
		return DebugNotif("Character or humanoid unavailable", 3)
	end

	local root = getRoot(character)
	if not root then
		return DebugNotif("Root part not found", 3)
	end

	if humanoid.RigType == Enum.HumanoidRigType.R6 then
		local clone = root:Clone()
		clone.CFrame = root.CFrame
		clone.Name = root.Name
		clone.Anchored = root.Anchored
		clone.Parent = character
		root:Destroy()
	else
		local lowerTorso = character:FindFirstChild("LowerTorso")
		if not lowerTorso then
			return DebugNotif("LowerTorso missing; unable to server freeze", 3)
		end
		lowerTorso.Anchored = true
		local rootJoint = lowerTorso:FindFirstChild("Root")
		if rootJoint and rootJoint:IsA("Motor6D") then
			rootJoint:Destroy()
		end
	end

	DebugNotif("Server freeze enabled. Reset to stop it.")
end)]]

fcBTNTOGGLE = nil

cmd.add({"freecam","fc","fcam"},{"freecam [speed] (fc,fcam)","Enable free camera"},function(...)
	argg = (...)
	local speed = argg or 5

	if NAlib.isConnected("freecam") then
		NAlib.disconnect("freecam")
		camera.CameraSubject = getChar()
		SpawnCall(function() cmd.run({"unfr"}) end)
	end

	if fcBTNTOGGLE then fcBTNTOGGLE:Destroy() fcBTNTOGGLE = nil end

	function runFREECAM()
		local cf = InstanceNew("CFrameValue")
		local camPart = InstanceNew("Part")
		camPart.Transparency = 1
		camPart.Anchored = true
		camPart.CFrame = camera.CFrame

		SpawnCall(function() cmd.run({"fr",''}) end)

		NAlib.connect("freecam", RunService.RenderStepped:Connect(function(dt)
			local primaryPart = camPart
			camera.CameraSubject = primaryPart

			local moveVec = GetCustomMoveVector()

			local x = moveVec.X * speed
			local y = moveVec.Y * speed
			local z = moveVec.Z * speed

			primaryPart.CFrame = CFrame.new(
				primaryPart.CFrame.p,
				(camera.CFrame * CFrame.new(0, 0, -100)).p
			)

			local moveDir = CFrame.new(x, y, z)
			cf.Value = cf.Value:lerp(moveDir, 0.2)
			primaryPart.CFrame = primaryPart.CFrame:lerp(primaryPart.CFrame * cf.Value, 0.2)
		end))
	end

	if IsOnMobile then
		if fcBTNTOGGLE then fcBTNTOGGLE:Destroy() fcBTNTOGGLE = nil end

		fcBTNTOGGLE = InstanceNew("ScreenGui")
		local btn = InstanceNew("TextButton")
		local speedBox = InstanceNew("TextBox")
		local toggleBtn = InstanceNew("TextButton")
		local corner = InstanceNew("UICorner")
		local corner2 = InstanceNew("UICorner")
		local corner3 = InstanceNew("UICorner")
		local aspect = InstanceNew("UIAspectRatioConstraint")

		NaProtectUI(fcBTNTOGGLE)
		fcBTNTOGGLE.ResetOnSpawn = false

		btn.Parent = fcBTNTOGGLE
		btn.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
		btn.BackgroundTransparency = 0.1
		btn.Position = UDim2.new(0.9, 0, 0.5, 0)
		btn.Size = UDim2.new(0.08, 0, 0.1, 0)
		btn.Font = Enum.Font.GothamBold
		btn.Text = "FC"
		btn.TextColor3 = Color3.fromRGB(255, 255, 255)
		btn.TextSize = 18
		btn.TextWrapped = true
		btn.Active = true
		btn.TextScaled = true

		corner.CornerRadius = UDim.new(0.2, 0)
		corner.Parent = btn

		aspect.Parent = btn
		aspect.AspectRatio = 1.0

		speedBox.Parent = fcBTNTOGGLE
		speedBox.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
		speedBox.BackgroundTransparency = 0.1
		speedBox.AnchorPoint = Vector2.new(0.5, 0)
		speedBox.Position = UDim2.new(0.5, 0, 0, 10)
		speedBox.Size = UDim2.new(0, 75, 0, 35)
		speedBox.Font = Enum.Font.GothamBold
		speedBox.Text = tostring(speed)
		speedBox.TextColor3 = Color3.fromRGB(255, 255, 255)
		speedBox.TextSize = 18
		speedBox.TextWrapped = true
		speedBox.ClearTextOnFocus = false
		speedBox.PlaceholderText = "Speed"
		speedBox.Visible = false

		corner2.CornerRadius = UDim.new(0.2, 0)
		corner2.Parent = speedBox

		toggleBtn.Parent = btn
		toggleBtn.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
		toggleBtn.BackgroundTransparency = 0.1
		toggleBtn.Position = UDim2.new(0.9, 0, -0.1, 0)
		toggleBtn.Size = UDim2.new(0.4, 0, 0.4, 0)
		toggleBtn.Font = Enum.Font.SourceSans
		toggleBtn.Text = "+"
		toggleBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
		toggleBtn.TextSize = 14
		toggleBtn.TextWrapped = true
		toggleBtn.Active = true
		toggleBtn.AutoButtonColor = true

		corner3.CornerRadius = UDim.new(1, 0)
		corner3.Parent = toggleBtn

		MouseButtonFix(toggleBtn, function()
			speedBox.Visible = not speedBox.Visible
			toggleBtn.Text = speedBox.Visible and "-" or "+"
		end)

		coroutine.wrap(function()
			MouseButtonFix(btn, function()
				if not flyVariables.mOn then
					local newSpeed = tonumber(speedBox.Text) or 5
					if newSpeed then
						speed = newSpeed
						speedBox.Text = tostring(speed)
					else
						speed = 5
						speedBox.Text = tostring(speed)
					end
					flyVariables.mOn = true
					btn.Text = "UNFC"
					btn.BackgroundColor3 = Color3.fromRGB(0, 170, 0)
					runFREECAM()
				else
					flyVariables.mOn = false
					btn.Text = "FC"
					btn.BackgroundColor3 = Color3.fromRGB(170, 0, 0)
					if NAlib.isConnected("freecam") then
						NAlib.disconnect("freecam")
					end
					camera.CameraSubject = getChar()
					SpawnCall(function() cmd.run({"unfr"}) end)
				end
			end)
		end)()

		NAgui.draggerV2(btn)
		NAgui.draggerV2(speedBox)
	else
		DebugNotif("Freecam is activated, use WASD to move around", 2)
		runFREECAM()
	end
end, true)

cmd.add({"unfreecam","unfc","unfcam"},{"unfreecam (unfc,unfcam)","Disable free camera"},function()
	NAlib.disconnect("freecam")
	camera.CameraSubject = getChar()
	SpawnCall(function() cmd.run({"unfr"}) end)
	if fcBTNTOGGLE then fcBTNTOGGLE:Destroy() fcBTNTOGGLE = nil end
end)

cmd.add({"nohats","drophats"},{"nohats (drophats)","Drop all of your hats"},function()
	for _,hat in pairs(getChar():GetChildren()) do
		if hat:IsA("Accoutrement") then
			hat:FindFirstChildWhichIsA("Weld",true):Destroy()
		end
	end
end)

cmd.add({"permadeath", "pdeath"}, {"permadeath (pdeath)", "be death permanently"}, function()
	if not replicatesignal then
		return DoNotif("Your executor does not support 'replicatesignal'")
	end

	replicatesignal(LocalPlayer.ConnectDiedSignalBackend)
	Wait(Players.RespawnTime + 0.1)

	local humanoid = getHum()
	if humanoid then
		humanoid:ChangeState(Enum.HumanoidStateType.Dead)
	end
end)

cmd.add({"unpermadeath", "unpdeath"}, {"unpermadeath (unpdeath)", "no perma death"}, function()
	if not replicatesignal then
		return DoNotif("Your executor does not support 'replicatesignal'")
	end

	replicatesignal(LocalPlayer.ConnectDiedSignalBackend)
end)

cmd.add({"instantrespawn", "instantr", "irespawn"}, {"instantrespawn (instantr, irespawn)", "respawn instantly"}, function()
	if not replicatesignal then
		return DoNotif("Your executor does not support 'replicatesignal'")
	end

	replicatesignal(LocalPlayer.ConnectDiedSignalBackend)

	local rootPart = LocalPlayer.Character and getRoot(LocalPlayer.Character)
	local cam = workspace.CurrentCamera

	Wait(Players.RespawnTime - 0.165)

	local humanoid = getHum()
	if humanoid then
		humanoid:ChangeState(Enum.HumanoidStateType.Dead)
	end

	Wait(0.5)

	if rootPart then
		getRoot(LocalPlayer.Character).CFrame = rootPart.CFrame
	end

	workspace.CurrentCamera = cam
end)

function getAllTools()
	local tools={}
	local backpack=localPlayer:FindFirstChildWhichIsA("Backpack")
	if backpack then
		for i,v in pairs(backpack:GetChildren()) do
			if v:IsA("Tool") then
				Insert(tools,v)
			end
		end
	end
	for i,v in pairs(character:GetChildren()) do
		if v:IsA("Tool") then
			Insert(tools,v)
		end
	end
	return tools
end

cmd.add({"circlemath", "cm"}, {"circlemath <mode> <size>", "Gay circle math\nModes: a,b,c,d,e"}, function(mode, size)
	local mode = mode or "a"
	local backpack = getBp()
	NAlib.disconnect("cm")
	if backpack and character.Parent then
		local tools = getAllTools()
		for i, tool in pairs(tools) do
			local cpos, g = (math.pi*2)*(i/#tools), CFrame.new()
			local tcon = {}
			tool.Parent = backpack

			if mode == "a" then
				size = tonumber(size) or 2
				g = (
					CFrame.new(0, 0, size)*
						CFrame.Angles(rad(90), 0, cpos)
				)
			elseif mode == "b" then
				size = tonumber(size) or 2
				g = (
					CFrame.new(i - #tools/2, 0, 0)*
						CFrame.Angles(rad(90), 0, 0)
				)
			elseif mode == "c" then
				size = tonumber(size) or 2
				g = (
					CFrame.new(cpos/3, 0, 0)*
						CFrame.Angles(rad(90), 0, cpos*2)
				)
			elseif mode == "d" then
				size = tonumber(size) or 2
				g = (
					CFrame.new(clamp(tan(cpos), -3, 3), 0, 0)*
						CFrame.Angles(rad(90), 0, cpos)
				)
			elseif mode == "e" then
				size = tonumber(size) or 2
				g = (
					CFrame.new(0, 0, clamp(tan(cpos), -5, 5))*
						CFrame.Angles(rad(90), 0, cpos)
				)
			end
			tool.Grip = g
			tool.Parent = character

			tcon[#tcon] = NAlib.connect("cm", mouse.Button1Down:Connect(function()
				tool:Activate()
			end))
			tcon[#tcon] = NAlib.connect("cm", tool.Changed:Connect(function(p)
				if p == "Grip" and tool.Grip ~= g then
					tool.Grip = g
				end
			end))

			NAlib.connect("cm", tool.AncestryChanged:Connect(function()
				for i = 1, #tcon do
					tcon[i]:Disconnect()
				end
			end))
		end
	end
end,true)

GRIPUITHINGYIDFK = nil

cmd.add({"grippos", "setgrip"}, {"grippos (setgrip)", "Opens a UI to manually input grip offset and rotation."}, function()
	local plr = LocalPlayer
	if GRIPUITHINGYIDFK then return end

	GRIPUITHINGYIDFK = InstanceNew("ScreenGui")
	GRIPUITHINGYIDFK.Name = "GripAdjustUI"
	GRIPUITHINGYIDFK.ResetOnSpawn = false
	NaProtectUI(GRIPUITHINGYIDFK)

	local frame = InstanceNew("Frame")
	frame.Size = UDim2.new(0, 320, 0, 270)
	frame.Position = UDim2.new(0.5, -160, 0.5, -135)
	frame.BackgroundColor3 = Color3.fromRGB(35, 35, 45)
	frame.BorderSizePixel = 0
	frame.Parent = GRIPUITHINGYIDFK

	local corner = InstanceNew("UICorner", frame)
	corner.CornerRadius = UDim.new(0, 6)

	local gradient = InstanceNew("UIGradient", frame)
	gradient.Rotation = 90
	gradient.Color = ColorSequence.new{
		ColorSequenceKeypoint.new(0, Color3.fromRGB(50, 50, 60)),
		ColorSequenceKeypoint.new(1, Color3.fromRGB(25, 25, 30))
	}

	local titleBar = InstanceNew("Frame")
	titleBar.Size = UDim2.new(1, 0, 0, 30)
	titleBar.BackgroundColor3 = Color3.fromRGB(60, 60, 75)
	titleBar.BorderSizePixel = 0
	titleBar.Parent = frame

	local barCorner = InstanceNew("UICorner", titleBar)
	barCorner.CornerRadius = UDim.new(0, 6)

	local title = InstanceNew("TextLabel")
	title.Size = UDim2.new(1, 0, 1, 0)
	title.BackgroundTransparency = 1
	title.Text = "Grip Position Editor"
	title.TextColor3 = Color3.fromRGB(255, 255, 255)
	title.Font = Enum.Font.GothamBold
	title.TextSize = 16
	title.Parent = titleBar

	local preview = InstanceNew("TextButton")
	preview.Size = UDim2.new(0, 260, 0, 28)
	preview.Position = UDim2.new(0, 30, 0, 180)
	preview.Text = "🔍 Preview"
	preview.Font = Enum.Font.GothamBold
	preview.TextSize = 15
	preview.BackgroundColor3 = Color3.fromRGB(75, 75, 95)
	preview.TextColor3 = Color3.new(1, 1, 1)
	preview.Parent = frame
	InstanceNew("UICorner", preview)

	local labels = {"X", "Y", "Z", "RX", "RY", "RZ"}
	local textBoxes = {}

	for i, label in ipairs(labels) do
		local xOffset = ((i - 1) % 3) * 100
		local yOffset = 40 + math.floor((i - 1) / 3) * 50

		local labelUI = InstanceNew("TextLabel")
		labelUI.Size = UDim2.new(0, 40, 0, 25)
		labelUI.Position = UDim2.new(0, 10 + xOffset, 0, yOffset)
		labelUI.BackgroundTransparency = 1
		labelUI.Text = label
		labelUI.TextColor3 = Color3.fromRGB(255, 255, 255)
		labelUI.Font = Enum.Font.Gotham
		labelUI.TextSize = 14
		labelUI.Parent = frame

		local box = InstanceNew("TextBox")
		box.Size = UDim2.new(0, 50, 0, 25)
		box.Position = UDim2.new(0, 50 + xOffset, 0, yOffset)
		box.PlaceholderText = "0"
		box.Text = ""
		box.Font = Enum.Font.Gotham
		box.TextSize = 14
		box.BackgroundColor3 = Color3.fromRGB(45, 45, 55)
		box.TextColor3 = Color3.fromRGB(255, 255, 255)
		box.BorderSizePixel = 0
		box.ClearTextOnFocus = false
		box.Parent = frame

		local boxCorner = InstanceNew("UICorner", box)
		boxCorner.CornerRadius = UDim.new(0, 4)

		textBoxes[label] = box
	end

	local function getVal(name)
		return tonumber(textBoxes[name].Text) or 0
	end

	local function closeUI()
		if GRIPUITHINGYIDFK then
			GRIPUITHINGYIDFK:Destroy()
			GRIPUITHINGYIDFK = nil
		end
	end

	local function applyGrip()
		local char = getChar()
		local tool = char and char:FindFirstChildOfClass("Tool")
		local backpack = getBp() or LocalPlayer:FindFirstChild("Backpack")
		if not tool or not backpack then return end

		local pos = Vector3.new(getVal("X"), getVal("Y"), getVal("Z"))
		local rot = Vector3.new(getVal("RX"), getVal("RY"), getVal("RZ"))
		local gripCFrame = CFrame.new(pos) * CFrame.Angles(math.rad(rot.X), math.rad(rot.Y), math.rad(rot.Z))

		tool.Parent = backpack
		Wait()
		tool.Grip = gripCFrame
		tool.Parent = char

		local fix
		fix = tool.Changed:Connect(function(prop)
			if prop == "Grip" and tool.Grip ~= gripCFrame then
				tool.Grip = gripCFrame
			end
		end)

		tool.AncestryChanged:Connect(function()
			if fix then fix:Disconnect() end
		end)
	end

	local confirm = InstanceNew("TextButton")
	confirm.Size = UDim2.new(0, 130, 0, 32)
	confirm.Position = UDim2.new(0, 20, 0, 215)
	confirm.Text = "Apply"
	confirm.Font = Enum.Font.GothamBold
	confirm.TextSize = 16
	confirm.BackgroundColor3 = Color3.fromRGB(0, 170, 80)
	confirm.TextColor3 = Color3.new(1, 1, 1)
	confirm.Parent = frame
	InstanceNew("UICorner", confirm)

	local cancel = InstanceNew("TextButton")
	cancel.Size = UDim2.new(0, 130, 0, 32)
	cancel.Position = UDim2.new(0, 170, 0, 215)
	cancel.Text = "Cancel"
	cancel.Font = Enum.Font.GothamBold
	cancel.TextSize = 16
	cancel.BackgroundColor3 = Color3.fromRGB(180, 40, 40)
	cancel.TextColor3 = Color3.new(1, 1, 1)
	cancel.Parent = frame
	InstanceNew("UICorner", cancel)

	confirm.MouseButton1Click:Connect(function()
		applyGrip()
		closeUI()
	end)

	preview.MouseButton1Click:Connect(applyGrip)
	cancel.MouseButton1Click:Connect(closeUI)

	NAgui.draggerV2(frame)
end)

cmd.add({"seizure"}, {"seizure", "Gives you a seizure"}, function()
	SpawnCall(function()
		if getgenv().Lzzz == true then return end

		local Anim = InstanceNew("Animation")
		if IsR15() then
			Anim.AnimationId = "rbxassetid://507767968"
		else
			Anim.AnimationId = "rbxassetid://180436148"
		end
		local k = getHum():LoadAnimation(Anim)
		getgenv().ssss = LocalPlayer:GetMouse()
		getgenv().Lzzz = false

		if Lzzz == false then
			getgenv().Lzzz = true
			if IsR15() then
				Anim.AnimationId = "rbxassetid://507767968"
			else
				Anim.AnimationId = "rbxassetid://180436148"
			end
			getgenv().currentnormal = workspace.Gravity
			workspace.Gravity = 196.2
			LocalPlayer.Character:PivotTo(LocalPlayer.Character:GetPivot() * CFrame.Angles(2, 0, 0))
			Wait(0.5)
			if getHum() and getHum().PlatformStand then getHum().PlatformStand = true end
			LocalPlayer.Character.Animate.Disabled = true

			k:Play()
			k:AdjustSpeed(10)

			LocalPlayer.Character.Animate.Disabled = true
		else
			getgenv().Lzzz = false
			if IsR15() then
				Anim.AnimationId = "rbxassetid://507767968"
			else
				Anim.AnimationId = "rbxassetid://180436148"
			end
			workspace.Gravity = currentnormal
			if getHum() and getHum().PlatformStand then getHum().PlatformStand = false end
			getHum().Jump = true
			k:Stop()

			LocalPlayer.Character.Animate.Disabled = false
			RunService.Heartbeat:Wait()
			for i = 1,10 do
				getRoot(LocalPlayer.Character).AssemblyLinearVelocity = Vector3.new(0, 0, 0)
				Wait(0.1)
			end
		end

		RunService.RenderStepped:Connect(function()
			if Lzzz == true then
				getRoot(LocalPlayer.Character).CFrame = getRoot(LocalPlayer.Character).CFrame * CFrame.new(
					.075 * math.sin(45 * tick()),
					.075 * math.sin(45 * tick()),
					.075 * math.sin(45 * tick())
				)
			end
		end)
	end)
end)

cmd.add({"unseizure"}, {"unseizure", "Stops you from having a seizure not in real life noob"}, function()
	SpawnCall(function()
		if getgenv().Lzzz ~= true then return end

		local Anim = InstanceNew("Animation")
		if IsR15() then
			Anim.AnimationId = "rbxassetid://507767968"
		else
			Anim.AnimationId = "rbxassetid://180436148"
		end

		local k = getHum():LoadAnimation(Anim)

		getgenv().Lzzz = false
		workspace.Gravity = currentnormal
		if getHum() and getHum().PlatformStand then getHum().PlatformStand = false end
		getHum().Jump = true
		k:Stop()

		LocalPlayer.Character.Animate.Disabled = false

		RunService.Heartbeat:Wait()
		for i = 1, 10 do
			getRoot(LocalPlayer.Character).AssemblyLinearVelocity = Vector3.new(0, 0, 0)
			Wait(0.1)
		end
	end)
end)

FakeLagCfg = { interval = 0.05, jitter = 0.02, duration = nil }

cmd.add({"fakelag", "flag"}, {"fakelag (flag)", "fake lag"}, function(interval, jitter, duration)
	if type(interval) == "number" then FakeLagCfg.interval = math.max(0, interval) end
	if type(jitter) == "number" then FakeLagCfg.jitter = math.max(0, jitter) end
	if type(duration) == "number" then FakeLagCfg.duration = (duration > 0) and duration or nil end
	if FakeLag then return end
	FakeLag = true
	NAlib.disconnect("FakeLag")

	local function nextInterval()
		local b = tonumber(FakeLagCfg.interval) or 0.05
		local j = tonumber(FakeLagCfg.jitter) or 0
		if j <= 0 then return math.max(0, b) end
		return math.max(0, b + Random.new():NextNumber(-j, j))
	end

	local startTs = time()
	local state = false
	local nextFlipAt = time()

	NAlib.connect("FakeLag", RunService.Heartbeat:Connect(function()
		if not FakeLag then
			NAlib.disconnect("FakeLag")
			local r = getRoot(getChar())
			if r then NAlib.setProperty(r, "Anchored", false) end
			return
		end
		if FakeLagCfg.duration and (time() - startTs) > FakeLagCfg.duration then
			FakeLag = false
			NAlib.disconnect("FakeLag")
			local r = getRoot(getChar())
			if r then NAlib.setProperty(r, "Anchored", false) end
			return
		end
		local now = time()
		if now >= nextFlipAt then
			local r = getRoot(getChar())
			if r and r.Parent then
				state = not state
				NAlib.setProperty(r, "Anchored", state)
				nextFlipAt = now + nextInterval()
			else
				FakeLag = false
				NAlib.disconnect("FakeLag")
			end
		end
	end))
end)

cmd.add({"unfakelag", "unflag"}, {"unfakelag (unflag)", "stops the fake lag command"}, function()
	if not FakeLag and not NAlib.isConnected("FakeLag") then return end
	FakeLag = false
	NAlib.disconnect("FakeLag")
	local r = getRoot(getChar())
	if r then NAlib.setProperty(r, "Anchored", false) end
end)

local r=math.rad
local center=CFrame.new(1.5,0.5,-1.5)

cmd.add({"hide", "unshow"}, {"hide <player> (unshow)", "places the selected player to lighting"}, function(...)
	Wait()
	DebugNotif("Hid the player")
	local Username = (...)
	local target = getPlr(Username)
	for _, plr in next, target do
		if plr and plr.Character then
			local A_1 = "/mute "..plr.Name
			local A_2 = "All"
			NAlib.LocalPlayerChat(A_1, A_2)
			plr.Character.Parent = Lighting
		end
	end
end, true)

cmd.add({"unhide", "show"}, {"show <player> (unhide)", "places the selected player back to workspace"}, function(...)
	Wait()
	DebugNotif("Unhid the player")
	local Username = (...)
	local target = getPlr(Username)
	for _, plr in next, target do
		if plr and plr.Character then
			local A_1 = "/unmute "..plr.Name
			local A_2 = "All"
			NAlib.LocalPlayerChat(A_1, A_2)
			plr.Character.Parent = workspace
		end
	end
end, true)


if IsOnPC then
	cmd.add({"aimbot","aimbotui","aimbotgui"},{"aimbot (aimbotui,aimbotgui)","aimbot and yeah"},function()
		loadstring(game:HttpGet("https://raw.githubusercontent.com/ltseverydayyou/uuuuuuu/refs/heads/main/NewAimbot.lua"))()
		--loadstring(game:HttpGet("https://raw.githubusercontent.com/ltseverydayyou/uuuuuuu/refs/heads/main/Aimbot.lua",true))()
	end)
end

NAmanage.grabAllTools=function()
	local char = getChar()
	local hum = char and getHum()
	if not hum then return 0 end
	local count = 0
	for _, tool in ipairs(workspace:GetDescendants()) do
		if tool:IsA("Tool") then
			if NACaller(function() hum:EquipTool(tool) end) then
				count += 1
			end
		end
	end
	return count
end

cmd.add({"grabtools"},{"grabtools","Grabs dropped tools"},function()
	local count = NAmanage.grabAllTools()
	if count > 0 then
		DebugNotif(("Grabbed %d tools"):format(count), 2)
	else
		DebugNotif("No tools to grab", 2)
	end
end)

cmd.add({"loopgrabtools"},{"loopgrabtools","Loop grabs dropped tools"},function()
	if loopgrab then
		DebugNotif("Loop grab already running", 2)
		return
	end
	loopgrab = true
	DebugNotif("Started loop grabbing tools", 2)
	SpawnCall(function()
		while loopgrab do
			NAmanage.grabAllTools()
			Wait(1)
		end
		DebugNotif("Stopped loop grabbing tools", 2)
	end)
end)

cmd.add({"unloopgrabtools"},{"unloopgrabtools","Stops the loop grab command"},function()
	if not loopgrab then
		DebugNotif("Loop grab is not running", 2)
		return
	end
	loopgrab = false
end)

cmd.add({"dance"},{"dance","Does a random dance"},function()
	dances={"248263260","27789359","45834924","28488254","33796059","30196114","52155728"}
	if getChar():FindFirstChildOfClass('Humanoid').RigType==Enum.HumanoidRigType.R15 then
		dances={"4555808220","4555782893","3333432454","4049037604"}
	end
	if theanim then
		theanim:Stop()
		theanim:Destroy()
		local animation=InstanceNew("Animation")
		animation.AnimationId="rbxassetid://"..dances[math.random(1,#dances)]
		theanim=getChar():FindFirstChildOfClass('Humanoid'):LoadAnimation(animation)
		theanim:Play()
	else
		local animation=InstanceNew("Animation")
		animation.AnimationId="rbxassetid://"..dances[math.random(1,#dances)]
		theanim=getChar():FindFirstChildOfClass('Humanoid'):LoadAnimation(animation)
		theanim:Play()
	end
end)

cmd.add({"undance"},{"undance","Stops the dance command"},function()
	theanim:Stop()
	theanim:Destroy()
end)

-- still worked on (i think)

--[[cmd.add({"antichatlogs","antichatlogger"},{"antichatlogs (antichatlogger)","Prevents you from getting banning when typing unspeakable messages (requires the new chat service)"},function()
	local CoreGui=SafeGetService("CoreGui")
	local LocalPlayer=Players.LocalPlayer
	local glyphs={
		b={"β","в","բ"},
		c={"ծ"},
		d={"δ","д","դ"},
		e={"ε","է"},
		f={"φ","ф","ֆ"},
		h={"η","н"},
		i={"ի"},
		j={"ջ"},
		k={"κ","к","կ"},
		l={"λ","л","լ"},
		m={"μ","м","մ"},
		n={"η","н","ն"},
		p={"պ"},
		r={"ր"},
		t={"τ","т","տ"},
		u={"մ"},
		v={"в"},
		w={"ω","ш","վ"},
		x={"χ","խ"},
		y={"յ"},
		z={"ζ","з"},
		["1"]={"१"},
		["2"]={"२","٢"},
		["3"]={"३","٣"},
		["4"]={"४","٤"},
		["5"]={"५"},
		["6"]={"६","٦"},
		["7"]={"७"},
		["8"]={"८","٨"},
		["9"]={"९","٩"}
	}
	local function obfuscateMessage(msg)
		local out={}
		for _,code in utf8.codes(msg) do
			local ch=utf8.char(code)
			local lower=Lower(ch)
			if glyphs[lower] then
				local g=glyphs[lower][math.random(#glyphs[lower])]
				if ch:match("%u") then g=g:upper() end
				ch=g
			end
			Insert(out,ch)
		end
		return Concat(out)
	end
	local CachedChannels={}
	NAlib.BypassChatMessage=function(message,recipient)
		Spawn(function()
			local text=obfuscateMessage(message)
			local channel
			if recipient and recipient~="All" then
				channel=CachedChannels[recipient]
				if not channel or not channel:IsDescendantOf(TextChatService) or not channel:FindFirstChild(recipient) then
					channel=nil
					for _,c in ipairs(TextChatService.TextChannels:GetChildren()) do
						if Find(c.Name,"^RBXWhisper:") and c:FindFirstChild(recipient) then
							channel=c
							CachedChannels[recipient]=c
							break
						end
					end
				end
			end
			if not channel then channel=TextChatService.TextChannels:FindFirstChild("RBXGeneral") or TextChatService.TextChannels:FindFirstChild("General") end
			if channel then NACaller(function() channel:SendAsync(text) end) end
		end)
	end
	local function resolveRecipient(chip)
		if chip and chip:IsA("TextButton") then
			local txt=chip.Text or ""
			local d=Match(txt,"^%[To%s+(.+)%]$")
			if d and d~="" then
				d=Lower(d)
				for _,plr in ipairs(Players:GetPlayers()) do
					if Lower(plr.DisplayName)==d then return plr.Name end
				end
			end
		end
		return "All"
	end
	Spawn(function()
		repeat Wait() until CoreGui:FindFirstChild("ExperienceChat")
		local ec=CoreGui:WaitForChild("ExperienceChat")
		local al=ec:WaitForChild("appLayout")
		local cb=al:WaitForChild("chatInputBar")
		local bg=cb:WaitForChild("Background")
		local ct=bg:WaitForChild("Container")
		local tc=ct:WaitForChild("TextContainer")
		local bc=tc:WaitForChild("TextBoxContainer")
		local box=bc:WaitForChild("TextBox")
		local btn=ct:WaitForChild("SendButton")
		local chip=tc:FindFirstChild("TargetChannelChip")
		local function hook()
			local m=box.Text
			if m~="" then
				box.Text=""
				NAlib.BypassChatMessage(m,resolveRecipient(chip))
			end
		end
		box.FocusLost:Connect(function(e) if e then hook() end end)
		btn.MouseButton1Click:Connect(hook)
	end)
	DoNotif("antichatlogs activated (W.I.P)")
end)]]

cmd.add({"animspoofer","animationspoofer","spoofanim","animspoof"},{"animspoofer (animationspoofer, spoofanim, animspoof)","Loads up an animation spoofer,spoofs animations that use rbxassetid"},function()
	loadstring(game:HttpGet("https://raw.githubusercontent.com/ltseverydayyou/Nameless-Admin/main/Animation%20Spoofer"))()
end)

cmd.add({"badgeviewer", "badgeview", "bviewer","badgev","bv"},{"badgeviewer (badgeview, bviewer, badgev, bv)","loads up a badge viewer UI that views all badges in the game you're in"},function()
	local BadgeService = SafeGetService("BadgeService")
	local Player = Players.LocalPlayer

	local COLORS = {
		PANEL = Color3.fromRGB(28, 28, 32),
		TOP = Color3.fromRGB(24, 24, 26),
		TEXT = Color3.fromRGB(240, 240, 240),
		MUTED = Color3.fromRGB(180, 180, 185),
		STROKE = Color3.fromRGB(60, 60, 65),
		OWNED = Color3.fromRGB(65, 200, 120),
	}

	local OWNERSHIP_CACHE = getgenv().__BadgeOwnershipCache or {}
	getgenv().__BadgeOwnershipCache = OWNERSHIP_CACHE
	local CACHE_TTL_SECS = 600

	local function cacheGet(userId, badgeId)
		local u = OWNERSHIP_CACHE[userId]
		if not u then return nil end
		local e = u[badgeId]
		if not e then return nil end
		if os.time() - e.t > CACHE_TTL_SECS then return nil end
		return e.v
	end

	local function cachePut(userId, badgeId, value)
		OWNERSHIP_CACHE[userId] = OWNERSHIP_CACHE[userId] or {}
		OWNERSHIP_CACHE[userId][badgeId] = { v = value, t = os.time() }
	end

	local function hasBadgeWithRetry(userId, badgeId)
		local cached = cacheGet(userId, badgeId)
		if cached ~= nil then
			return true, cached
		end
		local tries, delay = 0, 0.5
		while tries < 5 do
			tries += 1
			local ok, has = pcall(BadgeService.UserHasBadgeAsync, BadgeService, userId, badgeId)
			if ok then
				has = has == true
				cachePut(userId, badgeId, has)
				return true, has
			end
			Wait(delay)
			delay = delay * 1.6
		end
		return false, nil
	end

	local function getBadges()
		local all, cursor = {}, ""
		repeat
			local url = ("https://badges.roproxy.com/v1/universes/%d/badges?limit=100&sortOrder=Asc%s"):format(
				GameId,
				cursor ~= "" and "&cursor="..HttpService:UrlEncode(cursor) or ""
			)
			local res = opt.NAREQUEST({Url = url, Method = "GET"})
			if not res or res.StatusCode ~= 200 then break end
			local body = HttpService:JSONDecode(res.Body)
			for _, b in ipairs(body.data or {}) do
				Insert(all, {
					id = b.id,
					name = b.name,
					desc = b.displayDescription or b.description or "",
					icon = b.iconImageId,
					rarity = (b.statistics and b.statistics.winRatePercentage) or 0,
					awarded = (b.statistics and b.statistics.awardedCount) or 0,
					pastDay = (b.statistics and b.statistics.pastDayAwardedCount) or 0,
					universe = (b.awardingUniverse and b.awardingUniverse.name) or "Unknown",
				})
			end
			cursor = body.nextPageCursor or ""
		until cursor == ""
		return all
	end

	local function pill(parent, text, color)
		local p = InstanceNew("TextLabel", parent)
		p.BackgroundColor3 = color
		p.BackgroundTransparency = 0.15
		p.TextColor3 = Color3.new(1,1,1)
		p.Font = Enum.Font.GothamSemibold
		p.Text = text
		p.Size = UDim2.new(0, 0, 0, 0)
		p.AutomaticSize = Enum.AutomaticSize.XY
		p.AnchorPoint = Vector2.new(1,0)
		p.Position = UDim2.new(1, 0, 0, 0)
		p.TextScaled = true
		local pc = InstanceNew("UICorner", p); pc.CornerRadius = UDim.new(0, 8)
		local pad = InstanceNew("UIPadding", p)
		pad.PaddingLeft = UDim.new(0, 8)
		pad.PaddingRight = UDim.new(0, 8)
		pad.PaddingTop = UDim.new(0, 6)
		pad.PaddingBottom = UDim.new(0, 6)
		local ts = InstanceNew("UITextSizeConstraint", p); ts.MinTextSize = 10; ts.MaxTextSize = 14
		p.Visible = false
		return p
	end

	local function applyOwnedStyle(card, stroke, ownedTag)
		stroke.Color = COLORS.OWNED
		stroke.Transparency = 0
		stroke.Thickness = 2
		card.BackgroundTransparency = 0.1
		card.BackgroundColor3 = Color3.fromRGB(35, 44, 38)
		ownedTag.Visible = true
	end

	local function tweenTransparency(container, target, tinfo)
		for _, d in ipairs(container:GetDescendants()) do
			if d:IsA("TextLabel") or d:IsA("TextButton") or d:IsA("TextBox") then
				TweenService:Create(d, tinfo, {TextTransparency = target}):Play()
			elseif d:IsA("ImageLabel") or d:IsA("ImageButton") then
				TweenService:Create(d, tinfo, {ImageTransparency = target}):Play()
			elseif d:IsA("Frame") then
				TweenService:Create(d, tinfo, {BackgroundTransparency = math.clamp(target,0,1)}):Play()
			elseif d:IsA("UIStroke") then
				TweenService:Create(d, tinfo, {Transparency = target}):Play()
			end
		end
	end

	local function createBadgeUI(data)
		local sgui = InstanceNew("ScreenGui")
		NaProtectUI(sgui)
		sgui.Name = "BadgeViewer"

		local headerH = 60
		local expandedMainSize = UDim2.new(0.6,0,0.66,0)

		local main = InstanceNew("Frame", sgui)
		main.Size = expandedMainSize
		main.Position = UDim2.new(0.2,0,0.17,0)
		main.BackgroundColor3 = COLORS.PANEL
		main.BackgroundTransparency = 0.08
		main.BorderSizePixel = 0
		main.ClipsDescendants = true
		main.Active = true
		main.Name = "Main"
		local uicorner = InstanceNew("UICorner", main); uicorner.CornerRadius = UDim.new(0, 14)
		local stroke = InstanceNew("UIStroke", main); stroke.Color = COLORS.STROKE; stroke.Thickness = 1; stroke.Transparency = 0.2

		local header = InstanceNew("Frame", main)
		header.Size = UDim2.new(1, 0, 0, headerH)
		header.BackgroundColor3 = COLORS.TOP
		header.BackgroundTransparency = 0.12
		local headerC = InstanceNew("UICorner", header); headerC.CornerRadius = UDim.new(0, 14)

		local reservedLeft = 150
		local reservedRight = 88

		local title = InstanceNew("TextLabel", header)
		title.Position = UDim2.new(0, 10, 0, 0)
		title.Size = UDim2.new(0, reservedLeft-20, 1, 0)
		title.Text = "Badge Viewer"
		title.Font = Enum.Font.GothamBold
		title.TextColor3 = COLORS.TEXT
		title.BackgroundTransparency = 1
		title.TextXAlignment = Enum.TextXAlignment.Left
		title.TextScaled = true
		local tsTitle = InstanceNew("UITextSizeConstraint", title); tsTitle.MinTextSize = 12; tsTitle.MaxTextSize = 20

		local topbar = InstanceNew("ScrollingFrame", header)
		topbar.Position = UDim2.new(0, 6+reservedLeft, 0, 6)
		topbar.Size = UDim2.new(1, -(reservedLeft + reservedRight + 12), 1, -12)
		topbar.BackgroundTransparency = 1
		topbar.ScrollBarThickness = 4
		topbar.ScrollingDirection = Enum.ScrollingDirection.X
		topbar.AutomaticCanvasSize = Enum.AutomaticSize.X
		topbar.CanvasSize = UDim2.new(0,0,0,0)

		local row = InstanceNew("Frame", topbar)
		row.BackgroundTransparency = 1
		row.AutomaticSize = Enum.AutomaticSize.XY
		row.Size = UDim2.new(0,0,1,0)
		local rowLayout = InstanceNew("UIListLayout", row)
		rowLayout.FillDirection = Enum.FillDirection.Horizontal
		rowLayout.VerticalAlignment = Enum.VerticalAlignment.Center
		rowLayout.Padding = UDim.new(0, 8)

		local function mkBtn(parent, text, w)
			local b = InstanceNew("TextButton", parent)
			b.AutoButtonColor = true
			b.Text = text
			b.Font = Enum.Font.GothamSemibold
			b.TextColor3 = COLORS.TEXT
			b.Size = UDim2.new(0, w, 1, -4)
			b.BackgroundColor3 = Color3.fromRGB(34,34,38)
			b.BackgroundTransparency = 0.2
			b.TextScaled = true
			local c = InstanceNew("UICorner", b); c.CornerRadius = UDim.new(0, 8)
			local ts = InstanceNew("UITextSizeConstraint", b); ts.MinTextSize = 10; ts.MaxTextSize = 18
			return b
		end

		local search = InstanceNew("TextBox", row)
		search.Size = UDim2.new(0, 240, 1, -4)
		search.PlaceholderText = "Search badges..."
		search.ClearTextOnFocus = false
		search.Text = ""
		search.BackgroundColor3 = Color3.fromRGB(34,34,38)
		search.BackgroundTransparency = 0.2
		search.TextColor3 = COLORS.TEXT
		search.PlaceholderColor3 = COLORS.MUTED
		search.TextXAlignment = Enum.TextXAlignment.Left
		search.Font = Enum.Font.Gotham
		search.TextScaled = true
		local sc = InstanceNew("UICorner", search); sc.CornerRadius = UDim.new(0, 8)
		local sp = InstanceNew("UIPadding", search)
		sp.PaddingLeft = UDim.new(0, 10)
		sp.PaddingRight = UDim.new(0, 6)
		local tsSearch = InstanceNew("UITextSizeConstraint", search); tsSearch.MinTextSize = 10; tsSearch.MaxTextSize = 18

		local ownedOnlyBtn = mkBtn(row, "Owned: OFF", 110)
		local unownedOnlyBtn = mkBtn(row, "Unowned: OFF", 130)
		local layoutToggle = mkBtn(row, "List", 80)
		local refreshBtn = mkBtn(row, "Refresh", 100)

		local fixedBar = InstanceNew("Frame", header)
		fixedBar.AnchorPoint = Vector2.new(1,0)
		fixedBar.Position = UDim2.new(1, -6, 0, 6)
		fixedBar.Size = UDim2.new(0, reservedRight, 1, -12)
		fixedBar.BackgroundTransparency = 1
		fixedBar.ZIndex = 5
		local fixedLayout = InstanceNew("UIListLayout", fixedBar)
		fixedLayout.FillDirection = Enum.FillDirection.Horizontal
		fixedLayout.VerticalAlignment = Enum.VerticalAlignment.Center
		fixedLayout.Padding = UDim.new(0, 8)

		local minBtn = InstanceNew("TextButton", fixedBar)
		minBtn.Size = UDim2.new(0, 36, 1, 0)
		minBtn.Text = "-"
		minBtn.Font = Enum.Font.Gotham
		minBtn.BackgroundTransparency = 1
		minBtn.TextColor3 = COLORS.MUTED
		minBtn.TextScaled = true
		minBtn.ZIndex = 6
		local tsMin = InstanceNew("UITextSizeConstraint", minBtn); tsMin.MinTextSize = 12; tsMin.MaxTextSize = 24

		local closeBtn = InstanceNew("TextButton", fixedBar)
		closeBtn.Size = UDim2.new(0, 36, 1, 0)
		closeBtn.Text = "X"
		closeBtn.Font = Enum.Font.Gotham
		closeBtn.BackgroundTransparency = 1
		closeBtn.TextColor3 = Color3.fromRGB(255, 90, 90)
		closeBtn.TextScaled = true
		closeBtn.ZIndex = 6
		local tsClose = InstanceNew("UITextSizeConstraint", closeBtn); tsClose.MinTextSize = 12; tsClose.MaxTextSize = 22

		local content = InstanceNew("Frame", main)
		content.Name = "Content"
		content.Size = UDim2.new(1, 0, 1, -headerH)
		content.Position = UDim2.new(0, 0, 0, headerH)
		content.BackgroundTransparency = 1
		content.ClipsDescendants = true

		local scroll = InstanceNew("ScrollingFrame", content)
		scroll.Size = UDim2.new(1, 0, 1, 0)
		scroll.BackgroundTransparency = 1
		scroll.ScrollBarThickness = 6
		scroll.AutomaticCanvasSize = Enum.AutomaticSize.Y
		scroll.CanvasSize = UDim2.new(0,0,0,0)

		local pad = InstanceNew("UIPadding", scroll)
		pad.PaddingLeft = UDim.new(0, 10)
		pad.PaddingRight = UDim.new(0, 10)
		pad.PaddingTop = UDim.new(0, 10)
		pad.PaddingBottom = UDim.new(0, 10)

		local listLayout = InstanceNew("UIListLayout")
		listLayout.Padding = UDim.new(0, 10)
		listLayout.SortOrder = Enum.SortOrder.LayoutOrder

		local gridLayout = InstanceNew("UIGridLayout")
		gridLayout.FillDirection = Enum.FillDirection.Horizontal
		gridLayout.HorizontalAlignment = Enum.HorizontalAlignment.Left
		gridLayout.VerticalAlignment = Enum.VerticalAlignment.Top
		gridLayout.CellPadding = UDim2.new(0.01, 0, 0.01, 0)
		gridLayout.CellSize = UDim2.new(0.32, 0, 0, 190)
		gridLayout.FillDirectionMaxCells = 0

		local loadingOverlay = InstanceNew("Frame", content)
		loadingOverlay.Size = UDim2.new(1,0,1,0)
		loadingOverlay.BackgroundColor3 = Color3.new(0,0,0)
		loadingOverlay.BackgroundTransparency = 0.8
		loadingOverlay.Visible = true
		loadingOverlay.ZIndex = 50
		local loadingText = InstanceNew("TextLabel", loadingOverlay)
		loadingText.AnchorPoint = Vector2.new(0.5,0.5)
		loadingText.Position = UDim2.new(0.5,0,0.5,0)
		loadingText.Size = UDim2.new(0.5,0,0,40)
		loadingText.BackgroundTransparency = 1
		loadingText.Text = "Loading..."
		loadingText.Font = Enum.Font.GothamSemibold
		loadingText.TextColor3 = COLORS.TEXT
		loadingText.TextScaled = true
		loadingText.ZIndex = 51
		local ltSz = InstanceNew("UITextSizeConstraint", loadingText); ltSz.MinTextSize = 12; ltSz.MaxTextSize = 28

		local function updateGridColumns()
			local w = scroll.AbsoluteSize.X
			local padScale, sidePadScale, minCellPx = 0.01, 0.01, 260
			local cols = math.max(1, math.floor((w*(1 - sidePadScale*2) + (w*padScale)) / (minCellPx + (w*padScale))))
			local widthScale = (1 - sidePadScale*2 - padScale*(cols-1)) / cols
			gridLayout.CellSize = UDim2.new(math.clamp(widthScale, 0.18, 1), 0, 0, 190)
		end
		scroll:GetPropertyChangedSignal("AbsoluteSize"):Connect(updateGridColumns)
		Defer(updateGridColumns)

		local ownedOnly = false
		local unownedOnly = false
		local useGrid = false
		local ownedMap = {}
		local listCards, gridCards = {}, {}
		local idToCards = {}
		local badgesData = data
		local gridBuilt = false

		local function makeListCard(b)
			local f = InstanceNew("Frame")
			f.Size = UDim2.new(1, 0, 0, 118)
			f.BackgroundColor3 = Color3.fromRGB(36, 36, 40)
			f.BackgroundTransparency = 0.12
			local fc = InstanceNew("UICorner", f); fc.CornerRadius = UDim.new(0, 10)
			local fs = InstanceNew("UIStroke", f); fs.Color = COLORS.STROKE; fs.Thickness = 1; fs.Transparency = 0.2

			local img = InstanceNew("ImageLabel", f)
			img.Size = UDim2.new(0, 96, 0, 96)
			img.Position = UDim2.new(0, 12, 0, 11)
			img.BackgroundTransparency = 1
			img.Image = "rbxthumb://type=Asset&id="..tostring(b.icon or 0).."&w=420&h=420"

			local title = InstanceNew("TextLabel", f)
			title.Position = UDim2.new(0, 120, 0, 10)
			title.Size = UDim2.new(1, -130, 0, 24)
			title.Text = b.name or ("Badge "..tostring(b.id))
			title.TextColor3 = COLORS.TEXT
			title.BackgroundTransparency = 1
			title.Font = Enum.Font.GothamSemibold
			title.TextXAlignment = Enum.TextXAlignment.Left
			title.TextTruncate = Enum.TextTruncate.AtEnd
			title.TextScaled = true
			local tsLT = InstanceNew("UITextSizeConstraint", title); tsLT.MinTextSize = 10; tsLT.MaxTextSize = 18

			local desc = InstanceNew("TextLabel", f)
			desc.Position = UDim2.new(0, 120, 0, 36)
			desc.Size = UDim2.new(1, -130, 0, 32)
			desc.Text = b.desc
			desc.TextWrapped = true
			desc.TextColor3 = COLORS.MUTED
			desc.BackgroundTransparency = 1
			desc.Font = Enum.Font.Gotham
			desc.TextXAlignment = Enum.TextXAlignment.Left
			desc.TextYAlignment = Enum.TextYAlignment.Top
			desc.TextScaled = true
			local tsLD = InstanceNew("UITextSizeConstraint", desc); tsLD.MinTextSize = 9; tsLD.MaxTextSize = 14

			local stat = InstanceNew("TextLabel", f)
			stat.Position = UDim2.new(0, 120, 0, 72)
			stat.Size = UDim2.new(1, -130, 0, 28)
			stat.Text = Format("🎯 %.2f%%   📈 %d   ⏱️ %d   🧭 %s", b.rarity, b.awarded, b.pastDay, b.universe)
			stat.TextColor3 = Color3.fromRGB(160, 160, 165)
			stat.BackgroundTransparency = 1
			stat.Font = Enum.Font.Gotham
			stat.TextXAlignment = Enum.TextXAlignment.Left
			stat.TextScaled = true
			local tsLS = InstanceNew("UITextSizeConstraint", stat); tsLS.MinTextSize = 9; tsLS.MaxTextSize = 13

			local ownedTag = pill(f, "OWNED", COLORS.OWNED)

			f.Parent = scroll
			local card = {frame=f, data=b, stroke=fs, ownedTag=ownedTag}
			idToCards[b.id] = idToCards[b.id] or {}
			idToCards[b.id].list = card
			Insert(listCards, card)
			return card
		end

		local function makeGridCard(b)
			local f = InstanceNew("Frame")
			f.Size = UDim2.new(1, 0, 0, 190)
			f.BackgroundColor3 = Color3.fromRGB(36, 36, 40)
			f.BackgroundTransparency = 0.12
			local fc = InstanceNew("UICorner", f); fc.CornerRadius = UDim.new(0, 10)
			local fs = InstanceNew("UIStroke", f); fs.Color = COLORS.STROKE; fs.Thickness = 1; fs.Transparency = 0.2

			local img = InstanceNew("ImageLabel", f)
			img.AnchorPoint = Vector2.new(0.5,0)
			img.Position = UDim2.new(0.5, 0, 0, 10)
			img.Size = UDim2.new(0, 72, 0, 72)
			img.BackgroundTransparency = 1
			img.Image = "rbxthumb://type=Asset&id="..tostring(b.icon or 0).."&w=420&h=420"

			local title = InstanceNew("TextLabel", f)
			title.AnchorPoint = Vector2.new(0.5,0)
			title.Position = UDim2.new(0.5, 0, 0, 88)
			title.Size = UDim2.new(0.92, 0, 0, 20)
			title.Text = b.name or ("Badge "..tostring(b.id))
			title.TextColor3 = COLORS.TEXT
			title.BackgroundTransparency = 1
			title.Font = Enum.Font.GothamSemibold
			title.TextXAlignment = Enum.TextXAlignment.Center
			title.TextTruncate = Enum.TextTruncate.AtEnd
			title.TextScaled = true
			local tsGT = InstanceNew("UITextSizeConstraint", title); tsGT.MinTextSize = 10; tsGT.MaxTextSize = 16

			local desc = InstanceNew("TextLabel", f)
			desc.AnchorPoint = Vector2.new(0.5,0)
			desc.Position = UDim2.new(0.5, 0, 0, 110)
			desc.Size = UDim2.new(0.92, 0, 0, 28)
			desc.Text = b.desc
			desc.TextWrapped = true
			desc.TextColor3 = COLORS.MUTED
			desc.BackgroundTransparency = 1
			desc.Font = Enum.Font.Gotham
			desc.TextXAlignment = Enum.TextXAlignment.Center
			desc.TextYAlignment = Enum.TextYAlignment.Top
			desc.TextScaled = true
			local tsGD = InstanceNew("UITextSizeConstraint", desc); tsGD.MinTextSize = 9; tsGD.MaxTextSize = 12

			local stat = InstanceNew("TextLabel", f)
			stat.AnchorPoint = Vector2.new(0.5,0)
			stat.Position = UDim2.new(0.5, 0, 0, 140)
			stat.Size = UDim2.new(0.92, 0, 0, 24)
			stat.Text = Format("🎯 %.1f%%  📈 %d  ⏱️ %d  🧭 %s", b.rarity, b.awarded, b.pastDay, b.universe)
			stat.TextColor3 = Color3.fromRGB(160, 160, 165)
			stat.BackgroundTransparency = 1
			stat.Font = Enum.Font.Gotham
			stat.TextXAlignment = Enum.TextXAlignment.Center
			stat.TextScaled = true
			local tsGS = InstanceNew("UITextSizeConstraint", stat); tsGS.MinTextSize = 9; tsGS.MaxTextSize = 12

			local ownedTag = pill(f, "OWNED", COLORS.OWNED)

			local card = {frame=f, data=b, stroke=fs, ownedTag=ownedTag}
			idToCards[b.id] = idToCards[b.id] or {}
			idToCards[b.id].grid = card
			Insert(gridCards, card)
			return card
		end

		for _, b in ipairs(badgesData) do
			makeListCard(b)
		end

		local function buildGridIfNeeded()
			if gridBuilt then return end
			for _, b in ipairs(badgesData) do
				local c = makeGridCard(b)
				c.frame.Parent = nil
			end
			gridBuilt = true
		end

		local function textContains(h, n)
			if n == "" then return true end
			h = Lower(h or ""); n = Lower(n or "")
			return Find(h, n, 1, true) ~= nil
		end

		local function applyFilters()
			local q = search.Text
			for _, card in ipairs(listCards) do
				if card.frame.Parent == scroll then
					local id = card.data.id
					local show = textContains(card.data.name.." "..card.data.desc, q)
					if ownedOnly then
						show = show and (ownedMap[id] == true)
					elseif unownedOnly then
						show = show and (ownedMap[id] == false)
					end
					card.frame.Visible = show
				end
			end
			for _, card in ipairs(gridCards) do
				if card.frame.Parent == scroll then
					local id = card.data.id
					local show = textContains(card.data.name.." "..card.data.desc, q)
					if ownedOnly then
						show = show and (ownedMap[id] == true)
					elseif unownedOnly then
						show = show and (ownedMap[id] == false)
					end
					card.frame.Visible = show
				end
			end
		end

		local function applyOwnedVisualsFor(id)
			local pair = idToCards[id]
			if not pair then return end
			if pair.list then applyOwnedStyle(pair.list.frame, pair.list.stroke, pair.list.ownedTag) end
			if pair.grid then applyOwnedStyle(pair.grid.frame, pair.grid.stroke, pair.grid.ownedTag) end
		end

		local function refreshOwnedStylesForAll()
			for id, v in pairs(ownedMap) do
				if v == true then applyOwnedVisualsFor(id) end
			end
		end

		local function attachLayout()
			listLayout.Parent = nil
			gridLayout.Parent = nil
			for _, c in ipairs(listCards) do c.frame.Parent = nil end
			for _, c in ipairs(gridCards) do c.frame.Parent = nil end
			if useGrid then
				buildGridIfNeeded()
				gridLayout.Parent = scroll
				pad.PaddingLeft = UDim.new(0.01, 0)
				pad.PaddingRight = UDim.new(0.01, 0)
				pad.PaddingTop = UDim.new(0.01, 0)
				pad.PaddingBottom = UDim.new(0.01, 0)
				for _, c in ipairs(gridCards) do c.frame.Parent = scroll end
				layoutToggle.Text = "Grid"
			else
				listLayout.Parent = scroll
				pad.PaddingLeft = UDim.new(0, 10)
				pad.PaddingRight = UDim.new(0, 10)
				pad.PaddingTop = UDim.new(0, 10)
				pad.PaddingBottom = UDim.new(0, 10)
				for _, c in ipairs(listCards) do c.frame.Parent = scroll end
				layoutToggle.Text = "List"
			end
			refreshOwnedStylesForAll()
			applyFilters()
		end

		local function setOwnedOnly(v)
			ownedOnly = v and true or false
			if ownedOnly then unownedOnly = false end
			ownedOnlyBtn.Text = ownedOnly and "Owned: ON" or "Owned: OFF"
			unownedOnlyBtn.Text = "Unowned: OFF"
			applyFilters()
		end

		local function setUnownedOnly(v)
			unownedOnly = v and true or false
			if unownedOnly then ownedOnly = false end
			unownedOnlyBtn.Text = unownedOnly and "Unowned: ON" or "Unowned: OFF"
			ownedOnlyBtn.Text = "Owned: OFF"
			applyFilters()
		end

		search:GetPropertyChangedSignal("Text"):Connect(applyFilters)
		ownedOnlyBtn.MouseButton1Click:Connect(function() setOwnedOnly(not ownedOnly) end)
		unownedOnlyBtn.MouseButton1Click:Connect(function() setUnownedOnly(not unownedOnly) end)

		layoutToggle.MouseButton1Click:Connect(function()
			useGrid = not useGrid
			attachLayout()
		end)

		local minimized = false
		local function minimize()
			if minimized then return end
			tweenTransparency(content, 1, TweenInfo.new(0.18, Enum.EasingStyle.Quad, Enum.EasingDirection.Out))
			local tA = TweenService:Create(content, TweenInfo.new(0.18, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {Size = UDim2.new(1,0,0,0)})
			local tB = TweenService:Create(main, TweenInfo.new(0.26, Enum.EasingStyle.Back, Enum.EasingDirection.Out), {Size = UDim2.new(main.Size.X.Scale, 0, 0, headerH)})
			tA:Play(); tB:Play()
			Delay(0.18, function() content.Visible = false end)
			minimized = true
		end
		local function restore()
			if not minimized then return end
			content.Visible = true
			local tB = TweenService:Create(main, TweenInfo.new(0.3, Enum.EasingStyle.Quint, Enum.EasingDirection.Out), {Size = expandedMainSize})
			local tA = TweenService:Create(content, TweenInfo.new(0.22, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {Size = UDim2.new(1,0,1, -headerH)})
			tB:Play(); tA:Play()
			Delay(0.1, function() tweenTransparency(content, 0, TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)) end)
			minimized = false
		end
		minBtn.MouseButton1Click:Connect(function() if minimized then restore() else minimize() end end)

		closeBtn.MouseButton1Click:Connect(function()
			local t1 = TweenService:Create(main, TweenInfo.new(0.35, Enum.EasingStyle.Quint, Enum.EasingDirection.InOut), {
				Size = UDim2.new(0.02,0,0.02,0),
				Position = UDim2.new(0.99,0,0.01,0)
			})
			t1:Play(); t1.Completed:Wait()
			sgui:Destroy()
		end)

		NAgui.dragger(main, header)

		local function runOwnershipChecks(dataset)
			loadingOverlay.Visible = true
			local pending = #dataset
			if pending == 0 then
				loadingOverlay.Visible = false
				refreshBtn.AutoButtonColor = true
				refreshBtn.Text = "Refresh"
				refreshBtn.Active = true
				return
			end
			local i = 0
			for _, b in ipairs(dataset) do
				SpawnCall(function()
					i += 1
					if i % 8 == 0 then Wait(0.2) end
					local ok, has = hasBadgeWithRetry(Player.UserId, b.id)
					if ok then
						ownedMap[b.id] = has
						if has then applyOwnedVisualsFor(b.id) end
					else
						ownedMap[b.id] = nil
					end
					if ownedOnly or unownedOnly then applyFilters() end
					pending -= 1
					if pending <= 0 then
						loadingOverlay.Visible = false
						refreshBtn.AutoButtonColor = true
						refreshBtn.Text = "Refresh"
						refreshBtn.Active = true
					end
				end)
			end
		end

		refreshBtn.MouseButton1Click:Connect(function()
			if refreshBtn.Active == false then return end
			refreshBtn.Active = false
			refreshBtn.AutoButtonColor = false
			refreshBtn.Text = "Refreshing..."
			loadingOverlay.Visible = true
			for _, c in ipairs(listCards) do if c.frame and c.frame.Parent then c.frame:Destroy() end end
			for _, c in ipairs(gridCards) do if c.frame and c.frame.Parent then c.frame:Destroy() end end
			listCards, gridCards, idToCards, ownedMap = {}, {}, {}, {}
			gridBuilt = false
			local ok2, res2 = NACaller(getBadges)
			if ok2 then
				badgesData = res2
				for _, b in ipairs(badgesData) do
					makeListCard(b)
				end
				useGrid = false
				attachLayout()
				runOwnershipChecks(badgesData)
			else
				loadingOverlay.Visible = false
				refreshBtn.AutoButtonColor = true
				refreshBtn.Text = "Refresh"
				refreshBtn.Active = true
				DoNotif("Failed to refresh badge data")
			end
		end)

		tweenTransparency(content, 0, TweenInfo.new(0.22, Enum.EasingStyle.Quad, Enum.EasingDirection.Out))
		attachLayout()
		runOwnershipChecks(badgesData)
	end

	local ok, result = NACaller(getBadges)
	if ok then
		local root = NAmanage.guiCHECKINGAHHHHH()
		for _, g in ipairs(root:GetChildren()) do
			if g:IsA("ScreenGui") and g.Name == "BadgeViewer" then g:Destroy() end
		end
		createBadgeUI(result)
	else
		DoNotif("Failed to fetch badge data")
	end
end)

cmd.add({"bodytransparency","btransparency", "bodyt"}, {"bodytransparency <number> (btransparency,bodyt)", "Sets LocalTransparencyModifier of bodyparts to whatever number you put (0-1)"}, function(v)
	local vv = tonumber(v) or 0

	NAlib.disconnect("body_transparency")

	NAlib.connect("body_transparency", RunService.Stepped:Connect(function()
		local char = LocalPlayer.Character
		if char then
			for _, p in ipairs(char:GetChildren()) do
				if p:IsA("BasePart") and p.Name:lower() ~= "head" then
					p.LocalTransparencyModifier = vv
				end
			end
		end
	end))

	DebugNotif("Body transparency set to "..vv, 1.5)
end, true)

cmd.add({"unbodytransparency", "unbtransparency", "unbodyt"}, {"unbodytransparency (unbtransparency,unbodyt)", "Stops transparency loop"}, function()
	if NAlib.isConnected("body_transparency") then
		NAlib.disconnect("body_transparency")
	else
		DebugNotif("No loop running", 2)
	end
end)

cmd.add({"animationspeed", "animspeed", "aspeed"}, {"animationspeed <speed> (animspeed,aspeed)", "Adjusts the speed of currently playing animations"}, function(speed)
	local targetSpeed = tonumber(speed) or 1

	NAlib.disconnect("animation_speed")

	NAlib.connect("animation_speed", RunService.Stepped:Connect(function()
		local character = getChar()
		local humanoid = getHum() or character:FindFirstChildOfClass("AnimationController")
		if humanoid then
			for _, track in ipairs(humanoid:GetPlayingAnimationTracks()) do
				if track and track:IsA("AnimationTrack") then
					track:AdjustSpeed(targetSpeed)
				end
			end
		end
	end))

	DebugNotif("Animation speed set to "..targetSpeed)
end, true)

cmd.add({"unanimationspeed", "unanimspeed", "unaspeed"}, {"unanimationspeed (unanimspeed,unaspeed)", "Stops the animation speed adjustment loop"}, function()
	if NAlib.isConnected("animation_speed") then
		NAlib.disconnect("animation_speed")
		DebugNotif("Animation speed disabled")
	else
		DebugNotif("No active animation speed to disable")
	end
end)

cmd.add({"placeid","pid"},{"placeid (pid)","Copies the PlaceId of the game you're in"},function()
	setclipboard(tostring(PlaceId))

	Wait();

	DebugNotif("Copied the game's PlaceId: "..PlaceId)
end)

cmd.add({"gameid","universeid","gid"},{"gameid (universeid,gid)","Copies the GameId/Universe Id of the game you're in"},function()
	setclipboard(tostring(GameId))

	Wait();

	DebugNotif("Copied the game's GameId: "..GameId)
end)

cmd.add({"firework"}, {"firework", "pop"}, function()
	local character = LocalPlayer.Character
	if not character then return end

	local root = getRoot(character)
	local humanoid = getHum()
	if not root or not humanoid then return end

	local part = InstanceNew("Part")
	part.Size = Vector3.new(0.1, 0.1, 0.1)
	part.Transparency = 1
	part.Anchored = false
	part.CanCollide = false
	part.Parent = workspace

	local weld = InstanceNew("Weld")
	weld.Part0 = part
	weld.Part1 = root
	weld.C0 = CFrame.new()
	weld.Parent = part

	local bv = InstanceNew("BodyVelocity")
	bv.Velocity = Vector3.new(0, 50, 0)
	bv.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
	bv.Parent = part

	local bg = InstanceNew("BodyGyro")
	bg.MaxTorque = Vector3.new(math.huge, math.huge, math.huge)
	bg.P = 10000
	bg.D = 0
	bg.Parent = part

	local spinTime = 3
	local spinSpeed = 720
	local startTime = tick()
	local angle = 0

	NAlib.connect("firework_spin", RunService.Heartbeat:Connect(function(dt)
		if tick() - startTime > spinTime then
			NAlib.disconnect("firework_spin")
			bv:Destroy()
			bg:Destroy()
			part:Destroy()

			local explosion = InstanceNew("Explosion")
			explosion.Position = root.Position
			explosion.BlastRadius = 6
			explosion.BlastPressure = 500000
			explosion.Parent = workspace

			humanoid.Health = 0
			return
		end

		angle = angle + math.rad(spinSpeed * dt)
		bg.CFrame = CFrame.new(root.Position) * CFrame.Angles(0, angle, 0)
	end))
end)

cmd.add({"placename","pname"},{"placename (pname)","Copies the game's place name to your clipboard"},function()
	placeNaem = placeName()
	setclipboard(placeNaem)

	Wait();

	DebugNotif("Copied the game's place name: "..placeNaem)
end)

cmd.add({"gameinfo","ginfo"},{"gameinfo (ginfo)","shows info about the game you're playing"},function()
	loadstring(game:HttpGet("https://raw.githubusercontent.com/ltseverydayyou/uuuuuuu/refs/heads/main/GameInfo.lua"))()
end)

cmd.add({"userpreview","userp","upreview"},{"userpreview","show info about a user you name"},function()
	loadstring(game:HttpGet("https://raw.githubusercontent.com/ltseverydayyou/uuuuuuu/refs/heads/main/UserInfo.luau"))()
end)

cmd.add({"copyname", "cname"}, {"copyname <player> (cname)", "Copies the username of the target"}, function(...)
	local usr = ...
	local tgt = getPlr(usr)

	for _, plr in next, tgt do
		setclipboard(tostring(plr.Name))
		Wait()
		DebugNotif("Copied the username of "..nameChecker(plr))
	end
end, true)

cmd.add({"copydisplay", "cdisplay"}, {"copydisplay <player> (cdisplay)", "Copies the display name of the target"}, function(...)
	local usr = ...
	local tgt = getPlr(usr)

	for _, plr in next, tgt do
		setclipboard(tostring(plr.DisplayName))
		Wait()
		DebugNotif("Copied the display name of "..nameChecker(plr))
	end
end, true)

cmd.add({"copyid", "id"}, {"copyid <player> (id)", "Copies the UserId of the target"}, function(...)
	local usr = ...
	local tgt = getPlr(usr)

	for _, plr in next, tgt do
		setclipboard(tostring(plr.UserId))
		Wait()
		DebugNotif("Copied the UserId of "..nameChecker(plr))
	end
end, true)

--[ PLAYER ]--
cmd.add({"antikillbrick","antikb"},{"antikillbrick (antikb)","Prevents kill bricks from killing you"},function()
	NAlib.disconnect("antikb")
	NAlib.disconnect("antikb_char")
	NAStuff._kbTracked = NAStuff._kbTracked or setmetatable({}, {__mode="k"})
	NAStuff._kbOrig = NAStuff._kbOrig or setmetatable({}, {__mode="k"})
	NAStuff._kbSignals = NAStuff._kbSignals or setmetatable({}, {__mode="k"})
	local tracked, orig, signals = NAStuff._kbTracked, NAStuff._kbOrig, NAStuff._kbSignals
	local lp = Players.LocalPlayer
	local apply = function(p)
		if not (p and p:IsA("BasePart")) then return end
		if orig[p] == nil then orig[p] = NAlib.isProperty(p,"CanTouch") end
		if NAlib.isProperty(p,"CanTouch") ~= false then NAlib.setProperty(p,"CanTouch", false) end
		tracked[p] = true
		if not signals[p] then
			local c = p:GetPropertyChangedSignal("CanTouch"):Connect(function()
				if NAlib.isProperty(p,"CanTouch") ~= false then NAlib.setProperty(p,"CanTouch", false) end
			end)
			signals[p] = {c}
			NAlib.connect("antikb", c)
		end
	end
	local seed = function(char)
		if not char then return end
		for _,d in ipairs(char:GetDescendants()) do
			if d:IsA("BasePart") then apply(d) end
		end
		NAlib.connect("antikb", char.DescendantAdded:Connect(function(inst)
			if inst:IsA("BasePart") then apply(inst) end
		end))
		NAlib.connect("antikb", char.DescendantRemoving:Connect(function(inst)
			if signals[inst] then for _,c in ipairs(signals[inst]) do if c then c:Disconnect() end end signals[inst]=nil end
			tracked[inst] = nil
			orig[inst] = nil
		end))
	end
	if lp.Character then seed(lp.Character) end
	NAlib.connect("antikb_char", lp.CharacterAdded:Connect(function(char)
		for _,arr in pairs(signals) do if arr then for _,c in ipairs(arr) do if c then c:Disconnect() end end end end
		for k in pairs(signals) do signals[k]=nil end
		for k in pairs(tracked) do tracked[k]=nil end
		for k in pairs(orig) do orig[k]=nil end
		Wait(); seed(char)
	end))
	NAlib.connect("antikb_char", lp.CharacterRemoving:Connect(function()
		for _,arr in pairs(signals) do if arr then for _,c in ipairs(arr) do if c then c:Disconnect() end end end end
		for k in pairs(signals) do signals[k]=nil end
		for k in pairs(tracked) do tracked[k]=nil end
		for k in pairs(orig) do orig[k]=nil end
	end))
	NAlib.connect("antikb", RunService.Stepped:Connect(function()
		local char = lp.Character
		if not char then return end
		for p in pairs(tracked) do
			if typeof(p)=="Instance" and p:IsA("BasePart") and p:IsDescendantOf(char) then
				if p.CanTouch ~= false then NAlib.setProperty(p,"CanTouch", false) end
			end
		end
	end))
end)

cmd.add({"unantikillbrick","unantikb"},{"unantikillbrick (unantikb)","Allows kill bricks to kill you"},function()
	local tracked = NAStuff._kbTracked or {}
	local orig = NAStuff._kbOrig or {}
	local signals = NAStuff._kbSignals or {}
	NAlib.disconnect("antikb")
	NAlib.disconnect("antikb_char")
	for _,arr in pairs(signals) do if arr then for _,c in ipairs(arr) do if c then c:Disconnect() end end end end
	for p in pairs(tracked) do
		if typeof(p)=="Instance" and p:IsA("BasePart") then
			local v = orig[p]; if v == nil then v = true end
			NAlib.setProperty(p,"CanTouch", v)
		end
	end
	for k in pairs(signals) do signals[k] = nil end
	for k in pairs(tracked) do tracked[k] = nil end
	for k in pairs(orig) do orig[k] = nil end
end)

cmd.add({"height","hipheight","hh"},{"height <number> (hipheight,hh)","Changes your hipheight"},function(...)
	getHum().HipHeight=(...)
end,true)

cmd.add({"netbypass", "netb"}, {"netbypass (netb)", "Net bypass"}, function()
	Wait()
	DebugNotif("Netbypass enabled")
	local fenv = getfenv()
	local shp = fenv.sethiddenproperty or fenv.set_hidden_property or fenv.sethiddenprop or fenv.set_hidden_prop
	local ssr = fenv.setsimulationradius or fenv.setsimradius or fenv.set_simulation_radius
	net = shp and function(r) shp(lp, "SimulationRadius", r) end or ssr
end)

cmd.add({"day"},{"day","Makes it day"},function()
	Lighting.ClockTime=14
end)

cmd.add({"night"},{"night","Makes it night"},function()
	Lighting.ClockTime=0
end)

cmd.add({"time"}, {"time <number>", "Sets the time"}, function(...)
	local time = {...}
	if time then Lighting.ClockTime = time[1] end
end, true)

cmd.add({"chat", "message"}, {"chat <text> (message)", "Chats for you, useful if you're muted"}, function(...)
	local chatMessage = Concat({...}, " ")
	local chatTarget = "All"
	NAlib.LocalPlayerChat(chatMessage, chatTarget)
end, true)

cmd.add({"privatemessage", "pm"}, {"privatemessage <player> <text> (pm)", "Sends a private message to a player"}, function(...)
	local args = {...}
	local Player = getPlr(args[1])

	for _, plr in next, Player do
		local chatMessage = Concat(args, " ", 2)
		local chatTarget = plr.Name
		local result = NAlib.LocalPlayerChat(chatMessage, chatTarget)
		if result == "Hooking" then
			Wait(.5)
			NAlib.LocalPlayerChat(chatMessage, chatTarget)
		end
	end
end,true)

cmd.add({"mimicchat", "mimic"}, {"mimicchat <player> (mimic)", "Mimics the chat of a player"}, function(name)
	NAlib.disconnect("mimicchat")

	local targets = getPlr(name)
	if #targets == 0 then
		DoNotif("Player not found",2)
		return
	end

	for _, plr in pairs(targets) do
		DebugNotif("Now mimicking "..plr.Name.."'s chat", 2)

		NAlib.connect("mimicchat", plr.Chatted:Connect(function(msg)
			NAlib.LocalPlayerChat(msg, "All")
		end))
	end
end, true)

cmd.add({"stopmimicchat", "unmimicchat"}, {"stopmimicchat (unmimicchat)", "Stops mimicking a player"}, function()
	NAlib.disconnect("mimicchat")
	DebugNotif("Stopped mimicking", 2)
end, true)

cmd.add({"fixcam", "fix"}, {"fixcam", "Fix your camera"}, function()
	local ws = workspace
	local plr = Players.LocalPlayer
	ws.CurrentCamera:Remove()
	Wait(0.1)
	repeat Wait() until plr.Character
	local cam = ws.CurrentCamera
	cam.CameraSubject = getHum()
	cam.CameraType = "Custom"
	plr.CameraMinZoomDistance = 0.5
	plr.CameraMaxZoomDistance = math.huge
	plr.CameraMode = "Classic"
	getHead(plr.Character).Anchored = false
end)

cmd.add({"saw"}, {"saw <challenge>", "shush"}, function(...)
	local challenge = Concat({...}, " ")
	getgenv().SawFinish = false

	local function playSound(id, vol)
		local sfx = InstanceNew("Sound")
		sfx.Parent = PlrGui
		sfx.SoundId = "rbxassetid://"..id
		sfx.Volume = vol or 1
		sfx:Play()
		sfx.Ended:Connect(function()
			sfx:Destroy()
		end)
	end

	local function createUIElement(class, properties, parent)
		local element = InstanceNew(class)
		for prop, value in pairs(properties) do
			element[prop] = value
		end
		if parent then element.Parent = parent end
		return element
	end

	local ScreenGui = createUIElement("ScreenGui", { Name = '\0' })
	NaProtectUI(ScreenGui)

	local background = createUIElement("Frame", {
		BackgroundColor3 = Color3.fromRGB(0, 0, 0),
		BackgroundTransparency = 1,
		Size = UDim2.new(1, 0, 1, 0),
		ZIndex = 0
	}, ScreenGui)

	local staticOverlay = createUIElement("ImageLabel", {
		BackgroundTransparency = 1,
		Size = UDim2.new(1, 0, 1, 0),
		Image = "rbxassetid://259236205",
		ImageTransparency = 0.8,
		ZIndex = 1
	}, background)

	coroutine.wrap(function()
		while not getgenv().SawFinish do
			local tween = TweenService:Create(
				staticOverlay,
				TweenInfo.new(0.1, Enum.EasingStyle.Quad, Enum.EasingDirection.InOut),
				{ ImageTransparency = math.random(0.7, 0.9), Position = UDim2.new(math.random(-0.01, 0.01), 0, math.random(-0.01, 0.01), 0) }
			)
			tween:Play()
			Wait(math.random(0.05, 0.2))
		end
	end)()

	local bgTween = TweenService:Create(
		background,
		TweenInfo.new(1, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),
		{ BackgroundTransparency = 0.5 }
	)
	bgTween:Play()

	local progressBar = createUIElement("Frame", {
		BackgroundColor3 = Color3.fromRGB(50, 50, 50),
		Position = UDim2.new(0.25, 0, 0.05, 0),
		Size = UDim2.new(0.5, 0, 0.03, 0),
		BorderSizePixel = 0,
		ZIndex = 2
	}, ScreenGui)

	local progressFill = createUIElement("Frame", {
		BackgroundColor3 = Color3.fromRGB(255, 0, 0),
		Size = UDim2.new(1, 0, 1, 0),
		BorderSizePixel = 0,
		ZIndex = 3
	}, progressBar)

	local imgLabel = createUIElement("ImageLabel", {
		AnchorPoint = Vector2.new(0.5, 0),
		BackgroundTransparency = 1,
		Position = UDim2.new(0.5, 0, 0.1, 0),
		Size = UDim2.new(0, 150, 0, 150),
		Image = "rbxassetid://8747893766",
		ImageColor3 = Color3.fromRGB(255, 0, 0),
		ZIndex = 2
	}, ScreenGui)

	coroutine.wrap(function()
		while not getgenv().SawFinish do
			local newSize = math.random(140, 160)
			local newRotation = math.random(-10, 10)
			local tween = TweenService:Create(
				imgLabel,
				TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.InOut),
				{ Size = UDim2.new(0, newSize, 0, newSize), Rotation = newRotation, ImageColor3 = Color3.fromRGB(math.random(200, 255), 0, 0) }
			)
			tween:Play()
			tween.Completed:Wait()
			if math.random() < 0.2 then
				local glitchTween = TweenService:Create(
					imgLabel,
					TweenInfo.new(0.05, Enum.EasingStyle.Quad, Enum.EasingDirection.InOut),
					{ ImageTransparency = math.random(0.3, 0.7), Position = UDim2.new(0.5 + math.random(-0.05, 0.05), 0, 0.1 + math.random(-0.05, 0.05), 0) }
				)
				glitchTween:Play()
				glitchTween.Completed:Wait()
				local resetTween = TweenService:Create(
					imgLabel,
					TweenInfo.new(0.05, Enum.EasingStyle.Quad, Enum.EasingDirection.InOut),
					{ ImageTransparency = 0, Position = UDim2.new(0.5, 0, 0.1, 0) }
				)
				resetTween:Play()
			end
		end
	end)()

	local ttLabelLeft = createUIElement("TextLabel", {
		BackgroundColor3 = Color3.fromRGB(0, 0, 0),
		BackgroundTransparency = 0.3,
		AnchorPoint = Vector2.new(0, 0.5),
		Position = UDim2.new(0.05, 0, 0.5, 0),
		Size = UDim2.new(0.4, 0, 0.1, 0),
		Font = Enum.Font.SciFi,
		Text = "Challenge: "..challenge,
		TextColor3 = Color3.fromRGB(255, 0, 0),
		TextSize = 24,
		TextStrokeColor3 = Color3.fromRGB(100, 0, 0),
		TextStrokeTransparency = 0.5,
		TextWrapped = true,
		ZIndex = 3
	}, ScreenGui)

	local ttLabelRight = createUIElement("TextLabel", {
		BackgroundColor3 = Color3.fromRGB(0, 0, 0),
		BackgroundTransparency = 0.3,
		AnchorPoint = Vector2.new(1, 0.5),
		Position = UDim2.new(0.95, 0, 0.5, 0),
		Size = UDim2.new(0.4, 0, 0.1, 0),
		Font = Enum.Font.SciFi,
		Text = "Time Remaining: 180 seconds",
		TextColor3 = Color3.fromRGB(255, 0, 0),
		TextSize = 24,
		TextStrokeColor3 = Color3.fromRGB(100, 0, 0),
		TextStrokeTransparency = 0.5,
		TextWrapped = true,
		ZIndex = 3
	}, ScreenGui)

	local dramaticLabel = createUIElement("TextLabel", {
		BackgroundTransparency = 1,
		AnchorPoint = Vector2.new(0.5, 0.5),
		Position = UDim2.new(0.5, 0, 0.7, 0),
		Size = UDim2.new(0.5, 0, 0.2, 0),
		Font = Enum.Font.SciFi,
		Text = "",
		TextColor3 = Color3.fromRGB(255, 0, 0),
		TextSize = 50,
		TextStrokeTransparency = 0.5,
		TextWrapped = true,
		ZIndex = 4
	}, ScreenGui)

	local function flickerText()
		while not getgenv().SawFinish do
			local newColor = Color3.fromRGB(math.random(200, 255), 0, 0)
			ttLabelLeft.TextColor3 = newColor
			ttLabelRight.TextColor3 = newColor
			ttLabelLeft.TextStrokeTransparency = math.random(0.4, 0.7)
			ttLabelRight.TextStrokeTransparency = math.random(0.4, 0.7)
			ttLabelLeft.Text = "Challenge: "..challenge:sub(1, math.random(1, #challenge))
			Wait(math.random(0.05, 0.15))
		end
	end

	local function dramaticCountdown(num)
		dramaticLabel.Text = tostring(num)
		playSound(138081500, 2)
		for i = 1, 5 do
			local shakeTween = TweenService:Create(
				dramaticLabel,
				TweenInfo.new(0.05, Enum.EasingStyle.Quad, Enum.EasingDirection.InOut),
				{ Position = UDim2.new(0.5 + math.random(-0.02, 0.02), 0, 0.7 + math.random(-0.02, 0.02), 0) }
			)
			shakeTween:Play()
			shakeTween.Completed:Wait()
		end
		local resetTween = TweenService:Create(
			dramaticLabel,
			TweenInfo.new(0.1, Enum.EasingStyle.Quad, Enum.EasingDirection.InOut),
			{ Position = UDim2.new(0.5, 0, 0.7, 0) }
		)
		resetTween:Play()
		Wait(1)
		dramaticLabel.Text = ""
	end

	local ambientSound = InstanceNew("Sound")
	ambientSound.Parent = PlrGui
	ambientSound.SoundId = "rbxassetid://1846090198"
	ambientSound.Volume = 0.2
	ambientSound.Looped = true
	ambientSound:Play()

	local function count()
		local num = 180
		while Wait(1) do
			if not getgenv().SawFinish then
				if num > 0 then
					num = num - 1
					playSound(138081500, num <= 10 and 2 or 1)
					ttLabelRight.Text = "Time Remaining: "..num.." seconds"

					local progress = num / 180
					local jitter = math.random(-0.02, 0.02)
					local tween = TweenService:Create(
						progressFill,
						TweenInfo.new(1, Enum.EasingStyle.Linear),
						{ Size = UDim2.new(progress + jitter, 0, 1, 0), BackgroundColor3 = num <= 30 and Color3.fromRGB(math.random(200, 255), math.random(0, 50), 0) or Color3.fromRGB(255, 0, 0) }
					)
					tween:Play()

					if num == 30 or num == 20 or num == 10 then
						dramaticCountdown(num)
					elseif num <= 10 then
						dramaticLabel.Text = tostring(num)
						playSound(138081500, 2)
					end
				else
					local flash = createUIElement("Frame", {
						BackgroundColor3 = Color3.fromRGB(255, 0, 0),
						BackgroundTransparency = 0,
						Size = UDim2.new(1, 0, 1, 0),
						ZIndex = 10
					}, ScreenGui)
					playSound(9125915751, 5)
					Wait(0.2)
					flash:Destroy()
					Players.LocalPlayer:Kick("You Failed The Challenge")
				end
			else
				ttLabelLeft.Text = "You Survived... For Now"
				ttLabelRight.Text = ""
				dramaticLabel.Text = "I'll be watching..."
				local distortion = createUIElement("Frame", {
					BackgroundColor3 = Color3.fromRGB(100, 0, 0),
					BackgroundTransparency = 0.7,
					Size = UDim2.new(1, 0, 1, 0),
					ZIndex = 5
				}, ScreenGui)
				local glitchOverlay = createUIElement("ImageLabel", {
					BackgroundTransparency = 1,
					Size = UDim2.new(1, 0, 1, 0),
					Image = "rbxassetid://259236205",
					ImageTransparency = 0.5,
					ZIndex = 6
				}, distortion)
				playSound(9125915751, 5)
				for i = 1, 3 do
					local glitchTween = TweenService:Create(
						glitchOverlay,
						TweenInfo.new(0.1, Enum.EasingStyle.Quad, Enum.EasingDirection.InOut),
						{ Position = UDim2.new(math.random(-0.05, 0.05), 0, math.random(-0.05, 0.05), 0), ImageTransparency = math.random(0.3, 0.7) }
					)
					glitchTween:Play()
					Wait(0.15)
				end
				local fadeTween = TweenService:Create(
					dramaticLabel,
					TweenInfo.new(3, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),
					{ TextTransparency = 1 }
				)
				local distortionFade = TweenService:Create(
					distortion,
					TweenInfo.new(3, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),
					{ BackgroundTransparency = 1 }
				)
				local glitchFade = TweenService:Create(
					glitchOverlay,
					TweenInfo.new(3, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),
					{ ImageTransparency = 1 }
				)
				fadeTween:Play()
				distortionFade:Play()
				glitchFade:Play()
				Wait(3)
				ScreenGui:Destroy()
				ambientSound:Destroy()
				break
			end
		end
	end

	coroutine.wrap(count)()
	coroutine.wrap(flickerText)()
end, true)

cmd.add({"jend"}, {"jend", "nil"}, function()
	getgenv().SawFinish = true
end)

cmd.add({"fling"}, {"fling <player>", "Fling the given player"}, function(plr)
	local Players = game.GetService(game,"Players")
	local LocalPlayer    = Players.LocalPlayer
	local Character      = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
	local Humanoid       = getPlrHum(Character)
	local RootPart       = Humanoid and Humanoid.RootPart
	if not RootPart then return end

	local AllBool = false
	local function GetPlayer(Name)
		Name = Lower(Name)
		if Name == "all" or Name == "others" then
			AllBool = true
			return
		elseif Name == "random" then
			local list = Players:GetPlayers()
			if Discover(list, LocalPlayer) then
				table.remove(list, Discover(list, LocalPlayer))
			end
			return list[math.random(#list)]
		end
		for _, x in next, Players:GetPlayers() do
			if x ~= LocalPlayer then
				if Sub(Lower(x.Name), 1, #Name) == Name or Sub(Lower(x.DisplayName), 1, #Name) == Name then
					return x
				end
			end
		end
	end

	local flingManager       = flingManager
	local OrgDestroyHeight   = workspace.FallenPartsDestroyHeight

	local function SkidFling(TargetPlayer)
		local Character = LocalPlayer.Character
		local Humanoid  = getPlrHum(Character)
		local RootPart  = Humanoid and Humanoid.RootPart
		local TChar     = TargetPlayer.Character
		local THumanoid = getPlrHum(TChar)
		local TRootPart = THumanoid and THumanoid.RootPart
		local THead     = getHead(TChar)
		local Acc       = TChar:FindFirstChildOfClass("Accessory")
		local Handle    = Acc and Acc:FindFirstChild("Handle")

		if Character and Humanoid and RootPart then
			if not flingManager.cFlingOldPos or RootPart.Velocity.Magnitude < 50 then
				flingManager.cFlingOldPos = RootPart.CFrame
			end

			if THead then
				workspace.CurrentCamera.CameraSubject = THead
			elseif Handle then
				workspace.CurrentCamera.CameraSubject = Handle
			elseif THumanoid and TRootPart then
				workspace.CurrentCamera.CameraSubject = THumanoid
			end

			if not TChar:FindFirstChildWhichIsA("BasePart") then return end

			local function FPos(BasePart, Pos, Ang)
				RootPart.CFrame = CFrame.new(BasePart.Position) * Pos * Ang
				Character:SetPrimaryPartCFrame(CFrame.new(BasePart.Position) * Pos * Ang)
				RootPart.Velocity    = Vector3.new(9e7, 9e7*10, 9e7)
				RootPart.RotVelocity = Vector3.new(9e8, 9e8, 9e8)
			end

			local function SFBasePart(BasePart)
				local TimeToWait = 2
				local Time       = tick()
				local Angle      = 0
				repeat
					if RootPart and THumanoid then
						if BasePart.Velocity.Magnitude < 50 then
							Angle = Angle + 100
							FPos(BasePart, CFrame.new(0,1.5,0) + THumanoid.MoveDirection * BasePart.Velocity.Magnitude/1.25, CFrame.Angles(math.rad(Angle),0,0)) Wait()
							FPos(BasePart, CFrame.new(0,-1.5,0) + THumanoid.MoveDirection * BasePart.Velocity.Magnitude/1.25, CFrame.Angles(math.rad(Angle),0,0)) Wait()
							FPos(BasePart, CFrame.new(2.25,1.5,-2.25) + THumanoid.MoveDirection * BasePart.Velocity.Magnitude/1.25, CFrame.Angles(math.rad(Angle),0,0)) Wait()
							FPos(BasePart, CFrame.new(-2.25,-1.5,2.25) + THumanoid.MoveDirection * BasePart.Velocity.Magnitude/1.25, CFrame.Angles(math.rad(Angle),0,0)) Wait()
							FPos(BasePart, CFrame.new(0,1.5,0) + THumanoid.MoveDirection, CFrame.Angles(math.rad(Angle),0,0)) Wait()
							FPos(BasePart, CFrame.new(0,-1.5,0) + THumanoid.MoveDirection, CFrame.Angles(math.rad(Angle),0,0)) Wait()
						else
							FPos(BasePart, CFrame.new(0,1.5,THumanoid.WalkSpeed), CFrame.Angles(math.rad(90),0,0)) Wait()
							FPos(BasePart, CFrame.new(0,-1.5,-THumanoid.WalkSpeed), CFrame.Angles(0,0,0)) Wait()
							FPos(BasePart, CFrame.new(0,1.5,THumanoid.WalkSpeed), CFrame.Angles(math.rad(90),0,0)) Wait()
							FPos(BasePart, CFrame.new(0,1.5,TRootPart.Velocity.Magnitude/1.25), CFrame.Angles(math.rad(90),0,0)) Wait()
							FPos(BasePart, CFrame.new(0,-1.5,-TRootPart.Velocity.Magnitude/1.25), CFrame.Angles(0,0,0)) Wait()
							FPos(BasePart, CFrame.new(0,1.5,TRootPart.Velocity.Magnitude/1.25), CFrame.Angles(math.rad(90),0,0)) Wait()
							FPos(BasePart, CFrame.new(0,-1.5,0), CFrame.Angles(math.rad(90),0,0)) Wait()
							FPos(BasePart, CFrame.new(0,-1.5,0), CFrame.Angles(0,0,0)) Wait()
							FPos(BasePart, CFrame.new(0,-1.5,0), CFrame.Angles(math.rad(-90),0,0)) Wait()
							FPos(BasePart, CFrame.new(0,-1.5,0), CFrame.Angles(0,0,0)) Wait()
						end
					else
						break
					end
				until BasePart.Velocity.Magnitude > 500
					or BasePart.Parent ~= TargetPlayer.Character
					or TargetPlayer.Parent ~= Players
					or TargetPlayer.Character ~= TChar
					or THumanoid.Sit
					or Humanoid.Health <= 0
					or tick() > Time + TimeToWait
			end

			workspace.FallenPartsDestroyHeight = 0/0

			local BV = InstanceNew("BodyVelocity")
			BV.Parent    = RootPart
			BV.Velocity  = Vector3.new(9e8,9e8,9e8)
			BV.MaxForce  = Vector3.new(1/0,1/0,1/0)

			Humanoid:SetStateEnabled(Enum.HumanoidStateType.Seated, false)

			if TRootPart and THead then
				if (TRootPart.CFrame.p - THead.CFrame.p).Magnitude > 5 then
					SFBasePart(THead)
				else
					SFBasePart(TRootPart)
				end
			elseif TRootPart then
				SFBasePart(TRootPart)
			elseif THead then
				SFBasePart(THead)
			elseif Handle then
				SFBasePart(Handle)
			end

			BV:Destroy()
			Humanoid:SetStateEnabled(Enum.HumanoidStateType.Seated, true)
			workspace.CurrentCamera.CameraSubject = Humanoid

			repeat
				RootPart.CFrame                  = flingManager.cFlingOldPos * CFrame.new(0, .5, 0)
				Character:SetPrimaryPartCFrame( flingManager.cFlingOldPos * CFrame.new(0, .5, 0) )
				Humanoid:ChangeState("GettingUp")
				for _, x in next, Character:GetChildren() do
					if x:IsA("BasePart") then
						x.Velocity, x.RotVelocity = Vector3.new(), Vector3.new()
					end
				end
				Wait()
			until (RootPart.Position - flingManager.cFlingOldPos.p).Magnitude < 25

			workspace.FallenPartsDestroyHeight = OrgDestroyHeight
		end
	end

	local targets = {}
	for _, name in next, {plr} do
		local p = GetPlayer(name)
		if p then Insert(targets, p) end
	end

	if AllBool then
		for _, p in next, Players:GetPlayers() do
			if p ~= LocalPlayer then SkidFling(p) end
		end
	else
		for _, p in next, targets do
			SkidFling(p)
		end
	end
end)

cmd.add({"commitoof", "suicide", "kys"}, {"commitoof (suicide, kys)", "Triggers a dramatic oof sequence for the player"}, function()
	local p = Players.LocalPlayer
	if not p then
		return
	end

	local c = p.Character
	if not c then
		c = p.CharacterAdded:Wait()
	end

	local h = getPlrHum(c)
	if not h then
		return
	end

	local r = getRoot(c)
	if not r then
		return
	end

	NAlib.LocalPlayerChat("Okay... I will do it.", "All")
	Wait(1.5)
	NAlib.LocalPlayerChat("I will oof now...", "All")
	Wait(1.5)
	NAlib.LocalPlayerChat("Goodbye, cruel world.", "All")
	Wait(2)

	h:MoveTo(r.Position + r.CFrame.LookVector * 10)
	h:ChangeState(Enum.HumanoidStateType.Jumping)
	Wait(0.45)

	cmd.run({'die'})
end)

cmd.add({"volume","vol"},{"volume <0-10> (vol)","Changes your volume"},function(vol)
	if not vol then return DoNotif("please provide a number between 0-10",2) end
	local amount=math.clamp(vol, 0, 10)
	UserSettings():GetService("UserGameSettings").MasterVolume=amount
end,true)

cmd.add({"perfstats"},{"perfstats <on/off>","Shows or hides performance stats"},function(t)
	local s=UserSettings():GetService("UserGameSettings")
	local a=tostring(t or ""):lower()
	pcall(function() s.PerformanceStatsVisible=(a=="on" or a=="true" or a=="1") end)
end,true)

cmd.add({"preftransparency","prefalpha"},{"preftransparency <0-15>","Preferred UI transparency"},function(v)
	local s=UserSettings():GetService("UserGameSettings")
	local n=math.clamp(tonumber(v) or 0,0,15)
	pcall(function() s.PreferredTransparency=n end)
end,true)

cmd.add({"sensitivity","sens"},{"sensitivity <1-10> (sens)","Changes your sensitivity"},function(ss)
	UserInputService.MouseDeltaSensitivity=ss
end,true)

cmd.add({"torandom","tr"},{"torandom (tr)","Teleports to a random player"},function()
	target=getPlr("random")
	for _, plr in next, target do
		SpawnCall(function() getRoot(getChar()).CFrame=getPlrHum(plr).RootPart.CFrame end)
	end
end)

cmd.add({"timestop", "tstop"}, {"timestop (tstop)", "freezes all players (ZA WARUDO)"}, function()
	local target = getPlr("others")
	if #target == 0 then return end

	for _, plr in pairs(Players:GetPlayers()) do
		NAlib.disconnect("timestop_char_"..plr.UserId)
	end
	NAlib.disconnect("timestop_playeradd")

	for _, plr in pairs(target) do
		local char = plr.Character or getPlrChar(plr)
		if char then
			for _, v in pairs(char:GetDescendants()) do
				if v:IsA("BasePart") then
					v.Anchored = true
				end
			end
		end

		NAlib.connect("timestop_char_"..plr.UserId, plr.CharacterAdded:Connect(function(char)
			while not getRoot(char) do Wait(.1) end
			for _, v in pairs(char:GetDescendants()) do
				if v:IsA("BasePart") then
					v.Anchored = true
				end
			end
		end))
	end

	NAlib.connect("timestop_playeradd", Players.PlayerAdded:Connect(function(plr)
		NAlib.connect("timestop_char_"..plr.UserId, plr.CharacterAdded:Connect(function(char)
			while not getRoot(char) do Wait(.1) end
			for _, v in pairs(char:GetDescendants()) do
				if v:IsA("BasePart") then
					v.Anchored = true
				end
			end
		end))
	end))
end)

cmd.add({"untimestop", "untstop"}, {"untimestop (untstop)", "unfreeze all players"}, function()
	local target = getPlr("all")
	if #target == 0 then return end

	for _, plr in pairs(Players:GetPlayers()) do
		NAlib.disconnect("timestop_char_"..plr.UserId)
	end
	NAlib.disconnect("timestop_playeradd")

	for _, plr in pairs(target) do
		local char = plr.Character or getPlrChar(plr)
		if char then
			for _, v in pairs(char:GetDescendants()) do
				if v:IsA("BasePart") then
					v.Anchored = false
				end
			end
		end
	end
end)

NAStuff._outfitCache=NAStuff._outfitCache or{};NAStuff._httpBackoff=NAStuff._httpBackoff or{};NAStuff._httpCooldown=NAStuff._httpCooldown or{}
NAmanage._waitCharReady=function(timeout)
	local t=timeout or 5
	local plr=Players.LocalPlayer
	local t0=time()
	while time()-t0<t do
		local char=getChar()
		if char and char.Parent==workspace then
			local hum=getHum() or char:FindFirstChildOfClass("Humanoid")
			local root=getRoot(char) or char:FindFirstChild("HumanoidRootPart") or char:FindFirstChildWhichIsA("BasePart")
			local head=getHead(char) or char:FindFirstChild("Head")
			if hum and root and head then
				if plr and plr.CanLoadCharacterAppearance and not plr:HasAppearanceLoaded() then plr.CharacterAppearanceLoaded:Wait() end
				return char,hum,root,head
			end
		end
		Wait(0.1)
	end
	local c=getChar();return c,(c and (getHum() or c:FindFirstChildOfClass("Humanoid"))),(c and (getRoot(c) or c:FindFirstChild("HumanoidRootPart") or c:FindFirstChildWhichIsA("BasePart"))),(c and (getHead(c) or c:FindFirstChild("Head")))
end
NAmanage._applyFixedDescription=function(desc,uidFallback)
	if not desc then return end
	local plr=Players.LocalPlayer
	local char,hum=NAmanage._waitCharReady(5)
	if not char or not hum then return end
	if not NAStuff.originalDesc then local okA,ap=pcall(function()return hum:GetAppliedDescription() end);if okA and ap then NAStuff.originalDesc=ap:Clone() end end
	for _,inst in ipairs(char:GetChildren()) do
		if inst:IsA("Accessory") or inst:IsA("Shirt") or inst:IsA("Pants") or inst:IsA("ShirtGraphic") or inst:IsA("CharacterMesh") or inst:IsA("BodyColors") then inst:Destroy() end
	end
	local hd=getHead(char)
	if hd then for _,d in ipairs(hd:GetChildren()) do if d:IsA("Decal") and Lower(d.Name)=="face" then d:Destroy() end end end
	local success=false
	for i=1,3 do
		local blank=InstanceNew("HumanoidDescription");hum:ApplyDescriptionClientServer(blank);Wait(0.05*i);hum:ApplyDescriptionClientServer(desc);Wait(0.1*i)
		local hasClothes=(char:FindFirstChildOfClass("Shirt") or char:FindFirstChildOfClass("Pants") or char:FindFirstChildOfClass("ShirtGraphic"))~=nil
		local headNow=getHead(char);local hasFace=false
		if headNow then for _,d in ipairs(headNow:GetChildren()) do if d:IsA("Decal") and Lower(d.Name)=="face" then hasFace=true break end end end
		if hasClothes and hasFace then success=true break end
	end
	local headNow=getHead(char)
	if headNow then
		local hasFace=false
		for _,d in ipairs(headNow:GetChildren()) do if d:IsA("Decal") and Lower(d.Name)=="face" then hasFace=true break end end
		local faceId=0 pcall(function() faceId=desc.Face or 0 end)
		if not hasFace then
			if faceId and faceId>0 then local dec=InstanceNew("Decal");dec.Name="face";dec.Texture="rbxassetid://"..tostring(faceId);dec.Face=Enum.NormalId.Front;dec.Parent=headNow
			elseif uidFallback then local okA2,ap=pcall(Players.GetCharacterAppearanceAsync,Players,uidFallback);if okA2 and ap then for _,v in ipairs(ap:GetDescendants()) do if v:IsA("Decal") and Lower(v.Name)=="face" then v:Clone().Parent=headNow;break end end end
			end
		end
	end
	if not char:FindFirstChildOfClass("Shirt") then local sid=desc.Shirt;if sid and sid>0 then local s=InstanceNew("Shirt");s.ShirtTemplate="rbxassetid://"..sid;s.Parent=char end end
	if not char:FindFirstChildOfClass("Pants") then local pid=desc.Pants;if pid and pid>0 then local p=InstanceNew("Pants");p.PantsTemplate="rbxassetid://"..pid;p.Parent=char end end
	if not char:FindFirstChildOfClass("ShirtGraphic") then local gid=desc.GraphicTShirt or desc.TShirt;if gid and gid>0 then local g=InstanceNew("ShirtGraphic");g.Graphic="rbxassetid://"..gid;g.Parent=char end end
	if hum.RigType==Enum.HumanoidRigType.R6 and uidFallback then local okA3,ap=pcall(Players.GetCharacterAppearanceAsync,Players,uidFallback);if okA3 and ap then for _,v in ipairs(ap:GetDescendants()) do if v:IsA("CharacterMesh") then v:Clone().Parent=char end end end end
end

cmd.add({"team"},{"team <team name>","Changes your team (for the client)"},function(...)
	local args={...}
	local teamName=Concat(args," ")
	teamName=teamName and teamName:gsub("^%s+",""):gsub("%s+$","") or""
	if teamName=="" then DoNotif("team <team name>",3,"Team") return end
	local teamsService=SafeGetService("Teams")
	if not teamsService then return end
	local lookup=Lower(teamName)
	local targetTeam=nil
	for _,team in ipairs(teamsService:GetChildren()) do
		if Lower(team.Name):find(lookup,1,true) then targetTeam=team break end
	end
	if not targetTeam then DoNotif(Format("Invalid team \"%s\"",teamName),3,"Team") return end
	local localPlayer=Players.LocalPlayer
	if not localPlayer then return end
	local character=getChar()
	local root=character and getRoot(character)
	local function assignTeam()
		pcall(function()
			localPlayer.Neutral=false
			localPlayer.Team=targetTeam
		end)
	end
	if typeof(firetouchinterest)=="function" and root then
		for _,spawnLocation in ipairs(workspace:GetDescendants()) do
			if spawnLocation:IsA("SpawnLocation") and spawnLocation.BrickColor==targetTeam.TeamColor and spawnLocation.AllowTeamChangeOnTouch then
				pcall(firetouchinterest,spawnLocation,root,0)
				Wait()
				pcall(firetouchinterest,spawnLocation,root,1)
				assignTeam()
				return
			end
		end
	end
	assignTeam()
end,true)

cmd.add({"nilchar"},{"nilchar","Temporarily parent your character to nil"},function()
	local char=getChar()
	if not char then
		DoNotif("Character unavailable",2)
		return
	end
	char.Parent=nil
end)

cmd.add({"unnilchar","nonilchar"},{"unnilchar (nonilchar)","Move your character back to workspace"},function()
	local char=getChar()
	if not char then
		DoNotif("Character unavailable",2)
		return
	end
	char.Parent=workspace
end)

cmd.add({"char","character","morph"},{"char <username/userid>","change your character's appearance to someone else's"},function(arg)
	if not arg then return end
	local userId=tonumber(arg)
	if not userId then local ok,id=pcall(Players.GetUserIdFromNameAsync,Players,arg);if not ok then return end;userId=id end
	local okD,desc=pcall(Players.GetHumanoidDescriptionFromUserId,Players,userId)
	if not okD or not desc then return end
	SpawnCall(function() NAmanage._applyFixedDescription(desc:Clone(),userId) end)
end,true)

cmd.add({"unchar"},{"unchar","revert to your character"},function()
	local plr=Players.LocalPlayer;if not plr then return end
	local okD,desc=pcall(Players.GetHumanoidDescriptionFromUserId,Players,plr.UserId);if not okD or not desc then return end
	SpawnCall(function() NAmanage._applyFixedDescription(desc:Clone(),plr.UserId) end)
end)

cmd.add({"autochar","achar"},{"autochar","auto-change your character on respawn"},function(target)
	if not target or target=="" then return end
	NAlib.disconnect("autochar")
	NAlib.connect("autochar",Players.LocalPlayer.CharacterAdded:Connect(function()
		local id=tonumber(target);if not id then local ok,x=pcall(Players.GetUserIdFromNameAsync,Players,target);if not ok then return end;id=x end
		SpawnCall(function()
			local okD,desc=pcall(Players.GetHumanoidDescriptionFromUserId,Players,id)
			if okD and desc then NAmanage._applyFixedDescription(desc:Clone(),id) end
		end)
	end))
	cmd.run({"char",target})
end,true)

cmd.add({"unautochar","unachar"},{"unautochar","stop auto-change on respawn"},function()
	NAlib.disconnect("autochar")
end)

cmd.add({"autooutfit","aoutfit"},{"autooutfit {username/userid}","Auto-apply a selected outfit on respawn"},function(arg)
	if not arg or arg=="" then return end
	local req=opt and opt.NAREQUEST;if not req then DoNotif("HTTP not available",3,"AutoOutfit") return end
	local uid=tonumber(arg);if not uid then local ok,id=pcall(Players.GetUserIdFromNameAsync,Players,arg);if ok and id then uid=id else DoNotif("Couldn't resolve user",3,"AutoOutfit") return end end
	local function lowerKeys(t)local r={};for k,v in pairs(t or{})do r[Lower(k)]=v end;return r end
	local function hostOf(url)return Match(url,"^https?://([^/]+)") or"" end
	local function httpJSON(url)
		local host=hostOf(url)
		local cd=NAStuff._httpCooldown[host];if cd and time()<cd then local left=math.max(0,cd-time());DoNotif(Format("Loading outfits… retrying in %.1fs",left),math.max(1.2,left),"AutoOutfit");return false,"cooldown" end
		local okR,resp=pcall(req,{Url=url,Method="GET"})
		local status=okR and (resp.StatusCode or resp.Status) or 0
		local text=okR and (resp.Body or resp.body) or""
		if status==200 and type(text)=="string" then local okJ,data=pcall(HttpService.JSONDecode,HttpService,text);if okJ then NAStuff._httpBackoff[host]=0 return true,data end return false,"bad json" end
		if status==429 then
			local hdrs=lowerKeys(resp and (resp.Headers or resp.headers) or{})
			local ra=tonumber(hdrs["retry-after"]) or tonumber(hdrs["x-ratelimit-retryafter"]) or nil
			local waitSec=math.clamp((ra or (NAStuff._httpBackoff[host] and NAStuff._httpBackoff[host]*2 or 1.5))+math.random()*0.25,1,10)
			NAStuff._httpBackoff[host]=waitSec;NAStuff._httpCooldown[host]=time()+waitSec
			DoNotif(Format("Loading outfits… retrying in %.1fs",waitSec),math.max(1.5,waitSec),"AutoOutfit")
			return false,"retry"
		end
		if status>=500 and status<600 then
			local waitSec=math.clamp((NAStuff._httpBackoff[host] and NAStuff._httpBackoff[host]*1.5 or 1.0)+math.random()*0.2,0.8,8)
			NAStuff._httpBackoff[host]=waitSec;NAStuff._httpCooldown[host]=time()+waitSec
			DoNotif(Format("Loading outfits… retrying in %.1fs",waitSec),math.max(1.5,waitSec),"AutoOutfit")
			return false,"retry"
		end
		return false,"bad response "..tostring(status)
	end
	local outfits={}
	local cache=NAStuff._outfitCache[uid]
	if cache and (time()-cache.t)<120 and cache.list and #cache.list>0 then
		outfits=cache.list
	else
		local cursor=nil
		repeat
			local url=Format("https://avatar.roblox.com/v1/users/%d/outfits?itemsPerPage=50%s",uid,cursor and("&cursor="..HttpService:UrlEncode(cursor)) or"")
			local okD,data=httpJSON(url);if not okD then return end
			for _,it in ipairs(data.data or{})do if it and it.id and it.name and it.isEditable==true then Insert(outfits,{id=it.id,name=it.name}) end end
			cursor=data.nextPageCursor
			if cursor then Wait(0.4) end
		until not cursor
		if #outfits==0 then DoNotif("No user-created outfits for that user",2,"AutoOutfit") return end
		NAStuff._outfitCache[uid]={t=time(),list=outfits}
	end
	local buttons={}
	for _,o in ipairs(outfits)do
		Insert(buttons,{Text=Format("%s  (#%d)",o.name,o.id),Callback=function()
			NAlib.disconnect("autooutfit")
			NAStuff.autoOutfitState={id=o.id,name=o.name,owner=uid}
			NAlib.connect("autooutfit",Players.LocalPlayer.CharacterAdded:Connect(function()
				SpawnCall(function()
					local okD,desc=pcall(Players.GetHumanoidDescriptionFromOutfitId,Players,o.id)
					if okD and desc then NAmanage._applyFixedDescription(desc,Players.LocalPlayer.UserId) end
				end)
			end))
			SpawnCall(function()
				local okD,desc=pcall(Players.GetHumanoidDescriptionFromOutfitId,Players,o.id)
				if okD and desc then NAmanage._applyFixedDescription(desc,Players.LocalPlayer.UserId) end
			end)
			DoNotif("Auto outfit set: "..o.name,2,"AutoOutfit")
		end})
	end
	Window({Title=Format("AutoOutfit • %s (%d)",tostring(arg),uid),Buttons=buttons})
end,true)

cmd.add({"unautooutfit","unaoutfit"},{"unautooutfit","stop outfit auto-apply"},function()
	NAlib.disconnect("autooutfit");NAStuff.autoOutfitState=nil;DoNotif("Auto outfit disabled",2,"AutoOutfit")
end)

cmd.add({"outfit"},{"outfit {username/userid}","Open a list of a user's saved outfits"},function(arg)
	if not arg or arg=="" then return end
	NAStuff=NAStuff or{};NAStuff._outfitCache=NAStuff._outfitCache or{};NAStuff._httpBackoff=NAStuff._httpBackoff or{};NAStuff._httpCooldown=NAStuff._httpCooldown or{}
	local req=opt and opt.NAREQUEST;if not req then DoNotif("HTTP not available",3,"Outfits") return end
	local uid=tonumber(arg)
	if not uid then
		local ok,id=pcall(Players.GetUserIdFromNameAsync,Players,arg)
		if ok and id then uid=id else
			local body=HttpService:JSONEncode({usernames={arg},excludeBannedUsers=true})
			local okR,resp=pcall(req,{Url="https://users.roblox.com/v1/usernames/users",Method="POST",Headers={["Content-Type"]="application/json"},Body=body})
			local status=okR and (resp.StatusCode or resp.Status) or 0
			local text=okR and (resp.Body or resp.body) or""
			if status==200 and type(text)=="string" then
				local okJ,data=pcall(HttpService.JSONDecode,HttpService,text)
				if okJ and data and data.data and data.data[1] and data.data[1].id then uid=data.data[1].id end
			end
			if not uid then DoNotif("Couldn't resolve user",3,"Outfits") return end
		end
	end
	local cache=NAStuff._outfitCache[uid]
	if cache and (time()-cache.t)<120 and cache.list and #cache.list>0 then
		local buttons={}
		for _,o in ipairs(cache.list) do
			Insert(buttons,{Text=Format("%s  (#%d)",o.name,o.id),Callback=function()
				local okD,desc=pcall(Players.GetHumanoidDescriptionFromOutfitId,Players,o.id)
				if not okD or not desc then DoNotif("Failed to fetch outfit",3,"Outfits") return end
				NAStuff.lastSelectedOutfitId=o.id
				if NAmanage._applyFixedDescription then
					NAmanage._applyFixedDescription(desc:Clone(),Players.LocalPlayer.UserId)
				else
					local char=getChar() or Players.LocalPlayer.CharacterAdded:Wait()
					local hum=getHum() or char:WaitForChild("Humanoid",3)
					if not hum then return end
					local blank=InstanceNew("HumanoidDescription");hum:ApplyDescriptionClientServer(blank);Wait();hum:ApplyDescriptionClientServer(desc)
				end
				DoNotif("Outfit applied: "..o.name,2,"Outfits")
			end})
		end
		Window({Title=Format("Outfits • %s (%d) [cache]",tostring(arg),uid),Buttons=buttons})
		return
	end
	local function lowerKeys(t)local r={};for k,v in pairs(t or{})do r[Lower(k)]=v end;return r end
	local function hostOf(url)return Match(url,"^https?://([^/]+)") or"" end
	local function httpJSON(url)
		local host=hostOf(url)
		local cd=NAStuff._httpCooldown[host];if cd and time()<cd then local left=math.max(0,cd-time());DoNotif(Format("Loading outfits… retrying in %.1fs",left),math.max(1.2,left),"Outfits");return false,"cooldown" end
		local okR,resp=pcall(req,{Url=url,Method="GET"})
		local status=okR and (resp.StatusCode or resp.Status) or 0
		local text=okR and (resp.Body or resp.body) or""
		if status==200 and type(text)=="string" then local okJ,data=pcall(HttpService.JSONDecode,HttpService,text);if okJ then NAStuff._httpBackoff[host]=0 return true,data end return false,"bad json" end
		if status==429 then
			local hdrs=lowerKeys(resp and (resp.Headers or resp.headers) or{})
			local ra=tonumber(hdrs["retry-after"]) or tonumber(hdrs["x-ratelimit-retryafter"]) or nil
			local waitSec=math.clamp((ra or (NAStuff._httpBackoff[host] and NAStuff._httpBackoff[host]*2 or 1.5))+math.random()*0.25,1,10)
			NAStuff._httpBackoff[host]=waitSec;NAStuff._httpCooldown[host]=time()+waitSec
			DoNotif(Format("Loading outfits… retrying in %.1fs",waitSec),math.max(1.5,waitSec),"Outfits")
			return false,"429"
		end
		if status>=500 and status<600 then
			local waitSec=math.clamp((NAStuff._httpBackoff[host] and NAStuff._httpBackoff[host]*1.5 or 1.0)+math.random()*0.2,0.8,8)
			NAStuff._httpBackoff[host]=waitSec;NAStuff._httpCooldown[host]=time()+waitSec
			DoNotif(Format("Loading outfits… retrying in %.1fs",waitSec),math.max(1.5,waitSec),"Outfits")
			return false,"5xx"
		end
		return false,"bad response "..tostring(status)
	end
	local outfits,cursor={},nil
	repeat
		local url=Format("https://avatar.roblox.com/v1/users/%d/outfits?itemsPerPage=50%s",uid,cursor and("&cursor="..HttpService:UrlEncode(cursor)) or"")
		local okD,data=httpJSON(url)
		if not okD then if data=="429" or data=="5xx" or data=="cooldown" then return else DoNotif(data,3,"Outfits") return end end
		for _,it in ipairs(data.data or{})do if it and it.id and it.name and it.isEditable==true then Insert(outfits,{id=it.id,name=it.name}) end end
		cursor=data.nextPageCursor
		if cursor then Wait(0.4) end
	until not cursor
	if #outfits==0 then DoNotif("No user-created outfits for that user",2,"Outfits") return end
	NAStuff._outfitCache[uid]={t=time(),list=outfits}
	local buttons={}
	for _,o in ipairs(outfits)do
		Insert(buttons,{Text=Format("%s  (#%d)",o.name,o.id),Callback=function()
			local okD,desc=pcall(Players.GetHumanoidDescriptionFromOutfitId,Players,o.id)
			if not okD or not desc then DoNotif("Failed to fetch outfit",3,"Outfits") return end
			NAStuff.lastSelectedOutfitId=o.id
			if NAmanage._applyFixedDescription then
				NAmanage._applyFixedDescription(desc:Clone(),Players.LocalPlayer.UserId)
			else
				local char=getChar() or Players.LocalPlayer.CharacterAdded:Wait()
				local hum=getHum() or char:WaitForChild("Humanoid",3)
				if not hum then return end
				local blank=InstanceNew("HumanoidDescription");hum:ApplyDescriptionClientServer(blank);Wait();hum:ApplyDescriptionClientServer(desc)
			end
			DoNotif("Outfit applied: "..o.name,2,"Outfits")
		end})
	end
	Window({Title=Format("Outfits • %s (%d)",tostring(arg),uid),Buttons=buttons})
end,true)

cmd.add({"goto","to","tp","teleport"},{"goto <player|X,Y,Z>","Teleport to the given player or X,Y,Z coordinates"},function(...)
	local input   = Concat({...}," ")
	local targets = getPlr(input)
	local char    = getChar()
	if #targets > 0 then
		for _,plr in ipairs(targets) do
			char:PivotTo(plr.Character:GetPivot())
		end
	else
		local x,y,z = input:match("^(%-?%d+%.?%d*)[,%s]+(%-?%d+%.?%d*)[,%s]+(%-?%d+%.?%d*)$")
		if x and y and z then
			char:PivotTo(CFrame.new(tonumber(x),tonumber(y),tonumber(z)))
		else
			DebugNotif("Invalid input: not a valid player or X,Y,Z coordinates",3)
		end
	end
end,true)

function stareFIXER(char, facePos)
	local root = getRoot(char)
	if not root then return end
	local pos = root.Position
	local flatTarget = Vector3.new(facePos.X, pos.Y, facePos.Z)
	if (flatTarget - pos).Magnitude < 0.1 then return end
	root.CFrame = CFrame.new(pos, flatTarget)
end

cmd.add({"lookat", "stare"}, {"lookat <player>", "Stare at a player"}, function(...)
	local Username = (...)
	local Target = getPlr(Username)

	for _, plr in next, Target do
		NAlib.disconnect("stare_direct")

		local lp = Players.LocalPlayer
		if not (lp.Character and getRoot(lp.Character)) then return end
		if not (plr and plr.Character and getRoot(plr.Character)) then return end

		getHum().AutoRotate = false

		local function Stare()
			if lp.Character and plr.Character and getRoot(plr.Character) then
				stareFIXER(lp.Character, getRoot(plr.Character).Position)
			elseif not Players:FindFirstChild(plr.Name) then
				NAlib.disconnect("stare_direct")
			end
		end

		NAlib.connect("stare_direct", RunService.RenderStepped:Connect(Stare))
	end
end, true)

cmd.add({"unlookat", "unstare"}, {"unlookat", "Stops staring"}, function()
	NAlib.disconnect("stare_direct")
	if getHum() then
		getHum().AutoRotate = true
	end
end)

cmd.add({"starenear", "stareclosest"}, {"starenear (stareclosest)", "Stare at the closest player"}, function()
	NAlib.disconnect("stare_nearest")

	local function getClosest()
		local lp = Players.LocalPlayer
		local char = lp.Character
		if not (char and getRoot(char)) then return nil end

		local closest, dist = nil, math.huge
		local pos = getRoot(char).Position
		for _, p in ipairs(Players:GetPlayers()) do
			if p ~= lp and p.Character and getRoot(p.Character) then
				local pPos = getRoot(p.Character).Position
				local d = (pPos - pos).Magnitude
				if d < dist then
					dist = d
					closest = p
				end
			end
		end
		return closest
	end

	local lp = Players.LocalPlayer
	if getHum() then
		getHum().AutoRotate = false
	end

	local function stare()
		local lp = Players.LocalPlayer
		local char = lp.Character
		if not (char and getRoot(char)) then return end
		local target = getClosest()
		if target and target.Character and getRoot(target.Character) then
			stareFIXER(char, getRoot(target.Character).Position)
		end
	end

	NAlib.connect("stare_nearest", RunService.RenderStepped:Connect(stare))
end)

cmd.add({"unstarenear", "unstareclosest"}, {"unstarenear (unstareclosest)", "Stop staring at closest player"}, function()
	NAlib.disconnect("stare_nearest")
	if getHum() then
		getHum().AutoRotate = true
	end
end)

local specUI = nil
local connStep, connAdd, connRemove = nil, nil, nil

function cleanup()
	NAlib.disconnect("spectate_char")
	NAlib.disconnect("spectate_loop")
	NAlib.disconnect("spectate_leave")
	if connStep then connStep:Disconnect() connStep = nil end
	if connAdd then connAdd:Disconnect() connAdd = nil end
	if connRemove then connRemove:Disconnect() connRemove = nil end
	if specUI then specUI:Destroy() specUI = nil end
	local hum = getHum()
	local cam = workspace.CurrentCamera
	if hum then cam.CameraSubject = hum end
end

function spectatePlayer(targetPlayer)
	if not targetPlayer then return end
	NAlib.disconnect("spectate_char")
	NAlib.disconnect("spectate_loop")
	NAlib.disconnect("spectate_leave")
	NAlib.connect("spectate_char", targetPlayer.CharacterAdded:Connect(function(character)
		while not getPlrHum(character) do Wait(.1) end
		workspace.CurrentCamera.CameraSubject = getPlrHum(character)
	end))
	NAlib.connect("spectate_leave", Players.PlayerRemoving:Connect(function(player)
		if player == targetPlayer then
			cleanup()
			DebugNotif("Player left - camera reset")
		end
	end))
	local loop = coroutine.create(function()
		while true do
			if getPlrHum(targetPlayer) then
				workspace.CurrentCamera.CameraSubject = getPlrHum(targetPlayer)
			end
			Wait()
		end
	end)
	NAlib.connect("spectate_loop", {
		Disconnect = function()
			if coroutine.status(loop) ~= "dead" then
				coroutine.close(loop)
			end
		end
	})
	coroutine.resume(loop)
end

cmd.add({"watch", "view", "spectate"}, {"watch <Player> (view, spectate)", "Spectate player"}, function(...)
	cleanup()
	local targetPlayer = getPlr((...))
	for _, plr in next, targetPlayer do
		if not plr then return end
		spectatePlayer(plr)
	end
end, true)

cmd.add({"unwatch", "unview"}, {"unwatch (unview)", "Stop spectating"}, function()
	cleanup()
end)

cmd.add({"watch2","view2","spectate2"},{"watch2",""},function()
	NAlib.disconnect("spectate_char")
	NAlib.disconnect("spectate_loop")
	NAlib.disconnect("spectate_leave")

	local LocalPlayer = Players.LocalPlayer
	local PAD = 8
	local CARD_W = IsOnMobile and 0.6 or 0.4
	local CARD_H = IsOnMobile and 62 or 68
	local BTN_H = IsOnMobile and 34 or 32
	local BTN_W_SIDE = IsOnMobile and 58 or 60
	local BTN_W_V = IsOnMobile and 34 or 32
	local BTN_W_X = IsOnMobile and 34 or 32
	local AV_SZ = IsOnMobile and 40 or 42
	local ROW_H = IsOnMobile and 40 or 34
	local HEADER_H = IsOnMobile and 36 or 32

	local ui, card, avatar, nameMain, nameSub, toggleBtn, btnPrev, btnNext, btnClose
	local drop, searchBox, list, listLayout, dropMaxH
	local listOpen, dropdownBusy = false, false
	local dropdownSeq = 0

	local playerList, currentIndex, spectatedPlayer = {}, 1, nil
	local rows = {}
	local searchTerm = ""

	local function insertSorted(plr)
		local n = #playerList
		if n == 0 then Insert(playerList, plr) return 1 end
		local key = Lower(plr.Name)
		local lo, hi, pos = 1, n, n + 1
		while lo <= hi do
			local mid = (lo + hi) // 2
			if Lower(playerList[mid].Name) > key then
				pos = mid
				hi = mid - 1
			else
				lo = mid + 1
			end
		end
		Insert(playerList, pos, plr)
		return pos
	end

	local function removeFromList(plr)
		local i = Discover(playerList, plr)
		if i then table.remove(playerList, i) return i end
	end

	local function cam(p)
		local h = getPlrHum(p)
		if h then workspace.CurrentCamera.CameraSubject = h
		else
			local r = p.Character and (getRoot(p.Character) or p.Character:FindFirstChildWhichIsA("BasePart"))
			if r then workspace.CurrentCamera.CameraSubject = r end
		end
	end

	local function matchesFilter(plr)
		if searchTerm == "" then return true end
		return Find(Lower(nameChecker(plr)), searchTerm, 1, true) ~= nil
	end

	local function setHeader(plr)
		if not plr then
			nameSub.Text = "Spectating"
			nameMain.Text = "None"
			return
		end
		nameSub.Text = "Spectating"
		nameMain.Text = nameChecker(plr)
		nameMain.TextColor3 = (plr == LocalPlayer) and Color3.fromRGB(255,255,0) or Color3.fromRGB(255,255,255)
		avatar.Image = Players:GetUserThumbnailAsync(plr.UserId, Enum.ThumbnailType.HeadShot, Enum.ThumbnailSize.Size420x420)
	end

	local function recolor()
		for _, btn in pairs(rows) do
			local lbl = btn:FindFirstChild("NameLabel")
			if lbl then
				local uid = btn:GetAttribute("uid")
				local plr = Players:GetPlayerByUserId(uid)
				if plr == LocalPlayer then
					lbl.TextColor3 = Color3.fromRGB(255,255,0)
				elseif spectatedPlayer and plr == spectatedPlayer then
					lbl.TextColor3 = Color3.fromRGB(0,162,255)
				else
					lbl.TextColor3 = Color3.fromRGB(255,255,255)
				end
			end
		end
	end

	local function gotoPlayer(plr)
		if not plr then return end
		spectatedPlayer = plr
		currentIndex = Discover(playerList, plr) or currentIndex
		setHeader(plr)
		cam(plr)
		recolor()
	end

	local function gotoIndex(idx)
		if #playerList == 0 then return end
		if idx < 1 then idx = #playerList end
		if idx > #playerList then idx = 1 end
		currentIndex = idx
		gotoPlayer(playerList[currentIndex])
	end

	local function mkRow(plr)
		if not list or rows[plr.UserId] then return end
		local pb = InstanceNew("TextButton")
		pb.Parent = list
		pb.Name = Lower(plr.Name).."|"..tostring(plr.UserId)
		pb.Size = UDim2.new(1, 0, 0, ROW_H)
		pb.BackgroundColor3 = Color3.fromRGB(40,40,40)
		pb.AutoButtonColor = true
		pb.Text = ""
		pb:SetAttribute("uid", plr.UserId)
		local corner = InstanceNew("UICorner", pb) corner.CornerRadius = UDim.new(0, 10)
		local stroke = InstanceNew("UIStroke", pb) stroke.Thickness = 1 stroke.Transparency = 0.6 stroke.Color = Color3.fromRGB(70,70,70)
		local img = InstanceNew("ImageLabel", pb)
		img.Size = UDim2.new(0, ROW_H, 0, ROW_H)
		img.BackgroundTransparency = 1
		img.Image = Players:GetUserThumbnailAsync(plr.UserId, Enum.ThumbnailType.HeadShot, Enum.ThumbnailSize.Size420x420)
		local nameLbl = InstanceNew("TextLabel", pb)
		nameLbl.Name = "NameLabel"
		nameLbl.BackgroundTransparency = 1
		nameLbl.Size = UDim2.new(1, -ROW_H-12, 1, 0)
		nameLbl.Position = UDim2.new(0, ROW_H+12, 0, 0)
		nameLbl.Font = Enum.Font.SourceSansSemibold
		nameLbl.TextScaled = true
		nameLbl.TextXAlignment = Enum.TextXAlignment.Left
		nameLbl.TextColor3 = Color3.fromRGB(255,255,255)
		nameLbl.Text = nameChecker(plr)
		pb.Visible = matchesFilter(plr)
		MouseButtonFix(pb, function()
			gotoPlayer(plr)
		end)
		rows[plr.UserId] = pb
	end

	local function destroyRow(plr)
		local b = rows[plr.UserId]
		if b then b:Destroy() rows[plr.UserId] = nil end
	end

	local function filterRows()
		for uid, btn in pairs(rows) do
			local plr = Players:GetPlayerByUserId(uid)
			if plr then
				btn.Visible = matchesFilter(plr)
			else
				btn.Visible = false
			end
		end
		if drop and list then
			local headerH = HEADER_H + PAD*2
			local contentY = list.AbsoluteCanvasSize.Y
			local target = math.min(headerH + contentY + PAD, dropMaxH)
			drop.Size = UDim2.new(1, 0, 0, target)
		end
	end

	local function safeConnectProp(inst, prop, mySeq, cb)
		if not inst then return end
		local ok, sig = pcall(function() return inst:GetPropertyChangedSignal(prop) end)
		if not ok or not sig then return end
		sig:Connect(function()
			if dropdownSeq ~= mySeq or not drop or not list or inst.Parent == nil then return end
			cb()
		end)
	end

	local function openDropdown()
		if dropdownBusy or listOpen then return end
		dropdownBusy = true
		toggleBtn.Active = false
		toggleBtn.AutoButtonColor = false
		dropdownSeq += 1
		local mySeq = dropdownSeq

		drop = InstanceNew("Frame", card)
		drop.BackgroundColor3 = Color3.fromRGB(34,34,34)
		drop.BorderSizePixel = 0
		drop.Position = UDim2.new(0, 0, 1, PAD)
		drop.Size = UDim2.new(1, 0, 0, 0)
		local dCorner = InstanceNew("UICorner", drop) dCorner.CornerRadius = UDim.new(0, 12)
		local dStroke = InstanceNew("UIStroke", drop) dStroke.Thickness = 1 dStroke.Transparency = 0.6 dStroke.Color = Color3.fromRGB(64,64,64)

		local header = InstanceNew("Frame", drop)
		header.BackgroundTransparency = 1
		header.Size = UDim2.new(1, -PAD*2, 0, HEADER_H)
		header.Position = UDim2.new(0, PAD, 0, PAD)

		searchBox = InstanceNew("TextBox", header)
		searchBox.Size = UDim2.new(1, 0, 1, 0)
		searchBox.BackgroundColor3 = Color3.fromRGB(45,45,45)
		searchBox.TextXAlignment = Enum.TextXAlignment.Left
		searchBox.Font = Enum.Font.SourceSans
		searchBox.TextSize = IsOnMobile and 18 or 16
		searchBox.PlaceholderText = "Type to filter players"
		searchBox.PlaceholderColor3 = Color3.fromRGB(185,185,185)
		searchBox.ClearTextOnFocus = false
		searchBox.Text = searchTerm
		searchBox.TextColor3 = Color3.fromRGB(255,255,255)
		local sCorner = InstanceNew("UICorner", searchBox) sCorner.CornerRadius = UDim.new(0, 8)
		local sStroke = InstanceNew("UIStroke", searchBox) sStroke.Thickness = 1 sStroke.Transparency = 0.6 sStroke.Color = Color3.fromRGB(70,70,70)

		list = InstanceNew("ScrollingFrame", drop)
		list.BackgroundTransparency = 1
		list.BorderSizePixel = 0
		list.Position = UDim2.new(0, PAD, 0, HEADER_H + PAD*2)
		list.Size = UDim2.new(1, -PAD*2, 1, -(HEADER_H + PAD*3))
		list.AutomaticCanvasSize = Enum.AutomaticSize.Y
		list.CanvasSize = UDim2.new(0,0,0,0)
		list.ScrollBarThickness = 8
		list.ClipsDescendants = true
		listLayout = InstanceNew("UIListLayout", list)
		listLayout.SortOrder = Enum.SortOrder.Name
		listLayout.Padding = UDim.new(0, 6)
		local padIn = InstanceNew("UIPadding", list)
		padIn.PaddingLeft = UDim.new(0, 6)
		padIn.PaddingRight = UDim.new(0, 6)
		padIn.PaddingTop = UDim.new(0, 6)
		padIn.PaddingBottom = UDim.new(0, 6)

		local vpY = workspace.CurrentCamera and workspace.CurrentCamera.ViewportSize.Y or 720
		dropMaxH = math.floor(vpY * (IsOnMobile and 0.7 or 0.55))
		local openStart = TweenService:Create(drop, TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {Size = UDim2.new(1, 0, 0, math.min(dropMaxH, (IsOnMobile and 280 or 240)))})
		openStart:Play()

		for _, plr in ipairs(playerList) do
			mkRow(plr)
		end

		filterRows()

		safeConnectProp(searchBox, "Text", mySeq, function()
			searchTerm = Lower(searchBox.Text or "")
			filterRows()
		end)

		safeConnectProp(listLayout, "AbsoluteContentSize", mySeq, function()
			filterRows()
		end)

		toggleBtn.Text = "V"
		toggleBtn.Rotation = 180
		listOpen = true
		dropdownBusy = false
		toggleBtn.Active = true
		toggleBtn.AutoButtonColor = true
	end

	local function closeDropdown()
		if not listOpen and not dropdownBusy then return end
		dropdownSeq += 1
		dropdownBusy = false
		toggleBtn.Active = true
		toggleBtn.AutoButtonColor = true
		toggleBtn.Text = "V"
		toggleBtn.Rotation = 0
		if drop then
			local tClose = TweenService:Create(drop, TweenInfo.new(0.18, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {Size = UDim2.new(1, 0, 0, 0)})
			tClose:Play()
			tClose.Completed:Wait()
			if drop then drop:Destroy() end
		end
		drop, list, listLayout, searchBox = nil, nil, nil, nil
		listOpen = false
		rows = {}
	end

	local function buildCard()
		card = InstanceNew("Frame", ui)
		card.AnchorPoint = Vector2.new(0.5, 1)
		card.Size = UDim2.new(CARD_W, 0, 0, CARD_H)
		card.Position = UDim2.new(0.5, 0, 0.14, 0)
		card.BackgroundColor3 = Color3.fromRGB(24,24,24)
		card.BorderSizePixel = 0
		local cardCorner = InstanceNew("UICorner", card) cardCorner.CornerRadius = UDim.new(0, 12)
		local cardStroke = InstanceNew("UIStroke", card) cardStroke.Thickness = 1 cardStroke.Transparency = 0.5 cardStroke.Color = Color3.fromRGB(60,60,60)
		local grad = InstanceNew("UIGradient", card) grad.Color = ColorSequence.new(Color3.fromRGB(30,30,30), Color3.fromRGB(18,18,18))
		NAgui.draggerV2(card)

		local content = InstanceNew("Frame", card)
		content.BackgroundTransparency = 1
		content.Size = UDim2.new(1, -PAD*2, 1, -PAD*2)
		content.Position = UDim2.new(0, PAD, 0, PAD)

		avatar = InstanceNew("ImageLabel", content)
		avatar.Size = UDim2.new(0, AV_SZ, 0, AV_SZ)
		avatar.Position = UDim2.new(0, 0, 0.5, -AV_SZ/2)
		avatar.BackgroundTransparency = 1
		local avCorner = InstanceNew("UICorner", avatar) avCorner.CornerRadius = UDim.new(1, 0)

		nameSub = InstanceNew("TextLabel", content)
		nameSub.BackgroundTransparency = 1
		nameSub.Position = UDim2.new(0, AV_SZ + PAD, 0, 0)
		nameSub.Size = UDim2.new(1, -(AV_SZ + PAD), 0.45, 0)
		nameSub.Font = Enum.Font.SourceSans
		nameSub.TextScaled = true
		nameSub.TextXAlignment = Enum.TextXAlignment.Left
		nameSub.TextColor3 = Color3.fromRGB(185,185,185)
		nameSub.Text = "Spectating"

		nameMain = InstanceNew("TextLabel", content)
		nameMain.BackgroundTransparency = 1
		nameMain.Position = UDim2.new(0, AV_SZ + PAD, 0.48, 0)
		nameMain.Size = UDim2.new(1, -(AV_SZ + PAD), 0.5, 0)
		nameMain.Font = Enum.Font.SourceSansBold
		nameMain.TextScaled = true
		nameMain.TextXAlignment = Enum.TextXAlignment.Left
		nameMain.TextColor3 = Color3.fromRGB(255,255,255)
		nameMain.Text = ""

		btnPrev = InstanceNew("TextButton", card)
		btnPrev.Size = UDim2.new(0, BTN_W_SIDE, 0, BTN_H)
		btnPrev.AnchorPoint = Vector2.new(1, 0.5)
		btnPrev.Position = UDim2.new(0, -PAD, 0.5, 0)
		btnPrev.BackgroundColor3 = Color3.fromRGB(45,45,45)
		btnPrev.Text = "Prev"
		btnPrev.TextColor3 = Color3.fromRGB(255,255,255)
		btnPrev.Font = Enum.Font.SourceSansBold
		btnPrev.TextSize = IsOnMobile and 16 or 16
		local pc = InstanceNew("UICorner", btnPrev) pc.CornerRadius = UDim.new(0, 10)
		local ps = InstanceNew("UIStroke", btnPrev) ps.Thickness = 1 ps.Transparency = 0.5 ps.Color = Color3.fromRGB(70,70,70)
		MouseButtonFix(btnPrev, function() gotoIndex(currentIndex - 1) end)

		btnNext = InstanceNew("TextButton", card)
		btnNext.Size = UDim2.new(0, BTN_W_SIDE, 0, BTN_H)
		btnNext.AnchorPoint = Vector2.new(0, 0.5)
		btnNext.Position = UDim2.new(1, PAD, 0.5, 0)
		btnNext.BackgroundColor3 = Color3.fromRGB(45,45,45)
		btnNext.Text = "Next"
		btnNext.TextColor3 = Color3.fromRGB(255,255,255)
		btnNext.Font = Enum.Font.SourceSansBold
		btnNext.TextSize = IsOnMobile and 16 or 16
		local nc = InstanceNew("UICorner", btnNext) nc.CornerRadius = UDim.new(0, 10)
		local ns = InstanceNew("UIStroke", btnNext) ns.Thickness = 1 ns.Transparency = 0.5 ns.Color = Color3.fromRGB(70,70,70)
		MouseButtonFix(btnNext, function() gotoIndex(currentIndex + 1) end)

		toggleBtn = InstanceNew("TextButton", card)
		toggleBtn.Size = UDim2.new(0, BTN_W_V, 0, BTN_H)
		toggleBtn.AnchorPoint = Vector2.new(1, 1)
		toggleBtn.Position = UDim2.new(1, PAD, 1, PAD)
		toggleBtn.BackgroundColor3 = Color3.fromRGB(45,45,45)
		toggleBtn.Text = "V"
		toggleBtn.TextColor3 = Color3.fromRGB(255,255,255)
		toggleBtn.Font = Enum.Font.SourceSansBold
		toggleBtn.TextSize = IsOnMobile and 14 or 14
		local vc = InstanceNew("UICorner", toggleBtn) vc.CornerRadius = UDim.new(0, 10)
		local vs = InstanceNew("UIStroke", toggleBtn) vs.Thickness = 1 vs.Transparency = 0.5 vs.Color = Color3.fromRGB(70,70,70)
		MouseButtonFix(toggleBtn, function()
			if listOpen then closeDropdown() else openDropdown() end
		end)

		btnClose = InstanceNew("TextButton", card)
		btnClose.Size = UDim2.new(0, BTN_W_X, 0, BTN_H)
		btnClose.AnchorPoint = Vector2.new(1, 0)
		btnClose.Position = UDim2.new(1, PAD, 0, -PAD)
		btnClose.BackgroundColor3 = Color3.fromRGB(255,60,60)
		btnClose.Text = "X"
		btnClose.TextColor3 = Color3.fromRGB(255,255,255)
		btnClose.Font = Enum.Font.SourceSansBold
		btnClose.TextSize = IsOnMobile and 14 or 14
		local xc = InstanceNew("UICorner", btnClose) xc.CornerRadius = UDim.new(0, 10)
		local xs = InstanceNew("UIStroke", btnClose) xs.Thickness = 1 xs.Transparency = 0.5 xs.Color = Color3.fromRGB(120,30,30)
		MouseButtonFix(btnClose, function()
			NAlib.disconnect("spectate2_step")
			NAlib.disconnect("spectate2_add")
			NAlib.disconnect("spectate2_remove")
			if drop then drop:Destroy() drop=nil end
			listOpen, dropdownBusy = false, false
			cleanup()
		end)
	end

	local function initialRoster()
		table.clear(playerList)
		for _, p in ipairs(Players:GetPlayers()) do
			insertSorted(p)
		end
	end

	initialRoster()
	if #playerList == 0 then return DebugNotif("No players to spectate", 2) end

	ui = InstanceNew("ScreenGui")
	NaProtectUI(ui)
	ui.ResetOnSpawn = false
	ui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
	ui.DisplayOrder = 10

	buildCard()
	specUI = ui
	gotoIndex(1)

	NAlib.connect("spectate2_step", RunService.RenderStepped:Connect(function()
		if spectatedPlayer then cam(spectatedPlayer) end
	end))

	NAlib.connect("spectate2_add", Players.PlayerAdded:Connect(function(plr)
		local wasOpen = listOpen
		local keep = searchTerm
		local prevSel = spectatedPlayer
		insertSorted(plr)
		if wasOpen and list then mkRow(plr) filterRows() end
		if prevSel then
			currentIndex = Discover(playerList, prevSel) or currentIndex
		elseif #playerList > 0 and not prevSel then
			gotoIndex(1)
		end
		searchTerm = keep
	end))

	NAlib.connect("spectate2_remove", Players.PlayerRemoving:Connect(function(plr)
		local wasOpen = listOpen
		local keep = searchTerm
		local prevSel = spectatedPlayer
		local removedIndex = removeFromList(plr)
		if wasOpen and list then destroyRow(plr) filterRows() end
		if prevSel == plr then
			spectatedPlayer = nil
			nameMain.Text = "None"
			local hum = getHum()
			if hum then workspace.CurrentCamera.CameraSubject = hum end
		else
			if prevSel then currentIndex = Discover(playerList, prevSel) or currentIndex end
		end
		searchTerm = keep
	end))
end, true)

cmd.add({"unwatch2","unview2"},{"unwatch2",""},function()
	NAlib.disconnect("spectate2_step")
	NAlib.disconnect("spectate2_add")
	NAlib.disconnect("spectate2_remove")
	cleanup()
	DebugNotif("Spectate stopped", 1.2)
end, true)

cmd.add({"stealaudio","getaudio","steal","logaudio"},{"stealaudio <player>","Save all sounds a player is playing to a file -Cyrus"},function(p)
	Wait(.1)
	local players=getPlr(p)
	if not next(players) then DoNotif("Player not found") return end
	local ids={}
	for _,plr in pairs(players)do
		local char=plr and plr.Character
		if char then
			for _,snd in pairs(char:GetDescendants())do
				if snd:IsA("Sound") and snd.Playing then
					ids[#ids+1]=snd.SoundId
				end
			end
		end
	end
	if #ids>0 then
		setclipboard(Concat(ids,"\n"))
		DebugNotif("Audio links copied.")
	else
		DebugNotif("No audio found.")
	end
end,true)

cmd.add({"follow", "stalk", "walk"}, {"follow <player>", "Follow a player wherever they go"}, function(p)
	NAlib.disconnect("follow")
	local targetPlayers = getPlr(p)
	for _, plr in next, targetPlayers do
		if not plr then
			DoNotif("Player not found or invalid.")
			return
		end
		NAlib.connect("follow", RunService.RenderStepped:Connect(function()
			local target = plr.Character
			if target then
				local hum = getHum()
				local targetPart = getHead(target)
				if hum and targetPart then
					local targetPos = targetPart.Position
					hum:MoveTo(targetPos)
				else
					NAlib.disconnect("follow")
				end
			else
				NAlib.disconnect("follow")
			end
		end))
	end
end, true)

cmd.add({"unfollow", "unstalk", "unwalk", "unpathfind"}, {"unfollow", "Stop all attempts to follow a player"}, function()
	NAlib.disconnect("follow")
end)

PROXIMITY_RADIUS = 15
lastDistances = {}
ISfollowing = false
followTarget = nil
followConnection = nil
flwCharAdd = nil

cmd.add({"autofollow", "autostalk", "proxfollow"}, {"autofollow (autostalk,proxfollow)", "Automatically follow any player who comes close"}, function()
	NAlib.disconnect("autofollow")
	if followConnection then followConnection:Disconnect() followConnection = nil end
	if flwCharAdd then flwCharAdd:Disconnect() flwCharAdd = nil end
	lastDistances = {}
	ISfollowing = false
	followTarget = nil

	NAlib.connect("autofollow", RunService.Stepped:Connect(function()
		if ISfollowing then return end

		local myChar = getChar()
		local myRoot = getRoot(myChar)
		local myHum = getHum()
		if not (myChar and myRoot and myHum) then return end

		for _, plr in ipairs(Players:GetPlayers()) do
			if plr ~= LocalPlayer then
				local char = plr.Character
				local root = getRoot(char)
				if char and root then
					local currentDist = (myRoot.Position - root.Position).Magnitude
					local lastDist = lastDistances[plr]

					if lastDist and lastDist > PROXIMITY_RADIUS and currentDist < PROXIMITY_RADIUS and currentDist < lastDist then
						ISfollowing = true
						followTarget = plr

						local function setupFollow(char)
							local targetRoot = getRoot(char)
							while not targetRoot do Wait(.1) targetRoot=getRoot(char) end

							if followConnection then followConnection:Disconnect() end
							followConnection = RunService.Stepped:Connect(function()
								if myChar and myHum and targetRoot and char and char.Parent then
									myHum:MoveTo(targetRoot.Position)
								else
									if followConnection then followConnection:Disconnect() followConnection = nil end
									if flwCharAdd then flwCharAdd:Disconnect() flwCharAdd = nil end
									ISfollowing = false
									followTarget = nil
								end
							end)

							local hum = getPlrHum(plr)
							if hum then
								hum.Died:Connect(function()
									if followConnection then followConnection:Disconnect() followConnection = nil end
									ISfollowing = false
									followTarget = nil
								end)
							end
						end

						if plr.Character then
							setupFollow(plr.Character)
						end

						if flwCharAdd then flwCharAdd:Disconnect() end
						flwCharAdd = plr.CharacterAdded:Connect(function(newChar)
							Wait(0.1)
							setupFollow(newChar)
						end)

						break
					end

					lastDistances[plr] = currentDist
				end
			end
		end
	end))
end)

cmd.add({"unautofollow", "stopautofollow", "unproxfollow"}, {"unautofollow (stopautofollow,unproxfollow)", "Stop automatically following nearby players"}, function()
	NAlib.disconnect("autofollow")
	if followConnection then followConnection:Disconnect() followConnection = nil end
	if flwCharAdd then flwCharAdd:Disconnect() flwCharAdd = nil end
	lastDistances = {}
	ISfollowing = false
	followTarget = nil
end)

cmd.add({"pathfind"},{"pathfind <player>","Follow a player using the pathfinder API wherever they go"},function(p)
	Wait(.1)
	local players=getPlr(p)
	for _,plr in ipairs(players)do
		if plr then
			NAlib.disconnect("follow")
			local ps=SafeGetService("PathfindingService")
			local lastSrc, lastDst = Vector3.new(), Vector3.new()
			NAlib.connect("follow",RunService.Heartbeat:Connect(function()
				local hum=getHum() local char=getChar() local tgt=plr.Character
				if not(hum and char and tgt and hum.RootPart) then return end
				local src=hum.RootPart.Position
				local dst=(getRoot(tgt) or getHead(tgt)).Position+Vector3.new(0,0,-2)
				if (src-lastSrc).Magnitude>1 or (dst-lastDst).Magnitude>1 then
					lastSrc, lastDst = src, dst
					local path=ps:CreatePath{AgentRadius=2,AgentHeight=5,AgentCanJump=true}
					path:ComputeAsync(src,dst)
					if path.Status~=Enum.PathStatus.NoPath then
						for _,wp in ipairs(path:GetWaypoints())do
							if wp.Action==Enum.PathWaypointAction.Jump then
								if hum:GetState()~=Enum.HumanoidStateType.Freefall and hum.FloorMaterial~=Enum.Material.Air then
									hum:ChangeState(Enum.HumanoidStateType.Jumping)
								end
							end
							hum:MoveTo(wp.Position)
							hum.MoveToFinished:Wait(1)
						end
					end
				end
			end))
		end
	end
end,true)

freezeBTNTOGGLE = nil
isFrozennn = false

cmd.add({"freeze","thaw","anchor","fr"},{"freeze (thaw,anchor,fr)","Freezes your character"}, function(bool)
	local char = getChar()
	if not char then return end

	for _, part in ipairs(char:GetChildren()) do
		if part:IsA("BasePart") then
			part.Anchored = true
		end
	end
	isFrozennn = true

	if IsOnMobile and not bool then
		if freezeBTNTOGGLE then freezeBTNTOGGLE:Destroy() freezeBTNTOGGLE = nil end

		freezeBTNTOGGLE = InstanceNew("ScreenGui")
		local btn = InstanceNew("TextButton")
		local corner = InstanceNew("UICorner")
		local aspect = InstanceNew("UIAspectRatioConstraint")

		NaProtectUI(freezeBTNTOGGLE)
		freezeBTNTOGGLE.ResetOnSpawn = false

		btn.Parent = freezeBTNTOGGLE
		btn.BackgroundColor3 = Color3.fromRGB(0, 170, 0)
		btn.BackgroundTransparency = 0.1
		btn.Position = UDim2.new(0.9, 0, 0.6, 0)
		btn.Size = UDim2.new(0.08, 0, 0.1, 0)
		btn.Font = Enum.Font.GothamBold
		btn.Text = "UNFRZ"
		btn.TextColor3 = Color3.fromRGB(255, 255, 255)
		btn.TextSize = 18
		btn.TextWrapped = true
		btn.Active = true
		btn.TextScaled = true

		corner.CornerRadius = UDim.new(0.2, 0)
		corner.Parent = btn

		aspect.Parent = btn
		aspect.AspectRatio = 1.0

		NAgui.draggerV2(btn)

		MouseButtonFix(btn, function()
			local char = getChar()
			if not char then return end

			for _, part in ipairs(char:GetChildren()) do
				if part:IsA("BasePart") then
					part.Anchored = not isFrozennn
				end
			end

			isFrozennn = not isFrozennn
			btn.Text = isFrozennn and "UNFRZ" or "FRZ"
			btn.BackgroundColor3 = isFrozennn and Color3.fromRGB(0, 170, 0) or Color3.fromRGB(170, 0, 0)
		end)
	end
end)

cmd.add({"unfreeze","unthaw","unanchor","unfr"},{"unfreeze (unthaw,unanchor,unfr)","Unfreezes your character"}, function()
	local char = getChar()
	if not char then return end

	for _, part in ipairs(char:GetChildren()) do
		if part:IsA("BasePart") then
			part.Anchored = false
		end
	end

	isFrozennn = false

	if freezeBTNTOGGLE then
		freezeBTNTOGGLE:Destroy()
		freezeBTNTOGGLE = nil
	end
end)

cmd.add({"blackhole","bhole","bholepull"},{"blackhole","Makes unanchored parts teleport to the black hole"},function()
	if NAlib.isConnected("blackhole_force") then return DebugNotif("Blackhole already exists.") end

	local UIS=SafeGetService("UserInputService")
	local Mouse=LocalPlayer:GetMouse()
	local Folder=InstanceNew("Folder",workspace)
	local Part=InstanceNew("Part",Folder)
	local Attachment1=InstanceNew("Attachment",Part)
	Part.Anchored=true Part.CanCollide=false Part.Transparency=1

	local Updated=Mouse.Hit+Vector3.new(0,5,0)
	_G.BlackholeAttachment=Attachment1
	_G.BlackholeTarget=Updated
	_G.BlackholeActive=false

	NAlib.connect("blackhole_sim",RunService.RenderStepped:Connect(function()
		settings().Physics.AllowSleep=false
		for _,plr in next,Players:GetPlayers() do
			if plr~=LocalPlayer then NACaller(function()
					plr.MaximumSimulationRadius=0
					opt.hiddenprop(plr,"SimulationRadius",0)
				end) end
		end
		NACaller(function()
			LocalPlayer.MaximumSimulationRadius=1e9
			opt.hiddenprop(LocalPlayer,"SimulationRadius",1e9)
		end)
	end))

	NAlib.connect("blackhole_pos",RunService.RenderStepped:Connect(function()
		if _G.BlackholeAttachment then
			_G.BlackholeAttachment.WorldCFrame=_G.BlackholeTarget
		end
	end))

	local function ForcePart(v)
		if not _G.BlackholeActive then return end
		if v:IsA("Part") and not v.Anchored and not v.Parent:FindFirstChildWhichIsA("Humanoid") and not v.Parent:FindFirstChild("Head") and v.Name~="Handle" then
			for _,x in next,v:GetChildren() do
				if x:IsA("BodyMover") or x:IsA("RocketPropulsion") then x:Destroy() end
			end
			for _,n in next,{"Attachment","AlignPosition","Torque"} do local i=v:FindFirstChild(n) if i then i:Destroy() end end
			v.CanCollide=false
			local a2=InstanceNew("Attachment",v)
			local align=InstanceNew("AlignPosition",v)
			local torque=InstanceNew("Torque",v)
			align.Attachment0=a2 align.Attachment1=_G.BlackholeAttachment
			align.MaxForce=1e9 align.MaxVelocity=math.huge align.Responsiveness=200
			torque.Attachment0=a2 torque.Torque=Vector3.new(100000,100000,100000)
		end
	end

	for _,v in next,workspace:GetDescendants() do ForcePart(v) end
	NAlib.connect("blackhole_force",workspace.DescendantAdded:Connect(ForcePart))

	UIS.InputBegan:Connect(function(k,chat)
		if k.KeyCode==Enum.KeyCode.E and not chat then
			_G.BlackholeTarget=Mouse.Hit+Vector3.new(0,5,0)
		end
	end)

	local sGUI=InstanceNew("ScreenGui")
	NaProtectUI(sGUI)

	local toggleBtn=InstanceNew("TextButton",sGUI)
	local toggleCorner=InstanceNew("UICorner",toggleBtn)
	toggleBtn.Text="Enable Blackhole"
	toggleBtn.AnchorPoint=Vector2.new(0.5,0)
	toggleBtn.Size=UDim2.new(0,160,0,40)
	toggleBtn.Position=UDim2.new(0.5,0,0.88,0)
	toggleBtn.BackgroundColor3=Color3.new(0.15,0.15,0.15)
	toggleBtn.TextColor3=Color3.new(1,1,1)
	toggleBtn.Font=Enum.Font.SourceSansBold
	toggleBtn.TextSize=18
	toggleCorner.CornerRadius=UDim.new(0.25,0)

	MouseButtonFix(toggleBtn,function()
		_G.BlackholeActive=not _G.BlackholeActive
		toggleBtn.Text=_G.BlackholeActive and "Disable Blackhole" or "Enable Blackhole"
		if not _G.BlackholeActive then
			for _,p in ipairs(workspace:GetDescendants()) do
				if p:IsA("BasePart") and not p.Anchored then
					for _,o in ipairs(p:GetChildren()) do
						if o:IsA("AlignPosition") or o:IsA("Torque") or o:IsA("Attachment") then o:Destroy() end
					end
				end
			end
			DebugNotif("Blackhole force disabled",2)
		else
			for _,v in next,workspace:GetDescendants() do ForcePart(v) end
			DebugNotif("Blackhole force enabled",2)
		end
	end)

	local moveBtn=InstanceNew("TextButton",sGUI)
	local moveCorner=InstanceNew("UICorner",moveBtn)
	moveBtn.Text="Move Blackhole"
	moveBtn.AnchorPoint=Vector2.new(0.5,0)
	moveBtn.Size=UDim2.new(0,160,0,40)
	moveBtn.Position=UDim2.new(0.5,0,0.94,0)
	moveBtn.BackgroundColor3=Color3.new(0.2,0.2,0.2)
	moveBtn.TextColor3=Color3.new(1,1,1)
	moveBtn.Font=Enum.Font.SourceSansBold
	moveBtn.TextSize=18
	moveCorner.CornerRadius=UDim.new(0.25,0)

	MouseButtonFix(moveBtn,function()
		_G.BlackholeTarget=Mouse.Hit+Vector3.new(0,5,0)
	end)

	NAgui.draggerV2(toggleBtn)
	NAgui.draggerV2(moveBtn)

	DebugNotif("Blackhole created. Tap button or press E to move",3)
end,true)

cmd.add({"disableanimations","disableanims"},{"disableanimations (disableanims)","Freezes your animations"},function()
	getChar().Animate.Disabled=true
end)

cmd.add({"undisableanimations","undisableanims"},{"undisableanimations (undisableanims)","Unfreezes your animations"},function()
	getChar().Animate.Disabled=false
end)

cmd.add({"hatresize"},{"hatresize","Makes your hats very big r15 only"},function()
	Wait();

	DebugNotif("Hat resize loaded, rthro needed")

	loadstring(game:HttpGet('https://raw.githubusercontent.com/DigitalityScripts/roblox-scripts/refs/heads/main/Patched/hat%20resize'))()
end)

cmd.add({"exit"},{"exit","Close down pedoblox"},function()
	game:Shutdown()
end)

cmd.add({"firekey","fkey"},{"firekey <key> (fkey)","makes you fire a keybind using VirtualInputManager"},function(...)
	local vim=SafeGetService("VirtualInputManager");
	local input = (...)
	local keyMap = {
		["leftcontrol"] = Enum.KeyCode.LeftControl,
		["rightcontrol"] = Enum.KeyCode.RightControl,
		["leftshift"] = Enum.KeyCode.LeftShift,
		["rightshift"] = Enum.KeyCode.RightShift,
		["leftalt"] = Enum.KeyCode.LeftAlt,
		["rightalt"] = Enum.KeyCode.RightAlt,
		["space"] = Enum.KeyCode.Space,
		["tab"] = Enum.KeyCode.Tab,
		["escape"] = Enum.KeyCode.Escape,
		["enter"] = Enum.KeyCode.Return,
		["backspace"] = Enum.KeyCode.Backspace
	}

	local keyCode

	if keyMap[input:lower()] then
		keyCode = keyMap[input:lower()]
	else
		keyCode = Enum.KeyCode[input:upper()]
	end

	if keyCode then
		vim:SendKeyEvent(true, keyCode, 0, game)
		vim:SendKeyEvent(false, keyCode, 0, game)
	end
end,true)

LOOPPROTECT = nil

cmd.add({"loopfling"}, {"loopfling <player>", "Loop voids a player"}, function(plr)
	local Targets = {plr}
	Loopvoid = false
	Loopvoid = true
	repeat Wait()
		local mouse = LocalPlayer:GetMouse()
		local Players = game.GetService(game,"Players")
		local Player = Players.LocalPlayer
		local AllBool = false
		local GetPlayer = function(Name)
			Name = Name:lower()
			if Name == "all" or Name == "others" then
				AllBool = true
				return
			elseif Name == "random" then
				local GetPlayers = Players:GetPlayers()
				if Discover(GetPlayers, Player) then table.remove(GetPlayers, Discover(GetPlayers, Player)) end
				return GetPlayers[math.random(#GetPlayers)]
			elseif Name ~= "random" and Name ~= "all" and Name ~= "others" then
				for _, x in next, Players:GetPlayers() do
					if x ~= Player then
						if x.Name:lower():match("^"..Name) then
							return x
						elseif x.DisplayName:lower():match("^"..Name) then
							return x
						end
					end
				end
			else
				return
			end
		end
		local SkidFling = function(TargetPlayer)
			if LOOPPROTECT then LOOPPROTECT:Destroy() LOOPPROTECT = nil end
			local Character = Player.Character
			local Humanoid = getPlrHum(Character)
			local HRP = Humanoid and Humanoid.RootPart
			local camera = workspace.CurrentCamera
			LOOPPROTECT = InstanceNew("Part")
			LOOPPROTECT.Size = Vector3.new(1, 1, 1)
			LOOPPROTECT.Transparency = 1
			LOOPPROTECT.CanCollide = false
			LOOPPROTECT.Anchored = false
			LOOPPROTECT.Parent = camera
			local weld = InstanceNew("WeldConstraint")
			weld.Part0 = HRP
			weld.Part1 = LOOPPROTECT
			weld.Parent = LOOPPROTECT
			local bodyGyro = InstanceNew("BodyGyro")
			bodyGyro.MaxTorque = Vector3.new(400000, 400000, 400000)
			bodyGyro.D = 1000
			bodyGyro.P = 2000
			bodyGyro.Parent = LOOPPROTECT
			local RootPart = HRP
			local TCharacter = TargetPlayer.Character
			local THumanoid, TRootPart, THead, Accessory, Handle
			if not TCharacter then if LOOPPROTECT then LOOPPROTECT:Destroy() LOOPPROTECT = nil end return end
			if getPlrHum(TCharacter) then
				THumanoid = getPlrHum(TCharacter)
			end
			if THumanoid and THumanoid.RootPart then
				TRootPart = THumanoid.RootPart
			end
			if getHead(TCharacter) then
				THead = getHead(TCharacter)
			end
			if TCharacter:FindFirstChildOfClass("Accessory") then
				Accessory = TCharacter:FindFirstChildOfClass("Accessory")
			end
			if Accessory and Accessory:FindFirstChild("Handle") then
				Handle = Accessory.Handle
			end
			if Character and Humanoid and HRP then
				if not flingManager.lFlingOldPos or RootPart.Velocity.Magnitude < 50 then
					flingManager.lFlingOldPos = RootPart.CFrame
				end
				if THumanoid and THumanoid.Sit and not AllBool then
					return
				end
				if THead then
					workspace.CurrentCamera.CameraSubject = THead
				elseif not THead and Handle then
					workspace.CurrentCamera.CameraSubject = Handle
				elseif THumanoid and TRootPart then
					workspace.CurrentCamera.CameraSubject = THumanoid
				end
				if not TCharacter:FindFirstChildWhichIsA("BasePart") then
					return
				end
				local FPos = function(BasePart, Pos, Ang)
					RootPart.CFrame = CFrame.new(BasePart.Position) * Pos * Ang
					Character:SetPrimaryPartCFrame(CFrame.new(BasePart.Position) * Pos * Ang)
					RootPart.Velocity = Vector3.new(9e7, 9e7 * 10, 9e7)
					RootPart.RotVelocity = Vector3.new(9e8, 9e8, 9e8)
				end
				local SFBasePart = function(BasePart)
					local TimeToWait = 2
					local Time = tick()
					local Angle = 0
					repeat
						if RootPart and THumanoid then
							if BasePart.Velocity.Magnitude < 50 then
								Angle = Angle + 100
								FPos(BasePart, CFrame.new(0, 1.5, 0) + THumanoid.MoveDirection * BasePart.Velocity.Magnitude / 1.25, CFrame.Angles(math.rad(Angle), 0, 0))
								Wait()
								FPos(BasePart, CFrame.new(0, -1.5, 0) + THumanoid.MoveDirection * BasePart.Velocity.Magnitude / 1.25, CFrame.Angles(math.rad(Angle), 0, 0))
								Wait()
								FPos(BasePart, CFrame.new(2.25, 1.5, -2.25) + THumanoid.MoveDirection * BasePart.Velocity.Magnitude / 1.25, CFrame.Angles(math.rad(Angle), 0, 0))
								Wait()
								FPos(BasePart, CFrame.new(-2.25, -1.5, 2.25) + THumanoid.MoveDirection * BasePart.Velocity.Magnitude / 1.25, CFrame.Angles(math.rad(Angle), 0, 0))
								Wait()
								FPos(BasePart, CFrame.new(0, 1.5, 0) + THumanoid.MoveDirection, CFrame.Angles(math.rad(Angle), 0, 0))
								Wait()
								FPos(BasePart, CFrame.new(0, -1.5, 0) + THumanoid.MoveDirection, CFrame.Angles(math.rad(Angle), 0, 0))
								Wait()
							else
								FPos(BasePart, CFrame.new(0, 1.5, THumanoid.WalkSpeed), CFrame.Angles(math.rad(90), 0, 0))
								Wait()
								FPos(BasePart, CFrame.new(0, -1.5, -THumanoid.WalkSpeed), CFrame.Angles(0, 0, 0))
								Wait()
								FPos(BasePart, CFrame.new(0, 1.5, THumanoid.WalkSpeed), CFrame.Angles(math.rad(90), 0, 0))
								Wait()
								FPos(BasePart, CFrame.new(0, 1.5, TRootPart.Velocity.Magnitude / 1.25), CFrame.Angles(math.rad(90), 0, 0))
								Wait()
								FPos(BasePart, CFrame.new(0, -1.5, -TRootPart.Velocity.Magnitude / 1.25), CFrame.Angles(0, 0, 0))
								Wait()
								FPos(BasePart, CFrame.new(0, 1.5, TRootPart.Velocity.Magnitude / 1.25), CFrame.Angles(math.rad(90), 0, 0))
								Wait()
								FPos(BasePart, CFrame.new(0, -1.5, 0), CFrame.Angles(math.rad(90), 0, 0))
								Wait()
								FPos(BasePart, CFrame.new(0, -1.5, 0), CFrame.Angles(0, 0, 0))
								Wait()
								FPos(BasePart, CFrame.new(0, -1.5, 0), CFrame.Angles(math.rad(-90), 0, 0))
								Wait()
								FPos(BasePart, CFrame.new(0, -1.5, 0), CFrame.Angles(0, 0, 0))
								Wait()
							end
						else
							break
						end
					until BasePart.Velocity.Magnitude > 500 or BasePart.Parent ~= TargetPlayer.Character or TargetPlayer.Parent ~= Players or not TargetPlayer.Character == TCharacter or THumanoid.Sit or Humanoid.Health <= 0 or tick() > Time + TimeToWait
					if LOOPPROTECT then LOOPPROTECT:Destroy() LOOPPROTECT = nil end
				end
				workspace.FallenPartsDestroyHeight = 0/0
				local BV = InstanceNew("BodyVelocity")
				BV.Parent = RootPart
				BV.Velocity = Vector3.new(9e8, 9e8, 9e8)
				BV.MaxForce = Vector3.new(1/0, 1/0, 1/0)
				Humanoid:SetStateEnabled(Enum.HumanoidStateType.Seated, false)
				if TRootPart and THead then
					if (TRootPart.CFrame.p - THead.CFrame.p).Magnitude > 5 then
						SFBasePart(THead)
					else
						SFBasePart(TRootPart)
					end
				elseif TRootPart and not THead then
					SFBasePart(TRootPart)
				elseif not TRootPart and THead then
					SFBasePart(THead)
				elseif not TRootPart and not THead and Accessory and Handle then
					SFBasePart(Handle)
				else
					return
				end
				BV:Destroy()
				Humanoid:SetStateEnabled(Enum.HumanoidStateType.Seated, true)
				workspace.CurrentCamera.CameraSubject = Humanoid
				repeat
					RootPart.CFrame = flingManager.lFlingOldPos * CFrame.new(0, 0.5, 0)
					Character:SetPrimaryPartCFrame(flingManager.lFlingOldPos * CFrame.new(0, 0.5, 0))
					Humanoid:ChangeState("GettingUp")
					Foreach(Character:GetChildren(), function(_, x)
						if x:IsA("BasePart") then
							x.Velocity, x.RotVelocity = Vector3.new(), Vector3.new()
						end
					end)
					Wait()
				until (RootPart.Position - flingManager.lFlingOldPos.p).Magnitude < 25
				workspace.FallenPartsDestroyHeight = OrgDestroyHeight
				if LOOPPROTECT then LOOPPROTECT:Destroy() LOOPPROTECT = nil end
			else
				return
			end
		end
		if not getgenv().Welcome then DebugNotif("Enjoy!", 5, "Script by AnthonyIsntHere") end
		getgenv().Welcome = true
		if Targets[1] then for _, x in next, Targets do GetPlayer(x) end else return end
		if AllBool then
			for _, x in next, Players:GetPlayers() do
				SkidFling(x)
			end
		end
		for _, x in next, Targets do
			if GetPlayer(x) and GetPlayer(x) ~= Player then
				if GetPlayer(x).UserId ~= 1414978355 then
					local TPlayer = GetPlayer(x)
					if TPlayer then
						SkidFling(TPlayer)
					end
				end
			elseif not GetPlayer(x) and not AllBool then
			end
		end
	until Loopvoid == false
end, true)

cmd.add({"unloopfling"}, {"unloopfling", "Stops loop flinging a player"}, function()
	Loopvoid = false
	repeat Wait() if LOOPPROTECT then LOOPPROTECT:Destroy() LOOPPROTECT = nil end until LOOPPROTECT == nil
end)

cmd.add({"freegamepass", "freegp"},{"freegamepass (freegp)", "Pretends you own every gamepass and fires product purchase signals"},function()
	local market = SafeGetService("MarketplaceService")
	if not market then
		DoNotif("MarketplaceService is unavailable in this session", 3, "Free Gamepasses")
		return
	end

	if hookfunction and not NAStuff._freeGamepassHooked then
		local ok = pcall(function()
			return hookfunction(market.UserOwnsGamePassAsync, newcclosure(function(...)
				return true
			end))
		end)
		if ok then
			NAStuff._freeGamepassHooked = true
		end
	end

	local totalSignals = 0
	local success, err = pcall(function()
		local pages = market:GetDeveloperProductsAsync()
		while true do
			local page = pages:GetCurrentPage()
			for _, product in ipairs(page) do
				local id = product.ProductId or product.DeveloperProductId
				if id then
					market:SignalPromptProductPurchaseFinished(LocalPlayer.UserId, id, true)
					totalSignals += 1
				end
			end
			if pages.IsFinished then break end
			pages:AdvanceToNextPageAsync()
		end
	end)
	if success then
		DoNotif(Format("Hooked gamepass ownership and fired %d purchase signals", totalSignals), 6, "Free Gamepasses")
	else
		DoNotif("Failed to spoof gamepasses: "..tostring(err), 8, "Free Gamepasses")
	end
end)

NA_DEVPROD_GUI=nil

cmd.add({"devproducts","products"},{"devproducts (products)","Lists Developer Products"},function()
	if NA_DEVPROD_GUI and NA_DEVPROD_GUI.Parent then NA_DEVPROD_GUI:Destroy() end
	local MarketplaceService=SafeGetService("MarketplaceService")
	local GROUP="DevProductsGUI"
	NAlib.disconnect(GROUP)

	local gui=InstanceNew("ScreenGui")
	NAProtection(gui)
	NaProtectUI(gui)
	NA_DEVPROD_GUI=gui

	local shadow=InstanceNew("Frame",gui)
	shadow.BackgroundColor3=Color3.fromRGB(0,0,0)
	shadow.BackgroundTransparency=0.6
	shadow.BorderSizePixel=0
	shadow.Size=UDim2.fromOffset(680,600)
	shadow.ZIndex=0
	local shCorner=InstanceNew("UICorner",shadow); shCorner.CornerRadius=UDim.new(0,26)

	local win=InstanceNew("Frame",gui)
	win.BackgroundColor3=Color3.fromRGB(20,20,20)
	win.BorderSizePixel=0
	win.Size=UDim2.fromOffset(680,600)
	win.ZIndex=1
	NAProtection(win)
	NAmanage.centerFrame(win)
	shadow.Position=win.Position
	NAlib.connect(GROUP,win:GetPropertyChangedSignal("Position"):Connect(function() shadow.Position=win.Position end))

	local corner=InstanceNew("UICorner",win)
	corner.CornerRadius=UDim.new(0,26)
	local stroke=InstanceNew("UIStroke",win)
	stroke.Thickness=1
	stroke.Transparency=0.6
	stroke.Color=Color3.fromRGB(255,255,255)

	local top=InstanceNew("Frame",win)
	top.BackgroundColor3=Color3.fromRGB(26,26,26)
	top.Size=UDim2.new(1,0,0,60)
	top.BorderSizePixel=0
	local topCorner=InstanceNew("UICorner",top); topCorner.CornerRadius=UDim.new(0,26)
	local topMask=InstanceNew("Frame",top); topMask.BackgroundTransparency=1; topMask.Size=UDim2.new(1,-24,1,-16); topMask.Position=UDim2.fromOffset(12,8)
	NAgui.draggerV2(win,topMask)

	local title=InstanceNew("TextLabel",top)
	title.BackgroundTransparency=1
	title.Position=UDim2.fromOffset(20,0)
	title.Size=UDim2.new(1,-260,1,0)
	title.Font=Enum.Font.GothamBold
	title.TextXAlignment=Enum.TextXAlignment.Left
	title.TextColor3=Color3.fromRGB(240,240,240)
	title.Text="Developer Products"
	title.TextScaled=true

	local close=InstanceNew("TextButton",top)
	close.Size=UDim2.fromOffset(36,36)
	close.Position=UDim2.new(1,-44,0.5,-18)
	close.Text="X"
	close.Font=Enum.Font.GothamBold
	close.BackgroundColor3=Color3.fromRGB(50,50,50)
	close.TextColor3=Color3.fromRGB(255,255,255)
	close.TextScaled=true
	local closeCorner=InstanceNew("UICorner",close); closeCorner.CornerRadius=UDim.new(0,10)

	local minimize=InstanceNew("TextButton",top)
	minimize.Size=UDim2.fromOffset(36,36)
	minimize.Position=UDim2.new(1,-88,0.5,-18)
	minimize.Text="-"
	minimize.Font=Enum.Font.GothamBold
	minimize.BackgroundColor3=Color3.fromRGB(50,50,50)
	minimize.TextColor3=Color3.fromRGB(255,255,255)
	minimize.TextScaled=true
	local minCorner=InstanceNew("UICorner",minimize); minCorner.CornerRadius=UDim.new(0,10)

	local head=InstanceNew("Frame",win)
	head.BackgroundColor3=Color3.fromRGB(20,20,20)
	head.Position=UDim2.fromOffset(16,68)
	head.Size=UDim2.new(1,-32,0,48)
	head.BorderSizePixel=0
	local headCorner=InstanceNew("UICorner",head); headCorner.CornerRadius=UDim.new(0,16)
	local headStroke=InstanceNew("UIStroke",head); headStroke.Thickness=1; headStroke.Transparency=0.7

	local refresh=InstanceNew("TextButton",head)
	refresh.Size=UDim2.fromOffset(104,34)
	refresh.Position=UDim2.fromOffset(8,7)
	refresh.Text="Refresh"
	refresh.Font=Enum.Font.GothamMedium
	refresh.BackgroundColor3=Color3.fromRGB(56,56,56)
	refresh.TextColor3=Color3.fromRGB(255,255,255)
	refresh.TextScaled=true
	local rCorner=InstanceNew("UICorner",refresh); rCorner.CornerRadius=UDim.new(0,10)

	local search=InstanceNew("TextBox",head)
	search.Size=UDim2.new(1,-372,0,34)
	search.Position=UDim2.fromOffset(120,7)
	search.PlaceholderText="Search by name or ID"
	search.ClearTextOnFocus=false
	search.TextXAlignment=Enum.TextXAlignment.Left
	search.Text=""
	search.Font=Enum.Font.Gotham
	search.BackgroundColor3=Color3.fromRGB(34,34,34)
	search.TextColor3=Color3.fromRGB(230,230,230)
	search.TextScaled=true
	local sCorner=InstanceNew("UICorner",search); sCorner.CornerRadius=UDim.new(0,10)

	local buyAll=InstanceNew("TextButton",head)
	buyAll.Size=UDim2.fromOffset(108,34)
	buyAll.Position=UDim2.new(1,-244,0,7)
	buyAll.Text="Buy All"
	buyAll.Font=Enum.Font.GothamMedium
	buyAll.BackgroundColor3=Color3.fromRGB(70,70,110)
	buyAll.TextColor3=Color3.fromRGB(255,255,255)
	buyAll.TextScaled=true
	local bCorner=InstanceNew("UICorner",buyAll); bCorner.CornerRadius=UDim.new(0,10)

	local interval=InstanceNew("TextBox",head)
	interval.Size=UDim2.fromOffset(120,34)
	interval.Position=UDim2.new(1,-124,0,7)
	interval.PlaceholderText="Interval (s)"
	interval.Text="0.1"
	interval.ClearTextOnFocus=false
	interval.TextXAlignment=Enum.TextXAlignment.Center
	interval.Font=Enum.Font.GothamMedium
	interval.BackgroundColor3=Color3.fromRGB(34,34,34)
	interval.TextColor3=Color3.fromRGB(255,255,255)
	interval.TextScaled=true
	local iCorner=InstanceNew("UICorner",interval); iCorner.CornerRadius=UDim.new(0,10)

	local status=InstanceNew("TextLabel",win)
	status.BackgroundTransparency=1
	status.Size=UDim2.new(1,-32,0,20)
	status.Position=UDim2.fromOffset(16,116)
	status.Font=Enum.Font.Gotham
	status.TextXAlignment=Enum.TextXAlignment.Left
	status.TextColor3=Color3.fromRGB(190,190,190)
	status.Text="Ready."
	status.TextScaled=true

	local body=InstanceNew("Frame",win)
	body.BackgroundColor3=Color3.fromRGB(16,16,16)
	body.Position=UDim2.fromOffset(16,140)
	body.Size=UDim2.new(1,-32,1,-156)
	body.BorderSizePixel=0
	local bodyCorner=InstanceNew("UICorner",body); bodyCorner.CornerRadius=UDim.new(0,22)
	local bodyStroke=InstanceNew("UIStroke",body); bodyStroke.Thickness=1; bodyStroke.Transparency=0.75

	local list=InstanceNew("ScrollingFrame",body)
	list.BackgroundTransparency=1
	list.BorderSizePixel=0
	list.Position=UDim2.fromOffset(10,10)
	list.Size=UDim2.new(1,-20,1,-20)
	list.ScrollBarThickness=6
	list.CanvasSize=UDim2.new()

	local layout=InstanceNew("UIListLayout",list)
	layout.Padding=UDim.new(0,10)
	layout.SortOrder=Enum.SortOrder.LayoutOrder

	local padding=InstanceNew("UIPadding",list)
	padding.PaddingTop=UDim.new(0,2)
	padding.PaddingBottom=UDim.new(0,2)
	padding.PaddingLeft=UDim.new(0,2)
	padding.PaddingRight=UDim.new(0,2)

	local minimized=false
	local fullSize=win.Size
	local miniSize=UDim2.fromOffset(520,140)

	local function notify(m,t) if DoNotif then DoNotif(m,t or 4,"DevProducts") else warn("[DevProducts] "..m) end status.Text=m end
	local function setCanvas() list.CanvasSize=UDim2.fromOffset(0,layout.AbsoluteContentSize.Y+16) end
	NAlib.connect(GROUP,layout:GetPropertyChangedSignal("AbsoluteContentSize"):Connect(setCanvas))

	local loops={}
	local function stopAllLoops() for _,l in pairs(loops) do l.running=false end loops={} end

	NAlib.connect(GROUP,close.MouseButton1Click:Connect(function()
		stopAllLoops()
		NAlib.disconnect(GROUP)
		pcall(gui.Destroy,gui)
		NA_DEVPROD_GUI=nil
	end))

	NAlib.connect(GROUP,minimize.MouseButton1Click:Connect(function()
		if minimized then
			minimized=false
			body.Visible=true
			status.Visible=true
			TweenService:Create(win,TweenInfo.new(0.18,Enum.EasingStyle.Quad,Enum.EasingDirection.Out),{Size=fullSize}):Play()
			TweenService:Create(shadow,TweenInfo.new(0.18,Enum.EasingStyle.Quad,Enum.EasingDirection.Out),{Size=fullSize}):Play()
			minimize.Text="-"
		else
			minimized=true
			body.Visible=false
			status.Visible=false
			TweenService:Create(win,TweenInfo.new(0.18,Enum.EasingStyle.Quad,Enum.EasingDirection.Out),{Size=miniSize}):Play()
			TweenService:Create(shadow,TweenInfo.new(0.18,Enum.EasingStyle.Quad,Enum.EasingDirection.Out),{Size=miniSize}):Play()
			minimize.Text="+"
		end
	end))

	local cam=workspace.CurrentCamera
	if cam then
		NAlib.connect(GROUP,cam:GetPropertyChangedSignal("ViewportSize"):Connect(function()
			NAmanage.centerFrame(win)
			shadow.Position=win.Position
		end))
	end

	local rows={}
	local allItems={}

	local function clearList()
		for _,ch in ipairs(list:GetChildren()) do if ch:IsA("Frame") then ch:Destroy() end end
		table.clear(rows)
		setCanvas()
	end

	local function parseInterval()
		local v=tonumber(interval.Text) or tonumber(Match(interval.Text or "","%d*%.?%d+")) or 0.1
		if v<0 then v=0 end
		return v
	end

	local function makeRow(info)
		local id=info.ProductId
		local row=InstanceNew("Frame",list)
		row.BackgroundColor3=Color3.fromRGB(24,24,24)
		row.BorderSizePixel=0
		row.Size=UDim2.new(1,0,0,90)
		local rCorner=InstanceNew("UICorner",row); rCorner.CornerRadius=UDim.new(0,18)
		local rStroke=InstanceNew("UIStroke",row); rStroke.Thickness=1; rStroke.Transparency=0.75

		local nameL=InstanceNew("TextLabel",row)
		nameL.BackgroundTransparency=1
		nameL.Position=UDim2.fromOffset(14,10)
		nameL.Size=UDim2.new(1,-260,0,32)
		nameL.Font=Enum.Font.GothamMedium
		nameL.TextXAlignment=Enum.TextXAlignment.Left
		nameL.TextColor3=Color3.fromRGB(245,245,245)
		nameL.Text=info.Name or ("Product "..id)
		nameL.TextScaled=true
		nameL.TextWrapped=true

		local sub=InstanceNew("TextLabel",row)
		sub.BackgroundTransparency=1
		sub.Position=UDim2.fromOffset(14,46)
		sub.Size=UDim2.new(1,-260,0,24)
		sub.Font=Enum.Font.Gotham
		sub.TextXAlignment=Enum.TextXAlignment.Left
		sub.TextColor3=Color3.fromRGB(190,190,190)
		sub.Text=Format("ID: %d  •  Price: %s",id,info.PriceInRobux and (info.PriceInRobux.." R$") or "…")
		sub.TextScaled=true
		sub.TextWrapped=true

		local purchase=InstanceNew("TextButton",row)
		purchase.Size=UDim2.fromOffset(112,40)
		purchase.Position=UDim2.new(1,-240,0.5,-20)
		purchase.Font=Enum.Font.GothamBold
		purchase.AutoButtonColor=true
		purchase.TextColor3=Color3.fromRGB(255,255,255)
		purchase.BackgroundColor3=Color3.fromRGB(0,170,127)
		purchase.Text="Purchase"
		purchase.TextScaled=true
		local pCorner=InstanceNew("UICorner",purchase); pCorner.CornerRadius=UDim.new(0,12)

		local loopBtn=InstanceNew("TextButton",row)
		loopBtn.Size=UDim2.fromOffset(112,40)
		loopBtn.Position=UDim2.new(1,-120,0.5,-20)
		loopBtn.Font=Enum.Font.GothamBold
		loopBtn.AutoButtonColor=true
		loopBtn.TextColor3=Color3.fromRGB(255,255,255)
		loopBtn.BackgroundColor3=Color3.fromRGB(80,80,80)
		loopBtn.Text="Loop"
		loopBtn.TextScaled=true
		local lCorner=InstanceNew("UICorner",loopBtn); lCorner.CornerRadius=UDim.new(0,12)

		NAlib.connect(GROUP,purchase.MouseButton1Click:Connect(function()
			MarketplaceService:SignalPromptProductPurchaseFinished(LocalPlayer.UserId, id, true)
		end))
		NAlib.connect(GROUP,loopBtn.MouseButton1Click:Connect(function()
			local l=loops[id]
			if l and l.running then
				l.running=false
				loopBtn.Text="Loop"
				loopBtn.BackgroundColor3=Color3.fromRGB(80,80,80)
			else
				local state={running=true}
				loops[id]=state
				loopBtn.Text="Stop"
				loopBtn.BackgroundColor3=Color3.fromRGB(180,60,60)
				SpawnCall(function()
					while state.running do
						MarketplaceService:SignalPromptProductPurchaseFinished(LocalPlayer.UserId, id, true)
						Wait(parseInterval())
					end
					if loopBtn and loopBtn.Parent then
						loopBtn.Text="Loop"
						loopBtn.BackgroundColor3=Color3.fromRGB(80,80,80)
					end
					loops[id]=nil
				end)
			end
		end))

		rows[id]=row

		SpawnCall(function()
			local ok,pi=pcall(function() return MarketplaceService:GetProductInfo(id,Enum.InfoType.Product) end)
			if ok and type(pi)=="table" and rows[id] and rows[id].Parent then
				nameL.Text=pi.Name or nameL.Text
				sub.Text=Format("ID: %d  •  Price: %s",id,pi.PriceInRobux and (pi.PriceInRobux.." R$") or "—")
				info.Name=pi.Name or info.Name
				info.PriceInRobux=pi.PriceInRobux
				info.Description=pi.Description
			end
		end)

		return row
	end

	local fetching=false
	local function fetchAll()
		if fetching then return end
		fetching=true
		clearList()
		table.clear(allItems)
		notify("Loading developer products…")
		local ok,pagesOrErr=pcall(function() return MarketplaceService:GetDeveloperProductsAsync() end)
		if not ok then notify("Failed to get pages: "..tostring(pagesOrErr),8) fetching=false return end
		local pages=pagesOrErr
		local count=0
		while true do
			local pOk,pRes=pcall(function() return pages:GetCurrentPage() end)
			if not pOk then notify("Page error: "..tostring(pRes),8) break end
			for _,entry in ipairs(pRes) do
				local id=entry.ProductId or entry.DeveloperProductId
				if id then
					local info={ProductId=id,Name=entry.Name}
					Insert(allItems,info)
					makeRow(info)
					count+=1
					Wait()
				end
			end
			if pages.IsFinished then break end
			local aOk,aErr=pcall(function() pages:AdvanceToNextPageAsync() end)
			if not aOk then notify("Advance failed: "..tostring(aErr),8) break end
			Wait()
		end
		table.sort(allItems,function(a,b)
			local an=a.Name and Lower(a.Name) or ""
			local bn=b.Name and Lower(b.Name) or ""
			return an<bn
		end)
		notify(Format("Loaded %d developer product(s).",count))
		setCanvas()
		fetching=false
	end

	local function applyFilter(q)
		q=Lower(q or "")
		for _,info in ipairs(allItems) do
			local row=rows[info.ProductId]
			if row then
				local nameLabel=nil
				for _,c in ipairs(row:GetChildren()) do if c:IsA("TextLabel") then nameLabel=c break end end
				local nameText=nameLabel and nameLabel.Text or ""
				local idStr=tostring(info.ProductId)
				local vis=(q=="" or Find(Lower(nameText),q,1,true)~=nil or Find(idStr,q,1,true)~=nil)
				row.Visible=vis
			end
		end
		setCanvas()
	end

	NAlib.connect(GROUP,search:GetPropertyChangedSignal("Text"):Connect(function() applyFilter(search.Text) end))
	NAlib.connect(GROUP,refresh.MouseButton1Click:Connect(function() search.Text="" fetchAll() end))
	NAlib.connect(GROUP,buyAll.MouseButton1Click:Connect(function()
		if #allItems==0 then return end
		local delayS=parseInterval()
		SpawnCall(function()
			for _,info in ipairs(allItems) do
				MarketplaceService:SignalPromptProductPurchaseFinished(LocalPlayer.UserId, info.ProductId, true)
				Wait(delayS)
			end
		end)
	end))

	fetchAll()
end)

NA_GAMEPASS_GUI=nil

cmd.add({"gamepasses","passes"},{"gamepasses (passes)","Prompt & list Game Passes (manual IDs)"},function()
	if NA_GAMEPASS_GUI and NA_GAMEPASS_GUI.Parent then NA_GAMEPASS_GUI:Destroy() end
	local MarketplaceService=SafeGetService("MarketplaceService")
	local Players=SafeGetService("Players")
	local LocalPlayer=Players.LocalPlayer
	local GROUP="GamePassesGUI"
	NAlib.disconnect(GROUP)

	local gui=InstanceNew("ScreenGui")
	NAProtection(gui)
	NaProtectUI(gui)
	NA_GAMEPASS_GUI=gui

	local shadow=InstanceNew("Frame",gui)
	shadow.BackgroundColor3=Color3.fromRGB(0,0,0)
	shadow.BackgroundTransparency=0.6
	shadow.BorderSizePixel=0
	shadow.Size=UDim2.fromOffset(640,520)
	shadow.ZIndex=0
	local shCorner=InstanceNew("UICorner",shadow); shCorner.CornerRadius=UDim.new(0,22)

	local win=InstanceNew("Frame",gui)
	win.BackgroundColor3=Color3.fromRGB(20,20,20)
	win.BorderSizePixel=0
	win.Size=UDim2.fromOffset(640,520)
	win.ZIndex=1
	NAProtection(win)
	NAmanage.centerFrame(win)
	shadow.Position=win.Position
	NAlib.connect(GROUP,win:GetPropertyChangedSignal("Position"):Connect(function() shadow.Position=win.Position end))

	local corner=InstanceNew("UICorner",win); corner.CornerRadius=UDim.new(0,22)
	local stroke=InstanceNew("UIStroke",win); stroke.Thickness=1; stroke.Transparency=0.6; stroke.Color=Color3.fromRGB(255,255,255)

	local top=InstanceNew("Frame",win)
	top.BackgroundColor3=Color3.fromRGB(26,26,26)
	top.Size=UDim2.new(1,0,0,56)
	top.BorderSizePixel=0
	local topCorner=InstanceNew("UICorner",top); topCorner.CornerRadius=UDim.new(0,22)
	local topMask=InstanceNew("Frame",top); topMask.BackgroundTransparency=1; topMask.Size=UDim2.new(1,-24,1,-16); topMask.Position=UDim2.fromOffset(12,8)
	NAgui.draggerV2(win,topMask)

	local title=InstanceNew("TextLabel",top)
	title.BackgroundTransparency=1
	title.Position=UDim2.fromOffset(20,0)
	title.Size=UDim2.new(1,-200,1,0)
	title.Font=Enum.Font.GothamBold
	title.TextXAlignment=Enum.TextXAlignment.Left
	title.TextColor3=Color3.fromRGB(240,240,240)
	title.Text="Game Passes"
	title.TextScaled=true

	local close=InstanceNew("TextButton",top)
	close.Size=UDim2.fromOffset(36,36)
	close.Position=UDim2.new(1,-44,0.5,-18)
	close.Text="X"
	close.Font=Enum.Font.GothamBold
	close.BackgroundColor3=Color3.fromRGB(50,50,50)
	close.TextColor3=Color3.fromRGB(255,255,255)
	close.TextScaled=true
	local closeCorner=InstanceNew("UICorner",close); closeCorner.CornerRadius=UDim.new(0,10)

	local head=InstanceNew("Frame",win)
	head.BackgroundColor3=Color3.fromRGB(20,20,20)
	head.Position=UDim2.fromOffset(16,64)
	head.Size=UDim2.new(1,-32,0,140)
	head.BorderSizePixel=0
	local headCorner=InstanceNew("UICorner",head); headCorner.CornerRadius=UDim.new(0,14)
	local headStroke=InstanceNew("UIStroke",head); headStroke.Thickness=1; headStroke.Transparency=0.7

	local idBox=InstanceNew("TextBox",head)
	idBox.Size=UDim2.new(1,-16,0,64)
	idBox.Position=UDim2.fromOffset(8,8)
	idBox.PlaceholderText="Paste GamePass IDs (comma / space / newline separated)"
	idBox.ClearTextOnFocus=false
	idBox.TextXAlignment=Enum.TextXAlignment.Left
	idBox.TextYAlignment=Enum.TextYAlignment.Top
	idBox.MultiLine=true
	idBox.Text=""
	idBox.Font=Enum.Font.Gotham
	idBox.BackgroundColor3=Color3.fromRGB(34,34,34)
	idBox.TextColor3=Color3.fromRGB(230,230,230)
	idBox.TextScaled=false
	idBox.TextSize=16
	local idCorner=InstanceNew("UICorner",idBox); idCorner.CornerRadius=UDim.new(0,10)

	local addBtn=InstanceNew("TextButton",head)
	addBtn.Size=UDim2.fromOffset(96,34)
	addBtn.Position=UDim2.fromOffset(8,8+64+8)
	addBtn.Text="Add IDs"
	addBtn.Font=Enum.Font.GothamMedium
	addBtn.BackgroundColor3=Color3.fromRGB(70,110,70)
	addBtn.TextColor3=Color3.fromRGB(255,255,255)
	addBtn.TextScaled=true
	local addCorner=InstanceNew("UICorner",addBtn); addCorner.CornerRadius=UDim.new(0,10)

	local interval=InstanceNew("TextBox",head)
	interval.Size=UDim2.fromOffset(120,34)
	interval.Position=UDim2.new(1,-120,0,8+64+8)
	interval.PlaceholderText="Interval (s)"
	interval.Text="0.5"
	interval.ClearTextOnFocus=false
	interval.TextXAlignment=Enum.TextXAlignment.Center
	interval.Font=Enum.Font.GothamMedium
	interval.BackgroundColor3=Color3.fromRGB(34,34,34)
	interval.TextColor3=Color3.fromRGB(255,255,255)
	interval.TextScaled=true
	local iCorner=InstanceNew("UICorner",interval); iCorner.CornerRadius=UDim.new(0,10)

	local allBtn=InstanceNew("TextButton",head)
	allBtn.Size=UDim2.fromOffset(120,34)
	allBtn.Position=UDim2.new(1,-120-8-120,0,8+64+8)
	allBtn.Text="Prompt All"
	allBtn.Font=Enum.Font.GothamMedium
	allBtn.BackgroundColor3=Color3.fromRGB(70,70,110)
	allBtn.TextColor3=Color3.fromRGB(255,255,255)
	allBtn.TextScaled=true
	local allCorner=InstanceNew("UICorner",allBtn); allCorner.CornerRadius=UDim.new(0,10)

	local search=InstanceNew("TextBox",head)
	search.Size=UDim2.new(1,-8-120-8-120-8-96-16,0,34)
	search.Position=UDim2.fromOffset(8+96+8,8+64+8)
	search.PlaceholderText="Search by name or ID"
	search.ClearTextOnFocus=false
	search.TextXAlignment=Enum.TextXAlignment.Left
	search.Text=""
	search.Font=Enum.Font.Gotham
	search.BackgroundColor3=Color3.fromRGB(34,34,34)
	search.TextColor3=Color3.fromRGB(230,230,230)
	search.TextScaled=true
	local sCorner=InstanceNew("UICorner",search); sCorner.CornerRadius=UDim.new(0,10)

	local status=InstanceNew("TextLabel",win)
	status.BackgroundTransparency=1
	status.Size=UDim2.new(1,-32,0,20)
	status.Position=UDim2.fromOffset(16,208)
	status.Font=Enum.Font.Gotham
	status.TextXAlignment=Enum.TextXAlignment.Left
	status.TextColor3=Color3.fromRGB(190,190,190)
	status.Text="Ready."
	status.TextScaled=true

	local body=InstanceNew("Frame",win)
	body.BackgroundColor3=Color3.fromRGB(16,16,16)
	body.Position=UDim2.fromOffset(16,232)
	body.Size=UDim2.new(1,-32,1,-248)
	body.BorderSizePixel=0
	local bodyCorner=InstanceNew("UICorner",body); bodyCorner.CornerRadius=UDim.new(0,18)
	local bodyStroke=InstanceNew("UIStroke",body); bodyStroke.Thickness=1; bodyStroke.Transparency=0.75

	local list=InstanceNew("ScrollingFrame",body)
	list.BackgroundTransparency=1
	list.BorderSizePixel=0
	list.Position=UDim2.fromOffset(10,10)
	list.Size=UDim2.new(1,-20,1,-20)
	list.ScrollBarThickness=6
	list.CanvasSize=UDim2.new()

	local layout=InstanceNew("UIListLayout",list)
	layout.Padding=UDim.new(0,10)
	layout.SortOrder=Enum.SortOrder.LayoutOrder

	local padding=InstanceNew("UIPadding",list)
	padding.PaddingTop=UDim.new(0,2)
	padding.PaddingBottom=UDim.new(0,2)
	padding.PaddingLeft=UDim.new(0,2)
	padding.PaddingRight=UDim.new(0,2)

	local function notify(m,t) if DoNotif then DoNotif(m,t or 4,"GamePasses") else warn("[GamePasses] "..m) end status.Text=m end
	local function setCanvas() list.CanvasSize=UDim2.fromOffset(0,layout.AbsoluteContentSize.Y+16) end
	NAlib.connect(GROUP,layout:GetPropertyChangedSignal("AbsoluteContentSize"):Connect(setCanvas))
	NAlib.connect(GROUP,close.MouseButton1Click:Connect(function() NAlib.disconnect(GROUP) pcall(gui.Destroy,gui) NA_GAMEPASS_GUI=nil end))

	local function parseInterval()
		local v=tonumber(interval.Text) or tonumber(Match(interval.Text or "","%d*%.?%d+")) or 0.5
		if v<0 then v=0 end
		return v
	end

	local rows={}
	local passList={}
	local allPasses={}

	local function makeRow(id:number, nameText:string?, priceText:string?)
		if rows[id] then return end
		local row=InstanceNew("Frame",list)
		row.BackgroundColor3=Color3.fromRGB(24,24,24)
		row.BorderSizePixel=0
		row.Size=UDim2.new(1,0,0,84)
		local rCorner=InstanceNew("UICorner",row); rCorner.CornerRadius=UDim.new(0,16)
		local rStroke=InstanceNew("UIStroke",row); rStroke.Thickness=1; rStroke.Transparency=0.75

		local nameL=InstanceNew("TextLabel",row)
		nameL.BackgroundTransparency=1
		nameL.Position=UDim2.fromOffset(14,10)
		nameL.Size=UDim2.new(1,-240,0,30)
		nameL.Font=Enum.Font.GothamMedium
		nameL.TextXAlignment=Enum.TextXAlignment.Left
		nameL.TextColor3=Color3.fromRGB(245,245,245)
		nameL.Text=nameText or ("Pass "..id)
		nameL.TextScaled=true
		nameL.TextWrapped=true

		local sub=InstanceNew("TextLabel",row)
		sub.BackgroundTransparency=1
		sub.Position=UDim2.fromOffset(14,44)
		sub.Size=UDim2.new(1,-240,0,24)
		sub.Font=Enum.Font.Gotham
		sub.TextXAlignment=Enum.TextXAlignment.Left
		sub.TextColor3=Color3.fromRGB(190,190,190)
		sub.Text=Format("ID: %d  •  Price: %s",id, priceText or "—")
		sub.TextScaled=true
		sub.TextWrapped=true

		local prompt=InstanceNew("TextButton",row)
		prompt.Size=UDim2.fromOffset(104,38)
		prompt.Position=UDim2.new(1,-220,0.5,-19)
		prompt.Font=Enum.Font.GothamBold
		prompt.AutoButtonColor=true
		prompt.TextColor3=Color3.fromRGB(255,255,255)
		prompt.BackgroundColor3=Color3.fromRGB(0,170,127)
		prompt.Text="Prompt"
		prompt.TextScaled=true
		local pCorner=InstanceNew("UICorner",prompt); pCorner.CornerRadius=UDim.new(0,12)

		local toggleBtn=InstanceNew("TextButton",row)
		toggleBtn.Size=UDim2.fromOffset(104,38)
		toggleBtn.Position=UDim2.new(1,-108,0.5,-19)
		toggleBtn.Font=Enum.Font.GothamBold
		toggleBtn.AutoButtonColor=true
		toggleBtn.TextColor3=Color3.fromRGB(255,255,255)
		toggleBtn.BackgroundColor3=Color3.fromRGB(80,80,80)
		toggleBtn.Text="Queue"
		toggleBtn.TextScaled=true
		local lCorner=InstanceNew("UICorner",toggleBtn); lCorner.CornerRadius=UDim.new(0,12)

		NAlib.connect(GROUP,prompt.MouseButton1Click:Connect(function()
			MarketplaceService:SignalPromptGamePassPurchaseFinished(LocalPlayer,id,true)
		end))
		NAlib.connect(GROUP,toggleBtn.MouseButton1Click:Connect(function()
			local idx=Discover(passList,id)
			if idx then
				table.remove(passList,idx)
				toggleBtn.Text="Queue"
				toggleBtn.BackgroundColor3=Color3.fromRGB(80,80,80)
			else
				Insert(passList,id)
				toggleBtn.Text="Queued"
				toggleBtn.BackgroundColor3=Color3.fromRGB(70,110,70)
			end
		end))

		rows[id]=row
		SpawnCall(function()
			local ok,info=pcall(function() return MarketplaceService:GetProductInfo(id,Enum.InfoType.GamePass) end)
			if ok and type(info)=="table" and rows[id] and rows[id].Parent then
				nameL.Text=info.Name or nameL.Text
				local price=info.PriceInRobux and (tostring(info.PriceInRobux).." R$") or "—"
				sub.Text=Format("ID: %d  •  Price: %s",id,price)
			end
		end)
		setCanvas()
	end

	local function addIdsFromText(text:string)
		local clean=GSub(text or "","[,%s]+"," ")
		local added=0
		for token in clean:gmatch("%S+") do
			local id=tonumber(token)
			if id and not rows[id] then
				Insert(allPasses,{id=id})
				makeRow(id)
				added+=1
				Wait()
			end
		end
		return added
	end

	local function applyFilter(q)
		q=Lower(q or "")
		for id,row in pairs(rows) do
			local nameLabel
			for _,c in ipairs(row:GetChildren()) do if c:IsA("TextLabel") then nameLabel=c break end end
			local nameText=Lower(tostring(nameLabel and nameLabel.Text or ""))
			local idStr=tostring(id)
			row.Visible=(q=="" or (Find(nameText,q,1,true)~=nil) or (Find(idStr,q,1,true)~=nil))
		end
		setCanvas()
	end

	local function promptAllQueued()
		if #passList==0 then return end
		local delayS=parseInterval()
		SpawnCall(function()
			for _,id in ipairs(passList) do
				MarketplaceService:SignalPromptGamePassPurchaseFinished(LocalPlayer,id,true)
				Wait(delayS)
			end
		end)
	end

	NAlib.connect(GROUP,addBtn.MouseButton1Click:Connect(function()
		local n=addIdsFromText(idBox.Text or "")
		if n>0 then
			idBox.Text=""
			if n==1 then
				status.Text="Added 1 pass."
			else
				status.Text=Format("Added %d passes.",n)
			end
		else
			status.Text="No valid IDs."
		end
	end))

	NAlib.connect(GROUP,allBtn.MouseButton1Click:Connect(function() promptAllQueued() end))
	NAlib.connect(GROUP,search:GetPropertyChangedSignal("Text"):Connect(function() applyFilter(search.Text) end))
	NAlib.connect(GROUP,close.MouseButton1Click:Connect(function() NAlib.disconnect(GROUP) pcall(gui.Destroy,gui) NA_GAMEPASS_GUI=nil end))
end)

cmd.add({"listen"}, {"listen <player>", "Listen to your target's voice chat"}, function(plr)
	local trg = getPlr(plr)

	for _, plr in next, trg do
		local Root = getRoot(plr.Character)
		if Root then
			SafeGetService("SoundService"):SetListener(Enum.ListenerType.ObjectPosition, Root)
		end
	end
end,true)

cmd.add({"unlisten"}, {"unlisten", "Stops listening"}, function()
	SafeGetService("SoundService"):SetListener(Enum.ListenerType.Camera)
end)

if IsOnPC then
	cmd.add({"lockmouse", "lockm"}, {"lockmouse2 (lockm2)", "Default Mouse Behaviour (idk any description)"}, function()
		NAgui.doModal(false)
	end)
	cmd.add({"unlockmouse", "unlockm"}, {"unlockmouse2 (unlockm2)", "Unlocks your mouse (fr this time)"}, function()
		NAgui.doModal(true)
	end)
	cmd.add({"lockmouse2", "lockm2"}, {"lockmouse2 (lockm2)", "Locks your mouse in the center"}, function()
		UserInputService.MouseBehavior = Enum.MouseBehavior.LockCenter
	end)

	cmd.add({"unlockmouse2", "unlockm2"}, {"unlockmouse2 (unlockm2)", "Unlocks your mouse"}, function()
		UserInputService.MouseBehavior = Enum.MouseBehavior.Default
	end)
end

platformParts = {}

cmd.add({"headsit"}, {"headsit <player>", "sit on someone's head"}, function(p)
	local ppp = getPlr(p)

	for _, plr in next, ppp do
		if not plr then return end

		local char = getChar()
		local hum = getHum()
		if not hum then return end

		NAlib.disconnect("headsit_follow")
		NAlib.disconnect("headsit_died")

		local charRoot = getRoot(char)
		local target = plr.Character
		if not charRoot or not target then return end

		hum.Sit = true

		NAlib.connect("headsit_died", hum.Died:Connect(function()
			NAlib.disconnect("headsit_follow")
			NAlib.disconnect("headsit_died")
			for _, part in pairs(platformParts) do
				part:Destroy()
			end
			platformParts = {}
		end))

		for _, part in pairs(platformParts) do
			part:Destroy()
		end
		platformParts = {}

		local thick = 1
		local halfWidth = 2
		local halfDepth = 2
		local halfHeight = 3

		local walls = {
			{offset = CFrame.new(0, 0, halfDepth + thick / 500), size = Vector3.new(4, 6, thick)},
			{offset = CFrame.new(0, 0, -(halfDepth + thick / 500)), size = Vector3.new(4, 6, thick)},
			{offset = CFrame.new(halfWidth + thick / 500, 0, 0), size = Vector3.new(thick, 6, 4)},
			{offset = CFrame.new(-(halfWidth + thick / 500), 0, 0), size = Vector3.new(thick, 6, 4)},
			{offset = CFrame.new(0, halfHeight + thick / 500, 0), size = Vector3.new(4, thick, 4)},
			{offset = CFrame.new(0, -(halfHeight + thick / 500), 0), size = Vector3.new(4, thick, 4)}
		}

		for _, wall in ipairs(walls) do
			local part = InstanceNew("Part")
			part.Size = wall.size
			part.Anchored = true
			part.CanCollide = true
			part.Transparency = 1
			part.Parent = workspace
			Insert(platformParts, part)
		end

		NAlib.connect("headsit_follow", RunService.Stepped:Connect(function()
			if not SafeGetService("Players"):FindFirstChild(plr.Name)
				or not plr.Character
				or not getHead(plr.Character)
				or hum.Sit == false then

				NAlib.disconnect("headsit_follow")
				NAlib.disconnect("headsit_died")

				for _, part in pairs(platformParts) do
					part:Destroy()
				end
				platformParts = {}
			else
				local targetHead = getHead(plr.Character)
				charRoot.CFrame = targetHead.CFrame * CFrame.new(0, 1.6, 0.4)

				for i, wall in ipairs(walls) do
					platformParts[i].CFrame = charRoot.CFrame * wall.offset
				end
			end
		end))
	end
end, true)

cmd.add({"unheadsit"}, {"unheadsit", "Stop the headsit command."}, function()
	NAlib.disconnect("headsit_follow")
	NAlib.disconnect("headsit_died")

	for _, part in pairs(platformParts) do
		part:Destroy()
	end
	platformParts = {}

	local char = getChar()
	local hum = getHum()
	if hum then
		hum:ChangeState(Enum.HumanoidStateType.Jumping)
	end
end)

cmd.add({"wallhop"},{"wallhop","wallhop helper"},function()
	local char = getChar()
	local root = getRoot(char)
	local hum = getHum()

	NAlib.disconnect("wallhop_loop")

	local canHop = true

	NAlib.connect("wallhop_loop", RunService.Stepped:Connect(function()
		if not char or not root or not hum or hum.Health <= 0 then
			NAlib.disconnect("wallhop_loop")
			return
		end

		local params = RaycastParams.new()
		params.FilterType = Enum.RaycastFilterType.Blacklist
		params.FilterDescendantsInstances = {char}

		local origin = root.Position + Vector3.new(0, -1, 0)
		local direction = root.CFrame.LookVector * 1.5
		local wallResult = workspace:Raycast(origin, direction, params)

		if wallResult and hum.FloorMaterial == Enum.Material.Air then
			local hitPart = wallResult.Instance
			local topPoint = wallResult.Position + Vector3.new(0, 0.1, 0)
			local upperCheck = workspace:Raycast(topPoint, Vector3.new(0, 2, 0), params)

			if upperCheck and upperCheck.Instance ~= hitPart then
				if root.Velocity.Y < -1 and canHop then
					canHop = false

					local originalYaw = root.Orientation.Y
					local flickAngle = 35 * (math.random(0,1) == 0 and -1 or 1)
					local newYaw = originalYaw + flickAngle

					root.CFrame = CFrame.new(root.Position) * CFrame.Angles(0, math.rad(newYaw), 0)
					hum:ChangeState(Enum.HumanoidStateType.Jumping)

					Delay(0.1, function()
						if root and root.Parent then
							root.CFrame = CFrame.new(root.Position) * CFrame.Angles(0, math.rad(originalYaw), 0)
						end
					end)
				end
			end
		end

		if root.Velocity.Y > 0 then
			canHop = true
		end
	end))
end)

cmd.add({"unwallhop"},{"unwallhop","disable wallhop helper"},function()
	NAlib.disconnect("wallhop_loop")
end)

cmd.add({"jump"},{"jump","jump."},function()
	getHum():ChangeState(Enum.HumanoidStateType.Jumping)
end)

cmd.add({"loopjump","bhop"},{"loopjump (bhop)","Continuously jump."},function()
	NAlib.disconnect("loopjump")
	NAlib.connect("loopjump",RunService.RenderStepped:Connect(function()
		local h=getHum()
		if h and h:GetState()~=Enum.HumanoidStateType.Freefall and h.FloorMaterial~=Enum.Material.Air then
			h:ChangeState(Enum.HumanoidStateType.Jumping)
		end
	end))
end)

cmd.add({"unloopjump","unbhop"},{"unloopjump (unbhop)","Stop continuous jumping."},function()
	NAlib.disconnect("loopjump")
end)

cmd.add({"trussjump","tj","tjump","trussj"},{"trussjump","Boost off trusses when you jump"},function() -- totally didn't stole this idea from FE2 lmao
	NAlib.disconnect("trussjump_spawn") NAlib.disconnect("trussjump_jump")
	local function hook()
		local hm=getHum()
		if not hm then return false end
		NAlib.disconnect("trussjump_jump")
		NAlib.connect("trussjump_jump",hm.Jumping:Connect(function(isJump)
			NACaller(function()
				local char=getChar()
				local rt=char and getRoot(char)
				local h=getHum()
				if isJump and h and rt and h:GetState()==Enum.HumanoidStateType.Jumping then
					h:SetStateEnabled(Enum.HumanoidStateType.Climbing,false)
					local hor=Vector3.new(rt.Velocity.X,0,rt.Velocity.Z)
					rt.Velocity=hor+Vector3.new(0,h.JumpPower*1.1,0)
					Delay(0.2,function() h:SetStateEnabled(Enum.HumanoidStateType.Climbing,true) end)
				end
			end)
		end))
		return true
	end
	local attempts=5
	while attempts>0 and not hook() do
		attempts-=1
		Wait(1)
	end
	if not getHum() then DoNotif("failed to hook to Humanoid",2) end
	NAlib.connect("trussjump_spawn",LocalPlayer.CharacterAdded:Connect(function()
		local attempts2=5
		while attempts2>0 and not hook() do
			attempts2-=1
			Wait(1)
		end
		if not getHum() then DoNotif("failed to hook to Humanoid",2) end
	end))
	DebugNotif("Trussjump enabled",2)
end,true)

cmd.add({"untrussjump","untj","untjump","untrussj"},{"untrussjump","Disable trussjump"},function()
	NAlib.disconnect("trussjump_spawn") NAlib.disconnect("trussjump_jump")
end)

cmd.add({"chattranslate","ctranslate","chatt"},{"chattranslate","the very old chat translator came back after years"},function()
	loadstring(game:HttpGet("https://raw.githubusercontent.com/ltseverydayyou/uuuuuuu/refs/heads/main/translatoooor"))();
end)

standParts = {}

cmd.add({"headstand"}, {"headstand <player>", "Stand on someone's head."}, function(p)
	NAlib.disconnect("headstand_follow")
	NAlib.disconnect("headstand_died")

	local targets = getPlr(p)
	if #targets == 0 then return end

	local plr = targets[1]
	local char = getChar()
	if not char then return end
	local hum = getHum()
	if not hum then return end

	NAlib.connect("headstand_died", hum.Died:Connect(function()
		NAlib.disconnect("headstand_follow")
		NAlib.disconnect("headstand_died")
		for _, part in pairs(standParts) do
			part:Destroy()
		end
		standParts = {}
	end))

	for _, part in pairs(standParts) do
		part:Destroy()
	end
	standParts = {}

	local thick = 1
	local halfWidth = 2
	local halfDepth = 2
	local halfHeight = 3

	local walls = {
		{offset = CFrame.new(0, 0, halfDepth + thick/500), size = Vector3.new(4, 6, thick)},
		{offset = CFrame.new(0, 0, -(halfDepth + thick/500)), size = Vector3.new(4, 6, thick)},
		{offset = CFrame.new(halfWidth + thick/500, 0, 0), size = Vector3.new(thick, 6, 4)},
		{offset = CFrame.new(-(halfWidth + thick/500), 0, 0), size = Vector3.new(thick, 6, 4)},
		{offset = CFrame.new(0, halfHeight + thick/500, 0), size = Vector3.new(4, thick, 4)},
		{offset = CFrame.new(0, -(halfHeight + thick/500), 0), size = Vector3.new(4, thick, 4)}
	}

	for _, wall in ipairs(walls) do
		local part = InstanceNew("Part")
		part.Size = wall.size
		part.Anchored = true
		part.CanCollide = true
		part.Transparency = 1
		part.Parent = workspace
		Insert(standParts, part)
	end

	NAlib.connect("headstand_follow", RunService.Stepped:Connect(function()
		local plrCharacter = plr.Character
		if Players:FindFirstChild(plr.Name) and plrCharacter and getRoot(plrCharacter) and getRoot(char) then
			local charRoot = getRoot(char)
			charRoot.CFrame = getRoot(plrCharacter).CFrame * CFrame.new(0, 4.6, 0.4)
			for i, wall in ipairs(walls) do
				standParts[i].CFrame = charRoot.CFrame * wall.offset
			end
		else
			NAlib.disconnect("headstand_follow")
			NAlib.disconnect("headstand_died")
			for _, part in pairs(standParts) do
				part:Destroy()
			end
			standParts = {}
		end
	end))
end, true)

cmd.add({"unheadstand"}, {"unheadstand", "Stop the headstand command."}, function()
	NAlib.disconnect("headstand_follow")
	NAlib.disconnect("headstand_died")

	for _, part in pairs(standParts) do
		part:Destroy()
	end
	standParts = {}
end)

getgenv().NamelessWs = nil
local loopws = false

cmd.add({"loopwalkspeed", "loopws", "lws"}, {"loopwalkspeed <number> (loopws,lws)", "Loop walkspeed"}, function(...)
	local val = tonumber(...) or 16
	getgenv().NamelessWs = val
	loopws = true

	NAlib.disconnect("loopws_apply")
	NAlib.disconnect("loopws_char")

	local function applyWS()
		local hum = getHum()
		if hum then
			hum.WalkSpeed = val
			NAlib.connect("loopws_apply", hum:GetPropertyChangedSignal("WalkSpeed"):Connect(function()
				if loopws and hum.WalkSpeed ~= val then
					hum.WalkSpeed = val
				end
			end))
		end
	end

	applyWS()

	NAlib.connect("loopws_char", LocalPlayer.CharacterAdded:Connect(function()
		while not getHum() do Wait(.1) end
		if loopws then applyWS() end
	end))
end, true)

cmd.add({"unloopwalkspeed", "unloopws", "unlws"}, {"unloopwalkspeed (unloopws,unlws)", "Disable loop walkspeed"}, function()
	loopws = false
	NAlib.disconnect("loopws_apply")
	NAlib.disconnect("loopws_char")
end)

getgenv().NamelessJP = nil
local loopjp = false

cmd.add({"loopjumppower", "loopjp", "ljp"}, {"loopjumppower <number> (loopjp,ljp)", "Loop JumpPower"}, function(...)
	local val = tonumber(...) or 50
	getgenv().NamelessJP = val
	loopjp = true

	NAlib.disconnect("loopjp_apply")
	NAlib.disconnect("loopjp_char")

	local function applyJP()
		local hum = getHum()
		if not hum then return end

		if hum.UseJumpPower then
			hum.JumpPower = val
			NAlib.connect("loopjp_apply", hum:GetPropertyChangedSignal("JumpPower"):Connect(function()
				if loopjp and hum.JumpPower ~= val then
					hum.JumpPower = val
				end
			end))
		else
			hum.JumpHeight = val
			NAlib.connect("loopjp_apply", hum:GetPropertyChangedSignal("JumpHeight"):Connect(function()
				if loopjp and hum.JumpHeight ~= val then
					hum.JumpHeight = val
				end
			end))
		end
	end

	applyJP()

	NAlib.connect("loopjp_char", LocalPlayer.CharacterAdded:Connect(function()
		while not getHum() do Wait(.1) end
		if loopjp then applyJP() end
	end))
end, true)

cmd.add({"unloopjumppower", "unloopjp", "unljp"}, {"unloopjumppower (unloopjp,unljp)", "Disable loop jump power"}, function()
	loopjp = false
	NAlib.disconnect("loopjp_apply")
	NAlib.disconnect("loopjp_char")
end)

cmd.add({"stopanimations", "stopanims", "stopanim", "noanim"}, {"stopanimations (stopanims,stopanim,noanim)", "Stops running animations"}, function()
	local char = Players.LocalPlayer and Players.LocalPlayer.Character
	local hum = getHum() or (char and char:FindFirstChildOfClass("AnimationController"))
	if not hum then return end

	for _, track in ipairs(hum:GetPlayingAnimationTracks()) do
		track:Stop()
	end
end)

cmd.add({"refreshanimations", "refreshanimation", "refreshanims", "refreshanim"}, {"refreshanimations (refreshanimation,refreshanims,refreshanim)", "Reload character animations"}, function()
	local char=getChar()
	if not char then
		DoNotif("Character unavailable",2)
		return
	end
	local humanoid=char:FindFirstChildOfClass("Humanoid") or char:FindFirstChildOfClass("AnimationController")
	local animate=char:FindFirstChild("Animate")
	if not humanoid or not animate then
		DoNotif("Failed to locate Animate or Humanoid",3)
		return
	end
	animate.Disabled=true
	pcall(function()
		for _,track in ipairs(humanoid:GetPlayingAnimationTracks()) do
			track:Stop()
		end
	end)
	animate.Disabled=false
	DoNotif("Animations refreshed",2)
end)

loopwave = false

cmd.add({"loopwaveat", "loopwat"}, {"loopwaveat <player> (loopwat)", "Wave to a player in a loop"}, function(...)
	loopwave = true
	local playerName = (...)
	local targets = getPlr(playerName)
	for _, plr in next, targets do
		local char = getChar()
		local oldCFrame = getRoot(char).CFrame
		repeat
			Wait(0.2)
			local targetCFrame = getRoot(plr.Character).CFrame
			local waveAnim = InstanceNew("Animation")
			if getHum().RigType == Enum.HumanoidRigType.R15 then
				waveAnim.AnimationId = "rbxassetid://507770239"
			else
				waveAnim.AnimationId = "rbxassetid://128777973"
			end
			getRoot(char).CFrame = targetCFrame * CFrame.new(0, 0, -3)
			local charPos = char.PrimaryPart.Position
			local tpos = getRoot(plr.Character).Position
			local newCFrame = CFrame.new(charPos, Vector3.new(tpos.X, charPos.Y, tpos.Z))
			Players.LocalPlayer.Character:SetPrimaryPartCFrame(newCFrame)
			local wave = getHum():LoadAnimation(waveAnim)
			wave:Play(-1, 5, -1)
			Wait(1.6)
			wave:Stop()
		until not loopwave
		getRoot(char).CFrame = oldCFrame
	end
end, true)

cmd.add({"unloopwaveat", "unloopwat"}, {"unloopwaveat <player> (unloopwat)", "Stops the loopwaveat command"}, function()
	loopwave = false
end)

cmd.add({"tools", "gears"}, {"tools <player> (gears)", "Copies tools from ReplicatedStorage and Lighting"}, function()
	function copyTools(source)
		for _, item in pairs(source:GetDescendants()) do
			if item:IsA('Tool') or item:IsA('HopperBin') then
				item:Clone().Parent = getBp()
			end
		end
	end

	copyTools(Lighting)
	copyTools(ReplicatedStorage)

	Wait()
	DebugNotif("Copied tools from ReplicatedStorage and Lighting", 3)
end)

tviewBillboards = {}
tviewAddConn, tviewRemoveConn = nil, nil
tviewGlobalMode = nil

if toolConnections then
	for _, conn in pairs(toolConnections) do
		pcall(function() if conn and conn.Disconnect then conn:Disconnect() end end)
	end
else
	toolConnections = {}
end

idkwhyididntmakethisbruh = nil

NAmanage.tvCleanupVisual=function(data)
	if data.renderConn then data.renderConn:Disconnect() data.renderConn = nil end
	if data.headConn then data.headConn:Disconnect() data.headConn = nil end
	if data.bb then data.bb:Destroy() data.bb = nil end
	data.container = nil
	data.char = nil
	data.head = nil
	data.lastToolNames = nil
end

NAmanage.tvDetach=function(plr)
	local data = tviewBillboards[plr]
	if not data then return end
	NAmanage.tvCleanupVisual(data)
	if data.charAddedConn then data.charAddedConn:Disconnect() data.charAddedConn = nil end
	if data.charRemovingConn then data.charRemovingConn:Disconnect() data.charRemovingConn = nil end
	if data.ancestryConn then data.ancestryConn:Disconnect() data.ancestryConn = nil end
	tviewBillboards[plr] = nil
end

NAmanage.tvAttach=function(plr, data, char)
	NAmanage.tvCleanupVisual(data)
	if not char or not plr.Parent then return end

	local head = getHead(char)
	if not head then
		if data.headConn then data.headConn:Disconnect() end
		data.headConn = char.ChildAdded:Connect(function(child)
			if child:IsA("BasePart") and child.Name == "Head" then
				if data.headConn then data.headConn:Disconnect() data.headConn = nil end
				NAmanage.tvAttach(plr, data, char)
			end
		end)
		return
	end

	local bb = InstanceNew("BillboardGui")
	bb.Name = "ToolViewDisplay"
	bb.Size = UDim2.new(0, 0, 0, 0)
	bb.StudsOffset = Vector3.new(0, 2.5, 0)
	bb.Adornee = head
	bb.AlwaysOnTop = true
	bb.LightInfluence = 0
	bb.ResetOnSpawn = false
	bb.Parent = head

	local container = InstanceNew("Frame")
	container.BackgroundTransparency = 1
	container.Size = UDim2.new(0, 0, 0, 50)
	container.AutomaticSize = Enum.AutomaticSize.X
	container.ClipsDescendants = false
	container.Parent = bb

	local layout = InstanceNew("UIListLayout")
	layout.FillDirection = Enum.FillDirection.Horizontal
	layout.SortOrder = Enum.SortOrder.LayoutOrder
	layout.Padding = UDim.new(0, 6)
	layout.Parent = container

	local function makeToolBtn(tool)
		local hasImg = tool.TextureId and tool.TextureId ~= ""
		local btn = hasImg and InstanceNew("ImageButton") or InstanceNew("TextButton")
		btn.Size = UDim2.new(0, 50, 0, 50)
		btn.Name = tool.Name
		btn.BackgroundColor3 = Color3.fromRGB(80, 80, 80)
		btn.AutoButtonColor = false
		btn.ZIndex = 5
		InstanceNew("UICorner", btn).CornerRadius = UDim.new(0.2, 0)
		if hasImg then
			btn.Image = tool.TextureId
		else
			btn.Text = tool.Name
			btn.TextScaled = true
			btn.TextColor3 = Color3.new(1, 1, 1)
			btn.Font = Enum.Font.SourceSans
		end
		return btn
	end

	local function refresh()
		for _, child in ipairs(container:GetChildren()) do
			if child:IsA("GuiButton") then child:Destroy() end
		end

		local bp = plr:FindFirstChildOfClass("Backpack") or plr:FindFirstChild("Backpack")
		if bp then
			for _, t in ipairs(bp:GetChildren()) do
				if t:IsA("Tool") then makeToolBtn(t).Parent = container end
			end
		end

		local activeChar = getPlrChar(plr) or plr.Character
		if activeChar then
			for _, t in ipairs(activeChar:GetChildren()) do
				if t:IsA("Tool") then makeToolBtn(t).Parent = container end
			end
		end
	end

	local function getToolNames()
		local names = {}
		local function add(t)
			if t:IsA("Tool") then Insert(names, t.Name) end
		end
		local bp = plr:FindFirstChildOfClass("Backpack") or plr:FindFirstChild("Backpack")
		if bp then
			for _, t in ipairs(bp:GetChildren()) do add(t) end
		end
		local activeChar = getPlrChar(plr) or plr.Character
		if activeChar then
			for _, t in ipairs(activeChar:GetChildren()) do add(t) end
		end
		table.sort(names)
		return names
	end

	refresh()
	data.lastToolNames = getToolNames()

	data.renderConn = RunService.RenderStepped:Connect(function()
		if not plr.Parent then NAmanage.tvCleanupVisual(data) return end
		local activeChar = plr.Character or getPlrChar(plr)
		if activeChar ~= char then NAmanage.tvCleanupVisual(data) return end
		local currentHead = getHead(activeChar)
		if not currentHead then NAmanage.tvCleanupVisual(data) return end
		if currentHead ~= head then
			head = currentHead
			bb.Adornee = head
			bb.Parent = head
		end
		if not head:IsDescendantOf(workspace) then NAmanage.tvCleanupVisual(data) return end

		local currentNames = getToolNames()
		local previous = data.lastToolNames or {}
		local changed = false
		if #currentNames ~= #previous then
			changed = true
		else
			for i = 1, #currentNames do
				if currentNames[i] ~= previous[i] then changed = true break end
			end
		end
		if changed then
			data.lastToolNames = currentNames
			refresh()
		end
		local width = container.AbsoluteSize.X
		local height = container.AbsoluteSize.Y
		bb.Size = UDim2.new(0, width, 0, height)
	end)

	data.bb = bb
	data.container = container
	data.char = char
	data.head = head
end

NAmanage.tvEnsure=function(plr)
	NAmanage.tvDetach(plr)
	if not plr then return end

	local data = {}
	tviewBillboards[plr] = data

	local function onCharAdded(char)
		NAmanage.tvAttach(plr, data, char)
	end

	data.charAddedConn = plr.CharacterAdded:Connect(onCharAdded)
	data.charRemovingConn = plr.CharacterRemoving:Connect(function()
		NAmanage.tvCleanupVisual(data)
	end)
	data.ancestryConn = plr.AncestryChanged:Connect(function(_, parent)
		if not parent then
			NAmanage.tvDetach(plr)
		end
	end)

	onCharAdded(getPlrChar(plr) or plr.Character)
end

cmd.add({"toolview", "tview"}, {"toolview <player> (tview)", "3D tool viewer above a player's head"}, function(...)
	local args = {...}
	local firstArg = args[1]
	local lowerFirst = type(firstArg) == "string" and Lower(firstArg)
	local isGlobal = lowerFirst == "all" or lowerFirst == "others"
	local targets = getPlr(Unpack(args))
	if #targets == 0 and not isGlobal then
		DoNotif("No players found", 2)
		return
	end

	for _, plr in ipairs(targets) do
		if plr and plr.Parent then
			NAmanage.tvEnsure(plr)
		end
	end

	if isGlobal then
		if tviewAddConn then tviewAddConn:Disconnect() end
		if tviewRemoveConn then tviewRemoveConn:Disconnect() end
		tviewGlobalMode = lowerFirst
		tviewAddConn = Players.PlayerAdded:Connect(function(plr)
			if tviewGlobalMode == "others" and plr == Players.LocalPlayer then return end
			NAmanage.tvEnsure(plr)
		end)
		tviewRemoveConn = Players.PlayerRemoving:Connect(function(plr)
			NAmanage.tvDetach(plr)
		end)
	end
end, true)

cmd.add({"untoolview", "untview"}, {"untview <player> (untview)", "Removes the tool viewer above a player's head"}, function(...)
	local args = {...}
	local firstArg = args[1]
	local lowerFirst = type(firstArg) == "string" and Lower(firstArg)
	local targets = getPlr(Unpack(args))
	if #targets == 0 and not (lowerFirst == "all" or lowerFirst == "others") then
		DoNotif("No players found", 2)
		return
	end

	for _, plr in ipairs(targets) do
		NAmanage.tvDetach(plr)
	end

	if lowerFirst == "all" or lowerFirst == "others" or lowerFirst == tviewGlobalMode then
		if tviewAddConn then tviewAddConn:Disconnect() tviewAddConn = nil end
		if tviewRemoveConn then tviewRemoveConn:Disconnect() tviewRemoveConn = nil end
		tviewGlobalMode = nil
	end
end, true)

cmd.add({"toolview2", "tview2"}, {"toolview2 (tview2)", "Live-updating tool viewer"}, function()
	if renderConn then renderConn:Disconnect() end
	if playerAddConn then playerAddConn:Disconnect() end
	if playerRemoveConn then playerRemoveConn:Disconnect() end
	for _, c in pairs(toolConnections) do NACaller(function() if c and c.Disconnect then c:Disconnect() end end) end
	toolConnections = {}

	if idkwhyididntmakethisbruh then idkwhyididntmakethisbruh:Destroy() idkwhyididntmakethisbruh = nil end

	idkwhyididntmakethisbruh = InstanceNew("ScreenGui")
	NaProtectUI(idkwhyididntmakethisbruh)
	idkwhyididntmakethisbruh.Name = "ToolViewGui"
	idkwhyididntmakethisbruh.ZIndexBehavior = Enum.ZIndexBehavior.Sibling

	local main = InstanceNew("Frame")
	main.Name = "Main"
	main.Size = UDim2.new(0.4, 0, 0.5, 0)
	main.Position = UDim2.new(0.5, 0, 0.5, 0)
	main.AnchorPoint = Vector2.new(0.5, 0.5)
	main.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
	main.BorderSizePixel = 0
	main.ZIndex = 10
	main.Active = true
	main.Selectable = true
	main.Parent = idkwhyididntmakethisbruh
	InstanceNew("UICorner", main).CornerRadius = UDim.new(0, 20)

	local topbar = InstanceNew("Frame")
	topbar.Size = UDim2.new(1, 0, 0, 35)
	topbar.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
	topbar.BorderSizePixel = 0
	topbar.ZIndex = 11
	topbar.Active = true
	topbar.Selectable = true
	topbar.Parent = main
	InstanceNew("UICorner", topbar).CornerRadius = UDim.new(0, 8)

	local title = InstanceNew("TextLabel")
	title.Text = "Tool Viewer"
	title.Size = UDim2.new(1, -70, 1, 0)
	title.Position = UDim2.new(0, 10, 0, 0)
	title.BackgroundTransparency = 1
	title.TextColor3 = Color3.new(1, 1, 1)
	title.Font = Enum.Font.SourceSansBold
	title.TextSize = 18
	title.TextXAlignment = Enum.TextXAlignment.Left
	title.ZIndex = 11
	title.Parent = topbar

	local closeBtn = InstanceNew("TextButton")
	closeBtn.Size = UDim2.new(0, 30, 1, 0)
	closeBtn.Position = UDim2.new(1, -35, 0, 0)
	closeBtn.Text = "X"
	closeBtn.Font = Enum.Font.SourceSansBold
	closeBtn.TextSize = 16
	closeBtn.TextColor3 = Color3.new(1, 1, 1)
	closeBtn.BackgroundColor3 = Color3.fromRGB(180, 50, 50)
	closeBtn.ZIndex = 11
	closeBtn.Parent = topbar
	InstanceNew("UICorner", closeBtn).CornerRadius = UDim.new(0, 6)

	local minimizeBtn = InstanceNew("TextButton")
	minimizeBtn.Size = UDim2.new(0, 30, 1, 0)
	minimizeBtn.Position = UDim2.new(1, -70, 0, 0)
	minimizeBtn.Text = "-"
	minimizeBtn.Font = Enum.Font.SourceSansBold
	minimizeBtn.TextSize = 16
	minimizeBtn.TextColor3 = Color3.new(1, 1, 1)
	minimizeBtn.BackgroundColor3 = Color3.fromRGB(80, 80, 80)
	minimizeBtn.ZIndex = 11
	minimizeBtn.Parent = topbar
	InstanceNew("UICorner", minimizeBtn).CornerRadius = UDim.new(0, 6)

	local scroll = InstanceNew("ScrollingFrame")
	scroll.Name = "Content"
	scroll.Size = UDim2.new(1, 0, 1, -35)
	scroll.Position = UDim2.new(0, 0, 0, 35)
	scroll.CanvasSize = UDim2.new(0, 0, 0, 0)
	scroll.ScrollBarThickness = 6
	scroll.BackgroundTransparency = 1
	scroll.BorderSizePixel = 0
	scroll.ZIndex = 10
	scroll.AutomaticCanvasSize = Enum.AutomaticSize.Y
	scroll.Parent = main

	local list = InstanceNew("UIListLayout")
	list.Padding = UDim.new(0, 12)
	list.SortOrder = Enum.SortOrder.LayoutOrder
	list.Parent = scroll

	local sections = {}

	local function disconnectAll(list)
		for i = #list, 1, -1 do
			local conn = list[i]
			NACaller(function()
				if conn and conn.Disconnect then conn:Disconnect() end
			end)
			list[i] = nil
		end
	end

	local function registerConn(store, conn)
		if conn then
			Insert(store, conn)
			Insert(toolConnections, conn)
		end
	end

	local function makeToolBtn(tool)
		local hasImg = tool.TextureId and tool.TextureId ~= ""
		local btn = hasImg and InstanceNew("ImageButton") or InstanceNew("TextButton")
		btn.Size = UDim2.new(0, 50, 0, 50)
		btn.Name = tool.Name
		btn.BackgroundColor3 = Color3.fromRGB(80, 80, 80)
		btn.AutoButtonColor = false
		btn.ZIndex = 10
		InstanceNew("UICorner", btn).CornerRadius = UDim.new(0.2, 0)

		if hasImg then
			btn.Image = tool.TextureId
		else
			btn.Text = tool.Name
			btn.TextScaled = true
			btn.TextColor3 = Color3.new(1, 1, 1)
			btn.Font = Enum.Font.SourceSans
		end

		return btn
	end

	local function updateTools(plr)
		local sec = sections[plr]
		if not sec then return end

		for _, btn in ipairs(sec.Holder:GetChildren()) do
			if btn:IsA("GuiButton") then btn:Destroy() end
		end

		if not plr then return end

		local tools = {}

		local bp = plr:FindFirstChildOfClass("Backpack") or plr:FindFirstChild("Backpack")
		if bp then
			for _, t in ipairs(bp:GetChildren()) do
				if t:IsA("Tool") then Insert(tools, t) end
			end
		end

		local char = plr.Character or getPlrChar(plr)
		if char then
			for _, t in ipairs(char:GetChildren()) do
				if t:IsA("Tool") then Insert(tools, t) end
			end
		end

		table.sort(tools, function(a, b)
			return Lower((a and a.Name) or "") < Lower((b and b.Name) or "")
		end)

		for _, t in ipairs(tools) do
			if t then
				makeToolBtn(t).Parent = sec.Holder
			end
		end
	end

	local function createSection(plr)
		if not plr then return end
		if sections[plr] then
			updateTools(plr)
			return
		end

		local frame = InstanceNew("Frame")
		frame.Size = UDim2.new(1, -10, 0, 100)
		frame.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
		frame.BorderSizePixel = 0
		frame.ZIndex = 10
		frame.Parent = scroll
		InstanceNew("UICorner", frame).CornerRadius = UDim.new(0, 12)

		local name = InstanceNew("TextLabel")
		name.Size = UDim2.new(1, -10, 0, 30)
		name.Position = UDim2.new(0, 5, 0, 5)
		name.BackgroundTransparency = 1
		name.Text = nameChecker(plr)
		name.Font = Enum.Font.SourceSansSemibold
		name.TextSize = 18
		name.TextColor3 = Color3.new(1, 1, 1)
		name.TextXAlignment = Enum.TextXAlignment.Left
		name.ZIndex = 10
		name.Parent = frame

		local holder = InstanceNew("ScrollingFrame")
		holder.Name = "ToolHolder"
		holder.Position = UDim2.new(0, 5, 0, 35)
		holder.Size = UDim2.new(1, -10, 0, 55)
		holder.CanvasSize = UDim2.new(0, 0, 0, 0)
		holder.ScrollBarThickness = 4
		holder.ScrollingDirection = Enum.ScrollingDirection.X
		holder.AutomaticCanvasSize = Enum.AutomaticSize.X
		holder.BackgroundTransparency = 1
		holder.BorderSizePixel = 0
		holder.ZIndex = 10
		holder.Parent = frame

		local hList = InstanceNew("UIListLayout")
		hList.Padding = UDim.new(0, 6)
		hList.FillDirection = Enum.FillDirection.Horizontal
		hList.SortOrder = Enum.SortOrder.LayoutOrder
		hList.Parent = holder

		local sec = {
			Frame = frame,
			Holder = holder,
			charConns = {},
			backpackConns = {},
			playerConns = {}
		}
		sections[plr] = sec

		local function connectBackpack(bp)
			disconnectAll(sec.backpackConns)
			if typeof(bp) ~= "Instance" then return end
			registerConn(sec.backpackConns, bp.ChildAdded:Connect(function(item)
				if item:IsA("Tool") then updateTools(plr) end
			end))
			registerConn(sec.backpackConns, bp.ChildRemoved:Connect(function(item)
				if item:IsA("Tool") then updateTools(plr) end
			end))
		end

		local function connectCharacter(char)
			disconnectAll(sec.charConns)
			if typeof(char) ~= "Instance" then return end
			registerConn(sec.charConns, char.ChildAdded:Connect(function(item)
				if item:IsA("Tool") then updateTools(plr) end
			end))
			registerConn(sec.charConns, char.ChildRemoved:Connect(function(item)
				if item:IsA("Tool") then updateTools(plr) end
			end))
		end

		registerConn(sec.playerConns, plr.ChildAdded:Connect(function(child)
			if typeof(child) == "Instance" and child:IsA("Backpack") then
				connectBackpack(child)
				updateTools(plr)
			end
		end))
		registerConn(sec.playerConns, plr.ChildRemoved:Connect(function(child)
			if typeof(child) == "Instance" and child:IsA("Backpack") then
				disconnectAll(sec.backpackConns)
				updateTools(plr)
			end
		end))
		registerConn(sec.playerConns, plr.CharacterAdded:Connect(function(char)
			connectCharacter(char)
			updateTools(plr)
		end))
		registerConn(sec.playerConns, plr.CharacterRemoving:Connect(function()
			disconnectAll(sec.charConns)
			updateTools(plr)
		end))

		connectBackpack(plr:FindFirstChildOfClass("Backpack") or plr:FindFirstChild("Backpack"))
		connectCharacter(plr.Character or getPlrChar(plr))
		updateTools(plr)
	end

	local function removeSection(plr)
		local sec = sections[plr]
		if not sec then return end
		disconnectAll(sec.charConns)
		disconnectAll(sec.backpackConns)
		disconnectAll(sec.playerConns)
		if sec.Frame then sec.Frame:Destroy() end
		sections[plr] = nil
	end

	local function refreshAll()
		for plr in pairs(sections) do
			if plr and plr.Parent == Players then
				updateTools(plr)
			end
		end
	end

	for _, plr in ipairs(Players:GetPlayers()) do
		createSection(plr)
	end

	renderConn = RunService.RenderStepped:Connect(refreshAll)
	playerAddConn = Players.PlayerAdded:Connect(function(plr)
		createSection(plr)
	end)
	playerRemoveConn = Players.PlayerRemoving:Connect(function(plr)
		removeSection(plr)
	end)

	local minimized = false
	minimizeBtn.MouseButton1Click:Connect(function()
		minimized = not minimized
		scroll.Visible = not minimized
		main.Size = minimized and UDim2.new(0.4, 0, 0.05, 0) or UDim2.new(0.4, 0, 0.5, 0)
	end)

	closeBtn.MouseButton1Click:Connect(function()
		if renderConn then renderConn:Disconnect() end
		if playerAddConn then playerAddConn:Disconnect() end
		if playerRemoveConn then playerRemoveConn:Disconnect() end
		local toRemove = {}
		for plr in pairs(sections) do
			Insert(toRemove, plr)
		end
		for _, plr in ipairs(toRemove) do
			removeSection(plr)
		end
		for _, c in pairs(toolConnections) do NACaller(function() if c and c.Disconnect then c:Disconnect() end end) end
		toolConnections = {}
		if idkwhyididntmakethisbruh then idkwhyididntmakethisbruh:Destroy() idkwhyididntmakethisbruh = nil end
	end)

	NAgui.dragger(main,topbar)
end)


cmd.add({"waveat", "wat"}, {"waveat <player> (wat)", "Wave to a player"}, function(...)
	local playerName = (...)
	local targets = getPlr(playerName)
	if #targets == 0 then return end
	local plr = targets[1]
	local char = getChar()
	local humanoid = getHum()
	local localRoot = getRoot(char)
	local oldCFrame = localRoot.CFrame
	local targetRoot = getRoot(plr.Character)
	if targetRoot then
		localRoot.CFrame = targetRoot.CFrame * CFrame.new(0, 0, -3)
		local charPos = char.PrimaryPart.Position
		local targetHRP = getRoot(plr.Character)
		if targetHRP then
			local newCFrame = CFrame.new(charPos, Vector3.new(targetHRP.Position.X, charPos.Y, targetHRP.Position.Z))
			Players.LocalPlayer.Character:SetPrimaryPartCFrame(newCFrame)
		end
		local waveAnim = InstanceNew("Animation")
		if IsR15() then
			waveAnim.AnimationId = "rbxassetid://507770239"
		else
			waveAnim.AnimationId = "rbxassetid://128777973"
		end
		local wave = humanoid:LoadAnimation(waveAnim)
		wave:Play(-1, 5, -1)
		Wait(1.6)
		wave:Stop()
		localRoot.CFrame = oldCFrame
	end
end, true)

bang, bangAnim, bangLoop, bangDied, bangParts = nil, nil, nil, nil, {}

cmd.add({"headbang", "mouthbang", "headfuck", "mouthfuck", "facebang", "facefuck", "hb", "mb"}, {"headbang <player> (mouthbang,headfuck,mouthfuck,facebang,facefuck,hb,mb)", "Bang them in the mouth because you are gay"}, function(h, d)
	local speed = d or 10
	local username = h
	local players = getPlr(username)
	if #players == 0 then return end
	local plr = players[1]
	bangAnim = InstanceNew("Animation")
	if not IsR15(Players.LocalPlayer) then
		bangAnim.AnimationId = "rbxassetid://148840371"
	else
		bangAnim.AnimationId = "rbxassetid://5918726674"
	end
	local humanoid = getHum()
	if not humanoid then return end
	bang = humanoid:LoadAnimation(bangAnim)
	bang:Play(0.1, 1, 1)
	bang:AdjustSpeed(speed)
	local bangplr = plr.Name
	bangDied = humanoid.Died:Connect(function()
		if bangLoop then
			bangLoop:Disconnect()
		end
		bang:Stop()
		bangAnim:Destroy()
		bangDied:Disconnect()
		for _, part in pairs(bangParts) do
			part:Destroy()
		end
		bangParts = {}
	end)
	for _, part in pairs(bangParts) do
		part:Destroy()
	end
	bangParts = {}
	local thick = 0.2
	local halfWidth = 2
	local halfDepth = 2
	local halfHeight = 3
	local walls = {
		{offset = CFrame.new(0, 0, halfDepth + thick/500), size = Vector3.new(4, 6, thick)},
		{offset = CFrame.new(0, 0, -(halfDepth + thick/500)), size = Vector3.new(4, 6, thick)},
		{offset = CFrame.new(halfWidth + thick/500, 0, 0), size = Vector3.new(thick, 6, 4)},
		{offset = CFrame.new(-(halfWidth + thick/500), 0, 0), size = Vector3.new(thick, 6, 4)},
		{offset = CFrame.new(0, halfHeight + thick/500, 0), size = Vector3.new(4, thick, 4)},
		{offset = CFrame.new(0, -(halfHeight + thick/500), 0), size = Vector3.new(4, thick, 4)}
	}
	for i, wall in ipairs(walls) do
		local part = InstanceNew("Part")
		part.Size = wall.size
		part.Anchored = true
		part.CanCollide = true
		part.Transparency = 1
		part.Parent = workspace
		Insert(bangParts, part)
	end
	local bangOffset = CFrame.new(0, 1, -1.1)
	bangLoop = RunService.Stepped:Connect(function()
		NACaller(function()
			local targetPlayer = Players:FindFirstChild(bangplr)
			if not targetPlayer or not targetPlayer.Character then return end
			local targetCharacter = targetPlayer.Character
			local otherHead = getHead(targetCharacter)
			local localRoot = getRoot(getChar())
			if otherHead and localRoot then
				localRoot.CFrame = otherHead.CFrame * bangOffset
			end
			local charPos = getChar().PrimaryPart.Position
			local targetRoot = getRoot(targetCharacter)
			if targetRoot then
				local newCFrame = CFrame.new(charPos, Vector3.new(targetRoot.Position.X, charPos.Y, targetRoot.Position.Z))
				Players.LocalPlayer.Character:SetPrimaryPartCFrame(newCFrame)
			end
			for i, wall in ipairs(walls) do
				bangParts[i].CFrame = localRoot.CFrame * wall.offset
			end
		end)
	end)
end, true)

cmd.add({"unheadbang", "unmouthbang", "unhb", "unmb"}, {"unheadbang (unmouthbang,unhb,unmb)", "Stops headbang"}, function()
	if bangLoop then
		bangLoop:Disconnect()
		bang:Stop()
		bangAnim:Destroy()
		bangDied:Disconnect()
	end
	for _, part in pairs(bangParts) do
		part:Destroy()
	end
	bangParts = {}
end)

jerkAnim, jerkTrack, jerkLoop, jerkDied, jerkParts = nil, nil, nil, nil, {}

cmd.add({"jerkuser", "jorkuser", "handjob", "hjob", "handj"}, {"jerkuser <player> (jorkuser, handjob, hjob, handj)", "Lay under them and vibe"}, function(h, d)
	if not IsR6() then DoNotif("command requires R6",3) return end
	local username = h
	local players = getPlr(username)
	if #players == 0 then return end
	local plr = players[1]

	local char = getChar()
	if not char then return end

	local humanoid = getHum()
	if not humanoid then return end

	jerkAnim = InstanceNew("Animation")
	jerkAnim.AnimationId = "rbxassetid://95383980"
	jerkTrack = humanoid:LoadAnimation(jerkAnim)
	jerkTrack.Looped = true
	jerkTrack:Play()

	humanoid.Sit = true
	Wait(0.1)

	local root = getRoot(char)
	if not root then return end

	root.CFrame = root.CFrame * CFrame.Angles(math.pi * 0.5, math.pi, 0)

	for _, part in pairs(jerkParts) do
		part:Destroy()
	end
	jerkParts = {}

	local thick = 0.2
	local halfWidth = 2
	local halfDepth = 2
	local halfHeight = 3
	local walls = {
		{offset = CFrame.new(0, 0, halfDepth + thick / 500), size = Vector3.new(4, 6, thick)},
		{offset = CFrame.new(0, 0, -(halfDepth + thick / 500)), size = Vector3.new(4, 6, thick)},
		{offset = CFrame.new(halfWidth + thick / 500, 0, 0), size = Vector3.new(thick, 6, 4)},
		{offset = CFrame.new(-(halfWidth + thick / 500), 0, 0), size = Vector3.new(thick, 6, 4)},
		{offset = CFrame.new(0, halfHeight + thick / 500, 0), size = Vector3.new(4, thick, 4)},
		{offset = CFrame.new(0, -(halfHeight + thick / 500), 0), size = Vector3.new(4, thick, 4)}
	}

	for i, wall in ipairs(walls) do
		local part = InstanceNew("Part")
		part.Size = wall.size
		part.Anchored = true
		part.CanCollide = true
		part.Transparency = 1
		part.Parent = workspace
		Insert(jerkParts, part)
	end

	local jerkOffset = CFrame.new(0, -2.5, -0.25) * CFrame.Angles(math.pi * 0.5, 0, math.pi)
	jerkLoop = RunService.Stepped:Connect(function()
		NACaller(function()
			for i, wall in ipairs(walls) do
				jerkParts[i].CFrame = root.CFrame * wall.offset
			end
			local targetChar = plr.Character
			local targetRoot = targetChar and getRoot(targetChar)
			if targetRoot then
				root.CFrame = targetRoot.CFrame * jerkOffset
			end
		end)
	end)

	jerkDied = humanoid.Died:Connect(function()
		if jerkLoop then jerkLoop:Disconnect() end
		if jerkTrack then jerkTrack:Stop() end
		if jerkAnim then jerkAnim:Destroy() end
		for _, part in pairs(jerkParts) do
			part:Destroy()
		end
		jerkParts = {}
	end)
end, true)

cmd.add({"unjerkuser", "unjorkuser", "unhandjob", "unhjob", "unhandj"}, {"unjerkuser (unjorkuser, unhandjob, unhjob, unhandj)", "Stop the jerk user action"}, function()
	if jerkLoop then jerkLoop:Disconnect() end
	if jerkTrack then jerkTrack:Stop() end
	if jerkAnim then jerkAnim:Destroy() end
	if jerkDied then jerkDied:Disconnect() end

	local char = getChar()
	local root = getRoot(char)
	if root then
		root.CFrame = root.CFrame * CFrame.Angles(0, math.pi, 0)
	end

	local humanoid = getHum()
	if humanoid then
		humanoid.Sit = false
	end

	for _, part in pairs(jerkParts) do
		part:Destroy()
	end
	jerkParts = {}
end)

suckLOOP = nil
suckANIM = nil
suckDIED = nil
doSUCKING = nil
SUCKYSUCKY = {}

cmd.add({"suck","dicksuck"},{"suck <player> <number>","suck it"},function(h,d)
	if suckLOOP then suckLOOP = nil end
	if doSUCKING then doSUCKING:Stop() end
	if suckANIM then suckANIM:Destroy() end
	if suckDIED then suckDIED:Disconnect() end
	for _,p in pairs(SUCKYSUCKY) do p:Destroy() end
	SUCKYSUCKY = {}

	local speed = d or 10
	local tweenDuration = 1/speed
	local tweenInfo = TweenInfo.new(tweenDuration,Enum.EasingStyle.Sine,Enum.EasingDirection.Out)
	local targets = getPlr(h)
	if #targets == 0 then return end
	local plr = targets[1]
	local targetName = plr.Name

	suckANIM = InstanceNew("Animation")
	if not IsR15(Players.LocalPlayer) then
		suckANIM.AnimationId = "rbxassetid://189854234"
	else
		suckANIM.AnimationId = "rbxassetid://5918726674"
	end
	local hum = getHum()
	doSUCKING = hum:LoadAnimation(suckANIM)
	doSUCKING:Play(0.1,1,1)
	doSUCKING:AdjustSpeed(speed)

	suckDIED = hum.Died:Connect(function()
		if suckLOOP then suckLOOP = nil end
		doSUCKING:Stop()
		suckANIM:Destroy()
		suckDIED:Disconnect()
		for _,part in pairs(SUCKYSUCKY) do part:Destroy() end
		SUCKYSUCKY = {}
	end)

	local thick,halfWidth,halfDepth,halfHeight = 0.2,2,2,3
	local walls = {
		{offset=CFrame.new(0,0,halfDepth+thick/500), size=Vector3.new(4,6,thick)},
		{offset=CFrame.new(0,0,-(halfDepth+thick/500)), size=Vector3.new(4,6,thick)},
		{offset=CFrame.new(halfWidth+thick/500,0,0), size=Vector3.new(thick,6,4)},
		{offset=CFrame.new(-(halfWidth+thick/500),0,0), size=Vector3.new(thick,6,4)},
		{offset=CFrame.new(0,halfHeight+thick/500,0), size=Vector3.new(4,thick,4)},
		{offset=CFrame.new(0,-(halfHeight+thick/500),0), size=Vector3.new(4,thick,4)},
	}
	for i,wall in ipairs(walls) do
		local part = InstanceNew("Part")
		part.Size=wall.size
		part.Anchored=true
		part.CanCollide=true
		part.Transparency=1
		part.Parent=workspace
		Insert(SUCKYSUCKY,part)
	end

	suckLOOP = coroutine.wrap(function()
		while true do
			local targetPlayer = Players:FindFirstChild(targetName)
			local targetCharacter = targetPlayer and targetPlayer.Character
			local localCharacter = getChar()
			if targetCharacter and getRoot(targetCharacter) and localCharacter and getRoot(localCharacter) then
				local targetHRP = getRoot(targetCharacter)
				local localHRP = getRoot(localCharacter)
				local forwardCFrame = targetHRP.CFrame * CFrame.new(0,-2.3,-2.5) * CFrame.Angles(0,math.pi,0)
				local backwardCFrame = targetHRP.CFrame * CFrame.new(0,-2.3,-1.3) * CFrame.Angles(0,math.pi,0)
				local tweenForward = TweenService:Create(localHRP,TweenInfo.new(0.15,Enum.EasingStyle.Linear,Enum.EasingDirection.Out),{CFrame=forwardCFrame})
				tweenForward:Play()
				tweenForward.Completed:Wait()
				local tweenBackward = TweenService:Create(localHRP,TweenInfo.new(0.15,Enum.EasingStyle.Linear,Enum.EasingDirection.Out),{CFrame=backwardCFrame})
				tweenBackward:Play()
				tweenBackward.Completed:Wait()
				for i,wall in ipairs(walls) do
					SUCKYSUCKY[i].CFrame = localHRP.CFrame * wall.offset
				end
			end
			Wait(0.1)
		end
	end)
	suckLOOP()
end,true)

cmd.add({"unsuck","undicksuck"},{"unsuck","no more fun"},function()
	suckLOOP = nil
	if doSUCKING then doSUCKING:Stop() end
	if suckANIM then suckANIM:Destroy() end
	if suckDIED then suckDIED:Disconnect() end
	for _,p in pairs(SUCKYSUCKY) do p:Destroy() end
	SUCKYSUCKY = {}
end)

cmd.add({"improvetextures"},{"improvetextures","Switches Textures"},function()
	opt.hiddenprop(SafeGetService("MaterialService"), "Use2022Materials", true)
end)

cmd.add({"undotextures"},{"undotextures","Switches Textures"},function()
	opt.hiddenprop(SafeGetService("MaterialService"), "Use2022Materials", false)
end)

cmd.add({"serverlist","serverlister","slist"},{"serverlist (serverlister,slist)","list of servers to join in"},function()
	loadstring(game:HttpGet("https://raw.githubusercontent.com/ltseverydayyou/uuuuuuu/refs/heads/main/ServerLister.lua"))();
end)

cmd.add({"keyboard"},{"keyboard","provides a keyboard gui for mobile users"},function()
	loadstring(game:HttpGet("https://raw.githubusercontent.com/ltseverydayyou/uuuuuuu/refs/heads/main/VirtualKeyboard.lua"))();
end)

cmd.add({"autoclicker"},{"autoclicker","provides a autoclicker gui"},function()
	loadstring(game:HttpGet("https://raw.githubusercontent.com/ltseverydayyou/uuuuuuu/refs/heads/main/AutoClicker.luau"))();
end)

cmd.add({"backpack"},{"backpack","provides a custom backpack gui"},function()
	loadstring(game:HttpGet("https://raw.githubusercontent.com/ltseverydayyou/uuuuuuu/refs/heads/main/mobileBACKPACK.lua"))();
end)

-- patched
--[[cmd.add({"reserveserver","privateserver","ps","rs"},{"reserveserver [code]","Teleports to a reserved server or creates one if code is missing"},function(code)
	local md5={}
	local hmac={}
	local base64={}
	do
		local T={
			0xd76aa478,0xe8c7b756,0x242070db,0xc1bdceee,0xf57c0faf,0x4787c62a,0xa8304613,0xfd469501,
			0x698098d8,0x8b44f7af,0xffff5bb1,0x895cd7be,0x6b901122,0xfd987193,0xa679438e,0x49b40821,
			0xf61e2562,0xc040b340,0x265e5a51,0xe9b6c7aa,0xd62f105d,0x02441453,0xd8a1e681,0xe7d3fbc8,
			0x21e1cde6,0xc33707d6,0xf4d50d87,0x455a14ed,0xa9e3e905,0xfcefa3f8,0x676f02d9,0x8d2a4c8a,
			0xfffa3942,0x8771f681,0x6d9d6122,0xfde5380c,0xa4beea44,0x4bdecfa9,0xf6bb4b60,0xbebfbc70,
			0x289b7ec6,0xeaa127fa,0xd4ef3085,0x04881d05,0xd9d4d039,0xe6db99e5,0x1fa27cf8,0xc4ac5665,
			0xf4292244,0x432aff97,0xab9423a7,0xfc93a039,0x655b59c3,0x8f0ccc92,0xffeff47d,0x85845dd1,
			0x6fa87e4f,0xfe2ce6e0,0xa3014314,0x4e0811a1,0xf7537e82,0xbd3af235,0x2ad7d2bb,0xeb86d391
		}
		local function add(a,b)
			local lsw=bit32.band(a,0xFFFF)+bit32.band(b,0xFFFF)
			local msw=bit32.rshift(a,16)+bit32.rshift(b,16)+bit32.rshift(lsw,16)
			return bit32.bor(bit32.lshift(msw,16),bit32.band(lsw,0xFFFF))
		end
		local function rol(x,n) return bit32.bor(bit32.lshift(x,n),bit32.rshift(x,32-n)) end
		local function F(x,y,z) return bit32.bor(bit32.band(x,y),bit32.band(bit32.bnot(x),z)) end
		local function G(x,y,z) return bit32.bor(bit32.band(x,z),bit32.band(y,bit32.bnot(z))) end
		local function H(x,y,z) return bit32.bxor(x,bit32.bxor(y,z)) end
		local function I(x,y,z) return bit32.bxor(y,bit32.bor(x,bit32.bnot(z))) end
		function md5.sum(message)
			local a,b,c,d=0x67452301,0xefcdab89,0x98badcfe,0x10325476
			local message_len=#message
			local padded_message=message.."\128"
			while #padded_message%64~=56 do
				padded_message=padded_message.."\0"
			end
			local len_bytes=""
			local len_bits=message_len*8
			for i=0,7 do
				len_bytes=len_bytes..string.char(bit32.band(bit32.rshift(len_bits,i*8),0xFF))
			end
			padded_message=padded_message..len_bytes
			for i=1,#padded_message,64 do
				local chunk=padded_message:sub(i,i+63)
				local X={}
				for j=0,15 do
					local b1,b2,b3,b4=chunk:byte(j*4+1,j*4+4)
					X[j]=bit32.bor(b1,bit32.lshift(b2,8),bit32.lshift(b3,16),bit32.lshift(b4,24))
				end
				local aa,bb,cc,dd=a,b,c,d
				local s={7,12,17,22,5,9,14,20,4,11,16,23,6,10,15,21}
				for j=0,63 do
					local f,k,si
					if j<16 then f=F(b,c,d) k=j si=j%4
					elseif j<32 then f=G(b,c,d) k=(1+5*j)%16 si=4+(j%4)
					elseif j<48 then f=H(b,c,d) k=(5+3*j)%16 si=8+(j%4)
					else f=I(b,c,d) k=(7*j)%16 si=12+(j%4) end
					local t=add(a,f)
					t=add(t,X[k])
					t=add(t,T[j+1])
					t=rol(t,s[si+1])
					local nb=add(b,t)
					a,b,c,d=d,nb,b,c
				end
				a=add(a,aa) b=add(b,bb) c=add(c,cc) d=add(d,dd)
			end
			local function to_le(n)
				local s=""
				for i=0,3 do s=s..string.char(bit32.band(bit32.rshift(n,i*8),0xFF)) end
				return s
			end
			return to_le(a)..to_le(b)..to_le(c)..to_le(d)
		end
	end
	function hmac.new(key,msg,hash_func)
		if #key>64 then key=hash_func(key) end
		local o="" local i=""
		for n=1,64 do
			local by=(n<=#key and string.byte(key,n)) or 0
			o=o..string.char(bit32.bxor(by,0x5C))
			i=i..string.char(bit32.bxor(by,0x36))
		end
		return hash_func(o..hash_func(i..msg))
	end
	do
		local b="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
		function base64.encode(data)
			return ((data:gsub(".",function(x)
				local r,bv="",x:byte()
				for i=8,1,-1 do r=r..(bv%2^i-bv%2^(i-1)>0 and "1" or "0") end
				return r
			end).."0000"):gsub("%d%d%d?%d?%d?%d?",function(x)
				if #x<6 then return "" end
				local c=0
				for i=1,6 do c=c+((x:sub(i,i)=="1") and 2^(6-i) or 0) end
				return b:sub(c+1,c+1)
			end)..({"","==","="})[#data%3+1])
		end
	end
	local function isLikelyAccessCode(s)
		if not s then return false end
		if #s<20 then return false end
		if not s:match("%d$") then return false end
		if s:find("[_%-]") then return true end
		return s:find("[A-Za-z]")~=nil
	end
	local function GenerateAccessCode(placeId,seed)
		local firstBytes
		if seed and seed~="" then
			local dig=md5.sum(tostring(seed)..":"..tostring(placeId))
			local t={}
			for i=1,16 do t[i]=string.byte(dig,i) end
			t[7]=bit32.bor(bit32.band(t[7],0x0F),0x40)
			t[9]=bit32.bor(bit32.band(t[9],0x3F),0x80)
			firstBytes=string.char(Unpack(t))
		else
			local uuid={}
			for i=1,16 do uuid[i]=math.random(0,255) end
			uuid[7]=bit32.bor(bit32.band(uuid[7],0x0F),0x40)
			uuid[9]=bit32.bor(bit32.band(uuid[9],0x3F),0x80)
			firstBytes=""
			for i=1,16 do firstBytes=firstBytes..string.char(uuid[i]) end
		end
		local pid=placeId
		local placeIdBytes=""
		for _=1,8 do placeIdBytes=placeIdBytes..string.char(pid%256) pid=math.floor(pid/256) end
		local content=firstBytes..placeIdBytes
		local key="e4Yn8ckbCJtw2sv7qmbg"
		local sig=hmac.new(key,content,md5.sum)
		local final=base64.encode(sig..content)
		final=final:gsub("%+","-"):gsub("/","_")
		local pad=0
		final=final:gsub("=",function() pad=pad+1 return "" end)
		return final..tostring(pad)
	end
	local function getTeleportRemote()
		local RRS=SafeGetService("RobloxReplicatedStorage") or game:GetService("ReplicatedStorage"):FindFirstChild("RobloxReplicatedStorage")
		if not RRS then DoNotif("Missing RRS") return nil end
		local remote=RRS:FindFirstChild("ContactListIrisInviteTeleport")
		if not remote then DoNotif("Missing Teleport Remote") return nil end
		return remote
	end
	local function attemptTeleport(placeInfo,accessCode)
		local remote=getTeleportRemote()
		if not remote then return end
		local ok,err=pcall(function()
			remote:FireServer(placeInfo.PlaceId,"",accessCode)
		end)
		if ok then
			DoNotif(Format("Joining reserved server using code: %s",accessCode))
		else
			DoNotif("Teleport failed: "..tostring(err))
		end
	end
	local function copyCode(accessCode)
		if setclipboard then setclipboard(accessCode) DoNotif("Reserved server code copied to clipboard") return true end
		DoNotif("Clipboard unavailable")
		return false
	end
	local providedRaw=code and tostring(code) or nil
	if providedRaw and #providedRaw<1 then providedRaw=nil end
	local assetService=SafeGetService("AssetService")
	local places={}
	local fetchErr
	if assetService then
		local ok,pages=pcall(function() return assetService:GetGamePlacesAsync() end)
		if ok and pages then
			while true do
				for _,place in pages:GetCurrentPage() do
					places[#places+1]={Name=place.Name or "",PlaceId=place.PlaceId}
				end
				if pages.IsFinished then break end
				local advOk,advErr=pcall(function() pages:AdvanceToNextPageAsync() end)
				if not advOk then fetchErr=advErr break end
			end
		else
			fetchErr=pages
		end
	else
		fetchErr="AssetService unavailable"
	end
	local marketplace=SafeGetService("MarketplaceService")
	local currentPlaceName=Format("Place %d",game.PlaceId)
	if marketplace then
		local ok,info=pcall(function() return marketplace:GetProductInfo(game.PlaceId) end)
		if ok and info and info.Name and info.Name~="" then currentPlaceName=info.Name end
	end
	local seen,processed={},{}
	for _,info in ipairs(places) do
	if info.PlaceId and not seen[info.PlaceId] then
		seen[info.PlaceId]=true
		if not info.Name or info.Name=="" then info.Name=Format("Place %d",info.PlaceId) end
		processed[#processed+1]=info
	end
	end
	places=processed
	if not seen[game.PlaceId] then
		Insert(places,1,{Name=currentPlaceName,PlaceId=game.PlaceId})
	else
		for _,info in ipairs(places) do if info.PlaceId==game.PlaceId then info.Name=currentPlaceName break end end
	end
	if fetchErr then DoNotif("Some places may be missing: "..tostring(fetchErr)) end
	local function resolveName(info) return (info and info.Name and info.Name~="") and info.Name or Format("Place %d",info and info.PlaceId or game.PlaceId) end
	local function showOptions(selectedInfo)
		if not selectedInfo then DoNotif("Invalid place selection") return end
		local codeToUse
		if providedRaw then
			if isLikelyAccessCode(providedRaw) then
				codeToUse=providedRaw
			else
				codeToUse=GenerateAccessCode(selectedInfo.PlaceId,providedRaw)
			end
		else
			codeToUse=GenerateAccessCode(selectedInfo.PlaceId,nil)
		end
		local placeLabel=resolveName(selectedInfo)
		local description=Format("Place: %s\nPlaceId: %d\nCode: %s",placeLabel,selectedInfo.PlaceId,codeToUse)
		local buttons={}
		buttons[#buttons+1]={Text="Copy & Join",Callback=function() copyCode(codeToUse) attemptTeleport(selectedInfo,codeToUse) end}
		buttons[#buttons+1]={Text="Join (no copy)",Callback=function() attemptTeleport(selectedInfo,codeToUse) end}
		buttons[#buttons+1]={Text="Cancel",Callback=function() DoNotif("Cancelled reserved server request") end}
		Popup({Title="Reserved Server Ready",Description=description,Buttons=buttons})
	end
	local buttons={}
	for _,info in ipairs(places) do
		local label=Format("%s (%d)",resolveName(info),info.PlaceId)
		buttons[#buttons+1]={Text=label,Callback=function() showOptions(info) end}
	end
	buttons[#buttons+1]={Text="Cancel",Callback=function() DoNotif("Cancelled reserved server request") end}
	Popup({Title="Select Place",Description=providedRaw and "Choose the place for the reserved server code." or "Choose a place to create a reserved server.",Buttons=buttons})
end)]]

HumanModCons = {}

ToolLoopCons = {}

originalIO.stopEquipToolLoop=function(silent)
	if ToolLoopCons.loop then
		ToolLoopCons.loop:Disconnect()
		ToolLoopCons.loop = nil
	end

	if not silent then
		if ToolLoopCons.display then
			DoNotif(Format("Loop equip disabled for \"%s\".", ToolLoopCons.display), 2)
		else
			DoNotif("Loop equip disabled.", 2)
		end
	end

	ToolLoopCons.filter = nil
	ToolLoopCons.display = nil
	ToolLoopCons.warned = nil
end

originalIO.gatherPlayerTools=function()
	local char = getChar()
	local backpack = getBp()
	local tools = {}

	if not char and not backpack then
		return char, backpack, tools
	end

	local seen = {}
	local function considerTool(tool)
		if typeof(tool) == "Instance" and tool:IsA("Tool") and not seen[tool] then
			seen[tool] = true
			Insert(tools, tool)
		end
	end

	if backpack then
		for _, item in ipairs(backpack:GetChildren()) do
			considerTool(item)
		end
	end

	if char then
		for _, item in ipairs(char:GetChildren()) do
			considerTool(item)
		end
	end

	table.sort(tools, function(a, b)
		return Lower(a.Name) < Lower(b.Name)
	end)

	return char, backpack, tools
end

originalIO.safeToolImage=function(inst, props)
	for _, propName in ipairs(props) do
		local ok, value = pcall(function()
			return inst[propName]
		end)
		if ok then
			if typeof(value) == "number" then
				value = "rbxassetid://" .. value
			end
			if typeof(value) == "string" and value ~= "" then
				return value
			end
		end
	end
end

originalIO.findToolImage=function(tool)
	if not tool then
		return nil
	end

	local direct = originalIO.safeToolImage(tool, { "TextureId", "TextureID", "Texture", "Image" })
	if direct then
		return direct
	end

	for _, desc in ipairs(tool:GetDescendants()) do
		local image
		if desc:IsA("Decal") or desc:IsA("Texture") then
			image = originalIO.safeToolImage(desc, { "Texture" })
		elseif desc:IsA("SpecialMesh") or desc:IsA("Mesh") or desc:IsA("DataModelMesh") then
			image = originalIO.safeToolImage(desc, { "TextureId" })
		elseif desc:IsA("MeshPart") or desc:IsA("UnionOperation") or desc:IsA("BasePart") then
			image = originalIO.safeToolImage(desc, { "TextureID", "TextureId" })
		elseif desc:IsA("ImageLabel") or desc:IsA("ImageButton") then
			image = originalIO.safeToolImage(desc, { "Image" })
		else
			image = originalIO.safeToolImage(desc, { "Texture", "TextureId", "TextureID", "Image" })
		end
		if image then
			return image
		end
	end

	return nil
end

originalIO.findToolByName=function(tools, query)
	if type(query) ~= "string" or query == "" then
		return nil
	end

	local lowerQuery = Lower(query)
	local partial
	for _, tool in ipairs(tools) do
		local lowerName = Lower(tool.Name)
		if lowerName == lowerQuery then
			return tool
		end
		if not partial and lowerName:find(lowerQuery, 1, true) then
			partial = tool
		end
	end
	return partial
end

originalIO.equipToolInstance=function(toolRef)
	if typeof(toolRef) ~= "Instance" or not toolRef:IsA("Tool") then
		DoNotif("Tool is no longer available.", 2)
		return false
	end

	local charNow = getChar()
	if not charNow then
		DoNotif("Could not find your character.", 2)
		return false
	end

	local target = toolRef
	if not (target and target.Parent) then
		local currentBp = getBp()
		if currentBp then
			local found = currentBp:FindFirstChild(toolRef.Name)
			if found and found:IsA("Tool") then
				target = found
			end
		end
	end

	if not target or not target:IsA("Tool") then
		DoNotif("Tool is no longer available.", 2)
		return false
	end

	local targetRef = target
	Defer(function()
		local charLater = getChar()
		if not charLater then
			return
		end

		local toolToEquip = targetRef
		if not (toolToEquip and toolToEquip.Parent) then
			local laterBackpack = getBp()
			if laterBackpack then
				local foundLater = laterBackpack:FindFirstChild(toolRef.Name)
				if foundLater and foundLater:IsA("Tool") then
					toolToEquip = foundLater
				end
			end
		end

		if toolToEquip and toolToEquip:IsA("Tool") and toolToEquip.Parent ~= charLater then
			toolToEquip.Parent = charLater
		end
	end)

	return true
end

originalIO.buildToolButtons=function(tools, action)
	local buttons = {}
	for _, toolRef in ipairs(tools) do
		local imageId = originalIO.findToolImage(toolRef) or ""
		local toolName = toolRef.Name
		buttons[#buttons + 1] = {
			Text = toolName,
			Image = imageId,
			Callback = function()
				action(toolRef)
			end
		}
	end
	buttons[#buttons + 1] = { Text = "Cancel", Callback = function() end }
	return buttons
end

originalIO.startLoopForTool=function(toolRef)
	if typeof(toolRef) ~= "Instance" or not toolRef:IsA("Tool") then
		DoNotif("Select a valid tool to loop equip.", 2)
		return
	end

	local displayName = toolRef.Name
	local filterLower = Lower(displayName)

	originalIO.stopEquipToolLoop(true)

	ToolLoopCons.filter = filterLower
	ToolLoopCons.display = displayName
	ToolLoopCons.warned = false

	originalIO.equipToolInstance(toolRef)

	ToolLoopCons.loop = RunService.Stepped:Connect(function()
		if not ToolLoopCons.filter then
			return
		end

		local currentChar = getChar()
		if not currentChar then
			return
		end

		local currentBackpack = getBp()
		if not currentBackpack then
			return
		end

		local function findMatch(container)
			for _, tool in ipairs(container:GetChildren()) do
				if tool:IsA("Tool") and Lower(tool.Name):find(filterLower, 1, true) then
					return tool
				end
			end
		end

		if findMatch(currentChar) then
			ToolLoopCons.warned = false
			return
		end

		local match = findMatch(currentBackpack)
		if match then
			ToolLoopCons.warned = false
			originalIO.equipToolInstance(match)
		elseif not ToolLoopCons.warned then
			DoNotif(Format("Loop equip: \"%s\" not found.", ToolLoopCons.display), 2)
			ToolLoopCons.warned = true
		end
	end)

	DoNotif(Format("Loop equip enabled for \"%s\". Use unloopequiptool to stop.", displayName), 3)
end

cmd.add({"edgejump", "ejump"}, {"edgejump (ejump)", "Automatically jumps when you get to the edge of an object"}, function()
	local Char = speaker.Character
	local Human = getHum()
	local currentState
	local previousState
	local lastCFrame

	local function edgeJump()
		if Char and Human then
			previousState = currentState
			currentState = Human:GetState()
			if previousState ~= currentState and currentState == Enum.HumanoidStateType.Freefall and previousState ~= Enum.HumanoidStateType.Jumping then
				local rootPart = getRoot(Char)
				rootPart.CFrame = lastCFrame
				rootPart.Velocity = Vector3.new(rootPart.Velocity.X, Human.JumpPower or Human.JumpHeight, rootPart.Velocity.Z)
			end
			lastCFrame = getRoot(Char).CFrame
		end
	end

	edgeJump()
	HumanModCons.ejLoop = (HumanModCons.ejLoop and HumanModCons.ejLoop:Disconnect() and false) or RunService.Stepped:Connect(edgeJump)
	HumanModCons.ejCA = (HumanModCons.ejCA and HumanModCons.ejCA:Disconnect() and false) or speaker.CharacterAdded:Connect(function(newChar)
		Char = newChar
		Human = getPlrHum(newChar)
		edgeJump()
		HumanModCons.ejLoop = (HumanModCons.ejLoop and HumanModCons.ejLoop:Disconnect() and false) or RunService.Stepped:Connect(edgeJump)
	end)
end)

cmd.add({"unedgejump", "noedgejump", "noejump", "unejump"}, {"unedgejump (noedgejump, noejump, unejump)", "Disables edgejump"}, function()
	if HumanModCons.ejLoop then
		HumanModCons.ejLoop:Disconnect()
		HumanModCons.ejLoop = nil
	end

	if HumanModCons.ejCA then
		HumanModCons.ejCA:Disconnect()
		HumanModCons.ejCA = nil
	end
end)

cmd.add({"equiptools","etools","equipt"},{"equiptools (etools,equipt)","Equips every tool in your inventory"},function()
	for i,v in pairs(LocalPlayer:FindFirstChildOfClass("Backpack"):GetChildren()) do
		if v:IsA("Tool") then
			v.Parent = getChar()
		end
	end
end)
cmd.add({"unequiptools"},{"unequiptools","Unequips every tool you are currently holding"},function()
	if getChar() then
		getChar():FindFirstChildOfClass('Humanoid'):UnequipTools()
	end
end)

cmd.add({"equiptool","etool"},{"equiptool (etool)","Equip a specific tool by name or selection"},function(...)
	local char, backpack, tools = originalIO.gatherPlayerTools()
	if not char or not backpack then
		DoNotif("Could not find your character or backpack.", 2)
		return
	end

	if #tools == 0 then
		DoNotif("You do not have any tools to equip.", 2)
		return
	end

	local rawInput = Concat({...}, " ")
	rawInput = (type(rawInput) == "string") and rawInput:gsub("^%s+", ""):gsub("%s+$", "") or ""

	if rawInput ~= "" then
		local match = originalIO.findToolByName(tools, rawInput)
		if match then
			originalIO.equipToolInstance(match)
		else
			DoNotif(Format("No tools matching '%s' found.", rawInput), 2)
		end
		return
	end

	if type(Popup) ~= "function" then
		DoNotif("Popup UI is unavailable in this session. Provide a tool name instead.", 3)
		return
	end

	local buttons = originalIO.buildToolButtons(tools, function(toolRef)
		originalIO.equipToolInstance(toolRef)
	end)

	Popup({
		Title = "Equip Tool",
		Description = "Select a tool to equip.",
		Buttons = buttons
	})
end)

cmd.add({"loopequiptool","lequiptool","loopet"},{"loopequiptool <tool name>","Keeps a specific tool equipped until disabled"},function(...)
	local char, backpack, tools = originalIO.gatherPlayerTools()
	if not char or not backpack then
		DoNotif("Could not find your character or backpack.", 2)
		return
	end

	if #tools == 0 then
		DoNotif("You do not have any tools to loop equip.", 2)
		return
	end

	local rawInput = Concat({...}, " ")
	rawInput = (type(rawInput) == "string") and rawInput:gsub("^%s+", ""):gsub("%s+$", "") or ""

	if rawInput ~= "" then
		local match = originalIO.findToolByName(tools, rawInput)
		if match then
			originalIO.startLoopForTool(match)
		else
			DoNotif(Format("No tools matching '%s' found.", rawInput), 2)
		end
		return
	end

	if type(Popup) ~= "function" then
		DoNotif("Popup UI is unavailable in this session. Provide a tool name instead.", 3)
		return
	end

	local buttons = originalIO.buildToolButtons(tools, function(toolRef)
		originalIO.startLoopForTool(toolRef)
	end)

	Popup({
		Title = "Loop Equip Tool",
		Description = "Select a tool to keep equipped.",
		Buttons = buttons
	})
end)

cmd.add({"unloopequiptool","unloopet","unlequiptool"},{"unloopequiptool","Stops the loop equip behaviour"},function()
	originalIO.stopEquipToolLoop()
end)

bangLoop = nil
bangAnim = nil
bangDied = nil
doBang = nil
BANGPARTS = {}

cmd.add({"bang", "fuck"}, {"bang <player> <number> (fuck)", "fucks the player by attaching to them"}, function(h, d)
	if bangLoop then
		bangLoop:Disconnect()
	end
	if doBang then
		doBang:Stop()
	end
	if bangAnim then
		bangAnim:Destroy()
	end
	if bangDied then
		bangDied:Disconnect()
	end
	for _, p in pairs(BANGPARTS) do
		p:Destroy()
	end
	BANGPARTS = {}

	local speed = d or 10
	local username = h
	local targets = getPlr(username)
	if #targets == 0 then return end
	local plr = targets[1]

	bangAnim = InstanceNew("Animation")
	if not IsR15(Players.LocalPlayer) then
		bangAnim.AnimationId = "rbxassetid://148840371"
	else
		bangAnim.AnimationId = "rbxassetid://5918726674"
	end
	local hum = getHum()
	doBang = hum:LoadAnimation(bangAnim)
	doBang:Play(0.1, 1, 1)
	doBang:AdjustSpeed(speed)

	local bangplr = plr.Name
	bangDied = hum.Died:Connect(function()
		if bangLoop then
			bangLoop:Disconnect()
		end
		doBang:Stop()
		bangAnim:Destroy()
		if bangDied then
			bangDied:Disconnect()
		end
		for _, part in pairs(BANGPARTS) do
			part:Destroy()
		end
		BANGPARTS = {}
	end)

	local thick = 0.2
	local halfWidth = 2
	local halfDepth = 2
	local halfHeight = 3
	local walls = {
		{offset = CFrame.new(0, 0, halfDepth + thick/500), size = Vector3.new(4, 6, thick)},
		{offset = CFrame.new(0, 0, -(halfDepth + thick/500)), size = Vector3.new(4, 6, thick)},
		{offset = CFrame.new(halfWidth + thick/500, 0, 0), size = Vector3.new(thick, 6, 4)},
		{offset = CFrame.new(-(halfWidth + thick/500), 0, 0), size = Vector3.new(thick, 6, 4)},
		{offset = CFrame.new(0, halfHeight + thick/500, 0), size = Vector3.new(4, thick, 4)},
		{offset = CFrame.new(0, -(halfHeight + thick/500), 0), size = Vector3.new(4, thick, 4)}
	}
	for i, wall in ipairs(walls) do
		local part = InstanceNew("Part")
		part.Size = wall.size
		part.Anchored = true
		part.CanCollide = true
		part.Transparency = 1
		part.Parent = workspace
		Insert(BANGPARTS, part)
	end

	local bangOffset = CFrame.new(0, 0, 1.1)
	bangLoop = RunService.Stepped:Connect(function()
		NACaller(function()
			local targetPlayer = Players:FindFirstChild(bangplr)
			if not targetPlayer or not targetPlayer.Character then return end
			local targetRoot = getRoot(targetPlayer.Character)
			local localRoot = getRoot(getChar())
			if targetRoot and localRoot then
				localRoot.CFrame = targetRoot.CFrame * bangOffset
				for i, wall in ipairs(walls) do
					BANGPARTS[i].CFrame = localRoot.CFrame * wall.offset
				end
			end
		end)
	end)
end, true)

cmd.add({"unbang", "unfuck"}, {"unbang (unfuck)", "Unbangs the player"}, function()
	if bangLoop then
		bangLoop:Disconnect()
	end
	if doBang then
		doBang:Stop()
	end
	if bangAnim then
		bangAnim:Destroy()
	end
	if bangDied then
		bangDied:Disconnect()
	end
	for _, p in pairs(BANGPARTS) do
		p:Destroy()
	end
	BANGPARTS = {}
end)

inversebangLoop = nil
inversebangAnim = nil
inversebangAnim2 = nil
inversebangDied = nil
doInversebang = nil
doInversebang2 = nil
INVERSEBANGPARTS = {}

cmd.add({"inversebang","ibang","inverseb"},{"inversebang <player> <number>","you're the one getting fucked today ;)"},function(h,d)
	if inversebangLoop then inversebangLoop = nil end
	if doInversebang then doInversebang:Stop() end
	if inversebangAnim then inversebangAnim:Destroy() end
	if inversebangAnim2 then inversebangAnim2:Destroy() end
	if inversebangDied then inversebangDied:Disconnect() end
	for _,p in pairs(INVERSEBANGPARTS) do p:Destroy() end
	INVERSEBANGPARTS = {}

	local speed = d or 10
	local targets = getPlr(h)
	if #targets == 0 then return end
	local plr = targets[1]
	local bangplr = plr.Name

	inversebangAnim = InstanceNew("Animation")
	local isR15 = IsR15(Players.LocalPlayer)
	if not isR15 then
		inversebangAnim.AnimationId = "rbxassetid://189854234"
		inversebangAnim2 = InstanceNew("Animation")
		inversebangAnim2.AnimationId = "rbxassetid://106772613"
	else
		inversebangAnim.AnimationId = "rbxassetid://10714360343"
		inversebangAnim2 = nil
	end

	local hum = getHum()
	doInversebang = hum:LoadAnimation(inversebangAnim)
	doInversebang:Play(0.1,1,1)
	doInversebang:AdjustSpeed(speed)
	if not isR15 and inversebangAnim2 then
		doInversebang2 = hum:LoadAnimation(inversebangAnim2)
		doInversebang2:Play(0.1,1,1)
		doInversebang2:AdjustSpeed(speed)
	end

	inversebangDied = hum.Died:Connect(function()
		if inversebangLoop then inversebangLoop = nil end
		doInversebang:Stop()
		if doInversebang2 then doInversebang2:Stop() end
		inversebangAnim:Destroy()
		inversebangDied:Disconnect()
		for _,part in pairs(INVERSEBANGPARTS) do part:Destroy() end
		INVERSEBANGPARTS = {}
	end)

	local thick,halfWidth,halfDepth,halfHeight = 0.2,2,2,3
	local walls = {
		{offset=CFrame.new(0,0,halfDepth+thick/500),    size=Vector3.new(4,6,thick)},
		{offset=CFrame.new(0,0,-(halfDepth+thick/500)), size=Vector3.new(4,6,thick)},
		{offset=CFrame.new(halfWidth+thick/500,0,0),    size=Vector3.new(thick,6,4)},
		{offset=CFrame.new(-(halfWidth+thick/500),0,0), size=Vector3.new(thick,6,4)},
		{offset=CFrame.new(0,halfHeight+thick/500,0),   size=Vector3.new(4,thick,4)},
		{offset=CFrame.new(0,-(halfHeight+thick/500),0),size=Vector3.new(4,thick,4)},
	}
	for i,wall in ipairs(walls) do
		local part = InstanceNew("Part")
		part.Size = wall.size
		part.Anchored = true
		part.CanCollide = true
		part.Transparency = 1
		part.Parent = workspace
		Insert(INVERSEBANGPARTS,part)
	end

	inversebangLoop = coroutine.wrap(function()
		while true do
			local targetPlayer = Players:FindFirstChild(bangplr)
			local targetCharacter = targetPlayer and targetPlayer.Character
			local localCharacter = getChar()
			if targetCharacter and getRoot(targetCharacter) and localCharacter and getRoot(localCharacter) then
				local targetHRP = getRoot(targetCharacter)
				local localHRP = getRoot(localCharacter)
				local forwardCFrame = targetHRP.CFrame * CFrame.new(0,0,-2.5)
				local backwardCFrame = targetHRP.CFrame * CFrame.new(0,0,-1.3)
				local tweenForward = TweenService:Create(localHRP,TweenInfo.new(0.15,Enum.EasingStyle.Linear,Enum.EasingDirection.Out),{CFrame=forwardCFrame})
				tweenForward:Play()
				tweenForward.Completed:Wait()
				local tweenBackward = TweenService:Create(localHRP,TweenInfo.new(0.15,Enum.EasingStyle.Linear,Enum.EasingDirection.Out),{CFrame=backwardCFrame})
				tweenBackward:Play()
				tweenBackward.Completed:Wait()
				for i,wall in ipairs(walls) do
					INVERSEBANGPARTS[i].CFrame = localHRP.CFrame * wall.offset
				end
			end
			Wait(0.1)
		end
	end)
	inversebangLoop()
end,true)

cmd.add({"uninversebang","unibang","uninverseb"},{"uninversebang","no more fun"},function()
	if inversebangLoop then inversebangLoop = nil end
	if doInversebang then doInversebang:Stop() end
	if doInversebang2 then doInversebang2:Stop() end
	if inversebangAnim then inversebangAnim:Destroy() end
	if inversebangDied then inversebangDied:Disconnect() end
	for _,p in pairs(INVERSEBANGPARTS) do p:Destroy() end
	INVERSEBANGPARTS = {}
end)

sussyID = "rbxassetid://106772613"
susTrack, susCONN = nil, nil

cmd.add({"suslay", "laysus"}, {"suslay (laysus)", "Lay down in a suspicious way"}, function()
	if not IsR6() then return DoNotif("R6 only") end

	if susTrack then
		susTrack:Stop()
		susTrack = nil
	end

	if susCONN then
		susCONN:Disconnect()
		susCONN = nil
	end

	local hum = getHum()
	local root = hum.RootPart

	hum.Sit = true
	Wait(0.1)
	root.CFrame=root.CFrame * CFrame.Angles(math.pi * 0.5, 0, 0)

	for _, a in ipairs(hum:GetPlayingAnimationTracks()) do
		a:Stop()
	end

	local anim = InstanceNew("Animation")
	anim.AnimationId = sussyID
	susTrack = hum:LoadAnimation(anim)
	susTrack:Play()

	susCONN = hum:GetPropertyChangedSignal("Jump"):Connect(function()
		if susTrack then
			susTrack:Stop()
			susTrack = nil
		end
		if susCONN then
			susCONN:Disconnect()
			susCONN = nil
		end
	end)
end)

cmd.add({"unsuslay"}, {"unsuslay", "Stand up from the sussy lay"}, function()
	getHum():ChangeState(Enum.HumanoidStateType.Jumping)

	if susTrack then
		susTrack:Stop()
		susTrack = nil
	end

	if susCONN then
		susCONN:Disconnect()
		susCONN = nil
	end
end)

cmd.add({"jerk", "jork"}, {"jerk (jork)", "jorking it"}, function()
	local humanoid = getHum()
	local backpack = getBp()
	if not humanoid or not backpack then return end

	local tool = InstanceNew("Tool")
	tool.Name = "Jerk"
	tool.ToolTip = "oh yes i am feeling it COMING OUT AHHHHHHHHHHHHHHHHHHHHH"
	tool.RequiresHandle = false
	tool.Parent = backpack

	local jorkin = false
	local track = nil

	local function stopTomfoolery()
		jorkin = false
		if track then
			track:Stop()
			track = nil
		end
	end

	tool.Equipped:Connect(function() jorkin = true end)
	tool.Unequipped:Connect(stopTomfoolery)
	humanoid.Died:Connect(stopTomfoolery)

	while Wait() do
		if not jorkin then continue end

		if not track then
			local anim = InstanceNew("Animation")
			anim.AnimationId = not IsR15() and "rbxassetid://72042024" or "rbxassetid://698251653"
			track = humanoid:LoadAnimation(anim)
		end

		track:Play()
		track:AdjustSpeed(IsR15() and 0.7 or 0.65)
		track.TimePosition = 0.6
		Wait(0.2)
		while track and track.TimePosition < (not IsR15() and 0.65 or 0.7) do Wait(0.2) end
		if track then
			track:Stop()
			track = nil
		end
	end
end)

huggiePARTS = {}
hugUI = nil
currentHugTracks = {}
currentHugTarget = nil
hugFromFront = false
hugModeEnabled = false

cmd.add({"hug", "clickhug"}, {"hug (clickhug)", "huggies time (click on a target to hug)"}, function()
	if IsR6() then
		local mouse = LocalPlayer:GetMouse()

		NAlib.disconnect("hug_toggle")
		NAlib.disconnect("hug_side")
		NAlib.disconnect("hug_click")
		NAlib.disconnect("hug_plat")

		for _, track in pairs(currentHugTracks) do NACaller(function() track:Stop() end) end
		currentHugTracks = {}

		if hugUI then hugUI:Destroy() end
		hugFromFront = false
		currentHugTarget = nil
		for _, part in pairs(huggiePARTS) do part:Destroy() end
		huggiePARTS = {}

		hugUI = InstanceNew("ScreenGui")
		hugUI.Name = "HugModeUI"
		NaProtectUI(hugUI)

		local toggleHugButton = InstanceNew("TextButton")
		toggleHugButton.AnchorPoint = Vector2.new(0.5, 0)
		toggleHugButton.Size = UDim2.new(0, 150, 0, 50)
		toggleHugButton.Position = UDim2.new(0.4, 0, 0.1, 0)
		toggleHugButton.Text = "Hug Mode: OFF"
		toggleHugButton.TextSize = 14
		toggleHugButton.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
		toggleHugButton.TextColor3 = Color3.fromRGB(255, 255, 255)
		toggleHugButton.Parent = hugUI

		local sideToggleButton = InstanceNew("TextButton")
		sideToggleButton.AnchorPoint = Vector2.new(0.5, 0)
		sideToggleButton.Size = UDim2.new(0, 150, 0, 50)
		sideToggleButton.Position = UDim2.new(0.6, 0, 0.1, 0)
		sideToggleButton.Text = "Hug Side: Back"
		sideToggleButton.TextSize = 14
		sideToggleButton.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
		sideToggleButton.TextColor3 = Color3.fromRGB(255, 255, 255)
		sideToggleButton.Parent = hugUI

		local uiCorner = InstanceNew("UICorner")
		uiCorner.CornerRadius = UDim.new(0, 8)
		uiCorner.Parent = toggleHugButton

		local sideUICorner = InstanceNew("UICorner")
		sideUICorner.CornerRadius = UDim.new(0, 8)
		sideUICorner.Parent = sideToggleButton

		NAgui.draggerV2(toggleHugButton)
		NAgui.draggerV2(sideToggleButton)

		hugModeEnabled = false

		local function performHug(targetCharacter)
			currentHugTarget = targetCharacter

			local offsetDistance = 1.5
			local targetHRP = getRoot(targetCharacter)
			local localCharacter = LocalPlayer.Character
			if not localCharacter then return end
			local localHRP = getRoot(localCharacter)
			if targetHRP and localHRP then
				local offset = (hugFromFront and (targetHRP.CFrame.LookVector * offsetDistance)) or (-(targetHRP.CFrame.LookVector * offsetDistance))
				local initialHugPos = targetHRP.Position + offset
				localHRP.CFrame = CFrame.new(initialHugPos, targetHRP.Position)
				local humanoid = getPlrHum(localCharacter)
				if humanoid then
					local anim1 = InstanceNew("Animation")
					anim1.AnimationId = "rbxassetid://283545583"
					local track1 = humanoid:LoadAnimation(anim1)
					local anim2 = InstanceNew("Animation")
					anim2.AnimationId = "rbxassetid://225975820"
					local track2 = humanoid:LoadAnimation(anim2)
					Insert(currentHugTracks, track1)
					Insert(currentHugTracks, track2)
					track1:Play()
					track2:Play()

					if #huggiePARTS == 0 then
						local thick = 0.2
						local halfWidth = 2
						local halfDepth = 2
						local halfHeight = 3
						local walls = {
							{offset = CFrame.new(0, 0, halfDepth + thick/500), size = Vector3.new(4, 6, thick)},
							{offset = CFrame.new(0, 0, -(halfDepth + thick/500)), size = Vector3.new(4, 6, thick)},
							{offset = CFrame.new(halfWidth + thick/500, 0, 0), size = Vector3.new(thick, 6, 4)},
							{offset = CFrame.new(-(halfWidth + thick/500), 0, 0), size = Vector3.new(thick, 6, 4)},
							{offset = CFrame.new(0, halfHeight + thick/500, 0), size = Vector3.new(4, thick, 4)},
							{offset = CFrame.new(0, -(halfHeight + thick/500), 0), size = Vector3.new(4, thick, 4)}
						}
						for i, wall in ipairs(walls) do
							local part = InstanceNew("Part")
							part.Size = wall.size
							part.Anchored = true
							part.CanCollide = true
							part.Transparency = 1
							part.Parent = workspace
							Insert(huggiePARTS, part)
						end
						NAlib.connect("hug_plat", RunService.Stepped:Connect(function()
							local charRoot = getRoot(LocalPlayer.Character)
							if charRoot then
								for i, wall in ipairs(walls) do
									huggiePARTS[i].CFrame = charRoot.CFrame * wall.offset
								end
							end
						end))
					end

					SpawnCall(function()
						while hugModeEnabled and targetCharacter and getRoot(targetCharacter) and (currentHugTarget == targetCharacter) do
							targetHRP = getRoot(targetCharacter)
							offset = (hugFromFront and (targetHRP.CFrame.LookVector * offsetDistance)) or (-(targetHRP.CFrame.LookVector * offsetDistance))
							local newHugPos = targetHRP.Position + offset
							if localHRP then
								localHRP.CFrame = CFrame.new(newHugPos, targetHRP.Position)
							end
							Wait()
						end
					end)
				end
			end
		end

		NAlib.connect("hug_toggle", MouseButtonFix(toggleHugButton, function()
			hugModeEnabled = not hugModeEnabled
			if hugModeEnabled then
				toggleHugButton.Text = "Hug Mode: ON"
			else
				toggleHugButton.Text = "Hug Mode: OFF"
				for _, track in pairs(currentHugTracks) do NACaller(function() track:Stop() end) end
				currentHugTracks = {}
				currentHugTarget = nil
				for _, part in pairs(huggiePARTS) do part:Destroy() end
				huggiePARTS = {}
				NAlib.disconnect("hug_plat")
			end
		end))

		NAlib.connect("hug_side", MouseButtonFix(sideToggleButton, function()
			hugFromFront = not hugFromFront
			sideToggleButton.Text = (hugFromFront and "Hug Side: Front") or "Hug Side: Back"
		end))

		NAlib.connect("hug_click", LocalPlayer:GetMouse().Button1Down:Connect(function()
			if not hugModeEnabled then return end
			local target = mouse.Target
			if target and target.Parent then
				local targetPlayer = Players:GetPlayerFromCharacter(target.Parent)
				if targetPlayer and targetPlayer ~= LocalPlayer and targetPlayer.Character then
					performHug(targetPlayer.Character)
				end
			end
		end))
	else
		DoNotif("command requires R6")
	end
end)

cmd.add({"unhug"}, {"unhug", "no huggies :("}, function()
	NAlib.disconnect("hug_toggle")
	NAlib.disconnect("hug_side")
	NAlib.disconnect("hug_click")
	NAlib.disconnect("hug_plat")

	for _, track in pairs(currentHugTracks) do NACaller(function() track:Stop() end) end
	currentHugTracks = {}
	currentHugTarget = nil
	hugFromFront = false
	hugModeEnabled = false
	for _, part in pairs(huggiePARTS) do part:Destroy() end
	huggiePARTS = {}
	if hugUI then hugUI:Destroy() hugUI = nil end
end)

glueloop = {}

cmd.add({"glue","loopgoto","lgoto"},{"glue <player>","Loop teleport to a player"},function(...)
	local input = (...)
	local players = getPlr(input)
	for _, p in next, players do
		local name = p.Name
		if glueloop[name] then glueloop[name]:Disconnect() end
		glueloop[name] = RunService.RenderStepped:Connect(function()
			local target = Players:FindFirstChild(name)
			if target and target.Character then
				getRoot(getChar()).CFrame=getRoot(target.Character).CFrame
			end
		end)
	end
end,true)

cmd.add({"unglue","unloopgoto","noloopgoto"},{"unglue","Stops teleporting you to a player"},function()
	for _, conn in pairs(glueloop) do conn:Disconnect() end
	glueloop = {}
end)

glueBACKER = {}

cmd.add({"glueback","loopbehind","lbehind"},{"glueback <player>","Loop teleport behind a player"},function(...)
	local input   = (...)
	local targets = getPlr(input)
	for _,target in next,targets do
		local name = target.Name
		if glueBACKER[name] then
			glueBACKER[name]:Disconnect()
			glueBACKER[name] = nil
		end
		glueBACKER[name] = RunService.RenderStepped:Connect(function()
			local tp = Players:FindFirstChild(name)
			if not tp or not tp.Character then return end
			getRoot(getChar()).CFrame=getRoot(tp.Character).CFrame*CFrame.new(0,0,3)
		end)
	end
end,true)

cmd.add({"unglueback","unloopbehind","unlbehind"},{"unglueback","Stops teleporting you to a player"},function()
	for _,conn in pairs(glueBACKER) do conn:Disconnect() end
	glueBACKER = {}
end)

cmd.add({"spook", "scare"}, {"spook <player> (scare)", "Teleports next to a player for a few seconds"}, function(...)
	local username = (...)
	local targets = getPlr(username)
	for _, plr in next, targets do
		local char = getChar()
		local root = getRoot(char)
		local oldCF = root.CFrame
		local distancepl = 2
		if getPlrHum(plr) then
			local targetRoot = getRoot(plr.Character)
			if targetRoot then
				root.CFrame = targetRoot.CFrame + targetRoot.CFrame.LookVector * distancepl
				root.CFrame = CFrame.new(root.Position, targetRoot.Position)
				Wait(0.5)
				root.CFrame = oldCF
			end
		end
	end
end, true)

loopspook = false

cmd.add({"loopspook","loopscare"},{"loopspook <player>","Teleports next to a player repeatedly"},function(...)
	local input = (...)
	local names = {}
	for _, p in ipairs(getPlr(input)) do
		names[#names+1] = p.Name
	end
	loopspook = true

	SpawnCall(function()
		while loopspook do
			for _, name in ipairs(names) do
				local target = Players:FindFirstChild(name)
				if target and getPlrHum(target) then
					local lc = getChar()
					local lr = getRoot(lc)
					local tr = getRoot(target.Character)
					if lr and tr then
						local old = lr.CFrame
						lr.CFrame = tr.CFrame + tr.CFrame.LookVector * 2
						lr.CFrame = CFrame.new(lr.Position, tr.Position)
						Wait(0.5)
						lr.CFrame = old
					end
				end
			end
			Wait(0.3)
		end
	end)
end,true)

cmd.add({"unloopspook","unloopscare"},{"unloopspook","Stops the loopspook command"},function()
	loopspook = false
end)

Airwalker, awPart = nil, nil
local airwalk = {
	Vars = {
		keybinds = {
			Increase = Enum.KeyCode.E,
			Decrease = Enum.KeyCode.Q,
		},
		decrease = false,
		increase = false,
		offset = 0,
		isTyping = false,
	},
	connections = {},
	guis = {},
}

cmd.add({"airwalk", "float", "aw"}, {"airwalk (float, aw)", "Press space to go up, unairwalk to stop"}, function()
	DebugNotif(IsOnMobile and "Airwalk: ON" or "Airwalk: ON (Q And E)")
	if Airwalker then Airwalker:Disconnect() Airwalker = nil end
	if awPart then awPart:Destroy() awPart = nil end

	function createButton(parent, text, position, callbackDown, callbackUp)
		local button = InstanceNew("TextButton")
		button.Parent = parent
		button.BackgroundColor3 = Color3.fromRGB(45, 45, 45)
		button.BackgroundTransparency = 0
		button.Position = position
		button.Size = UDim2.new(0.05, 0, 0.1, 0)
		button.Font = Enum.Font.SourceSansBold
		button.Text = text
		button.TextColor3 = Color3.fromRGB(255, 255, 255)
		button.TextSize = 18
		button.TextScaled = true
		button.AutoButtonColor = false

		local corner = InstanceNew("UICorner", button)
		corner.CornerRadius = UDim.new(0.2, 0)

		local stroke = InstanceNew("UIStroke", button)
		stroke.Color = Color3.fromRGB(255, 255, 255)
		stroke.Thickness = 2

		local hoverEffect = function(isHovering)
			button.BackgroundColor3 = isHovering and Color3.fromRGB(70, 70, 70) or Color3.fromRGB(45, 45, 45)
		end

		button.MouseEnter:Connect(function() hoverEffect(true) end)
		button.MouseLeave:Connect(function() hoverEffect(false) end)
		button.MouseButton1Down:Connect(callbackDown)
		button.MouseButton1Up:Connect(callbackUp)
		NAgui.draggerV2(button)

		return button
	end

	if IsOnMobile then
		local guiDown = InstanceNew("ScreenGui")
		NaProtectUI(guiDown)
		guiDown.ResetOnSpawn = false
		airwalk.guis.down = guiDown
		createButton(guiDown, "DOWN", UDim2.new(0.9, 0, 0.7, 0), function() airwalk.Vars.decrease = true end, function() airwalk.Vars.decrease = false end)

		local guiUp = InstanceNew("ScreenGui")
		NaProtectUI(guiUp)
		guiUp.ResetOnSpawn = false
		airwalk.guis.up = guiUp
		createButton(guiUp, "UP", UDim2.new(0.9, 0, 0.5, 0), function() airwalk.Vars.increase = true end, function() airwalk.Vars.increase = false end)
	else
		airwalk.connections.focused = UserInputService.TextBoxFocused:Connect(function() airwalk.Vars.isTyping = true end)
		airwalk.connections.released = UserInputService.TextBoxFocusReleased:Connect(function() airwalk.Vars.isTyping = false end)

		airwalk.connections.inputBegan = uis.InputBegan:Connect(function(input, gpe)
			if gpe or airwalk.Vars.isTyping then return end
			if input.KeyCode == airwalk.Vars.keybinds.Increase then airwalk.Vars.increase = true end
			if input.KeyCode == airwalk.Vars.keybinds.Decrease then airwalk.Vars.decrease = true end
		end)
		airwalk.connections.inputEnded = uis.InputEnded:Connect(function(input, gpe)
			if gpe then return end
			if input.KeyCode == airwalk.Vars.keybinds.Increase then airwalk.Vars.increase = false end
			if input.KeyCode == airwalk.Vars.keybinds.Decrease then airwalk.Vars.decrease = false end
		end)
	end

	awPart = InstanceNew("Part", workspace)
	awPart.Size = Vector3.new(7, 2, 3)
	awPart.Transparency = 1
	awPart.Anchored = true
	awPart.CanCollide = true

	Airwalker = RunService.RenderStepped:Connect(function()
		if not awPart then Airwalker:Disconnect() return end

		local char = getChar()
		local root = getRoot(char)
		local hum = getHum(char)
		if not (char and root and hum) then return end

		local hrpY = root.Position.Y
		local hrpHalf = ((NAlib.isProperty(root, "Size") and root.Size.Y) or 2) * 0.5
		local partHalf = awPart.Size.Y * 0.5

		local feetFromRoot
		if IsR6() then
			feetFromRoot = hrpHalf + 2
			if hum.HipHeight and hum.HipHeight > 0 then
				feetFromRoot = hrpHalf + hum.HipHeight
			end
		else
			feetFromRoot = hrpHalf + (hum.HipHeight or 2)
		end

		local baseOffset = feetFromRoot + partHalf
		local delta = (airwalk.Vars.decrease and 1.5) or (airwalk.Vars.increase and -1.5) or 0
		airwalk.Vars.offset = math.max(0, baseOffset + delta)

		awPart.CFrame = CFrame.new(root.Position.X, hrpY - airwalk.Vars.offset, root.Position.Z)
	end)
end)

cmd.add({"unairwalk", "unfloat", "unaw"}, {"unairwalk (unfloat, unaw)", "Stops the airwalk command"}, function()
	if Airwalker then Airwalker:Disconnect() Airwalker = nil end
	if awPart then awPart:Destroy() awPart = nil end
	for _, conn in pairs(airwalk.connections) do
		if conn then conn:Disconnect() end
	end
	airwalk.connections = {}
	for _, gui in pairs(airwalk.guis) do
		if gui then gui:Destroy() end
	end
	airwalk.guis = {}
	DebugNotif("Airwalk: OFF")
end)

bringc = {}

cmd.add({"cbring", "clientbring", "clientb"}, {"cbring <player>", "Brings the player once on your client"}, function(...)
	local username = (...)
	local target = getPlr(username)
	if #target == 0 then return end
	local localChar = getChar()
	if not localChar then return end
	local localRoot = getRoot(localChar)
	if not localRoot then return end
	for _, plr in next, target do
		local targetChar = getPlrChar(plr)
		if targetChar then
			local targetRoot = getRoot(targetChar)
			if targetRoot then
				targetRoot.CFrame = localRoot.CFrame + localRoot.CFrame.LookVector * 3
			end
		end
	end
end, true)

cmd.add({"loopcbring", "loppclientb", "loopclientbring", "lcbring", "lclientb"}, {"loopcbring <player>", "Continuously brings the player on your client"}, function(...)
	local username = (...)
	local target = getPlr(username)
	if #target == 0 then return end
	for _, conn in ipairs(bringc) do
		conn:Disconnect()
	end
	bringc = {}
	if NAlib.isConnected("cbnoclip") then
		NAlib.disconnect("cbnoclip")
	end
	NAlib.connect("cbnoclip", RunService.RenderStepped:Connect(function()
		local char = getChar()
		if not char then return end
		for _, descendant in pairs(char:GetDescendants()) do
			if descendant:IsA("BasePart") then
				descendant.CanCollide = false
			end
		end
	end))
	for _, plr in next, target do
		if not plr then return end
		local conn = RunService.RenderStepped:Connect(function()
			local targetChar = getPlrChar(plr)
			local localChar = getChar()
			if targetChar and localChar then
				local targetRoot = getRoot(targetChar)
				local localRoot = getRoot(localChar)
				if targetRoot and localRoot then
					targetRoot.CFrame = localRoot.CFrame + localRoot.CFrame.LookVector * 3
				end
			end
		end)
		Insert(bringc, conn)
	end
end, true)

cmd.add({"unloopcbring", "unloopcientb", "unlcbring", "unlclientb", "uncbring", "unclientb"}, {"unloopcbring", "Disable looped client bring"}, function()
	for _, conn in ipairs(bringc) do
		conn:Disconnect()
	end
	bringc = {}
	if NAlib.isConnected("cbnoclip") then
		NAlib.disconnect("cbnoclip")
	end
end)

cmd.add({"mute", "muteboombox"}, {"mute <player> (muteboombox)", "Mutes the player's boombox"}, function(...)
	local uuuu = ...
	local pp = getPlr(uuuu)
	if #pp == 0 then return end

	local function NONOSOUND(container)
		for _, descendant in ipairs(container:GetDescendants()) do
			if descendant:IsA("Sound") and descendant.Playing then
				descendant.Playing = false
			end
		end
	end

	for _, plr in ipairs(pp) do
		if plr and plr.Character then
			NONOSOUND(plr.Character)
		end

		local BK = plr:FindFirstChildOfClass("Backpack")
		if BK then
			NONOSOUND(BK)
		end
	end
end, true)

TPWalk = false

cmd.add({"tpwalk", "tpwalk"}, {"tpwalk <number>", "More undetectable walkspeed script"}, function(...)
	if TPWalk then
		TPWalk = false
		NAlib.disconnect("TPWalkingConnection")
	end

	TPWalk = true
	local Speed = ...

	NAlib.connect("TPWalkingConnection", RunService.Stepped:Connect(function(_, deltaTime)
		if TPWalk then
			local humanoid = getHum()
			if humanoid and humanoid.MoveDirection.Magnitude > 0 then
				local moveDirection = humanoid.MoveDirection
				local translation = moveDirection * (Speed or 1) * deltaTime * 10
				getChar():TranslateBy(translation)
			end
		end
	end))
end, true)

cmd.add({"untpwalk"}, {"untpwalk", "Stops the tpwalk command"}, function()
	TPWalk = false
	NAlib.disconnect("TPWalkingConnection")
end)

muteLOOP = {}

cmd.add({"loopmute", "loopmuteboombox"}, {"loopmute <player> (loopmuteboombox)", "Loop mutes the player's boombox"}, function(...)
	local u = ...
	local pls = getPlr(u)
	if #pls == 0 then return end

	local function mute(p)
		if p and p.Character then
			for _, d in ipairs(p.Character:GetDescendants()) do
				if d:IsA("Sound") and d.Playing then
					d.Playing = false
				end
			end
		end
		local bp = p:FindFirstChildOfClass("Backpack")
		if bp then
			for _, d in ipairs(bp:GetDescendants()) do
				if d:IsA("Sound") and d.Playing then
					d.Playing = false
				end
			end
		end
	end

	for _, p in ipairs(pls) do
		local id = p.UserId
		if not muteLOOP[id] then
			muteLOOP[id] = Spawn(function()
				while p and p.Parent do
					mute(p)
					Wait(1)
				end
				muteLOOP[id] = nil
			end)
			DebugNotif("Loopmuted "..p.Name)
		else
			DebugNotif(p.Name.." already loopmuted")
		end
	end
end, true)

cmd.add({"unloopmute", "unloopmuteboombox"}, {"unloopmute <player> (unloopmuteboombox)", "Unloop mutes the player's boombox"}, function(...)
	local u = ...
	local pls = getPlr(u)
	if #pls == 0 then return end

	for _, p in ipairs(pls) do
		local id = p.UserId
		local t = muteLOOP[id]
		if t then
			coroutine.close(t)
			muteLOOP[id] = nil
			DebugNotif("Unloopmuted "..p.Name)
		else
			DebugNotif(p.Name.." not loopmuted")
		end
	end
end, true)

cmd.add({"getmass"}, {"getmass <player>", "Get your mass"}, function(...)
	local target = getPlr(...)
	for _, plr in next, target do
		local char = plr.Character or getPlrChar(plr)
		if char then
			local root = getRoot(char)
			if root then
				local mass = root.AssemblyMass
				DoNotif(nameChecker(plr).."'s mass is "..mass)
			end
		end
		Wait()
	end
end, true)

cmd.add({"copyposition", "copypos", "cpos"}, {"copyposition <player>", "Get the position of another player"}, function(...)
	local target = getPlr(...)
	for _, plr in next, target do
		local char = plr.Character or getPlrChar(plr)
		if char then
			local root = getRoot(char)
			if root then
				local pos = root.Position
				DebugNotif(nameChecker(plr).."'s position is: "..tostring(pos))
				if setclipboard then
					setclipboard(tostring(pos))
				end
			end
		end
		Wait()
	end
end, true)

cmd.add({"equiptools"},{"equiptools","Equips every tool in your inventory at once"},function()
	for i,v in pairs(Player:FindFirstChildOfClass("Backpack"):GetChildren()) do
		if v:IsA("Tool") or v:IsA("HopperBin") then
			v.Parent=Player.Character
		end
	end
end)

cmd.add({"unequiptools"},{"unequiptools","Unequips every tool you are currently holding at once"},function()
	Player.Character:FindFirstChildOfClass('Humanoid'):UnequipTools()
end)

cmd.add({"removeterrain", "rterrain", "noterrain"},{"removeterrain (rterrain, noterrain)","clears terrain"},function()
	workspace:FindFirstChildOfClass('Terrain'):Clear()
end)

cmd.add({"clearnilinstances", "nonilinstances", "cni"},{"clearnilinstances (nonilinstances, cni)","Removes nil instances"},function()
	if getnilinstances then
		for _,nill in pairs(getnilinstances()) do
			nill:Destroy()
		end
	else
		DoNotif("Your exploit does not support getnilinstances")
	end
end)

cmd.add({"inspect"}, {"inspect", "checks a user's items"}, function(args)
	local targetPlayers = getPlr(args)

	for _, plr in next, targetPlayers do
		SafeGetService("GuiService"):CloseInspectMenu()
		SafeGetService("GuiService"):InspectPlayerFromUserId(plr.UserId)
	end
end, true)

promptTBL = promptTBL or {tracked = {}, conns = {}, blocking = false}

function nuhuhprompt(v)
	NACaller(function()
		if v == false then
			if promptTBL.blocking then return end
			promptTBL.blocking = true
			for _, d in ipairs(COREGUI:GetDescendants()) do
				local gui = d:IsA("ScreenGui") and d or d:FindFirstAncestorWhichIsA("ScreenGui")
				if gui and gui.Name and gui.Name:lower():find("purchaseprompt") then
					if promptTBL.tracked[gui] == nil then promptTBL.tracked[gui] = gui.Enabled end
					pcall(function() gui.Enabled = false end)
					for _, x in ipairs(gui:GetDescendants()) do
						if x:IsA("ScreenGui") then
							if promptTBL.tracked[x] == nil then promptTBL.tracked[x] = x.Enabled end
							pcall(function() x.Enabled = false end)
						end
					end
					local inner = gui.DescendantAdded:Connect(function(inst)
						if inst:IsA("ScreenGui") then
							if promptTBL.tracked[inst] == nil then promptTBL.tracked[inst] = inst.Enabled end
							pcall(function() inst.Enabled = false end)
						end
					end)
					Insert(promptTBL.conns, inner)
				end
			end
			local c = COREGUI.DescendantAdded:Connect(function(inst)
				local gui = inst:IsA("ScreenGui") and inst or inst:FindFirstAncestorWhichIsA("ScreenGui")
				if gui and gui.Name and gui.Name:lower():find("purchaseprompt") then
					if promptTBL.tracked[gui] == nil then promptTBL.tracked[gui] = gui.Enabled end
					pcall(function() gui.Enabled = false end)
					for _, x in ipairs(gui:GetDescendants()) do
						if x:IsA("ScreenGui") then
							if promptTBL.tracked[x] == nil then promptTBL.tracked[x] = x.Enabled end
							pcall(function() x.Enabled = false end)
						end
					end
					local inner = gui.DescendantAdded:Connect(function(inst2)
						if inst2:IsA("ScreenGui") then
							if promptTBL.tracked[inst2] == nil then promptTBL.tracked[inst2] = inst2.Enabled end
							pcall(function() inst2.Enabled = false end)
						end
					end)
					Insert(promptTBL.conns, inner)
				end
			end)
			Insert(promptTBL.conns, c)
		else
			if not promptTBL.blocking then return end
			promptTBL.blocking = false
			for i = #promptTBL.conns, 1, -1 do
				local c = promptTBL.conns[i]
				if c and c.Connected then c:Disconnect() end
				promptTBL.conns[i] = nil
			end
			for gui, prev in pairs(promptTBL.tracked) do
				if typeof(gui) == "Instance" and gui and gui.Parent ~= nil then
					pcall(function() gui.Enabled = prev end)
				end
				promptTBL.tracked[gui] = nil
			end
		end
	end)
end

cmd.add({"noprompt","nopurchaseprompts","noprompts"},{"noprompt (nopurchaseprompts,noprompts)","remove the stupid purchase prompt"},function()
	nuhuhprompt(false)
	DebugNotif("Purchase prompts have been disabled")
end)

cmd.add({"prompt","purchaseprompts","showprompts","showpurchaseprompts"},{"prompt (purchaseprompts,showprompts,showpurchaseprompts)","allows the stupid purchase prompt"},function()
	nuhuhprompt(true)
	DebugNotif("Purchase prompts have been enabled")
end)

cmd.add({"wallwalk"},{"wallwalk","Makes you walk on walls"},function()
	loadstring(game:HttpGet("https://raw.githubusercontent.com/ltseverydayyou/uuuuuuu/main/WallWalk.lua"))() -- backup cause i don't trust pastebin
end)

hiddenGUIS = hiddenGUIS or {}
showPrev = showPrev or {}

cmd.add({"hideguis"}, {"hideguis","Hides GUIs"}, function()
	for _, guiElement in pairs(PlrGui:GetDescendants()) do
		if guiElement:IsA("GuiObject") and guiElement.Visible then
			guiElement.Visible = false
			if not Discover(hiddenGUIS, guiElement) then
				Insert(hiddenGUIS, guiElement)
			end
		end
	end
end)

cmd.add({"unhideguis"}, {"unhideguis","Restores GUIs hidden by hideguis"}, function()
	for _, guiElement in pairs(hiddenGUIS) do
		if guiElement and guiElement.Parent then
			guiElement.Visible = true
		end
	end
	hiddenGUIS = {}
end)

cmd.add({"showguis"}, {"showguis","Enables every UI"}, function()
	for _, inst in pairs(PlrGui:GetDescendants()) do
		if inst:IsA("ScreenGui") then
			if not showPrev[inst] then showPrev[inst] = {enabled = inst.Enabled} end
			inst.Enabled = true
		elseif inst:IsA("GuiObject") then
			if not showPrev[inst] then showPrev[inst] = {visible = inst.Visible} else if showPrev[inst].visible == nil then showPrev[inst].visible = inst.Visible end end
			inst.Visible = true
		end
	end
end)

cmd.add({"unshowguis"}, {"unshowguis","Restores UI states set by showguis"}, function()
	for inst, prev in pairs(showPrev) do
		if inst and inst.Parent then
			if prev.enabled ~= nil and inst:IsA("ScreenGui") then inst.Enabled = prev.enabled end
			if prev.visible ~= nil and inst:IsA("GuiObject") then inst.Visible = prev.visible end
		end
		showPrev[inst] = nil
	end
end)

spinThingy = nil
spinPart = nil

cmd.add({"spin"}, {"spin {amount}", "Makes your character spin as fast as you want"}, function(...)
	Wait()

	local spinSpeed = (...)
	if not spinSpeed then spinSpeed = 20 end

	if spinThingy then
		spinThingy:Destroy()
		spinThingy = nil
	end

	if spinPart then
		spinPart:Destroy()
		spinPart = nil
	end

	spinPart = InstanceNew("Part")
	spinPart.Anchored = false
	spinPart.CanCollide = false
	spinPart.Transparency = 1
	spinPart.Size = Vector3.new(1, 1, 1)
	spinPart.Parent = workspace
	spinPart.CFrame = getRoot(LocalPlayer.Character).CFrame

	spinThingy = InstanceNew("BodyAngularVelocity")
	spinThingy.Parent = spinPart
	spinThingy.MaxTorque = Vector3.new(0, math.huge, 0)
	spinThingy.AngularVelocity = Vector3.new(0, spinSpeed, 0)

	local weld = InstanceNew("WeldConstraint")
	weld.Part0 = spinPart
	weld.Part1 = getRoot(LocalPlayer.Character)
	weld.Parent = spinPart

	DebugNotif("Spinning...")
end, true)

cmd.add({"unspin"}, {"unspin", "Makes your character unspin"}, function()
	Wait()

	if spinThingy then
		spinThingy:Destroy()
		spinThingy = nil
	end

	if spinPart then
		spinPart:Destroy()
		spinPart = nil
	end

	DebugNotif("Spin Disabled", 3)
end)

cmd.add({"notepad"},{"notepad","notepad for making scripts / etc"},function()
	loadstring(game:HttpGet("https://raw.githubusercontent.com/ltseverydayyou/Nameless-Admin/main/NAnotepad.lua"))()
end)

cmd.add({"rc7"},{"rc7","RC7 Internal UI"},function()
	loadstring(game:HttpGet("https://raw.githubusercontent.com/ltseverydayyou/Nameless-Admin/main/rc%20sexy%207"))()
end)

cmd.add({"scriptviewer","viewscripts"},{"scriptviewer (viewscripts)","Can view scripts made by 0866"},function()
	loadstring(game:HttpGet("https://raw.githubusercontent.com/ltseverydayyou/uuuuuuu/main/scriptviewer",true))()
end)

-- idk if this is either broken or patched but i'll keep it ig?
cmd.add({"hydroxide","hydro"},{"hydroxide (hydro)","executes hydroxide"},function()
	if IsOnMobile then
		local owner = "Hosvile"
		local branch = "revision"

		local function webImport(file)
			return loadstring(game:HttpGetAsync(("https://raw.githubusercontent.com/%s/MC-Hydroxide/%s/%s.lua"):format(owner, branch, file)), file..'.lua')()
		end

		webImport("init")
		webImport("ui/main")
	else
		local owner="Upbolt"
		local branch="revision"

		local function webImport(file)
			return loadstring(game:HttpGetAsync(("https://raw.githubusercontent.com/%s/Hydroxide/%s/%s.lua"):format(owner,branch,file)),file..'.lua')()
		end

		webImport("init")
		webImport("ui/main")
	end
end)

cmd.add({"remotespy","simplespy","rspy"},{"remotespy (simplespy,rspy)","executes simplespy that supports both pc and mobile"},function()
	loadstring(game:HttpGet("https://raw.githubusercontent.com/ltseverydayyou/uuuuuuu/main/simplee%20spyyy%20mobilee"))()
end)

cmd.add({"turtlespy","tspy"},{"turtlespy (tspy)","executes Turtle Spy that supports both pc and mobile"},function()
	loadstring(game:HttpGet("https://raw.githubusercontent.com/ltseverydayyou/uuuuuuu/main/Turtle%20Spy.lua"))()
end)

-- running this twice may lead to a crash (this shit is a bit broken idfk why)
cmd.add({"sigmaspy", "sspy","superspy"},{"sigmaspy","the strongest RemoteSpy able to detect (RemoteEvent/Function - BindableEvent/Function - OnClientEvent/OnClientInvoke) and can detect remotes that were fired from Actors"},function()
	loadstring(game:HttpGet("https://raw.githubusercontent.com/depthso/Sigma-Spy/refs/heads/main/Main.lua"))()
end)

cmd.add({"gravity","grav"},{"gravity <amount> (grav)","sets game gravity to whatever u want"},function(...)
	workspace.Gravity=(...)
end,true)

cmd.add({"fireclickdetectors","fcd","firecd"},{"fireclickdetectors (fcd,firecd)","Fires every ClickDetector in Workspace"},function(...)
	local args={...}
	local targetText = args[1] and Concat(args," ")
	local target = targetText and Lower(targetText) or nil
	if typeof(fireclickdetector)~="function" then return DoNotif("fireclickdetector not available",3) end
	NAindex.init()
	local list,f={},0
	if NAindex.click then
		for inst,rec in pairs(NAindex.click) do
			if inst and inst.Parent and rec and rec.names and NAindex.matchAny(rec.names, target) then
				Insert(list,inst)
			end
		end
	end
	if #list==0 then
		if target then return DebugNotif("No ClickDetectors found matching \""..targetText.."\"",2) end
		return DebugNotif("No ClickDetectors found",2)
	end
	for _,d in ipairs(list) do
		if not pcall(function() fireclickdetector(d) end) then f += 1 end
	end
	Wait()
	if f>0 then
		DebugNotif(("Fired %d ClickDetectors, Failed: %d"):format(#list,f),2)
	else
		DebugNotif(("Fired %d ClickDetectors"):format(#list),2)
	end
end,true)

cmd.add({"fireproximityprompts","fpp","firepp"},{"fireproximityprompts (fpp,firepp)","Fires every ProximityPrompt in Workspace"},function(...)
	local args={...}
	local targetText = args[1] and Concat(args," ")
	local target = targetText and Lower(targetText) or nil
	if typeof(fireproximityprompt)~="function" then return DoNotif("fireproximityprompt not available",3) end
	NAindex.init()
	local list,f={},0
	if NAindex.prompt then
		for inst,rec in pairs(NAindex.prompt) do
			if inst and inst.Parent and rec and rec.names and NAindex.matchAny(rec.names, target) then
				Insert(list,inst)
			end
		end
	end
	if #list==0 then
		if target then return DebugNotif("No ProximityPrompts found matching \""..targetText.."\"",2) end
		return DebugNotif("No ProximityPrompts found",2)
	end
	for _,p in ipairs(list) do
		if not pcall(function() fireproximityprompt(p,1) end) then f += 1 end
	end
	Wait()
	if f>0 then
		DebugNotif(("Fired %d ProximityPrompts, Failed: %d"):format(#list,f),2)
	else
		DebugNotif(("Fired %d ProximityPrompts"):format(#list),2)
	end
end,true)

cmd.add({"firetouchinterests","fti"},{"firetouchinterests (fti)","Fires every TouchInterest in Workspace"},function(...)
	local args = {...}
	local targetText = args[1] and Concat(args," ")
	local target = targetText and Lower(targetText) or nil
	if typeof(firetouchinterest) ~= "function" then return end
	local char = getChar()
	local root = char and (getRoot(char) or char:FindFirstChildWhichIsA("BasePart"))
	if not root then return end
	NAindex.init()
	local found = 0
	if NAindex.touch then
		for ti in pairs(NAindex.touch) do
			local container = ti.Parent
			if container and container.Parent then
				local part = NAindex.carPart(container)
				if part and part.Parent then
					local names = {}
					if ti.Name and ti.Name ~= "" then Insert(names, NAindex.lc(ti.Name)) end
					if container.Name and container.Name ~= "" then Insert(names, NAindex.lc(container.Name)) end
					if part.Name and part.Name ~= "" then Insert(names, NAindex.lc(part.Name)) end
					local model = part:FindFirstAncestorWhichIsA("Model")
					while model do
						if model.Name and model.Name ~= "" then Insert(names, NAindex.lc(model.Name)) end
						model = model:FindFirstAncestorWhichIsA("Model")
					end
					if NAindex.matchAny(names, target) then
						found += 1
						local targetPart = part
						SpawnCall(function()
							local orig = targetPart.CFrame
							targetPart.CFrame = root.CFrame
							firetouchinterest(targetPart,root,1)
							Wait()
							firetouchinterest(targetPart,root,0)
							Delay(0.1,function()
								if targetPart and targetPart.Parent then
									targetPart.CFrame = orig
								end
							end)
						end)
					end
				end
			end
		end
	end
	if found == 0 then
		if target then
			DebugNotif(("No TouchInterests found matching \"%s\""):format(targetText),2)
		else
			DebugNotif("No TouchInterests found",2)
		end
	else
		DebugNotif(("Fired %d TouchInterests"):format(found),2)
	end
end,true)

NAutil.parseInterval = function(defaultInterval, ...)
	local args = { ... }
	local n1 = tonumber(args[1])
	if n1 then
		return n1, (args[2] and Lower(Concat(args, " ", 2)) or nil)
	else
		return defaultInterval, (args[1] and Lower(Concat(args, " ", 1)) or nil)
	end
end

NAindex.lc = function(s) return s and Lower(s) or "" end

NAindex.carPart = function(inst)
	if not inst then return nil end
	if inst:IsA("BasePart") then return inst end
	if inst:IsA("Attachment") then
		local p = inst.Parent
		if p and p:IsA("BasePart") then return p end
	end
	return inst:FindFirstAncestorWhichIsA("BasePart")
end

NAindex.getPromptPart = function(pp)
	local parent = pp and pp.Parent
	if not parent then return nil end
	if parent:IsA("Attachment") then
		local p = parent.Parent
		return p and p:IsA("BasePart") and p or nil
	elseif parent:IsA("BasePart") then
		return parent
	end
	local model = pp:FindFirstAncestorWhichIsA("Model")
	if model then
		if model.PrimaryPart then return model.PrimaryPart end
		local bp = model:FindFirstChildWhichIsA("BasePart", true)
		if bp then return bp end
	end
	return pp:FindFirstAncestorWhichIsA("BasePart")
end

NAindex.namesForPrompt = function(p)
	local names = {}
	if p.Name then Insert(names, p.Name) end
	if p.ObjectText then Insert(names, p.ObjectText) end
	if p.ActionText then Insert(names, p.ActionText) end
	if p.Parent and p.Parent.Name then Insert(names, p.Parent.Name) end
	local part = NAindex.getPromptPart(p)
	if part then
		Insert(names, part.Name)
		local m = part:FindFirstAncestorWhichIsA("Model")
		while m do
			Insert(names, m.Name)
			m = m:FindFirstAncestorWhichIsA("Model")
		end
	else
		local m = p:FindFirstAncestorWhichIsA("Model")
		while m do
			Insert(names, m.Name)
			m = m:FindFirstAncestorWhichIsA("Model")
		end
	end
	for i = 1, #names do names[i] = NAindex.lc(names[i]) end
	return names
end

NAindex.namesForClick = function(d)
	local names = {}
	if d.Name then Insert(names, d.Name) end
	if d.Parent and d.Parent.Name then Insert(names, d.Parent.Name) end
	local part = NAindex.carPart(d.Parent or d)
	if part then
		Insert(names, part.Name)
		local m = part:FindFirstAncestorWhichIsA("Model")
		while m do
			Insert(names, m.Name)
			m = m:FindFirstAncestorWhichIsA("Model")
		end
	end
	for i = 1, #names do names[i] = NAindex.lc(names[i]) end
	return names
end

NAindex.matchAny = function(names, target)
	target = NAindex.lc(target)
	if not target or target == "" then return true end
	for i = 1, #names do
		if names[i] == target then
			return true
		end
	end
	return false
end

NAindex.matchAnyFind = function(names, target)
	target = NAindex.lc(target)
	if not target or target == "" then return true end
	for i = 1, #names do
		local n = names[i]
		if n == target or Find(n, target, 1, true) then
			return true
		end
	end
	return false
end

NAindex.promptTarget = function(pp)
	local part = NAindex.getPromptPart(pp)
	return part, part and part.Position or nil
end

NAindex.clickTarget = function(cd)
	local part = NAindex.carPart(cd.Parent or cd)
	return part, part and part.Position or nil
end

NAindex.inRangePrompt = function(pp, rootPos, extra)
	local part, pos = NAindex.promptTarget(pp)
	if not pos then return false, math.huge, part end
	local dist = (pos - rootPos).Magnitude
	local maxd = (pp.MaxActivationDistance or 0) + (extra or 0)
	return dist <= maxd, dist, part
end

NAindex.inRangeClick = function(cd, rootPos, extra)
	local part, pos = NAindex.clickTarget(cd)
	if not pos then return false, math.huge, part end
	local dist = (pos - rootPos).Magnitude
	local maxd = (cd.MaxActivationDistance or 0) + (extra or 0)
	return dist <= maxd, dist, part
end

NAindex.add = function(inst)
	if inst:IsA("ProximityPrompt") then
		NAindex.prompt = NAindex.prompt or {}
		NAindex.prompt[inst] = { inst = inst, names = NAindex.namesForPrompt(inst) }
	elseif inst:IsA("ClickDetector") then
		NAindex.click = NAindex.click or {}
		NAindex.click[inst] = { inst = inst, names = NAindex.namesForClick(inst) }
	elseif inst:IsA("TouchTransmitter") or inst.Name == "TouchInterest" then
		NAindex.touch = NAindex.touch or {}
		NAindex.touch[inst] = { inst = inst }
	end
end

NAindex.remove = function(inst)
	if NAindex.prompt then NAindex.prompt[inst] = nil end
	if NAindex.click   then NAindex.click[inst]   = nil end
	if NAindex.touch   then NAindex.touch[inst]   = nil end
end

NAindex.init = function()
	if NAindex._init then return end
	for _, obj in ipairs(workspace:GetDescendants()) do NAindex.add(obj) end
	NAlib.connect("NAindex_added", workspace.DescendantAdded:Connect(NAindex.add))
	NAlib.connect("NAindex_removed", workspace.DescendantRemoving:Connect(NAindex.remove))
	NAindex._init = true
end

NAsuppress._acquire = function(pp)
	local r = NAsuppress.ref[pp] or 0
	if r == 0 then
		NAsuppress.snap[pp] = pp.Enabled
		pp.Enabled = false
	end
	NAsuppress.ref[pp] = r + 1
end

NAsuppress._release = function(pp)
	local r = NAsuppress.ref[pp]
	if not r then return end
	r -= 1
	if r <= 0 then
		local prev = NAsuppress.snap[pp]
		if prev ~= nil and pp and pp.Parent then
			pp.Enabled = prev
		end
		NAsuppress.ref[pp] = nil
		NAsuppress.snap[pp] = nil
	else
		NAsuppress.ref[pp] = r
	end
end

NAsuppress.collectAndAcquire = function(centerPos, radius, allowSet)
	local list = {}
	if NAindex.prompt then
		for p in pairs(NAindex.prompt) do
			if p.Parent and p.Enabled and not allowSet[p] then
				local _, pos = NAindex.promptTarget(p)
				if pos and (pos - centerPos).Magnitude <= radius then
					NAsuppress._acquire(p)
					Insert(list, p)
				end
			end
		end
	end
	return list
end

NAsuppress.releaseList = function(list)
	for _, p in ipairs(list) do
		NAsuppress._release(p)
	end
end

NAjobs._claim = function(key)
	if not key then return true end
	if NAjobs._claimed[key] == NAjobs._frame then return false end
	NAjobs._claimed[key] = NAjobs._frame
	return true
end

NAjobs._restoreTouchDue = function()
	local now = time()
	for part, st in pairs(NAjobs._touchState) do
		if st.moved and st.restoreAt and now >= st.restoreAt then
			if part and part.Parent then
				part.CFrame = st.orig
			end
			st.moved = false
			st.orig = nil
			st.restoreAt = nil
			NAjobs._touchState[part] = nil
		end
	end
end

NAjobs._schedule = function()
	if NAjobs.hb then return end
	NAjobs.hb = NAlib.connect("NAjobs_stp", RunService.Heartbeat:Connect(function()
		NAjobs._frame += 1
		NAjobs._claimed = {}
		local now = time()
		for _, job in pairs(NAjobs.jobs) do
			if job.interval <= 0 then
				job.tick(job)
			else
				if now >= job.next then
					job.next = now + job.interval
					job.tick(job)
				end
			end
		end
		NAjobs._restoreTouchDue()
	end))
end

NAjobs._maybeStop = function()
	if not next(NAjobs.jobs) and NAjobs.hb then
		NAlib.disconnect("NAjobs_stp")
		NAjobs.hb = nil
	end
end

NAjobs.start = function(kind, interval, target, useFind)
	NAindex.init()
	NAjobs.seq += 1
	local id = kind.."#"..tostring(NAjobs.seq)
	local tgt = target and Lower(target) or nil
	local ivl = interval or 0.1
	local stagger = (ivl > 0) and math.min(0.02, ivl / 8) or 0
	local job = { id = id, kind = kind, interval = math.max(0, ivl), target = tgt, next = time(), stagger = stagger, m = (useFind and NAindex.matchAnyFind or NAindex.matchAny) }

	if kind == "prompt" then
		job.tick = function(self)
			if not NAindex.prompt then return end
			local char = getChar()
			local root = char and (getRoot(char) or char:FindFirstChildWhichIsA("BasePart"))
			if not root then return end
			local rootPos = root.Position
			local list = {}
			for inst, rec in pairs(NAindex.prompt) do
				if inst.Parent and inst.Enabled and self.m(rec.names, self.target) then
					local ok, dist, part = NAindex.inRangePrompt(inst, rootPos, 5)
					if ok then Insert(list, {inst = inst, dist = dist, part = part}) end
				end
			end
			table.sort(list, function(a, b) return a.dist < b.dist end)
			local step = (self.interval > 0) and self.stagger or 0
			local i = 0
			for _, it in ipairs(list) do
				if NAjobs._claim(it.inst) then
					i += 1
					Delay(step * (i - 1), function()
						local range = (it.inst.MaxActivationDistance or 0) + 5
						local allow = {[it.inst]=true}
						local suppressed = NAsuppress.collectAndAcquire(it.part and it.part.Position or rootPos, 10, allow)
						pcall(fireproximityprompt, it.inst, { hold = 0.03, distance = range, stagger = 0 })
						Delay(0.06, function() NAsuppress.releaseList(suppressed) end)
					end)
				end
			end
		end
	elseif kind == "click" then
		job.tick = function(self)
			if not NAindex.click then return end
			local char = getChar()
			local root = char and (getRoot(char) or char:FindFirstChildWhichIsA("BasePart"))
			if not root then return end
			local rootPos = root.Position
			local list = {}
			for inst, rec in pairs(NAindex.click) do
				if inst.Parent and self.m(rec.names, self.target) then
					local ok, dist, part = NAindex.inRangeClick(inst, rootPos, 5)
					if ok then Insert(list, {inst = inst, dist = dist, part = part}) end
				end
			end
			table.sort(list, function(a, b) return a.dist < b.dist end)
			local step = (self.interval > 0) and self.stagger or 0
			local i = 0
			for _, it in ipairs(list) do
				if NAjobs._claim(it.part) then
					i += 1
					Delay(step * (i - 1), function()
						pcall(fireclickdetector, it.inst)
					end)
				end
			end
		end
	elseif kind == "touch" then
		job.tick = function(self)
			if not NAindex.touch then return end
			local char = getChar()
			local root = char and (getRoot(char) or char:FindFirstChildWhichIsA("BasePart"))
			if not root or not root:IsDescendantOf(workspace) then return end
			local list = {}
			for ti in pairs(NAindex.touch) do
				local container = ti.Parent
				if container and container.Parent then
					local part = NAindex.carPart(container)
					if part then
						local names = { NAindex.lc(part.Name) }
						local m = part:FindFirstAncestorWhichIsA("Model")
						while m do Insert(names, NAindex.lc(m.Name)); m = m:FindFirstAncestorWhichIsA("Model") end
						if self.m(names, self.target) then
							local asm = part.AssemblyRootPart or part
							if asm then Insert(list, {part = asm}) end
						end
					end
				end
			end
			local i = 0
			for _, it in ipairs(list) do
				if NAjobs._claim(it.part) then
					i += 1
					Delay(self.stagger * (i - 1), function()
						local asm = it.part
						if not asm or not asm.Parent or not asm:IsDescendantOf(workspace) then return end
						local st = NAjobs._touchState[asm]
						if not st or not st.moved then
							st = st or {}
							st.orig = asm.CFrame
							st.moved = true
							NAjobs._touchState[asm] = st
						end
						local char2 = getChar()
						local root2 = char2 and (getRoot(char2) or char2:FindFirstChildWhichIsA("BasePart"))
						if not root2 or not root2:IsDescendantOf(workspace) then return end
						asm:PivotTo(root2.CFrame)
						pcall(firetouchinterest, asm, root2, 1)
						Wait()
						pcall(firetouchinterest, asm, root2, 0)
						st.restoreAt = time() + 0.05
					end)
				end
			end
		end
	end

	NAjobs.jobs[id] = job
	NAjobs._schedule()
	return id
end

NAjobs._restoreAllTouch = function()
	for part, st in pairs(NAjobs._touchState) do
		if st.moved and st.orig and part and part.Parent then
			part.CFrame = st.orig
		end
		NAjobs._touchState[part] = nil
	end
end

NAjobs.stopByKind = function(kind)
	for id, job in pairs(NAjobs.jobs) do
		if job.kind == kind then NAjobs.jobs[id] = nil end
	end
	if kind == "touch" then NAjobs._restoreAllTouch() end
	NAjobs._maybeStop()
end

NAjobs.stopById = function(id)
	local job = NAjobs.jobs[id]
	if not job then return end
	NAjobs.jobs[id] = nil
	if job.kind == "touch" then NAjobs._restoreAllTouch() end
	NAjobs._maybeStop()
end

NAjobs.stopAll = function()
	for id in pairs(NAjobs.jobs) do NAjobs.jobs[id] = nil end
	NAjobs._restoreAllTouch()
	NAjobs._maybeStop()
end

NAmanage._windowStopKind=function(kind, titleText)
	local buttons = {}
	for id, job in pairs(NAjobs.jobs) do
		if job.kind == kind and job.m ~= NAindex.matchAnyFind then
			local label = job.id..(job.target and (" • "..job.target) or "")
			Insert(buttons, {
				Text = label,
				Callback = function()
					NAjobs.stopById(job.id)
					DebugNotif("stopped "..label, 2)
				end
			})
		end
	end
	Insert(buttons, {
		Text = "All",
		Callback = function()
			for jid, j in pairs(NAjobs.jobs) do
				if j.kind == kind and j.m ~= NAindex.matchAnyFind then
					NAjobs.stopById(jid)
				end
			end
			DebugNotif("all "..kind.." stopped", 2)
		end
	})
	Window({
		Title = titleText,
		Buttons = buttons
	})
end

NAmanage._windowStopKindFind=function(kind, titleText)
	local buttons = {}
	for id, job in pairs(NAjobs.jobs) do
		if job.kind == kind and job.m == NAindex.matchAnyFind then
			local label = job.id..(job.target and (" • "..job.target) or "")
			Insert(buttons, {
				Text = label,
				Callback = function()
					NAjobs.stopById(job.id)
					DebugNotif("stopped "..label, 2)
				end
			})
		end
	end
	Insert(buttons, {
		Text = "All",
		Callback = function()
			for jid, j in pairs(NAjobs.jobs) do
				if j.kind == kind and j.m == NAindex.matchAnyFind then
					NAjobs.stopById(jid)
				end
			end
			DebugNotif("all "..kind.." (find) stopped", 2)
		end
	})
	Window({
		Title = titleText,
		Buttons = buttons
	})
end

cmd.add({"AutoFireProxi","afp"},{"AutoFireProxi <interval> [target] (afp)","Automatically fires ProximityPrompts matching [target] every <interval> seconds"}, function(...)
	local args = {...}
	local interval, target
	if args[1] and not tonumber(args[1]) then
		interval = 0
		target = Lower(Concat(args, " ", 1))
	else
		interval, target = NAutil.parseInterval(0.01, ...)
	end
	local id = NAjobs.start("prompt", interval, target)
	DebugNotif(target and ("afp started (%s) → %s"):format(target, id) or ("afp started → %s"):format(id), 2)
end, true)

cmd.add({"AutoFireProxiFind","afpfind"},{"AutoFireProxiFind <interval> [target] (afpfind)","Automatically fires ProximityPrompts matching [target] using substring matching every <interval> seconds"}, function(...)
	local args = {...}
	local interval, target
	if args[1] and not tonumber(args[1]) then
		interval = 0
		target = Lower(Concat(args, " ", 1))
	else
		interval, target = NAutil.parseInterval(0.01, ...)
	end
	local id = NAjobs.start("prompt", interval, target, true)
	DebugNotif(target and ("afpfind started (%s) → %s"):format(target, id) or ("afpfind started → %s"):format(id), 2)
end, true)

cmd.add({"AutoFireClick","afc"},{"AutoFireClick <interval> [target] (afc)","Automatically fires ClickDetectors matching [target] every <interval> seconds"}, function(...)
	local args = {...}
	local interval, target
	if args[1] and not tonumber(args[1]) then
		interval = 0
		target = Lower(Concat(args, " ", 1))
	else
		interval, target = NAutil.parseInterval(0.01, ...)
	end
	local id = NAjobs.start("click", interval, target)
	DebugNotif(target and ("afc started (%s) → %s"):format(target, id) or ("afc started → %s"):format(id), 2)
end, true)

cmd.add({"AutoFireClickFind","afcfind"},{"AutoFireClickFind <interval> [target] (afcfind)","Automatically fires ClickDetectors matching [target] using substring matching every <interval> seconds"}, function(...)
	local args = {...}
	local interval, target
	if args[1] and not tonumber(args[1]) then
		interval = 0
		target = Lower(Concat(args, " ", 1))
	else
		interval, target = NAutil.parseInterval(0.01, ...)
	end
	local id = NAjobs.start("click", interval, target, true)
	DebugNotif(target and ("afcfind started (%s) → %s"):format(target, id) or ("afcfind started → %s"):format(id), 2)
end, true)

cmd.add({"AutoTouch","at"},{"AutoTouch <interval> [target] (at)","Automatically fires TouchInterests on parts matching [target] every <interval> seconds"}, function(...)
	local interval, target = NAutil.parseInterval(0.5, ...)
	local id = NAjobs.start("touch", interval, target)
	DebugNotif(target and ("at started (%s) → %s"):format(target, id) or ("at started → %s"):format(id), 2)
end, true)

cmd.add({"unautofireproxi","uafp"},{"unautofireproxi (uafp)","Stops all AutoFireProxi loops"}, function()
	NAmanage._windowStopKind("prompt","AutoFireProxi Jobs")
end)

cmd.add({"unautofireclick","uafc"},{"unautofireclick (uafc)","Stops all AutoFireClick loops"}, function()
	NAmanage._windowStopKind("click","AutoFireClick Jobs")
end)

cmd.add({"unautotouch","uat"},{"unautotouch (uat)","Stops all AutoTouch loops"}, function()
	NAmanage._windowStopKind("touch","AutoTouch Jobs")
end)

cmd.add({"unautofireproxifind","uafpfind"},{"unautofireproxifind (uafpfind)","Stops substring-matching AutoFireProxi loops"}, function()
	NAmanage._windowStopKindFind("prompt","AutoFireProxiFind Jobs")
end)

cmd.add({"unautofireclickfind","uafcfind"},{"unautofireclickfind (uafcfind)","Stops substring-matching AutoFireClick loops"}, function()
	NAmanage._windowStopKindFind("click","AutoFireClickFind Jobs")
end)

cmd.add({"noclickdetectorlimits","nocdlimits","removecdlimits"},{"noclickdetectorlimits <limit> (nocdlimits,removecdlimits)","Sets all click detectors MaxActivationDistance to math.huge"},function(...)
	local limit = (...) or math.huge
	for _,v in ipairs(interactTbl.click) do
		v.MaxActivationDistance = limit
	end
end,true)

cmd.add({"noproximitypromptlimits","nopplimits","removepplimits"},{"noproximitypromptlimits <limit> (nopplimits,removepplimits)","Sets all proximity prompts MaxActivationDistance to math.huge"},function(...)
	local limit = (...) or math.huge
	for _,v in ipairs(interactTbl.proxy) do
		v.MaxActivationDistance = limit
	end
end,true)

cmd.add({"instantproximityprompts","instantpp","ipp"},{"instantproximityprompts (instantpp,ipp)","Disable the cooldown for proximity prompts"},function()
	NAlib.disconnect("instantpp")
	NAlib.connect("instantpp", SafeGetService("ProximityPromptService").PromptButtonHoldBegan:Connect(function(pp)
		fireproximityprompt(pp, 1)
	end))
end)

cmd.add({"uninstantproximityprompts","uninstantpp","unipp"},{"uninstantproximityprompts (uninstantpp,unipp)","Undo the cooldown removal"},function()
	NAlib.disconnect("instantpp")
end)

cmd.add({"enableproximityprompts","enableprox","enprox","enprx","enpp"},{"enableproximityprompts [name]","Enable ProximityPrompts (all or matching)"},function(...)
	local term = Lower(Concat({...}," "))
	for _,obj in ipairs(interactTbl.proxy) do
		if obj and obj.Parent then
			if term=="" or Find(Lower(obj.Name), term) then
				obj.Enabled = true
			end
		end
	end
end,true)

cmd.add({"disableproximityprompts","disableprox","disprox","dprx","dpp"},{"disableproximityprompts [name]","Disable ProximityPrompts (all or matching)"},function(...)
	local term = Lower(Concat({...}," "))
	for _,obj in ipairs(interactTbl.proxy) do
		if obj and obj.Parent then
			if term=="" or Find(Lower(obj.Name), term) then
				obj.Enabled = false
			end
		end
	end
end,true)

proxyEnableLoopState = {active=false;}

cmd.add({"loopenableproximityprompts","loopenableprox","lenprox","lenpp"},{"loopenableproximityprompts [name]","Continuously enable ProximityPrompts (all or matching)"},function(...)
	local term = Lower(Concat({...}," "))
	if proxyEnableLoopState then proxyEnableLoopState.active=false end
	proxyEnableLoopState = {active=true}
	SpawnCall(function()
		while proxyEnableLoopState and proxyEnableLoopState.active do
			for _,obj in ipairs(interactTbl.proxy) do
				if obj and obj.Parent and obj:IsA("ProximityPrompt") then
					if term=="" or Find(Lower(obj.Name), term) then
						if obj.Enabled ~= true then obj.Enabled = true end
					end
				end
			end
			Wait(0.1)
		end
	end)
end,true)

cmd.add({"unloopenableproximityprompts","unloopenableprox","unlenprox","unlenpp"},{"unloopenableproximityprompts","Stop enabling loop"},function()
	if proxyEnableLoopState then
		proxyEnableLoopState.active=false
		proxyEnableLoopState=nil
	end
end)

cmd.add({"r6"},{"r6","Shows a prompt that will switch your character rig type into R6"},function()
	SafeGetService("AvatarEditorService"):PromptSaveAvatar(getPlrHum(LocalPlayer).HumanoidDescription,Enum.HumanoidRigType.R6)
	SafeGetService("AvatarEditorService").PromptSaveAvatarCompleted:Wait()
	getHum():ChangeState(Enum.HumanoidStateType.Dead)
	getHum().Health=0
end)

cmd.add({"r15"},{"r15","Shows a prompt that will switch your character rig type into R15"},function()
	SafeGetService("AvatarEditorService"):PromptSaveAvatar(getPlrHum(LocalPlayer).HumanoidDescription,Enum.HumanoidRigType.R15)
	SafeGetService("AvatarEditorService").PromptSaveAvatarCompleted:Wait()
	getHum():ChangeState(Enum.HumanoidStateType.Dead)
	getHum().Health=0
end)

cmd.add({"breakvelocity"},{"breakvelocity","Sets your character's velocity to zero momentarily"},function()
	local char=getChar()
	if not char then
		DoNotif("Character unavailable",2)
		return
	end
	local zero=Vector3.zero
	local stopAt=time()+1
	repeat
		for _,part in ipairs(char:GetDescendants()) do
			if part:IsA("BasePart") then
				NAlib.setProperty(part,"AssemblyLinearVelocity",zero)
				NAlib.setProperty(part,"AssemblyAngularVelocity",zero)
				NAlib.setProperty(part,"Velocity",zero)
				NAlib.setProperty(part,"RotVelocity",zero)
			end
		end
		Wait()
	until time()>=stopAt or not char.Parent
end)

cmd.add({"maxslopeangle", "msa"}, {"maxslopeangle (msa)", "Changes your character's MaxSlopeAngle"}, function(...)
	local args = {...}
	local amount = tonumber(args[1]) or 89

	local humanoid = getHum()
	if humanoid then
		humanoid.MaxSlopeAngle = amount
		DebugNotif(Format("Set MaxSlopeAngle to %s", tostring(amount)), 2)
	else
		DebugNotif("Humanoid not found or invalid.", 2)
	end
end,true)

-- garbage that needs to be changed to something else

NAStuff._godEnabled = NAStuff._godEnabled or false
NAStuff._godMethod  = NAStuff._godMethod  or "nohooks_strong"
NAStuff._godTarget  = NAStuff._godTarget  or 1e9
NAStuff._godOrig    = NAStuff._godOrig    or setmetatable({}, {__mode="k"})
NAStuff._godSignals = NAStuff._godSignals or setmetatable({}, {__mode="k"})
NAStuff._godHumRef  = NAStuff._godHumRef  or nil
NAStuff._godHooked  = NAStuff._godHooked  or false
NAStuff._godOldNC   = NAStuff._godOldNC   or nil
NAStuff._godOldNI   = NAStuff._godOldNI   or nil

NAmanage.God_ClearSignals = function()
	NAlib.disconnect("godmode")
	NAlib.disconnect("god_char")
	NAlib.disconnect("god_loops")
	for _,arr in pairs(NAStuff._godSignals) do
		for _,c in ipairs(arr) do if c then c:Disconnect() end end
	end
	for k in pairs(NAStuff._godSignals) do NAStuff._godSignals[k] = nil end
end

NAmanage.God_UnhookMeta = function()
	if NAStuff._godHooked and NAStuff._godOldNC and NAStuff._godOldNI and typeof(getrawmetatable)=="function" and typeof(setreadonly)=="function" then
		local mt = getrawmetatable(game)
		local ro = isreadonly and isreadonly(mt)
		if ro then setreadonly(mt,false) end
		mt.__namecall = NAStuff._godOldNC
		mt.__newindex = NAStuff._godOldNI
		if ro then setreadonly(mt,true) end
	end
	NAStuff._godHooked, NAStuff._godOldNC, NAStuff._godOldNI = false, nil, nil
end

NAmanage.God_CommonApply = function(h)
	if not h then return end
	NAStuff._godHumRef = h
	if NAStuff._godOrig[h] == nil then
		NAStuff._godOrig[h] = { max = h.MaxHealth, bjd = NAlib.isProperty(h,"BreakJointsOnDeath") }
	end
	if h.MaxHealth < NAStuff._godTarget then NAlib.setProperty(h,"MaxHealth", NAStuff._godTarget) end
	if h.Health < h.MaxHealth then NAlib.setProperty(h,"Health", h.MaxHealth) end
	if NAlib.isProperty(h,"BreakJointsOnDeath") ~= false then NAlib.setProperty(h,"BreakJointsOnDeath", false) end
end

NAmanage.God_WireNoHooks = function(h, strong)
	if not h then return end
	if NAStuff._godSignals[h] then for _,c in ipairs(NAStuff._godSignals[h]) do if c then c:Disconnect() end end end
	NAStuff._godSignals[h] = {}
	Insert(NAStuff._godSignals[h], NAlib.connect("godmode", h.HealthChanged:Connect(function()
		if h.Health < h.MaxHealth then NAlib.setProperty(h,"Health", h.MaxHealth) end
	end)))
	Insert(NAStuff._godSignals[h], NAlib.connect("godmode", h:GetPropertyChangedSignal("Health"):Connect(function()
		if h.Health < h.MaxHealth then NAlib.setProperty(h,"Health", h.MaxHealth) end
	end)))
	Insert(NAStuff._godSignals[h], NAlib.connect("godmode", h:GetPropertyChangedSignal("MaxHealth"):Connect(function()
		if h.MaxHealth < NAStuff._godTarget then NAlib.setProperty(h,"MaxHealth", NAStuff._godTarget) end
		if h.Health < h.MaxHealth then NAlib.setProperty(h,"Health", h.MaxHealth) end
	end)))
	if strong then
		Insert(NAStuff._godSignals[h], NAlib.connect("godmode", h:GetPropertyChangedSignal("BreakJointsOnDeath"):Connect(function()
			if NAlib.isProperty(h,"BreakJointsOnDeath") ~= false then NAlib.setProperty(h,"BreakJointsOnDeath", false) end
		end)))
		Insert(NAStuff._godSignals[h], NAlib.connect("godmode", h.StateChanged:Connect(function(_, s)
			if s == Enum.HumanoidStateType.Dead then
				if h.Health < h.MaxHealth then NAlib.setProperty(h,"Health", h.MaxHealth) end
				pcall(function() h:SetStateEnabled(Enum.HumanoidStateType.Dead, false) end)
				pcall(function() h:ChangeState(Enum.HumanoidStateType.Running) end)
			end
		end)))
		Insert(NAStuff._godSignals[h], NAlib.connect("godmode", h.Died:Connect(function()
			if h.Health < h.MaxHealth then NAlib.setProperty(h,"Health", h.MaxHealth) end
			pcall(function() h:SetStateEnabled(Enum.HumanoidStateType.Dead, false) end)
			pcall(function() h:ChangeState(Enum.HumanoidStateType.Running) end)
		end)))
		pcall(function() h:SetStateEnabled(Enum.HumanoidStateType.Dead, false) end)
		if h:GetState() == Enum.HumanoidStateType.Dead then pcall(function() h:ChangeState(Enum.HumanoidStateType.Running) end) end
	end
	NAlib.connect("god_loops", RunService.RenderStepped:Connect(function()
		local hh = getHum()
		if not hh then return end
		NAStuff._godHumRef = hh
		if hh.MaxHealth < NAStuff._godTarget then NAlib.setProperty(hh,"MaxHealth", NAStuff._godTarget) end
		if hh.Health < hh.MaxHealth then NAlib.setProperty(hh,"Health", hh.MaxHealth) end
		if strong then
			if NAlib.isProperty(hh,"BreakJointsOnDeath") ~= false then NAlib.setProperty(hh,"BreakJointsOnDeath", false) end
			pcall(function() hh:SetStateEnabled(Enum.HumanoidStateType.Dead, false) end)
			if hh:GetState() == Enum.HumanoidStateType.Dead then pcall(function() hh:ChangeState(Enum.HumanoidStateType.Running) end) end
		end
	end))
	NAlib.connect("god_loops", RunService.Stepped:Connect(function()
		local hh = getHum()
		if hh and hh.Health < hh.MaxHealth then NAlib.setProperty(hh,"Health", hh.MaxHealth) end
	end))
	NAlib.connect("god_loops", RunService.Heartbeat:Connect(function()
		local hh = getHum()
		if hh and hh.Health < hh.MaxHealth then NAlib.setProperty(hh,"Health", hh.MaxHealth) end
	end))
end

NAmanage.God_HookMeta = function()
	if NAStuff._godHooked or not (typeof(hookmetamethod)=="function" and typeof(getnamecallmethod)=="function" and typeof(newcclosure)=="function") then return false end
	NAStuff._godHooked = true
	NAStuff._godOldNC = NAStuff._godOldNC or hookmetamethod(game,"__namecall",newcclosure(function(self,...)
		local m = getnamecallmethod()
		local hum = NAStuff._godHumRef
		if hum and typeof(self)=="Instance" then
			if self==hum and m=="ChangeState" then local st = ...; if st==Enum.HumanoidStateType.Dead then return end end
			if self==hum and m=="SetStateEnabled" then local st,en = ...; if st==Enum.HumanoidStateType.Dead and en==true then return end end
			if self==hum and m=="Destroy" then return end
			local char = Players.LocalPlayer.Character
			if char and self==char and m=="BreakJoints" then return end
		end
		return NAStuff._godOldNC(self,...)
	end))
	NAStuff._godOldNI = NAStuff._godOldNI or hookmetamethod(game,"__newindex",newcclosure(function(self,k,v)
		local hum = NAStuff._godHumRef
		if hum and self==hum then
			if k=="Health" and type(v)=="number" and v<=0 then return end
			if k=="MaxHealth" and type(v)=="number" and v<NAStuff._godTarget then return end
			if k=="BreakJointsOnDeath" and v==true then return end
			if k=="Parent" and v==nil then return end
		end
		return NAStuff._godOldNI(self,k,v)
	end))
	return true
end

NAmanage.God_Enable = function(method)
	NAmanage.God_ClearSignals()
	NAmanage.God_UnhookMeta()
	NAStuff._godMethod = method or NAStuff._godMethod
	local lp = Players.LocalPlayer
	local h = getHum()
	if not h then
		NAlib.connect("god_char", lp.CharacterAdded:Connect(function(char)
			local c; c = char.DescendantAdded:Connect(function(inst) if inst:IsA("Humanoid") then c:Disconnect(); NAmanage.God_Enable(NAStuff._godMethod) end end)
		end))
		return
	end
	NAStuff._godEnabled = true
	NAmanage.God_CommonApply(h)
	if NAStuff._godMethod == "hook_meta" then
		NAmanage.God_WireNoHooks(h, true)
		NAmanage.God_HookMeta()
	else
		NAmanage.God_WireNoHooks(h, true)
	end
	NAlib.connect("god_char", lp.CharacterAdded:Connect(function(char)
		Wait()
		local nh = getHum()
		if nh then
			NAmanage.God_CommonApply(nh)
			if NAStuff._godMethod=="hook_meta" then
				NAmanage.God_WireNoHooks(nh, true)
				NAmanage.God_HookMeta()
			else
				NAmanage.God_WireNoHooks(nh, true)
			end
		end
	end))
end

NAmanage.God_Disable = function()
	NAStuff._godEnabled = false
	NAmanage.God_ClearSignals()
	NAmanage.God_UnhookMeta()
	local h = getHum()
	local o = h and NAStuff._godOrig[h]
	if h and o then
		NAlib.setProperty(h,"MaxHealth", o.max or 100)
		if o.bjd ~= nil then NAlib.setProperty(h,"BreakJointsOnDeath", o.bjd) end
		pcall(function() h:SetStateEnabled(Enum.HumanoidStateType.Dead, true) end)
	end
	for k in pairs(NAStuff._godOrig) do NAStuff._godOrig[k] = nil end
	NAStuff._godHumRef = nil
end

cmd.add({"godmode","god"},{"godmode (god)","Pick and enable an invincibility method"},function(...)
	local args = {...}
	local choice = args[1] and Lower(args[1]) or nil
	local useHooking = (typeof(hookmetamethod)=="function" and typeof(getnamecallmethod)=="function" and typeof(newcclosure)=="function")

	local function enableStrong()
		NAStuff._godMethod = "strong"
		if NAmanage and NAmanage.God_Enable then
			NAmanage.God_Enable("nohooks_strong")
		end
		DebugNotif("Godmode ON (strong)",2)
	end

	local function enableHooking()
		NAStuff._godMethod = "hooking"
		if not useHooking then
			DebugNotif("Hooking unavailable; falling back to strong",2)
			return enableStrong()
		end
		if NAmanage and NAmanage.God_Enable then
			NAmanage.God_Enable("hook_meta")
		end
		DebugNotif("Godmode ON (hooking)",2)
	end

	local function disableGod()
		if NAmanage and NAmanage.God_Disable then
			NAmanage.God_Disable()
			DebugNotif("Godmode OFF",2)
		else
			NAlib.disconnect("godmode")
			DebugNotif("Godmode OFF",2)
		end
	end

	if choice == "strong" then return enableStrong() end
	if choice == "hook" or choice == "hooking" then return enableHooking() end
	if choice == "off" or choice == "disable" then return disableGod() end

	local buttons = {}
	Insert(buttons, { Text = "Enable: Strong (no hooks)",   Callback = enableStrong })
	Insert(buttons, { Text = "Enable: Hooking (metamethod)", Callback = enableHooking })
	if NAStuff._godEnabled then
		Insert(buttons, { Text = "Disable Godmode", Callback = disableGod })
	end

	Window({
		Title = "Godmode Methods",
		Buttons = buttons
	})
end)

cmd.add({"ungodmode","ungod"},{"ungodmode (ungod)","Disable invincibility"},function()
	NAmanage.God_Disable()
end)

cmd.add({"controllock","ctrllock"},{"controllock (ctrllock)","Set Shiftlock keys to Control for this session"},function()
	if not IsOnPC then DebugNotif("PC-only feature") return end
	NAmanage.ControlLock_Apply("LeftControl,RightControl")
end)

cmd.add({"uncontrollock","unctrllock"},{"uncontrollock (unctrllock)","Restore Shiftlock keys to default (Shift)"},function()
	if not IsOnPC then DebugNotif("PC-only feature") return end
	NAmanage.ControlLock_Apply("LeftShift,RightShift")
end)

cmd.add({"resetlock"}, {"resetlock", "Resets your Shiftlock keybinds to default (LeftShift)"}, function()
	local player = LocalPlayer
	local mouseLockController = player:WaitForChild("PlayerScripts"):WaitForChild("PlayerModule"):WaitForChild("CameraModule"):WaitForChild("MouseLockController")
	local boundKeys = mouseLockController:WaitForChild("BoundKeys")

	boundKeys.Value = "LeftShift,RightShift"

	DebugNotif("Reset your Shiftlock keybinds to Shift")
end)

cmd.add({"autoreport"}, {"autoreport", "Automatically reports players to get them banned"}, function()
	local ReportKeywords = {
		kid = "Bullying",
		youtube = "Offsite Links",
		date = "Dating",
		hack = "Cheating/Exploiting",
		idiot = "Bullying",
		fat = "Bullying",
		exploit = "Cheating/Exploiting",
		cheat = "Cheating/Exploiting",
		noob = "Bullying",
		clown = "Bullying",
	}

	local function CheckIfReportable(message)
		message = message:lower()
		for keyword, reason in pairs(ReportKeywords) do
			if message:find(keyword) then
				return keyword, reason
			end
		end
		return nil, nil
	end

	local function MonitorPlayerChat(player)
		if player == LocalPlayer then return end

		player.Chatted:Connect(function(message)
			local keyword, reason = CheckIfReportable(message)
			if keyword and reason then
				DebugNotif(Format("Reported %s", nameChecker(player)).." | "..Format("Reason - %s", reason))

				if reportplayer then
					reportplayer(player, reason, Format("Saying %s", keyword))
				else
					SafeGetService("Players"):ReportAbuse(player, reason, Format("Saying %s", keyword))
				end
			end
		end)
	end

	for _, player in ipairs(SafeGetService("Players"):GetPlayers()) do
		MonitorPlayerChat(player)
	end

	SafeGetService("Players").PlayerAdded:Connect(function(player)
		MonitorPlayerChat(player)
	end)
end)

cmd.add({"light"},{"light <range> <brightness> <hexColor>","Gives your player dynamic light"},function(rangeStr,brightnessStr,colorHex)
	local range     = tonumber(rangeStr)   or settingsLight.range
	local brightness= tonumber(brightnessStr)or settingsLight.brightness
	local color     = settingsLight.color
	if colorHex and #colorHex>0 then
		local hex = colorHex:match("^#?(%x+)")
		if hex and (#hex==6 or #hex==3) then
			if #hex==3 then hex = hex:gsub(".", function(c) return c..c end) end
			local r = tonumber(hex:sub(1,2),16)/255
			local g = tonumber(hex:sub(3,4),16)/255
			local b = tonumber(hex:sub(5,6),16)/255
			color = Color3.new(r,g,b)
		end
	end

	local root = getRoot(Player.Character)
	if not root then return end

	local light = settingsLight.LIGHTER
	if not light or not light.Parent then
		light = InstanceNew("PointLight")
		settingsLight.LIGHTER = light
	end

	light.Parent     = root
	light.Range      = range
	light.Brightness = brightness
	light.Color      = color
end, true)

cmd.add({"unlight","nolight"},{"unlight (nolight)","Removes dynamic light from your player"},function()
	if settingsLight.LIGHTER then
		settingsLight.LIGHTER:Destroy()
		settingsLight.LIGHTER = nil
	end
end)

cmd.add({"lighting","lightingcontrol"},{"lighting (lightingcontrol)","Manage lighting technology settings"},function(...)
	local args = {...}
	local target = args[1]
	local buttons = {}
	for _, lt in ipairs(Enum.Technology:GetEnumItems()) do
		Insert(buttons, {
			Text = lt.Name,
			Callback = function()
				Lighting.Technology = lt
			end
		})
	end
	if target and target ~= "" then
		local found = false
		for _, btn in ipairs(buttons) do
			if Match(Lower(btn.Text), Lower(target)) then
				btn.Callback()
				DebugNotif("Lighting technology set to "..btn.Text, 3)
				found = true
				break
			end
		end
		if not found then
			DebugNotif("No matching lighting tech for: "..target, 3)
		end
	else
		Window({
			Title = "Lighting Technology Options",
			Buttons = buttons
		})
	end
end)

cmd.add({"friend"}, {"friend", "Sends a friend request to your target"}, function(p)
	local Targets = getPlr(p)

	for Index, Target in next, Targets do
		LocalPlayer:RequestFriendship(Target)
	end
end,true)

cmd.add({"tweengotocampos","tweentocampos","tweentcp"},{"tweengotocampos (tweentcp)","Another version of goto camera position but bypassing more anti-cheats"},function()
	local player=Players.LocalPlayer
	local TweenService=TweenService

	function teleportPlayer()
		local character=player.Character or player.CharacterAdded:wait(1)
		local camera=workspace.CurrentCamera
		local cameraPosition=camera.CFrame.Position

		local tween=TweenService:Create(character.PrimaryPart,TweenInfo.new(NAmanage.resolveTweenDuration(2)),{
			CFrame=CFrame.new(cameraPosition)
		})

		tween:Play()
	end


	local camera=workspace.CurrentCamera
	repeat Wait() until camera.CFrame~=CFrame.new()

	teleportPlayer()

end)

cmd.add({"delete", "remove", "del"}, {"delete {partname} (remove, del)", "Removes any part with a certain name from the workspace"}, function(...)
	local deleteCount = 0
	local args = {...}
	local targetName = Concat(args, " ")

	for _, d in pairs(workspace:GetDescendants()) do
		if d.Name:lower() == targetName:lower() then
			d:Destroy()
			deleteCount = deleteCount + 1
		end
	end

	Wait()

	if deleteCount > 0 then
		DebugNotif("Deleted "..deleteCount.." instance(s) of '"..targetName.."'", 2.5)
	else
		DebugNotif("'"..targetName.."' not found to delete", 2.5)
	end
end, true)

cmd.add({"deletefind", "removefind", "delfind"}, {"deletefind {partname} (removefind, delfind)", "Removes any part with a name containing the given text from the workspace"}, function(...)
	local deFind = 0
	local targetName = Concat({...}, " "):lower()

	for _, d in pairs(workspace:GetDescendants()) do
		if d.Name:lower():find(targetName) then
			d:Destroy()
			deFind = deFind + 1
		end
	end

	Wait()

	if deFind > 0 then
		DebugNotif("Deleted "..deFind.." instance(s) containing '"..targetName.."'", 2.5)
	else
		DebugNotif("No instances found containing '"..targetName.."'", 2.5)
	end
end, true)

cmd.add({"deletelighting", "removelighting", "removel", "ldel"},{"deletelighting (removelighting, removel, ldel)","Removes all descendants (objects) within Lighting."},function()
	for _, l in ipairs(Lighting:GetDescendants()) do
		l:Destroy()
	end
end)

cmd.add({"lightingdisable", "disablelighting", "ldisable"},{"lightingdisable (disablelighting, ldisable)", "Disables all post-processing effects in Lighting instead of deleting them."},function()
	for _, inst in ipairs(Lighting:GetDescendants()) do
		if inst:IsA("PostEffect") then
			inst.Enabled = false
		end
	end
end)

autoRemover = {}
autoRemoveConnection = nil

function handleDescendantAdd(part)
	if #autoRemover > 0 then
		if FindInTable(autoRemover, part.Name:lower()) then
			Defer(function()
				if part and part.Parent then
					part:Destroy()
				end
			end)
		end
	else
		if autoRemoveConnection then
			autoRemoveConnection:Disconnect()
			autoRemoveConnection = nil
		end
	end
end

cmd.add({"autodelete", "autoremove", "autodel"}, {"autodelete {partname} (autoremove, autodel)", "Removes any part with a certain name from the workspace on loop"}, function(...)
	local args = {...}
	local targetName = Concat(args, " "):lower()

	if not FindInTable(autoRemover, targetName) then
		Insert(autoRemover, targetName)
		for _, part in pairs(workspace:GetDescendants()) do
			if part.Name:lower() == targetName then
				part:Destroy()
			end
		end
	end

	if not autoRemoveConnection then
		autoRemoveConnection = workspace.DescendantAdded:Connect(handleDescendantAdd)
	end

	Wait()
	DebugNotif("Auto deleting instances with name: "..targetName, 2.5)
end, true)

cmd.add({"unautodelete", "unautoremove", "unautodel"}, {"unautodelete {partname} (unautoremove, unautodel)", "Disables autodelete"}, function(...)
	if type(autoRemover) ~= "table" then
		autoRemover = {}
	end

	if #autoRemover == 0 then
		DoNotif("No autodelete names are active.", 2)
		return
	end

	local filter = Lower(Concat({...}, " "))

	local function disconnectAutoRemove()
		if autoRemoveConnection then
			autoRemoveConnection:Disconnect()
			autoRemoveConnection = nil
		end
	end

	local function cleanupConnection()
		if #autoRemover == 0 then
			disconnectAutoRemove()
		end
	end

	local function removeAll()
		autoRemover = {}
		disconnectAutoRemove()
		DoNotif("Cleared all autodelete names.", 2)
	end

	local function removeByTerm(term)
		for i = #autoRemover, 1, -1 do
			if autoRemover[i] == term then
				table.remove(autoRemover, i)
			end
		end
		cleanupConnection()
		DoNotif("Stopped autodeleting '"..term.."'.", 2)
	end

	if filter ~= "" then
		if filter == "all" then
			removeAll()
			return
		end
		local picked = nil
		for _, t in ipairs(autoRemover) do
			if t == filter then
				picked = t
				break
			end
		end
		if not picked then
			for _, t in ipairs(autoRemover) do
				if Match(t, filter) then
					picked = t
					break
				end
			end
		end
		if picked then
			removeByTerm(picked)
		else
			DoNotif("No matching autodelete name for: "..filter, 3)
		end
		return
	end

	local buttons = {}
	Insert(buttons, { Text = "All", Callback = removeAll })
	for _, t in ipairs(autoRemover) do
		Insert(buttons, { Text = t, Callback = function() removeByTerm(t) end })
	end

	Window({
		Title = "AutoDelete Names",
		Description = "Choose a tracked name to stop deleting (future spawns included).",
		Buttons = buttons
	})
end)

autoFinder = {}
finderConn = nil

function onAdd(obj)
	if #autoFinder > 0 then
		for _, kw in pairs(autoFinder) do
			if obj.Name:lower():find(kw) then
				Defer(function()
					if obj and obj.Parent then
						obj:Destroy()
					end
				end)
				break
			end
		end
	else
		if finderConn then
			finderConn:Disconnect()
			finderConn = nil
		end
	end
end

cmd.add({"autodeletefind", "autoremovefind", "autodelfind"}, {"autodeletefind {name} (autoremovefind, autodelfind)", "Auto removes parts with names containing text"}, function(...)
	local args = {...}
	local kw = Concat(args, " "):lower()

	if not FindInTable(autoFinder, kw) then
		Insert(autoFinder, kw)
		for _, obj in pairs(workspace:GetDescendants()) do
			if obj.Name:lower():find(kw) then
				obj:Destroy()
			end
		end
	end

	if not finderConn then
		finderConn = workspace.DescendantAdded:Connect(onAdd)
	end

	Wait()
	DebugNotif("Auto deleting parts containing: "..kw, 2.5)
end, true)

cmd.add({"unautodeletefind", "unautoremovefind", "unautodelfind"}, {"unautodeletefind (unautoremovefind,unautodelfind)", "Stops autodeletefind"}, function(...)
	if type(autoFinder) ~= "table" then
		autoFinder = {}
	end

	if #autoFinder == 0 then
		DoNotif("No autodeletefind keywords are active.", 2)
		return
	end

	local filter = Lower(Concat({...}, " "))

	local function disconnectFinder()
		if finderConn then
			finderConn:Disconnect()
			finderConn = nil
		end
	end

	local function cleanupConnection()
		if #autoFinder == 0 then
			disconnectFinder()
		end
	end

	local function removeAll()
		autoFinder = {}
		disconnectFinder()
		DoNotif("Cleared all autodeletefind keywords.", 2)
	end

	local function removeByTerm(term)
		for i = #autoFinder, 1, -1 do
			if autoFinder[i] == term then
				table.remove(autoFinder, i)
			end
		end
		cleanupConnection()
		DoNotif("Stopped autodeleting parts containing '"..term.."'.", 2)
	end

	if filter ~= "" then
		if filter == "all" then
			removeAll()
			return
		end
		local picked = nil
		for _, t in ipairs(autoFinder) do
			if t == filter then
				picked = t
				break
			end
		end
		if not picked then
			for _, t in ipairs(autoFinder) do
				if Match(t, filter) then
					picked = t
					break
				end
			end
		end
		if picked then
			removeByTerm(picked)
		else
			DoNotif("No matching autodeletefind keyword for: "..filter, 3)
		end
		return
	end

	local buttons = {}
	Insert(buttons, { Text = "All", Callback = removeAll })
	for _, t in ipairs(autoFinder) do
		Insert(buttons, { Text = t, Callback = function() removeByTerm(t) end })
	end

	Window({
		Title = "AutoDeleteFind Keywords",
		Description = "Select a keyword to stop clearing matching descendants.",
		Buttons = buttons
	})
end)

cmd.add({"deleteclass", "removeclass", "dc"}, {"deleteclass {ClassName} (removeclass, dc)", "Removes any part with a certain classname from the workspace"}, function(...)
	local args = {...}
	local targetClass = args[1]:lower()
	local deleteCount = 0

	for _, part in pairs(workspace:GetDescendants()) do
		if part.ClassName:lower() == targetClass then
			part:Destroy()
			deleteCount = deleteCount + 1
		end
	end

	Wait()
	if deleteCount > 0 then
		DebugNotif("Deleted "..deleteCount.." instance(s) of class: "..targetClass, 2.5)
	else
		DebugNotif("No instances of class: "..targetClass.." found to delete", 2.5)
	end
end, true)

local autoClassRemover = {}
local autoClassConnection = nil

function handleClassDescendantAdd(part)
	if #autoClassRemover > 0 then
		if FindInTable(autoClassRemover, part.ClassName:lower()) then
			Defer(function()
				if part and part.Parent then
					part:Destroy()
				end
			end)
		end
	else
		if autoClassConnection then
			autoClassConnection:Disconnect()
			autoClassConnection = nil
		end
	end
end

cmd.add({"autodeleteclass", "autoremoveclass", "autodc"}, {"autodeleteclass {ClassName} (autoremoveclass, autodc)", "Removes any part with a certain classname from the workspace on loop"}, function(...)
	local args = {...}
	local targetClass = args[1]:lower()

	if not FindInTable(autoClassRemover, targetClass) then
		Insert(autoClassRemover, targetClass)
		for _, part in pairs(workspace:GetDescendants()) do
			if part.ClassName:lower() == targetClass then
				part:Destroy()
			end
		end
	end

	if not autoClassConnection then
		autoClassConnection = workspace.DescendantAdded:Connect(handleClassDescendantAdd)
	end

	Wait()
	DebugNotif("Auto deleting instances with class: "..targetClass, 2.5)
end, true)

cmd.add({"unautodeleteclass", "unautoremoveclass", "unautodc"}, {"unautodeleteclass {ClassName} (unautoremoveclass, unautodc)", "Disables autodeleteclass"}, function(...)
	if type(autoClassRemover) ~= "table" then
		autoClassRemover = {}
	end

	if #autoClassRemover == 0 then
		DoNotif("No autodeleteclass entries are active.", 2)
		return
	end

	local filter = Lower(Concat({...}, " "))

	local function disconnectClass()
		if autoClassConnection then
			autoClassConnection:Disconnect()
			autoClassConnection = nil
		end
	end

	local function cleanupConnection()
		if #autoClassRemover == 0 then
			disconnectClass()
		end
	end

	local function removeAll()
		autoClassRemover = {}
		disconnectClass()
		DoNotif("Cleared all autodeleteclass entries.", 2)
	end

	local function removeByTerm(term)
		for i = #autoClassRemover, 1, -1 do
			if autoClassRemover[i] == term then
				table.remove(autoClassRemover, i)
			end
		end
		cleanupConnection()
		DoNotif("Stopped autodeleting class '"..term.."'.", 2)
	end

	if filter ~= "" then
		if filter == "all" then
			removeAll()
			return
		end
		local picked = nil
		for _, t in ipairs(autoClassRemover) do
			if t == filter then
				picked = t
				break
			end
		end
		if not picked then
			for _, t in ipairs(autoClassRemover) do
				if Match(t, filter) then
					picked = t
					break
				end
			end
		end
		if picked then
			removeByTerm(picked)
		else
			DoNotif("No matching autodeleteclass term for: "..filter, 3)
		end
		return
	end

	local buttons = {}
	Insert(buttons, { Text = "All", Callback = removeAll })
	for _, t in ipairs(autoClassRemover) do
		Insert(buttons, { Text = t, Callback = function() removeByTerm(t) end })
	end

	Window({
		Title = "AutoDeleteClass",
		Description = "Pick a class name to stop auto deleting.",
		Buttons = buttons
	})
end)

cmd.add({"chardelete", "charremove", "chardel", "cdelete", "cremove", "cdel"}, {"chardelete {partname} (charremove, chardel, cdelete, cremove, cdel)", "Removes any part with a certain name from your character"}, function(...)
	local args = {...}
	local targetName = Concat(args, " "):lower()
	local deleteCount = 0

	for _, part in pairs(Player.Character:GetDescendants()) do
		if part.Name:lower() == targetName then
			part:Destroy()
			deleteCount = deleteCount + 1
		end
	end

	Wait()
	if deleteCount > 0 then
		DebugNotif("Deleted "..deleteCount.." instance(s) of '"..targetName.."' inside the character", 2.5)
	else
		DebugNotif("'"..targetName.."' not found in the character", 2.5)
	end
end, true)

cmd.add({"chardeletefind", "charremovefind", "chardelfind", "cdeletefind", "cremovefind", "cdelfind"}, {"chardeletefind {name} (charremovefind, chardelfind, cdeletefind, cremovefind, cdelfind)", "Removes parts in your character with names containing text"}, function(...)
	local args = {...}
	local kw = Concat(args, " "):lower()
	local count = 0

	for _, obj in pairs(Player.Character:GetDescendants()) do
		if obj.Name:lower():find(kw) then
			obj:Destroy()
			count = count + 1
		end
	end

	Wait()
	if count > 0 then
		DebugNotif("Deleted "..count.." instance(s) containing '"..kw.."' in character", 2.5)
	else
		DebugNotif("Nothing found containing '"..kw.."' in character", 2.5)
	end
end, true)

cmd.add({"chardeleteclass", "charremoveclass", "chardeleteclassname", "cdc"}, {"chardeleteclass {ClassName} (charremoveclass, chardeleteclassname, cdc)", "Removes any part with a certain classname from your character"}, function(...)
	local args = {...}
	local targetClass = args[1]:lower()
	local deleteCount = 0

	for _, part in pairs(Player.Character:GetDescendants()) do
		if part.ClassName:lower() == targetClass then
			part:Destroy()
			deleteCount = deleteCount + 1
		end
	end

	Wait()
	if deleteCount > 0 then
		DebugNotif("Deleted "..deleteCount.." instance(s) of class: "..targetClass.." inside the character", 2.5)
	else
		DebugNotif("No instances of class: "..targetClass.." found in the character", 2.5)
	end
end, true)

local activeTeleports = {}

originalIO.gotoNext = originalIO.gotoNext or {}

do
	local gotoNext = originalIO.gotoNext
	local state = gotoNext.state or {
		teleporting = false,
		totalDuplicates = 0,
		duplicatesSessionOrder = {},
		tracerPart = nil,
		tracerConnection = nil,
		tracerHue = 0,
	}
	gotoNext.state = state

	function gotoNext.trim(str)
		if type(str) ~= "string" then
			return str
		end
		local trimmed = str:match("^%s*(.-)%s*$")
		return trimmed or str
	end

	function gotoNext.tokenizeArgs(rawArgs)
		local tokens = {}
		if not rawArgs or #rawArgs == 0 then
			return tokens
		end

		local combined = Concat(rawArgs, " ")
		if combined == "" then
			return tokens
		end

		local length = #combined
		local index = 1

		while index <= length do
			while index <= length and combined:sub(index, index):match("%s") do
				index = index + 1
			end
			if index > length then
				break
			end

			local ch = combined:sub(index, index)
			if ch == '"' or ch == "'" then
				local quote = ch
				index = index + 1
				local buffer = {}

				while index <= length do
					local current = combined:sub(index, index)
					if current == quote then
						index = index + 1
						break
					end
					buffer[#buffer + 1] = current
					index = index + 1
				end

				tokens[#tokens + 1] = Concat(buffer)
			else
				local start = index
				while index <= length and not combined:sub(index, index):match("%s") do
					index = index + 1
				end
				tokens[#tokens + 1] = combined:sub(start, index - 1)
			end
		end

		if #tokens == 0 then
			for _, value in ipairs(rawArgs) do
				if type(value) == "string" and value ~= "" then
					tokens[#tokens + 1] = value
				end
			end
		end

		for i = 1, #tokens do
			tokens[i] = gotoNext.trim(tokens[i])
		end

		return tokens
	end

	function gotoNext.buildSearchNames(rawPrefix, normalizedPrefix, index)
		local variants = {}
		local seen = {}
		local function add(name)
			if not name or name == "" then
				return
			end
			local canonical = name:lower()
			if not seen[canonical] then
				variants[#variants + 1] = name
				seen[canonical] = true
			end
		end

		local idx = tostring(index)
		add(idx)

		local normalized = normalizedPrefix and gotoNext.trim(normalizedPrefix) or nil
		if normalized and normalized ~= "" then
			add(normalized.." "..idx)
			add(normalized..idx)
		end

		if rawPrefix and rawPrefix ~= "" then
			if not rawPrefix:match("%s$") then
				add(rawPrefix.." "..idx)
			end
			add(rawPrefix..idx)
		end

		return variants
	end

	function gotoNext.extractIndexedToken(token)
		if type(token) ~= "string" then
			return nil
		end

		if token == "" then
			return nil
		end

		local head, digits = token:match("^(.-)(%-?%d+)%s*$")
		if not digits then
			return nil
		end

		local rawPrefix = head
		local normalized = gotoNext.trim(rawPrefix or "")
		if normalized == "" then
			normalized = nil
			rawPrefix = nil
		end

		return {
			raw = rawPrefix,
			normalized = normalized,
			number = tonumber(digits),
		}
	end

	function gotoNext.sessionKey(objectType, normalizedLower, index)
		local keyPrefix = gotoNext.trim(normalizedLower or "")
		if keyPrefix ~= "" then
			keyPrefix = keyPrefix:lower()
		end
		return (objectType or "Part").."|"..keyPrefix.."|"..tostring(index)
	end

	function gotoNext.notify(message, duration)
		DoNotif(message, duration or 3, "GotoNext")
	end

	function gotoNext.clearTracer()
		if state.tracerConnection then
			state.tracerConnection:Disconnect()
			state.tracerConnection = nil
		end

		if state.tracerPart and state.tracerPart.Parent then
			state.tracerPart:Destroy()
		end

		state.tracerPart = nil
	end

	function gotoNext.setTracer(nextCFrame)
		gotoNext.clearTracer()
		if not nextCFrame then
			return
		end

		local tracer = InstanceNew("Part", workspace)
		tracer.Name = "NA_GotoNextTracer"
		tracer.Anchored = true
		tracer.CanCollide = false
		tracer.Material = Enum.Material.Neon
		tracer.Size = Vector3.new(2, 2, 2)
		tracer.CFrame = nextCFrame + Vector3.new(0, 3, 0)
		tracer.TopSurface = Enum.SurfaceType.Smooth
		tracer.BottomSurface = Enum.SurfaceType.Smooth

		state.tracerPart = tracer
		state.tracerHue = 0
		state.tracerConnection = RunService.Heartbeat:Connect(function(dt)
			if not state.tracerPart or not state.tracerPart.Parent then
				gotoNext.clearTracer()
				return
			end

			state.tracerHue = (state.tracerHue + dt * 0.5) % 1
			state.tracerPart.Color = Color3.fromHSV(state.tracerHue, 1, 1)
		end)
	end

	function gotoNext.fullPath(inst)
		if not inst then
			return "Unknown"
		end

		local segments = {inst.Name}
		local parent = inst.Parent
		while parent do
			Insert(segments, 1, parent.Name)
			parent = parent.Parent
		end

		return Concat(segments, ".")
	end

	function gotoNext.findMatches(objectType, targetName)
		local matches = {}
		if not targetName or targetName == "" then
			return matches
		end

		local targetLower = targetName:lower()

		local queue = {workspace}
		local index = 1

		while queue[index] do
			local current = queue[index]
			index += 1

			for _, child in ipairs(current:GetChildren()) do
				local isValid = false
				if objectType == "Part" then
					isValid = child:IsA("BasePart")
				elseif objectType == "Model" then
					isValid = child:IsA("Model")
				elseif objectType == "Folder" then
					isValid = child:IsA("Folder")
				end

				if isValid and child.Name and child.Name:lower() == targetLower then
					Insert(matches, {inst = child, parent = child.Parent})
				end

				queue[#queue + 1] = child
			end
		end

		return matches
	end

	function gotoNext.resolveCFrame(inst)
		if not inst then
			return nil
		end

		if inst:IsA("BasePart") then
			return inst.CFrame
		elseif inst:IsA("Model") then
			local ok, pivot = pcall(function()
				return inst:GetPivot()
			end)
			if ok then
				return pivot
			end

			local primary = inst.PrimaryPart or inst:FindFirstChildWhichIsA("BasePart")
			if primary then
				return primary.CFrame
			end
		end

		return nil
	end

	function gotoNext.teleportToInstance(inst)
		local char = getChar()
		if not char then
			return false
		end

		local targetCFrame = gotoNext.resolveCFrame(inst)
		if not targetCFrame then
			return false
		end

		local hum = getHum(char)
		if hum then
			hum.Sit = false
		end

		pcall(function()
			char:PivotTo(targetCFrame + Vector3.new(0, 4, 0))
		end)

		return true
	end

	function gotoNext.collectFolderParts(folder)
		local parts = {}
		for _, descendant in ipairs(folder:GetDescendants()) do
			if descendant:IsA("BasePart") then
				Insert(parts, descendant)
			end
		end

		table.sort(parts, function(a, b)
			return a:GetFullName() < b:GetFullName()
		end)

		return parts
	end

	function gotoNext.normalizeSelection(selection)
		local normalized = {}
		for _, inst in ipairs(selection or {}) do
			if inst and inst.Parent then
				Insert(normalized, {inst = inst, parent = inst.Parent})
			end
		end
		return normalized
	end

	function gotoNext.promptDuplicates(name, duplicates)
		local selectionEvent = InstanceNew("BindableEvent")
		local selected
		local resolved = false
		local window

		local descriptionLines = {
			Format("Found %d duplicates for '%s'. Choose a starting instance or TP all.", #duplicates, name)
		}

		for idx, info in ipairs(duplicates) do
			Insert(descriptionLines, Format("%d) %s", idx, gotoNext.fullPath(info.inst)))
		end

		local buttons = {}

		local function finalize(choice)
			if resolved then
				return
			end

			selected = choice
			resolved = true
			if window and window.Parent then
				window:Destroy()
			end
			selectionEvent:Fire()
		end

		for idx, info in ipairs(duplicates) do
			Insert(buttons, {
				Text = Format("Start #%d", idx),
				Callback = function()
					finalize({info.inst})
				end
			})
		end

		Insert(buttons, {
			Text = Format("TP All (%d)", #duplicates),
			Callback = function()
				local all = {}
				for _, entry in ipairs(duplicates) do
					Insert(all, entry.inst)
				end
				finalize(all)
			end
		})

		Insert(buttons, {
			Text = "Cancel",
			Callback = function()
				finalize(nil)
			end
		})

		window = Window({
			Title = "GotoNext",
			Description = Concat(descriptionLines, "\n"),
			Buttons = buttons
		})

		if window then
			window.AncestryChanged:Connect(function(_, parent)
				if not parent and not resolved then
					resolved = true
					selected = nil
					selectionEvent:Fire()
				end
			end)
		end

		selectionEvent.Event:Wait()
		selectionEvent:Destroy()

		return selected
	end

	function gotoNext.parseArgs(rawArgs)
		local tokens = gotoNext.tokenizeArgs(rawArgs)
		local args = {}
		for _, value in ipairs(tokens) do
			if type(value) == "string" and value ~= "" then
				Insert(args, value)
			end
		end

		local first = args[1]
		if not first then
			return nil, "Usage:\n- gotopartnext <start> [end] [delay]\n- gotopartnext <prefix> <start> [end] [delay]"
		end

		local prefixRaw
		local prefixNormalized
		local startNum
		local endNum
		local delay

		local function applyPrefix(rawCandidate, normalizedCandidate)
			if rawCandidate and rawCandidate ~= "" then
				if not prefixRaw then
					prefixRaw = rawCandidate
				end
			end

			if normalizedCandidate and normalizedCandidate ~= "" then
				normalizedCandidate = gotoNext.trim(normalizedCandidate)
				if normalizedCandidate == "" then
					normalizedCandidate = nil
				end
			else
				normalizedCandidate = nil
			end

			if normalizedCandidate then
				if prefixNormalized and prefixNormalized ~= normalizedCandidate then
					return false
				end
				prefixNormalized = prefixNormalized or normalizedCandidate
			end

			if not prefixRaw and prefixNormalized then
				prefixRaw = prefixNormalized
			end

			return true
		end

		local second = args[2]
		local third = args[3]
		local fourth = args[4]

		local firstNumeric = tonumber(first)
		local firstInfo = gotoNext.extractIndexedToken(first)
		local secondNumeric = tonumber(second)
		local secondInfo = gotoNext.extractIndexedToken(second)
		local thirdNumeric = tonumber(third)
		local thirdInfo = gotoNext.extractIndexedToken(third)

		if firstNumeric then
			startNum = math.floor(firstNumeric)
			if secondNumeric then
				endNum = math.floor(secondNumeric)
				delay = tonumber(third)
			elseif secondInfo and secondInfo.number then
				if not applyPrefix(secondInfo.raw, secondInfo.normalized) then
					return nil, "Start/end names use different prefixes."
				end
				endNum = math.floor(secondInfo.number)
				delay = tonumber(third)
			else
				endNum = startNum
				delay = tonumber(second)
			end
		elseif firstInfo and firstInfo.number then
			if not applyPrefix(firstInfo.raw, firstInfo.normalized) then
				return nil, "Start/end names use different prefixes."
			end
			startNum = math.floor(firstInfo.number)

			if secondNumeric then
				endNum = math.floor(secondNumeric)
				delay = tonumber(third)
			elseif secondInfo and secondInfo.number then
				if not applyPrefix(secondInfo.raw, secondInfo.normalized) then
					return nil, "Start/end names use different prefixes."
				end
				endNum = math.floor(secondInfo.number)
				delay = tonumber(third)
			else
				endNum = startNum
				delay = tonumber(second)
			end
		else
			if not applyPrefix(first, first) then
				return nil, "Invalid prefix value."
			end

			if not second then
				return nil, "Start number missing. Example: gotopartnext checkpoint 1 5"
			end

			if secondNumeric then
				startNum = math.floor(secondNumeric)
				if thirdNumeric then
					endNum = math.floor(thirdNumeric)
					delay = tonumber(fourth)
				elseif thirdInfo and thirdInfo.number then
					if not applyPrefix(thirdInfo.raw, thirdInfo.normalized) then
						return nil, "Start/end names use different prefixes."
					end
					endNum = math.floor(thirdInfo.number)
					delay = tonumber(fourth)
				else
					endNum = startNum
					delay = tonumber(third)
				end
			elseif secondInfo and secondInfo.number then
				if not applyPrefix(secondInfo.raw, secondInfo.normalized) then
					return nil, "Start/end names use different prefixes."
				end
				startNum = math.floor(secondInfo.number)
				if thirdNumeric then
					endNum = math.floor(thirdNumeric)
					delay = tonumber(fourth)
				elseif thirdInfo and thirdInfo.number then
					if not applyPrefix(thirdInfo.raw, thirdInfo.normalized) then
						return nil, "Start/end names use different prefixes."
					end
					endNum = math.floor(thirdInfo.number)
					delay = tonumber(fourth)
				else
					endNum = startNum
					delay = tonumber(third)
				end
			else
				return nil, "Start number missing. Example: gotopartnext checkpoint 1 10 0.5"
			end
		end

		if not startNum then
			return nil, "Start number missing. Example: gotopartnext checkpoint 1 10 0.5"
		end

		endNum = endNum or startNum

		delay = tonumber(delay) or 0.5
		if delay < 0 then
			delay = 0
		end

		local prefixRawOriginal = prefixRaw
		if prefixRawOriginal then
			local trimmedCandidate = gotoNext.trim(prefixRawOriginal)
			if trimmedCandidate == "" then
				prefixRawOriginal = nil
			end
		end

		if prefixNormalized then
			prefixNormalized = gotoNext.trim(prefixNormalized)
			if prefixNormalized == "" then
				prefixNormalized = nil
			end
		end

		if not prefixNormalized and prefixRawOriginal then
			local trimmedRaw = gotoNext.trim(prefixRawOriginal)
			if trimmedRaw ~= "" then
				prefixNormalized = trimmedRaw
			end
		end

		local prefixDisplay = nil
		if prefixRawOriginal then
			prefixDisplay = gotoNext.trim(prefixRawOriginal)
			if prefixDisplay == "" then
				prefixDisplay = nil
			end
		end
		if not prefixDisplay then
			prefixDisplay = prefixNormalized
		end

		local prefixLower = prefixNormalized and prefixNormalized:lower() or nil

		return {
			prefixRaw = prefixRawOriginal,
			prefixNormalized = prefixNormalized,
			prefixLower = prefixLower,
			prefixDisplay = prefixDisplay,
			startNum = startNum,
			endNum = endNum,
			delay = delay,
		}
	end

	function gotoNext.handleSequence(objectType, rawArgs)
		if state.teleporting then
			gotoNext.notify("Sequence already running.", 2)
			return
		end

		local parsed, err = gotoNext.parseArgs(rawArgs)
		if not parsed then
			gotoNext.notify(err or "Invalid arguments.", 4)
			return
		end

		state.teleporting = true
		state.totalDuplicates = 0

		local prefixLabel = parsed.prefixDisplay
		local descriptor
		if prefixLabel and prefixLabel ~= "" then
			descriptor = Format("Teleporting %s '%s' %d -> %d (delay %.2fs)", objectType, prefixLabel, parsed.startNum, parsed.endNum, parsed.delay)
		else
			descriptor = Format("Teleporting %s %d -> %d (delay %.2fs)", objectType, parsed.startNum, parsed.endNum, parsed.delay)
		end
		gotoNext.notify(descriptor, 3)

		SpawnCall(function()
			local step = parsed.startNum <= parsed.endNum and 1 or -1

			for index = parsed.startNum, parsed.endNum, step do
				if not state.teleporting then
					break
				end

				local searchNames = gotoNext.buildSearchNames(parsed.prefixRaw, parsed.prefixNormalized, index)
				if #searchNames == 0 then
					searchNames = {tostring(index)}
				end
				local indexString = tostring(index)
				local displayName = searchNames[1]
				for _, candidateName in ipairs(searchNames) do
					if candidateName:find(" "..indexString, 1, true) then
						displayName = candidateName
						break
					end
				end
				if parsed.prefixDisplay and parsed.prefixDisplay ~= "" then
					local prefixLowerForDisplay = parsed.prefixDisplay:lower()
					for _, candidateName in ipairs(searchNames) do
						local candidateLower = candidateName:lower()
						if candidateLower:find(prefixLowerForDisplay, 1, true) then
							displayName = candidateName
							if candidateName:find(" "..indexString, 1, true) then
								break
							end
						end
					end
				end
				local sessionKey = gotoNext.sessionKey(objectType, parsed.prefixLower, index)

				local candidates = {}
				local seen = {}

				for _, name in ipairs(searchNames) do
					local found = gotoNext.findMatches(objectType, name)
					for _, info in ipairs(found) do
						local inst = info.inst
						if inst and not seen[inst] then
							seen[inst] = true
							Insert(candidates, info)
						end
					end
				end

				if #candidates == 0 then
					gotoNext.notify(Format("No %s named '%s'.", objectType, displayName), 2)
				else
					if #candidates > 1 then
						local sessionChoice = state.duplicatesSessionOrder[sessionKey]

						if sessionChoice then
							sessionChoice = gotoNext.normalizeSelection(sessionChoice)
							if #sessionChoice == 0 then
								state.duplicatesSessionOrder[sessionKey] = nil
								sessionChoice = nil
							end
						end

						if not sessionChoice then
							local selection = gotoNext.promptDuplicates(displayName, candidates)
							if not selection or #selection == 0 then
								gotoNext.notify("Sequence canceled.", 2)
								state.teleporting = false
								gotoNext.clearTracer()
								return
							end
							state.duplicatesSessionOrder[sessionKey] = selection
							sessionChoice = gotoNext.normalizeSelection(selection)
						end

						state.totalDuplicates = state.totalDuplicates + math.max(0, #sessionChoice - 1)
						candidates = sessionChoice
					end

					for idx, info in ipairs(candidates) do
						if not state.teleporting then
							break
						end

						local inst = info.inst
						if objectType == "Folder" then
							local parts = gotoNext.collectFolderParts(inst)
							for partIndex, part in ipairs(parts) do
								if not state.teleporting then
									break
								end
								local nextPart = parts[partIndex + 1]
								gotoNext.setTracer(nextPart and nextPart.CFrame or nil)
								gotoNext.teleportToInstance(part)
								Wait(parsed.delay)
							end
						else
							local nextInfo = candidates[idx + 1]
							local nextTarget = nextInfo and gotoNext.resolveCFrame(nextInfo.inst) or nil
							gotoNext.setTracer(nextTarget)
							gotoNext.teleportToInstance(inst)
							Wait(parsed.delay)
						end
					end
				end
			end

			gotoNext.clearTracer()
			if state.teleporting then
				gotoNext.notify(Format("Finished teleporting! Duplicates: %d", state.totalDuplicates), 4)
			else
				gotoNext.notify("Sequence stopped.", 2)
			end

			state.teleporting = false
		end)
	end

	function gotoNext.cancelSequence()
		state.totalDuplicates = 0
		state.duplicatesSessionOrder = {}
		if state.teleporting then
			state.teleporting = false
			gotoNext.clearTracer()
			gotoNext.notify("Teleport sequence stopped!", 3)
		else
			gotoNext.clearTracer()
			gotoNext.notify("No teleport in progress.", 2)
		end
	end
end

cmd.add({"gotopartnext", "gpn"}, {"gotopartnext [prefix] <start> [end] [delay] (gpn)", "Teleport sequentially to parts with optional prefix and duplicate handling."}, function(...)
	originalIO.gotoNext.handleSequence("Part", {...})
end, true)

cmd.add({"gotomodelnext", "gmn"}, {"gotomodelnext [prefix] <start> [end] [delay] (gmn)", "Teleport sequentially to models with optional prefix and duplicate handling."}, function(...)
	originalIO.gotoNext.handleSequence("Model", {...})
end, true)

cmd.add({"gotofoldernext", "gfn"}, {"gotofoldernext [prefix] <start> [end] [delay] (gfn)", "Teleport sequentially through folder contents with optional prefix."}, function(...)
	originalIO.gotoNext.handleSequence("Folder", {...})
end, true)

cmd.add({"gotobreak", "gb"}, {"gotobreak (gb)", "Stop the active goto sequence and clear duplicate selections."}, function()
	originalIO.gotoNext.cancelSequence()
end)

cmd.add({"gotopart", "topart", "toprt"}, {"gotopart {partname}", "Teleports you to each matching part by name once"}, function(...)
	local partName = Concat({...}, " "):lower()
	local commandKey = "gotopart"

	if activeTeleports[commandKey] then
		activeTeleports[commandKey].active = false
	end

	local taskState = {active = true}
	activeTeleports[commandKey] = taskState

	SpawnCall(function()
		for _, part in pairs(workspace:GetDescendants()) do
			if not taskState.active then return end
			if part:IsA("BasePart") and part.Name:lower() == partName then
				if getHum() then getHum().Sit = false Wait(0.1) end
				if getChar() then getChar():PivotTo(part:GetPivot()) end
				Wait(.2)
			end
		end
	end)
end, true)

cmd.add({"tweengotopart","tgotopart","ttopart","ttoprt"},{"tweengotopart <partName>","Tween to each matching part by name once"},function(...)
	local partName = Concat({...}," "):lower()
	local key      = "tweengotopart"
	if activeTeleports[key] then activeTeleports[key].active = false end
	local state    = {active = true}
	activeTeleports[key] = state
	SpawnCall(function()
		local char = getChar()
		for _,obj in ipairs(workspace:GetDescendants()) do
			if not state.active then return end
			if obj:IsA("BasePart") and obj.Name:lower() == partName then
				local hum = getHum()
				if hum then hum.Sit = false end
				local cfVal = InstanceNew("CFrameValue")
				cfVal.Value = char:GetPivot()
				cfVal.Changed:Connect(function(newCF) char:PivotTo(newCF) end)
				local duration = NAmanage.resolveTweenDuration()
				local tw = TweenService:Create(cfVal, TweenInfo.new(duration, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),{Value = obj.CFrame})
				tw:Play()
				tw.Completed:Connect(function() cfVal:Destroy() end)
				Wait(duration + 0.1)
			end
		end
	end)
end,true)


cmd.add({"gotopartfind", "topartfind", "toprtfind"}, {"gotopartfind {name}", "Teleports to each part containing name once"}, function(...)
	local name = Concat({...}, " "):lower()
	local commandKey = "gotopartfind"

	if activeTeleports[commandKey] then
		activeTeleports[commandKey].active = false
	end

	local taskState = {active = true}
	activeTeleports[commandKey] = taskState

	SpawnCall(function()
		for _, part in pairs(workspace:GetDescendants()) do
			if not taskState.active then return end
			if part:IsA("BasePart") and part.Name:lower():find(name) then
				if getHum() then getHum().Sit = false Wait(0.1) end
				if getChar() then getChar():PivotTo(part:GetPivot()) end
				Wait(.2)
			end
		end
	end)
end, true)

cmd.add({"tweengotopartfind", "tgotopartfind", "ttopartfind", "ttoprtfind"}, {"tweengotopartfind {name}", "Tweens to each part containing name once"}, function(...)
	local name = Concat({...}, " "):lower()
	local commandKey = "tweengotopartfind"

	if activeTeleports[commandKey] then
		activeTeleports[commandKey].active = false
	end

	local taskState = {active = true}
	activeTeleports[commandKey] = taskState

	SpawnCall(function()
		for _, part in pairs(workspace:GetDescendants()) do
			if not taskState.active then return end
			if part:IsA("BasePart") and part.Name:lower():find(name) then
				local hum = getHum()
				if hum then
					hum.Sit = false
					Wait(0.1)
				end
				local char = getChar()
				local root = char and getRoot(char)
				if root then
					local duration = NAmanage.resolveTweenDuration()
					local tween = TweenService:Create(root, TweenInfo.new(duration, Enum.EasingStyle.Linear), {CFrame = part.CFrame})
					tween:Play()
					Wait(duration + 0.1)
				end
			end
		end
	end)
end, true)

cmd.add({"gotopartclass", "gpc", "gotopartc", "gotoprtc"}, {"gotopartclass {classname}", "Teleports to each part of class once"}, function(...)
	local className = ({...})[1]:lower()
	local commandKey = "gotopartclass"

	if activeTeleports[commandKey] then
		activeTeleports[commandKey].active = false
	end

	local taskState = {active = true}
	activeTeleports[commandKey] = taskState

	SpawnCall(function()
		for _, part in pairs(workspace:GetDescendants()) do
			if not taskState.active then return end
			if part:IsA("BasePart") and part.ClassName:lower() == className then
				if getHum() then getHum().Sit = false Wait(0.1) end
				if getChar() then getChar():PivotTo(part:GetPivot()) end
				Wait(.2)
			end
		end
	end)
end, true)

cmd.add({"bringpart", "bpart", "bprt"}, {"bringpart {partname} (bpart, bprt)", "Brings a part to your character by name"}, function(...)
	local partName = Concat({...}, " "):lower()

	for _, part in pairs(workspace:GetDescendants()) do
		if part:IsA("BasePart") and part.Name:lower() == partName then
			if getChar() then
				part:PivotTo(getChar():GetPivot())
			end
		end
	end
end, true)

cmd.add({"bringmodel", "bmodel"}, {"bringmodel {modelname} (bmodel)", "Brings a model to your character by name"}, function(...)
	local modelName = Concat({...}, " "):lower()

	for _, model in pairs(workspace:GetDescendants()) do
		if model:IsA("Model") and model.Name:lower() == modelName then
			if getChar() then
				model:PivotTo(getChar():GetPivot())
			end
		end
	end
end, true)

cmd.add({"bringfolder","bfldr"},{"bringfolder {folderName} [partName] (bfldr)","Brings all parts in a folder or a specified part"},function(...)
	local raw = {...}
	if #raw == 0 then return end
	local lower = {}
	for i=1,#raw do lower[i] = tostring(raw[i]):lower() end
	local folder, partFilter
	do
		local nameAll = Concat(lower," ")
		for _,obj in ipairs(workspace:GetDescendants()) do
			if obj:IsA("Folder") and obj.Name:lower() == nameAll then folder = obj break end
		end
		if not folder and #lower>=2 then
			local nameWithoutLast = Concat(lower," ",1,#lower-1)
			local last = lower[#lower]
			for _,obj in ipairs(workspace:GetDescendants()) do
				if obj:IsA("Folder") and obj.Name:lower() == nameWithoutLast then folder = obj partFilter = last break end
			end
		end
		if not folder then
			for _,obj in ipairs(workspace:GetDescendants()) do
				if obj:IsA("Folder") and obj.Name:lower() == lower[1] then folder = obj break end
			end
			if folder and #lower>1 then
				partFilter = Concat(lower," ",2,#lower)
			end
		end
	end
	if not folder then return end
	local char = getChar()
	if not char then return end
	local pivot = char:GetPivot()
	for _,desc in ipairs(folder:GetDescendants()) do
		if desc:IsA("BasePart") then
			local ok = true
			if partFilter and partFilter ~= "" then
				local n = desc.Name:lower()
				ok = (n == partFilter) or (Find(n, partFilter, 1, true) ~= nil)
			end
			if ok then
				desc:PivotTo(pivot)
			end
		end
	end
end,true)

cmd.add({"gotomodel", "tomodel"}, {"gotomodel {modelname}", "Teleports to each model with name once"}, function(...)
	local modelName = Concat({...}, " "):lower()
	local commandKey = "gotomodel"

	if activeTeleports[commandKey] then
		activeTeleports[commandKey].active = false
	end

	local taskState = {active = true}
	activeTeleports[commandKey] = taskState

	SpawnCall(function()
		for _, model in pairs(workspace:GetDescendants()) do
			if not taskState.active then return end
			if model:IsA("Model") and model.Name:lower() == modelName then
				if getHum() then getHum().Sit = false Wait(0.1) end
				if getChar() then getChar():PivotTo(model:GetPivot()) end
				Wait(.2)
			end
		end
	end)
end, true)

cmd.add({"gotomodelfind", "tomodelfind"}, {"gotomodelfind {name}", "Teleports to each model containing name once"}, function(...)
	local name = Concat({...}, " "):lower()
	local commandKey = "gotomodelfind"

	if activeTeleports[commandKey] then
		activeTeleports[commandKey].active = false
	end

	local taskState = {active = true}
	activeTeleports[commandKey] = taskState

	SpawnCall(function()
		for _, model in pairs(workspace:GetDescendants()) do
			if not taskState.active then return end
			if model:IsA("Model") and model.Name:lower():find(name) then
				if getHum() then getHum().Sit = false Wait(0.1) end
				if getChar() then getChar():PivotTo(model:GetPivot()) end
				Wait(.2)
			end
		end
	end)
end, true)

cmd.add({"gotomodelfind", "tomodelfind"}, {"gotomodelfind {name} (tomodelfind)", "Teleports you to a model whose name contains the given text"}, function(...)
	local name = Concat({...}, " "):lower()

	for _, model in pairs(workspace:GetDescendants()) do
		if model:IsA("Model") and model.Name:lower():find(name) then
			if getHum() then
				getHum().Sit = false
				Wait(0.1)
			end
			if getChar() then
				getChar():PivotTo(model:GetPivot())
			end
			Wait(0.2)
		end
	end
end, true)

cmd.add({"gotofolder","gofldr"},{"gotofolder {folderName}","Teleports you to all parts in a folder"},function(...)
	local lower = {}
	for i,v in ipairs({...}) do lower[i] = tostring(v):lower() end
	local folderName = Concat(lower," ")
	if folderName == "" then return end
	local key = "gotofolder"
	if activeTeleports[key] then activeTeleports[key].active = false end
	local state = {active = true}
	activeTeleports[key] = state
	SpawnCall(function()
		local folder
		for _,obj in ipairs(workspace:GetDescendants()) do
			if obj:IsA("Folder") and obj.Name:lower() == folderName then folder = obj break end
		end
		if not folder then return end
		for _,desc in ipairs(folder:GetDescendants()) do
			if not state.active then return end
			if desc:IsA("BasePart") then
				local hum = getHum()
				if hum then hum.Sit = false Wait(0.1) end
				local char = getChar()
				if char then char:PivotTo(desc:GetPivot()) end
				Wait(0.2)
			end
		end
	end)
end,true)

OGGRAVV = workspace.Gravity
SWIMMERRRR = false

function ZEhumSTATE(humanoid, enabled)
	local states = Enum.HumanoidStateType:GetEnumItems()
	table.remove(states, Discover(states, Enum.HumanoidStateType.None))
	for _, state in ipairs(states) do
		humanoid:SetStateEnabled(state, enabled)
	end
end

cmd.add({"swim"}, {"swim {speed}", "Swim in the air"}, function(speed)
	local player = Players.LocalPlayer
	local humanoid = getHum()

	if not SWIMMERRRR and humanoid and humanoid.Parent then
		local hrp = getRoot(humanoid.Parent)
		if not hrp then return end

		OGGRAVV = workspace.Gravity
		workspace.Gravity = 0

		ZEhumSTATE(humanoid, false)
		humanoid:ChangeState(Enum.HumanoidStateType.Swimming)
		humanoid.WalkSpeed = speed or 16

		NAlib.connect("swim_die", humanoid.Died:Connect(function()
			workspace.Gravity = OGGRAVV
			SWIMMERRRR = false
		end))

		NAlib.connect("swim_heartbeat", RunService.Stepped:Connect(function()
			NACaller(function()
				if humanoid and hrp then
					local move = humanoid.MoveDirection
					local velocity = (move.Magnitude > 0 or UserInputService:IsKeyDown(Enum.KeyCode.Space)) and hrp.Velocity or Vector3.zero
					hrp.Velocity = velocity
				end
			end)
		end))

		SWIMMERRRR = true
	end
end, true)

cmd.add({"unswim"}, {"unswim", "Stops the swim script"}, function()
	local player = Players.LocalPlayer
	local humanoid = getHum()

	if humanoid then
		workspace.Gravity = OGGRAVV
		SWIMMERRRR = false

		NAlib.disconnect("swim_die")
		NAlib.disconnect("swim_heartbeat")

		ZEhumSTATE(humanoid, true)
		humanoid:ChangeState(Enum.HumanoidStateType.RunningNoPhysics)
		humanoid.WalkSpeed = 16
	end
end)

cmd.add({"punch"},{"punch","punch tool that flings"},function()
	loadstring(game:HttpGet('https://raw.githubusercontent.com/ltseverydayyou/Nameless-Admin/refs/heads/main/puncher.luau'))()
end)

cmd.add({"tpua","bringua"},{"tpua <player>","Brings every unanchored part on the map to the player"},function(...)
	local targets=getPlr(...)
	local targetPlayer=targets[1]
	if not targetPlayer then targetPlayer=LocalPlayer end

	local root=getRoot(getPlrChar(targetPlayer))
	if not root then return end

	local targetCF=root.CFrame

	SpawnCall(function()
		while RunService.Heartbeat:Wait() do
			NACaller(function()
				opt.hiddenprop(LocalPlayer,"SimulationRadius",1e9)
				LocalPlayer.MaximumSimulationRadius=1e9
			end)
		end
	end)

	local function ForcePart(v)
		if not v:IsA("BasePart") then return end
		if v.Anchored or v:IsDescendantOf(targetPlayer.Character) then return end
		if v.Parent:FindFirstChildWhichIsA("Humanoid") or v.Parent:FindFirstChild("Head") or v.Name=="Handle" then return end

		for _,x in next,v:GetChildren() do
			if x:IsA("BodyMover") or x:IsA("RocketPropulsion") then x:Destroy() end
		end
		for _,n in next,{"Attachment","AlignPosition","Torque"} do
			local i=v:FindFirstChild(n)
			if i then i:Destroy() end
		end

		v.CanCollide=false
		v.CFrame=targetCF*CFrame.new(math.random(-10,10),0,math.random(-10,10))
	end

	for _,part in ipairs(workspace:GetDescendants()) do
		ForcePart(part)
	end
end,true)

cmd.add({"blackholefollow","bhf","bhpull","bhfollow"},{"blackholefollow","Pulls unanchored parts to you with spin"},function()
	if NAlib.isConnected("bhf") then return DoNotif("BHF already active") end

	local root=getRoot(getPlrChar(LocalPlayer));if not root then return end
	local att1=InstanceNew("Attachment",root);att1.Name="BHF_Attach"

	local function ForcePart(v)
		if not v:IsA("BasePart") then return end
		if v.Anchored or v:IsDescendantOf(LocalPlayer.Character) then return end
		if v.Parent:FindFirstChildWhichIsA("Humanoid") or v.Parent:FindFirstChild("Head") or v.Name=="Handle" then return end

		for _,x in next,v:GetChildren() do
			if x:IsA("BodyMover") or x:IsA("RocketPropulsion") then x:Destroy() end
		end
		for _,n in next,{"Attachment","AlignPosition","Torque"} do
			local i=v:FindFirstChild(n)
			if i then i:Destroy() end
		end

		v.CanCollide=false

		local att0=InstanceNew("Attachment",v)
		local align=InstanceNew("AlignPosition",v)
		align.Attachment0=att0
		align.Attachment1=att1
		align.MaxForce=1e9
		align.MaxVelocity=math.huge
		align.Responsiveness=200

		local torque=InstanceNew("Torque",v)
		torque.Attachment0=att0
		torque.Torque=Vector3.new(100000,100000,100000)
	end

	for _,part in ipairs(workspace:GetDescendants()) do Defer(function() ForcePart(part) end) end

	NAlib.connect("bhf",workspace.DescendantAdded:Connect(ForcePart))
	NAlib.connect("bhf_sim",RunService.Heartbeat:Connect(function()
		NACaller(function()
			opt.hiddenprop(LocalPlayer,"SimulationRadius",1e9)
			LocalPlayer.MaximumSimulationRadius=1e9
		end)
	end))

	DebugNotif("Blackhole follow enabled.")
end,true)

cmd.add({"noblackholefollow","nobhf","nobhpull","stopbhf"},{"noblackholefollow","Stops blackhole follow and clears constraints"},function()
	NAlib.disconnect("bhf")
	NAlib.disconnect("bhf_sim")

	local root=getRoot(getPlrChar(LocalPlayer))
	if root then local att=root:FindFirstChild("BHF_Attach") if att then att:Destroy() end end

	for _,part in ipairs(workspace:GetDescendants()) do
		if part:IsA("BasePart") and not part.Anchored then
			for _,obj in ipairs(part:GetChildren()) do
				if obj:IsA("AlignPosition") or obj:IsA("Torque") or obj:IsA("Attachment") then obj:Destroy() end
			end
		end
	end

	DebugNotif("Blackhole follow disabled.")
end,true)

cmd.add({"swordfighter", "sfighter", "swordf", "swordbot", "sf"},{"swordfighter (sfighter, swordf, swordbot, sf)", "Activates a sword fighting bot that engages in automated PvP combat"},function()
	loadstring(game:HttpGet("https://raw.githubusercontent.com/ltseverydayyou/uuuuuuu/refs/heads/main/Sword%20Fight%20Bot"))()
end)

NAmanage.CreateBox = function(part, color, transparency)
	if not part or not part.Parent then return end
	NAmanage.RemoveEspFromPart(part)
	local c = (typeof(color) == "Color3" and color) or Color3.new(1,1,1)
	local entryTransparency = NAgui.sanitizeTransparency(transparency or (NAStuff.ESP_Transparency or 0.45))
	local h, s, v = Color3.toHSV(c)
	local off = 0.35
	local darker = Color3.fromHSV(h, s, math.clamp(v - off, 0, 1))
	local lighter = Color3.fromHSV(h, s, math.clamp(v + off, 0, 1))
	local useHighlight = NAgui.espUsesHighlight()
	local adornName = Lower(part.Name).."_peepee"
	local visual
	if useHighlight then
		visual = InstanceNew("Highlight", part)
		visual.Name = adornName
		visual.Adornee = part
		visual.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
		visual.FillColor = lighter
		visual.OutlineColor = darker
		visual.FillTransparency = entryTransparency
		visual.OutlineTransparency = 0
		visual.Enabled = false
		Defer(function()
			if visual and visual.Parent then
				visual.Enabled = true
			end
		end)
	else
		visual = InstanceNew("BoxHandleAdornment", part)
		visual.Name = adornName
		visual.Adornee = part
		visual.AlwaysOnTop = true
		visual.ZIndex = 0
		visual.Transparency = entryTransparency
		visual.Color3 = lighter
	end
	local bb = InstanceNew("BillboardGui", part)
	bb.Name = Lower(part.Name).."_label"
	bb.Adornee = part
	bb.Size = UDim2.new(0, 160, 0, 28)
	bb.StudsOffset = Vector3.new(0, 0.5, 0)
	bb.AlwaysOnTop = true
	bb.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
	local tl = InstanceNew("TextLabel", bb)
	tl.Size = UDim2.new(1, 0, 1, 0)
	tl.BackgroundTransparency = 1
	tl.Text = part.Name
	tl.TextColor3 = Color3.new(1,1,1)
	tl.Font = Enum.Font.SourceSansBold
	tl.TextStrokeTransparency = 0.5
	tl.ZIndex = 1
	NAgui.applyLabelStyle(tl)
	local gr = InstanceNew("UIGradient", tl)
	gr.Color = ColorSequence.new(darker, lighter)
	local function update()
		if not part or not part.Parent then return end
		if not bb.Parent then return end
		local sizeY = 2.5
		if part:IsA("Model") then
			local ok, _, ms = pcall(part.GetBoundingBox, part)
			if ok and ms then
				sizeY = ms.Y
				if not useHighlight and visual and visual:IsA("BoxHandleAdornment") then
					local newSize = ms + Vector3.new(0.1,0.1,0.1)
					if visual.Size ~= newSize then
						visual.Size = newSize
					end
				end
			end
		elseif part:IsA("BasePart") then
			sizeY = part.Size.Y
			if not useHighlight and visual and visual:IsA("BoxHandleAdornment") then
				local newSize = part.Size + Vector3.new(0.1,0.1,0.1)
				if visual.Size ~= newSize then
					visual.Size = newSize
				end
			end
		end
		bb.StudsOffset = Vector3.new(0, (sizeY / 2) + 0.2, 0)
	end
	update()
	Defer(update)
	local key = "esp_update_"..tostring(visual)
	if part:IsA("Model") then
		NAlib.connect(key, part.DescendantAdded:Connect(update))
		NAlib.connect(key, part.DescendantRemoving:Connect(update))
	elseif NAlib.isProperty(part, "Size") then
		NAlib.connect(key, part:GetPropertyChangedSignal("Size"):Connect(update))
	end
	NAlib.connect(key, part.AncestryChanged:Connect(function(_, parentNow)
		if not parentNow then
			NAlib.disconnect(key)
		end
	end))
	local entry = {
		part = part,
		billboard = bb,
		label = tl,
		visual = visual,
		baseColor = c,
		lightColor = lighter,
		darkColor = darker,
		transparency = entryTransparency,
		gradient = gr,
		useHighlight = useHighlight,
		updateKey = key,
	}
	NAmanage.PartESP_RegisterEntry(entry)
	return visual
end

NAmanage.RemoveEspFromPart = function(part)
	if not part then return end
	for _, child in ipairs(part:GetChildren()) do
		if (child:IsA("BoxHandleAdornment") or child:IsA("Highlight")) and Sub(child.Name,-7) == "_peepee" then
			NAlib.disconnect("esp_update_"..tostring(child))
			local entry = NAStuff.partESPVisualMap and NAStuff.partESPVisualMap[child]
			if entry then
				NAmanage.PartESP_UnregisterEntry(entry)
			end
			child:Destroy()
		end
	end
	for _, child in ipairs(part:GetChildren()) do
		if child:IsA("BillboardGui") and Sub(Lower(child.Name),-6) == "_label" then
			local entry = NAStuff.partESPEntries and NAStuff.partESPEntries[child]
			if entry then
				NAmanage.PartESP_UnregisterEntry(entry)
			end
			child:Destroy()
		end
	end
end

NAmanage.EnableEsp = function(objType, color, list)
	for _,obj in ipairs(workspace:GetDescendants()) do
		if obj:IsA(objType) then
			local parent = obj:FindFirstAncestorWhichIsA("BasePart") or obj:FindFirstAncestorWhichIsA("Model")
			if parent and not Discover(list, parent) then
				Insert(list, parent)
				NAmanage.CreateBox(parent, color, 0.45)
			end
		end
	end
	if not NAStuff.espTriggers[objType] then
		NAStuff.espTriggers[objType] = workspace.DescendantAdded:Connect(function(obj)
			if obj:IsA(objType) then
				local parent = obj:FindFirstAncestorWhichIsA("BasePart") or obj:FindFirstAncestorWhichIsA("Model")
				if parent and not Discover(list, parent) then
					Insert(list, parent)
					NAmanage.CreateBox(parent, color, 0.45)
				end
			end
		end)
	end
end

NAmanage.DisableEsp = function(objType, list)
	if NAStuff.espTriggers[objType] then
		NAStuff.espTriggers[objType]:Disconnect()
		NAStuff.espTriggers[objType] = nil
	end
	for _,part in ipairs(list) do
		NAmanage.RemoveEspFromPart(part)
	end
	table.clear(list)
end

NAmanage.EnableNameEsp = function(mode, color, ...)
	NAStuff.nameESPExclusions = NAStuff.nameESPExclusions or { exact = {}, partial = {} }
	local terms = {...}
	local list = NAStuff.espNameLists[mode]
	local parts = NAStuff.nameESPPartLists[mode]
	for _,term in ipairs(terms) do
		local t = Lower(term)
		if mode == "exact" then
			NAStuff.nameESPExclusions.exact[t] = nil
		else
			for nm,_ in pairs(NAStuff.nameESPExclusions.partial) do
				if Find(nm, t) then
					NAStuff.nameESPExclusions.partial[nm] = nil
				end
			end
		end
		if not Discover(list, t) then
			Insert(list, t)
		end
	end
	local function matchFn(obj)
		if not (obj:IsA("BasePart") or obj:IsA("Model")) then return false end
		local nm = Lower(obj.Name)
		local ex = NAStuff.nameESPExclusions and NAStuff.nameESPExclusions[mode]
		if ex and ex[nm] then
			return false
		end
		for _,term in ipairs(list) do
			if (mode=="exact" and nm==term) or (mode=="partial" and Find(nm,term)) then
				return true
			end
		end
		return false
	end
	local function handleNameChange(obj)
		local matches = matchFn(obj)
		local idx = Discover(parts,obj)
		if matches and not idx then
			Insert(parts,obj)
			NAmanage.CreateBox(obj,color,0.45)
		elseif not matches and idx then
			NAmanage.RemoveEspFromPart(obj)
			table.remove(parts,idx)
		end
	end
	for _,obj in ipairs(workspace:GetDescendants()) do
		if obj:IsA("BasePart") or obj:IsA("Model") then
			NAlib.connect("esp_namechange_"..mode, obj:GetPropertyChangedSignal("Name"):Connect(function()
				handleNameChange(obj)
			end))
			handleNameChange(obj)
		end
	end
	if not NAStuff.espNameTriggers[mode] then
		NAStuff.espNameTriggers[mode] = workspace.DescendantAdded:Connect(function(obj)
			if obj:IsA("BasePart") or obj:IsA("Model") then
				NAlib.connect("esp_namechange_"..mode, obj:GetPropertyChangedSignal("Name"):Connect(function()
					handleNameChange(obj)
				end))
				handleNameChange(obj)
			end
		end)
	end
end

NAmanage.DisableNameEsp = function(mode)
	if NAStuff.espNameTriggers[mode] then
		NAStuff.espNameTriggers[mode]:Disconnect()
		NAStuff.espNameTriggers[mode] = nil
	end
	NAlib.disconnect("esp_namechange_"..mode)
	local parts = NAStuff.nameESPPartLists[mode]
	for _,part in ipairs(parts) do
		NAmanage.RemoveEspFromPart(part)
	end
	table.clear(parts)
	table.clear(NAStuff.espNameLists[mode])
end

NAmanage.EnableUnanchoredEsp = function(color)
	local col = color or Color3.fromRGB(255,220,0)
	local function update(part)
		if not part:IsA("BasePart") then return end
		local idx = Discover(NAStuff.unanchoredESPList, part)
		if part.Anchored == false and not idx then
			Insert(NAStuff.unanchoredESPList, part)
			NAmanage.CreateBox(part, col, 0.45)
		elseif part.Anchored == true and idx then
			NAmanage.RemoveEspFromPart(part)
			table.remove(NAStuff.unanchoredESPList, idx)
		end
	end
	for _,obj in ipairs(workspace:GetDescendants()) do
		if obj:IsA("BasePart") then
			update(obj)
			NAlib.connect("esp_unanchored_prop", obj:GetPropertyChangedSignal("Anchored"):Connect(function()
				update(obj)
			end))
		end
	end
	if not NAStuff.espTriggers["__unanchored"] then
		NAStuff.espTriggers["__unanchored"] = workspace.DescendantAdded:Connect(function(obj)
			if obj:IsA("BasePart") then
				update(obj)
				NAlib.connect("esp_unanchored_prop", obj:GetPropertyChangedSignal("Anchored"):Connect(function()
					update(obj)
				end))
			end
		end)
	end
end

NAmanage.DisableUnanchoredEsp = function()
	if NAStuff.espTriggers["__unanchored"] then
		NAStuff.espTriggers["__unanchored"]:Disconnect()
		NAStuff.espTriggers["__unanchored"] = nil
	end
	NAlib.disconnect("esp_unanchored_prop")
	for _,part in ipairs(NAStuff.unanchoredESPList) do
		NAmanage.RemoveEspFromPart(part)
	end
	table.clear(NAStuff.unanchoredESPList)
end

NAmanage.EnableCollisionEsp = function(targetState, color)
	local list = targetState and NAStuff.collisiontrueESPList or NAStuff.collisionfalseESPList
	local trigKey = targetState and "__cancollide_true" or "__cancollide_false"
	local propKey = targetState and "esp_cancollide_true_prop" or "esp_cancollide_false_prop"
	local col = color or (targetState and Color3.fromRGB(0,200,255) or Color3.fromRGB(255,120,120))
	local function update(part)
		if not part:IsA("BasePart") then return end
		local idx = Discover(list, part)
		local matches = part.CanCollide == targetState
		if matches and not idx then
			Insert(list, part)
			NAmanage.CreateBox(part, col, 0.45)
		elseif not matches and idx then
			NAmanage.RemoveEspFromPart(part)
			table.remove(list, idx)
		end
	end
	for _,obj in ipairs(workspace:GetDescendants()) do
		if obj:IsA("BasePart") then
			update(obj)
			NAlib.connect(propKey, obj:GetPropertyChangedSignal("CanCollide"):Connect(function()
				update(obj)
			end))
		end
	end
	if not NAStuff.espTriggers[trigKey] then
		NAStuff.espTriggers[trigKey] = workspace.DescendantAdded:Connect(function(obj)
			if obj:IsA("BasePart") then
				update(obj)
				NAlib.connect(propKey, obj:GetPropertyChangedSignal("CanCollide"):Connect(function()
					update(obj)
				end))
			end
		end)
	end
end

NAmanage.DisableCollisionEsp = function(targetState)
	local list = targetState and NAStuff.collisiontrueESPList or NAStuff.collisionfalseESPList
	local trigKey = targetState and "__cancollide_true" or "__cancollide_false"
	local propKey = targetState and "esp_cancollide_true_prop" or "esp_cancollide_false_prop"
	if NAStuff.espTriggers[trigKey] then
		NAStuff.espTriggers[trigKey]:Disconnect()
		NAStuff.espTriggers[trigKey] = nil
	end
	NAlib.disconnect(propKey)
	for _,part in ipairs(list) do
		NAmanage.RemoveEspFromPart(part)
	end
	table.clear(list)
end

NAmanage.ESP_LocatorEnsureGui = function()
	if NAStuff.ESP_LocatorGui and NAStuff.ESP_LocatorGui.Parent then return NAStuff.ESP_LocatorGui end
	local g = InstanceNew("ScreenGui")
	NaProtectUI(g)
	NAStuff.ESP_LocatorGui = g
	return g
end

NAmanage.ESP_LocatorEnable = function(force)
	if NAStuff.ESP_LocatorEnabled and not force and NAlib.isConnected("esp_locator_loop") then return end
	NAStuff.ESP_LocatorEnabled = true

	local gui = NAmanage.ESP_LocatorEnsureGui()
	NAStuff.ESP_LocatorArrows = NAStuff.ESP_LocatorArrows or setmetatable({}, { __mode = "k" })
	local arrows = NAStuff.ESP_LocatorArrows

	local function getHolder(entry)
		local holder = arrows[entry]
		if holder and holder.Parent then return holder end

		holder = InstanceNew("Frame")
		holder.Name = "locator"
		holder.Size = UDim2.fromOffset(1, 1)
		holder.AnchorPoint = Vector2.new(0.5, 0.5)
		holder.BackgroundTransparency = 1
		holder.ZIndex = 1
		holder.Visible = false
		holder.Parent = gui

		local pointer = InstanceNew("TextLabel")
		pointer.Name = "Pointer"
		pointer.Size = UDim2.fromOffset(NAStuff.ESP_LocatorSize or 26, NAStuff.ESP_LocatorSize or 26)
		pointer.AnchorPoint = Vector2.new(0.5, 0.5)
		pointer.Position = UDim2.fromOffset(0, 0)
		pointer.BackgroundTransparency = 1
		pointer.Text = "V"
		pointer.TextScaled = true
		pointer.TextStrokeTransparency = 0.5
		pointer.Font = Enum.Font.SourceSansBold
		pointer.ZIndex = 3
		pointer.Visible = true
		pointer.Parent = holder

		local label = InstanceNew("TextLabel")
		label.Name = "Name"
		label.Size = UDim2.fromOffset(150, 20)
		label.AnchorPoint = Vector2.new(0.5, 0.5)
		label.Position = UDim2.fromOffset(0, 0)
		label.BackgroundTransparency = 1
		label.Text = ""
		label.TextScaled = false
		label.TextSize = NAStuff.ESP_LocatorTextSize or 14
		label.TextWrapped = true
		label.Font = Enum.Font.SourceSansBold
		label.TextXAlignment = Enum.TextXAlignment.Center
		label.TextYAlignment = Enum.TextYAlignment.Center
		label.TextStrokeTransparency = 0.5
		label.ZIndex = 2
		label.Visible = NAStuff.ESP_LocatorShowText == true
		label.Parent = holder

		arrows[entry] = holder
		return holder
	end

	local function applyStyle(holder, col)
		local size = math.clamp(tonumber(NAStuff.ESP_LocatorSize) or 26, 12, 128)
		local showText = (NAStuff.ESP_LocatorShowText == true)
		local textSize = math.clamp(tonumber(NAStuff.ESP_LocatorTextSize) or 14, 10, 48)

		local pointer = holder:FindFirstChild("Pointer")
		local label = holder:FindFirstChild("Name")

		if pointer then
			if pointer.TextColor3 ~= col then pointer.TextColor3 = col end
			local s = UDim2.fromOffset(size,size)
			if pointer.Size ~= s then pointer.Size = s end
		end
		if label then
			if label.TextColor3 ~= col then label.TextColor3 = col end
			if label.TextSize ~= textSize then label.TextSize = textSize end
			label.Visible = showText
		end
	end

	local function measure(text, textSize, maxWidth)
		local b = TextService:GetTextSize(text, textSize, Enum.Font.SourceSansBold, Vector2.new(maxWidth, 1e5))
		local w = math.clamp(b.X + 12, 40, maxWidth)
		local h = math.max(b.Y + 6, textSize + 4)
		return w, h
	end

	NAlib.disconnect("esp_locator_loop")
	NAlib.connect("esp_locator_loop", RunService.RenderStepped:Connect(function()
		if not NAStuff.ESP_LocatorEnabled then return end
		local cam = workspace.CurrentCamera
		if not cam then return end
		local vp = cam.ViewportSize
		if vp.X <= 0 or vp.Y <= 0 then return end

		local size = math.clamp(tonumber(NAStuff.ESP_LocatorSize) or 26, 12, 128)
		local textOn = (NAStuff.ESP_LocatorShowText == true)
		local textSize = math.clamp(tonumber(NAStuff.ESP_LocatorTextSize) or 14, 10, 48)

		local cx, cy = vp.X * 0.5, vp.Y * 0.5
		local margin = 16 + size * 0.5
		local minX, maxX = margin, vp.X - margin
		local minY, maxY = margin, vp.Y - margin

		local seen = {}

		local root = nil
		if NAStuff.ESP_ShowPartDistance == true then
			local lp = Players.LocalPlayer
			local ch = lp and lp.Character
			root = ch and getRoot(ch)
		end

		for _, entry in pairs(NAStuff.partESPEntries or {}) do
			if entry and not entry.removed and entry.part and entry.part.Parent then
				local pos = NAgui.getInstanceWorldPosition(entry.part)
				if pos then
					local v3 = cam:WorldToViewportPoint(pos)
					local x, y, z = v3.X, v3.Y, v3.Z
					local holder = getHolder(entry)
					local pointer = holder:FindFirstChild("Pointer")
					local label = holder:FindFirstChild("Name")
					local col = entry.lightColor or entry.baseColor or Color3.new(1,1,1)

					applyStyle(holder, col)

					if z > 0 and x >= 0 and x <= vp.X and y >= 0 and y <= vp.Y then
						holder.Visible = false
					else
						local dirX, dirY = x - cx, y - cy
						if z <= 0 then dirX = -dirX dirY = -dirY end
						local mag = math.sqrt(dirX*dirX + dirY*dirY)
						if mag < 1e-3 then dirX, dirY = 0, -1 else dirX, dirY = dirX/mag, dirY/mag end

						local sx = (cx - margin) / math.max(1e-4, math.abs(dirX))
						local sy = (cy - margin) / math.max(1e-4, math.abs(dirY))
						local scale = math.min(sx, sy)
						local px = cx + dirX * scale
						local py = cy + dirY * scale

						if px < minX then px = minX elseif px > maxX then px = maxX end
						if py < minY then py = minY elseif py > maxY then py = maxY end

						local wantPos = UDim2.fromOffset(px, py)
						if holder.Position.X.Offset ~= wantPos.X.Offset or holder.Position.Y.Offset ~= wantPos.Y.Offset then
							holder.Position = wantPos
						end

						if pointer then
							local ang = math.deg(math.atan2(dirY, dirX)) - 90
							if pointer.Rotation ~= ang then pointer.Rotation = ang end
						end

						if textOn and label then
							local nm = entry.customName or (entry.part and entry.part.Name) or "Part"
							if NAStuff.ESP_ShowPartDistance == true and root and root.Position then
								local d = math.floor((root.Position - pos).Magnitude + 0.5)
								nm = nm.." | "..tostring(d).." studs"
							end

							local side = math.abs(dirX) > math.abs(dirY)
							local textForSide = nm
							if side then
								local nameOnly, distOnly = nm, ""
								local bar = Find(nm, "|", 1, true)
								if bar then
									nameOnly = Sub(nm, 1, bar-2)
									distOnly = Sub(nm, bar+2)
								end
								textForSide = nameOnly..(distOnly ~= "" and ("\n"..distOnly) or "")
							end

							if label.Text ~= (side and textForSide or nm) then
								label.Text = side and textForSide or nm
							end

							if side then
								local maxW = math.max(60, math.floor(size * 3.5))
								local w, h = measure(textForSide, textSize, maxW)
								if label.Size.X.Offset ~= maxW or label.Size.Y.Offset ~= h then
									label.Size = UDim2.fromOffset(maxW, h)
								end
							else
								local maxW = math.floor(vp.X * 0.25)
								local w, h = measure(nm, textSize, maxW)
								if label.Size.X.Offset ~= w or label.Size.Y.Offset ~= h then
									label.Size = UDim2.fromOffset(w, h)
								end
							end

							local gap = 6 + math.floor(size * 0.35)
							local bx, by = -dirX, -dirY
							local offX = bx * (size*0.5 + gap)
							local offY = by * (size*0.5 + gap)

							local lblAbsX = px + offX
							local lblAbsY = py + offY

							local halfW = label.Size.X.Offset * 0.5
							local halfH = label.Size.Y.Offset * 0.5

							if lblAbsX - halfW < 4 then lblAbsX = 4 + halfW end
							if lblAbsX + halfW > vp.X - 4 then lblAbsX = vp.X - 4 - halfW end
							if lblAbsY - halfH < 4 then lblAbsY = 4 + halfH end
							if lblAbsY + halfH > vp.Y - 4 then lblAbsY = vp.Y - 4 - halfH end

							local relX = lblAbsX - px
							local relY = lblAbsY - py
							local wantLabel = UDim2.fromOffset(relX, relY)
							if label.Position.X.Offset ~= wantLabel.X.Offset or label.Position.Y.Offset ~= wantLabel.Y.Offset then
								label.Position = wantLabel
							end

							if not label.Visible then label.Visible = true end
						elseif label and label.Visible then
							label.Visible = false
						end

						holder.Visible = true
					end

					seen[entry] = true
				end
			end
		end

		for entry, holder in pairs(arrows) do
			if (not entry) or entry.removed or (not seen[entry]) or (not entry.part) or (not entry.part.Parent) then
				if holder and holder.Parent then holder:Destroy() end
				arrows[entry] = nil
			end
		end
	end))
end

NAmanage.ESP_LocatorDisable = function()
	NAStuff.ESP_LocatorEnabled = false
	NAlib.disconnect("esp_locator_loop")
	if NAStuff.ESP_LocatorArrows then
		for _, a in pairs(NAStuff.ESP_LocatorArrows) do
			if a and a.Parent then a:Destroy() end
		end
	end
	NAStuff.ESP_LocatorArrows = setmetatable({}, {__mode="k"})
	if NAStuff.ESP_LocatorGui and NAStuff.ESP_LocatorGui.Parent then
		NAStuff.ESP_LocatorGui:Destroy()
		NAStuff.ESP_LocatorGui = nil
	end
end

cmd.add({"touchesp","tesp"},{"touchesp"},function()
	NAmanage.EnableEsp("TouchTransmitter", Color3.fromRGB(255,0,0), NAStuff.touchESPList)
end)

cmd.add({"untouchesp","untesp"},{"untouchesp"},function()
	NAmanage.DisableEsp("TouchTransmitter", NAStuff.touchESPList)
end)

cmd.add({"proximityesp","prxesp","proxiesp"},{"proximityesp"},function()
	NAmanage.EnableEsp("ProximityPrompt", Color3.fromRGB(0,0,255), NAStuff.proximityESPList)
end)

cmd.add({"unproximityesp","unprxesp","unproxiesp"},{"unproximityesp"},function()
	NAmanage.DisableEsp("ProximityPrompt", NAStuff.proximityESPList)
end)

cmd.add({"clickesp","cesp"},{"clickesp"},function()
	NAmanage.EnableEsp("ClickDetector", Color3.fromRGB(255,165,0), NAStuff.clickESPList)
end)

cmd.add({"unclickesp","uncesp"},{"unclickesp"},function()
	NAmanage.DisableEsp("ClickDetector", NAStuff.clickESPList)
end)

cmd.add({"sitesp","ssp"},{"sitesp"},function()
	NAmanage.EnableEsp("Seat", Color3.fromRGB(0,255,0), NAStuff.siteESPList)
end)

cmd.add({"unsitesp","unssp"},{"unsitesp"},function()
	NAmanage.DisableEsp("Seat", NAStuff.siteESPList)
end)

cmd.add({"vehiclesitesp","vsitesp","vsp"},{"vehiclesitesp"},function()
	NAmanage.EnableEsp("VehicleSeat", Color3.fromRGB(255,0,255), NAStuff.vehicleSiteESPList)
end)

cmd.add({"unvehiclesitesp","unvsitesp","unvsp"},{"unvehiclesitesp"},function()
	NAmanage.DisableEsp("VehicleSeat", NAStuff.vehicleSiteESPList)
end)

cmd.add({"pesp","esppart","partesp"},{"pesp {partname}"},function(...)
	local name = Concat({...}," ")
	if name=="" then
		NAmanage.DisableNameEsp("exact")
	else
		NAmanage.EnableNameEsp("exact", nil, name)
	end
end,true)

cmd.add({"unpesp","unesppart","unpartesp"},{"unpesp [name|All]","Remove exact-name part ESP by name or All"},function(...)
	local mode = "exact"
	local parts = NAStuff.nameESPPartLists and NAStuff.nameESPPartLists[mode] or {}
	local terms = NAStuff.espNameLists and NAStuff.espNameLists[mode] or {}
	if type(terms) ~= "table" or #terms == 0 then
		DoNotif("No exact-name ESP terms are active.", 2)
		return
	end

	local filter = Lower(Concat({...}," "))

	local function removeAll()
		NAmanage.DisableNameEsp(mode)
		DoNotif("Cleared all exact-name part ESP.", 2)
	end

	local function termMatchesName(term, name)
		return Lower(name) == term
	end

	local function removeByTerm(term)
		for i = #terms, 1, -1 do
			if terms[i] == term then
				table.remove(terms, i)
			end
		end
		for i = #parts, 1, -1 do
			local p = parts[i]
			if p and p.Parent and termMatchesName(term, p.Name) then
				NAmanage.RemoveEspFromPart(p)
				table.remove(parts, i)
			end
		end
		DoNotif("Removed exact-name ESP for '"..term.."'.", 2)
	end

	if filter ~= "" then
		if filter == "all" then
			removeAll()
			return
		end
		local picked = nil
		for _, t in ipairs(terms) do
			if t == filter then picked = t break end
		end
		if not picked then
			for _, t in ipairs(terms) do
				if Match(t, filter) then picked = t break end
			end
		end
		if picked then
			removeByTerm(picked)
		else
			DoNotif("No matching exact-name ESP term for: "..filter, 3)
		end
		return
	end

	local buttons = {}
	Insert(buttons, { Text = "All", Callback = removeAll })
	for _, t in ipairs(terms) do
		Insert(buttons, { Text = t, Callback = function() removeByTerm(t) end })
	end

	Window({
		Title = "Remove Exact Part ESP",
		Description = "Select a term to stop tracking (future spawns included).",
		Buttons = buttons
	})
end,true)

cmd.add({"pespfind","partespfind","esppartfind"},{"pespfind {partname}"},function(...)
	local name = Concat({...}," ")
	if name=="" then
		NAmanage.DisableNameEsp("partial")
	else
		NAmanage.EnableNameEsp("partial", nil, name)
	end
end,true)

cmd.add({"unpespfind","unpartespfind","unesppartfind"},{"unpespfind [name|All]","Remove partial-name part ESP by name or All"},function(...)
	local mode = "partial"
	local parts = NAStuff.nameESPPartLists and NAStuff.nameESPPartLists[mode] or {}
	local terms = NAStuff.espNameLists and NAStuff.espNameLists[mode] or {}
	if type(terms) ~= "table" or #terms == 0 then
		DoNotif("No partial-name ESP terms are active.", 2)
		return
	end

	local filter = Lower(Concat({...}," "))

	local function removeAll()
		NAmanage.DisableNameEsp(mode)
		DoNotif("Cleared all partial-name part ESP.", 2)
	end

	local function termMatchesName(term, name)
		return Find(Lower(name), term) ~= nil
	end

	local function removeByTerm(term)
		for i = #terms, 1, -1 do
			if terms[i] == term then
				table.remove(terms, i)
			end
		end
		for i = #parts, 1, -1 do
			local p = parts[i]
			if p and p.Parent and termMatchesName(term, p.Name) then
				NAmanage.RemoveEspFromPart(p)
				table.remove(parts, i)
			end
		end
		DoNotif("Removed partial-name ESP for '"..term.."'.", 2)
	end

	if filter ~= "" then
		if filter == "all" then
			removeAll()
			return
		end
		local picked = nil
		for _, t in ipairs(terms) do
			if t == filter then picked = t break end
		end
		if not picked then
			for _, t in ipairs(terms) do
				if Match(t, filter) then picked = t break end
			end
		end
		if picked then
			removeByTerm(picked)
		else
			DoNotif("No matching partial-name ESP term for: "..filter, 3)
		end
		return
	end

	local buttons = {}
	Insert(buttons, { Text = "All", Callback = removeAll })
	for _, t in ipairs(terms) do
		Insert(buttons, { Text = t, Callback = function() removeByTerm(t) end })
	end

	Window({
		Title = "Remove Partial Part ESP",
		Description = "Select a term to stop tracking (future spawns included).",
		Buttons = buttons
	})
end,true)

cmd.add({"unanchored","unanchoredesp","uaesp"},{"unanchored"},function()
	NAmanage.EnableUnanchoredEsp(Color3.fromRGB(255,220,0))
end)

cmd.add({"ununanchored","ununanchoredesp","unuaesp"},{"ununanchored"},function()
	NAmanage.DisableUnanchoredEsp()
end)

cmd.add({"collisionesp","colesp"},{"collisionesp"},function()
	NAmanage.EnableCollisionEsp(true, Color3.fromRGB(0,200,255))
end)

cmd.add({"uncollisionesp","uncolesp"},{"uncollisionesp"},function()
	NAmanage.DisableCollisionEsp(true)
end)

cmd.add({"nocollisionesp","ncolesp"},{"nocollisionesp"},function()
	NAmanage.EnableCollisionEsp(false, Color3.fromRGB(255,120,120))
end)

cmd.add({"unnocollisionesp","unncolesp"},{"unnocollisionesp"},function()
	NAmanage.DisableCollisionEsp(false)
end)

cmd.add({"esplocator","locator","trackesp"},{"esplocator",""},function()
	NAmanage.ESP_LocatorEnable(true)
end)

cmd.add({"unesplocator","unlocator","untrackesp"},{"unesplocator",""},function()
	NAmanage.ESP_LocatorDisable()
end)

cmd.add({"folderesp","fesp"},{"folderesp {folderName}","Highlights all parts in a folder"},function(...)
	local name = Lower(Concat({...}," "))
	if name=="" then return end
	if not NAStuff.folderESPMembers then NAStuff.folderESPMembers = {} end
	if not NAStuff.folderESPKeys then NAStuff.folderESPKeys = {} end
	local folder
	for _,obj in ipairs(workspace:GetDescendants()) do
		if obj:IsA("Folder") and Lower(obj.Name)==name then folder=obj break end
	end
	if not folder then return end
	local list = NAStuff.folderESPMembers[folder]
	if not list then list = {}; NAStuff.folderESPMembers[folder]=list end
	local key = NAStuff.folderESPKeys[folder]
	if not key then key = "esp_folder_"..tostring(folder); NAStuff.folderESPKeys[folder]=key end
	for _,desc in ipairs(folder:GetDescendants()) do
		if desc:IsA("BasePart") and not Discover(list,desc) then
			Insert(list,desc)
			NAmanage.CreateBox(desc, Color3.fromRGB(255,220,0), 0.45)
		end
	end
	NAlib.connect(key, folder.DescendantAdded:Connect(function(obj)
		if obj:IsA("BasePart") and not Discover(list,obj) then
			Insert(list,obj)
			NAmanage.CreateBox(obj, Color3.fromRGB(255,220,0), 0.45)
		end
	end))
	NAlib.connect(key, folder.DescendantRemoving:Connect(function(obj)
		if obj:IsA("BasePart") then
			local idx = Discover(list,obj)
			if idx then
				NAmanage.RemoveEspFromPart(obj)
				table.remove(list,idx)
			end
		end
	end))
end,true)

cmd.add({"unfolderesp","unfesp"},{"unfolderesp [folderName]","Disables folder ESP for a folder or all"},function(...)
	local members = NAStuff.folderESPMembers
	if type(members) ~= "table" then
		DoNotif("No folder ESP entries are active.", 2)
		return
	end

	local keysCache = NAStuff.folderESPKeys

	local function detachFolder(folder)
		if typeof(folder) ~= "Instance" then
			return false
		end

		local removed = false

		if keysCache then
			local conn = keysCache[folder]
			if conn then
				NAlib.disconnect(conn)
				keysCache[folder] = nil
				removed = true
			end
		end

		local list = members[folder]
		if list then
			for _, part in ipairs(list) do
				NAmanage.RemoveEspFromPart(part)
			end
			table.clear(list)
			members[folder] = nil
			removed = true
		end

		return removed
	end

	local function collectTrackedFolders()
		local tracked = {}
		for folder, _ in pairs(members) do
			if typeof(folder) == "Instance" then
				tracked[#tracked + 1] = folder
			else
				members[folder] = nil
			end
		end
		table.sort(tracked, function(a, b)
			return Lower(a.Name) < Lower(b.Name)
		end)
		return tracked
	end

	local function removeAllFolders()
		local tracked = collectTrackedFolders()
		local removed = 0
		for _, folder in ipairs(tracked) do
			if detachFolder(folder) then
				removed += 1
			end
		end
		if removed > 0 then
			DoNotif(Format("Stopped folder ESP for %d folder(s).", removed), 2)
		else
			DoNotif("No folder ESP entries were active.", 2)
		end
	end

	local trackedFolders = collectTrackedFolders()

	local rawInput = Concat({...}, " ")
	rawInput = (type(rawInput) == "string") and rawInput:gsub("^%s+", ""):gsub("%s+$", "") or ""
	local loweredInput = Lower(rawInput)

	if loweredInput ~= "" then
		if loweredInput == "all" or loweredInput == "*" then
			removeAllFolders()
			return
		end

		local picked = nil
		for _, folder in ipairs(trackedFolders) do
			if Lower(folder.Name) == loweredInput then
				picked = folder
				break
			end
		end

		if not picked then
			for _, folder in ipairs(trackedFolders) do
				if Match(Lower(folder.Name), loweredInput) then
					picked = folder
					break
				end
			end
		end

		if picked and detachFolder(picked) then
			DoNotif(Format("Stopped folder ESP for '%s'.", picked.Name), 2)
		else
			DoNotif(Format("No folder ESP entry matching '%s'.", rawInput ~= "" and rawInput or loweredInput), 3)
		end
		return
	end

	if #trackedFolders == 0 then
		DoNotif("No folder ESP entries are active.", 2)
		return
	end

	local buttons = {
		{
			Text = "All",
			Callback = removeAllFolders
		}
	}

	for _, folder in ipairs(trackedFolders) do
		local folderRef = folder
		buttons[#buttons + 1] = {
			Text = folderRef.Name,
			Callback = function()
				if detachFolder(folderRef) then
					DoNotif(Format("Stopped folder ESP for '%s'.", folderRef.Name), 2)
				else
					DoNotif("Folder ESP entry was not active.", 2)
				end
			end
		}
	end

	Window({
		Title = "Folder ESP",
		Description = "Select a folder ESP entry to disable.",
		Buttons = buttons
	})
end,true)

cmd.add({"viewpart", "viewp", "vpart"}, {"viewpart {partName} (viewp, vpart)", "Focuses camera on a part, model, or folder"},function(...)
	local partName = Concat({...}, " "):lower()
	local ws = workspace
	local camera = ws.CurrentCamera

	for _, obj in ipairs(ws:GetDescendants()) do
		if obj.Name:lower() == partName then
			if obj:IsA("BasePart") then
				camera.CameraSubject = obj
				return
			elseif obj:IsA("Model") or obj:IsA("Folder") then
				for _, child in ipairs(obj:GetDescendants()) do
					if child:IsA("BasePart") then
						camera.CameraSubject = child
						return
					end
				end
			end
		end
	end

	DebugNotif("No matching part, model, or folder with a BasePart found named '"..partName.."'")
end,true)

cmd.add({"unviewpart", "unviewp"}, {"unviewpart (unviewp)", "Resets the camera to the local humanoid"}, function()
	local camera = workspace.CurrentCamera
	local humanoid = getHum()
	if humanoid then
		camera.CameraSubject = humanoid
	end
end)

cmd.add({"viewpartfind", "viewpfind", "vpartfind"}, {"viewpartfind {name} (viewpfind, vpartfind)", "Focuses camera on a part, model, or folder with name containing the given text"}, function(...)
	local name = Concat({...}, " "):lower()
	local ws = workspace
	local cam = ws.CurrentCamera

	for _, obj in ipairs(ws:GetDescendants()) do
		if obj.Name:lower():find(name) then
			if obj:IsA("BasePart") then
				cam.CameraSubject = obj
				return
			elseif obj:IsA("Model") or obj:IsA("Folder") then
				for _, child in ipairs(obj:GetDescendants()) do
					if child:IsA("BasePart") then
						cam.CameraSubject = child
						return
					end
				end
			end
		end
	end

	DebugNotif("No part, model, or folder containing '"..name.."' with a BasePart found")
end, true)

cmd.add({"unviewpart", "unviewp"}, {"unviewpart (unviewp)", "Resets the camera to the local humanoid"}, function()
	local cam = workspace.CurrentCamera
	local hum = getHum()
	if hum then
		cam.CameraSubject = hum
	end
end)

cmd.add({"console", "debug"}, {"console (debug)", "Opens developer console"}, function()
	local consoleButtons = {
		{
			Text = "Roblox Console",
			Callback = function()
				StarterGui:SetCore("DevConsoleVisible", true)
			end
		},
		{
			Text = "Custom Console",
			Callback = function()
				NAgui.consoleeee()
			end
		}
	}

	Window({
		Title = "Select Console",
		Buttons = consoleButtons
	})
end)

cmd.add({"hitbox","hbox"},{"hitbox <player> {size}",""},function(pArg,sArg)
	NAStuff.HB = NAStuff.HB or {}
	NAStuff.HB.P = NAStuff.HB.P or {loops=setmetatable({}, {__mode="k"}), og=setmetatable({}, {__mode="k"}), charAdded=setmetatable({}, {__mode="k"}), addConn=nil, remConn=nil}
	NAStuff.HB.N = NAStuff.HB.N or {loops=setmetatable({}, {__mode="k"}), og=setmetatable({}, {__mode="k"}), perModelAdded=setmetatable({}, {__mode="k"}), scanConn=nil, descConn=nil, config=nil}

	local targets = getPlr(pArg) if #targets==0 then DoNotif("No targets found",2) return end
	local n = tonumber(sArg) or 10
	local argLower = Lower(pArg)
	local npcMode = (argLower=="npc")
	local global = (argLower=="all" or argLower=="others")

	local function GetChar(t)
		if typeof(t)=="Instance" and t:IsA("Player") then
			return getPlrChar(t)
		elseif typeof(t)=="Instance" and t:IsA("Model") then
			return t
		end
	end

	local partSet = {All=true}
	for _,t in ipairs(targets) do
		local c = GetChar(t)
		if c then
			for _,p in ipairs(c:GetChildren()) do
				if p:IsA("BasePart") then partSet[p.Name]=true end
			end
		end
	end

	local btns = {}
	for limb,_ in pairs(partSet) do
		Insert(btns,{
			Text = limb,
			Callback = function()
				local newSize = Vector3.new(n,n,n)

				if npcMode then
					local D = NAStuff.HB.N
					D.config = {limb=limb,size=newSize}

					local function Cache(key, bp)
						D.og[key] = D.og[key] or setmetatable({}, {__mode="k"})
						if not D.og[key][bp] then
							D.og[key][bp] = {
								Size=bp.Size, Transparency=bp.Transparency, BrickColor=bp.BrickColor,
								Material=bp.Material, CanCollide=bp.CanCollide, Massless=bp.Massless
							}
						end
					end

					local function ApplyTo(model)
						if not model then return end
						for _,bp in ipairs(model:GetChildren()) do
							if bp:IsA("BasePart") and (limb=="All" or Lower(bp.Name)==Lower(limb)) then
								Cache(model, bp)
								bp.Size = newSize
								bp.Transparency = 0.9
								bp.BrickColor = BrickColor.new("Really black")
								bp.Material = Enum.Material.Neon
								bp.CanCollide = false
								bp.Massless = true
							end
						end
					end

					local function EnsureLoop(model)
						if D.loops[model] then D.loops[model]:Disconnect() end
						D.loops[model] = RunService.Stepped:Connect(function()
							if model and model.Parent then
								ApplyTo(model)
							end
						end)
					end

					local function IsNPCModel(inst)
						if inst:IsA("Model") and CheckIfNPC(inst) then return inst end
						local m = inst:FindFirstAncestorWhichIsA("Model")
						if m and CheckIfNPC(m) then return m end
						return nil
					end

					for _,t in ipairs(targets) do
						local m = GetChar(t)
						if m then
							EnsureLoop(m)
							Defer(function() ApplyTo(m) end)
							if D.perModelAdded[m] then D.perModelAdded[m]:Disconnect() end
							D.perModelAdded[m] = m.DescendantAdded:Connect(function()
								ApplyTo(m)
							end)
						end
					end

					if D.descConn then D.descConn:Disconnect() D.descConn=nil end
					D.descConn = workspace.DescendantAdded:Connect(function(inst)
						local mdl = IsNPCModel(inst)
						if mdl then
							EnsureLoop(mdl)
							Defer(function() ApplyTo(mdl) end)
							local key = D.perModelAdded[mdl]
							if key then key:Disconnect() end
							D.perModelAdded[mdl] = mdl.DescendantAdded:Connect(function()
								ApplyTo(mdl)
							end)
						end
					end)

					if D.scanConn then D.scanConn:Disconnect() D.scanConn=nil end
					local acc = 0
					D.scanConn = RunService.Heartbeat:Connect(function(dt)
						acc += dt
						if acc < 0.4 then return end
						acc = 0
						for _,child in ipairs(workspace:GetChildren()) do
							if child:IsA("Model") and CheckIfNPC(child) then
								EnsureLoop(child)
								ApplyTo(child)
							end
						end
					end)
				else
					local D = NAStuff.HB.P

					local function Cache(key, bp)
						D.og[key] = D.og[key] or setmetatable({}, {__mode="k"})
						if not D.og[key][bp] then
							D.og[key][bp] = {
								Size=bp.Size, Transparency=bp.Transparency, BrickColor=bp.BrickColor,
								Material=bp.Material, CanCollide=bp.CanCollide, Massless=bp.Massless
							}
						end
					end

					local function ApplyTo(charKey, char)
						if not char then return end
						for _,bp in ipairs(char:GetChildren()) do
							if bp:IsA("BasePart") and (limb=="All" or Lower(bp.Name)==Lower(limb)) then
								Cache(charKey, bp)
								bp.Size = newSize
								bp.Transparency = 0.9
								bp.BrickColor = BrickColor.new("Really black")
								bp.Material = Enum.Material.Neon
								bp.CanCollide = false
								bp.Massless = true
							end
						end
					end

					local function EnsureLoop(key)
						if D.loops[key] then D.loops[key]:Disconnect() end
						D.loops[key] = RunService.Stepped:Connect(function()
							local c = GetChar(key)
							if c then ApplyTo(key, c) end
						end)
					end

					for _,t in ipairs(targets) do
						EnsureLoop(t)
						if typeof(t)=="Instance" and t:IsA("Player") and t.CharacterAdded then
							if D.charAdded[t] then D.charAdded[t]:Disconnect() end
							D.charAdded[t] = t.CharacterAdded:Connect(function(c)
								Defer(function() ApplyTo(t, c) end)
							end)
						end
						local c = GetChar(t)
						if c then Defer(function() ApplyTo(t, c) end) end
					end

					if global then
						if D.addConn then D.addConn:Disconnect() end
						if D.remConn then D.remConn:Disconnect() end
						D.addConn = Players.PlayerAdded:Connect(function(plr)
							EnsureLoop(plr)
							if D.charAdded[plr] then D.charAdded[plr]:Disconnect() end
							if plr.CharacterAdded then
								D.charAdded[plr] = plr.CharacterAdded:Connect(function(c)
									Defer(function() ApplyTo(plr, c) end)
								end)
							end
						end)
						D.remConn = Players.PlayerRemoving:Connect(function(plr)
							if D.loops[plr] then D.loops[plr]:Disconnect() D.loops[plr]=nil end
							if D.charAdded[plr] then D.charAdded[plr]:Disconnect() D.charAdded[plr]=nil end
							D.og[plr]=nil
						end)
					end
				end
			end
		})
	end

	Window({Title="Hitbox Menu",Description="Choose limb to resize",Buttons=btns})
end,true)

cmd.add({"unhitbox","unhbox"},{"unhitbox <player>",""},function(pArg)
	NAStuff.HB = NAStuff.HB or {}
	NAStuff.HB.P = NAStuff.HB.P or {loops=setmetatable({}, {__mode="k"}), og=setmetatable({}, {__mode="k"}), charAdded=setmetatable({}, {__mode="k"}), addConn=nil, remConn=nil}
	NAStuff.HB.N = NAStuff.HB.N or {loops=setmetatable({}, {__mode="k"}), og=setmetatable({}, {__mode="k"}), perModelAdded=setmetatable({}, {__mode="k"}), scanConn=nil, descConn=nil, config=nil}

	local targets = getPlr(pArg)
	if #targets==0 then DoNotif("No targets found",2) return end
	local argLower = Lower(pArg)
	local npcMode = (argLower=="npc")
	local global = (argLower=="all" or argLower=="others")

	if npcMode then
		local D = NAStuff.HB.N
		for _,t in ipairs(targets) do
			if D.og[t] then
				for bp,props in pairs(D.og[t]) do
					if bp and bp.Parent then
						bp.Size = props.Size
						bp.Transparency = props.Transparency
						bp.BrickColor = props.BrickColor
						bp.Material = props.Material
						bp.CanCollide = props.CanCollide
						bp.Massless = props.Massless
					end
				end
				D.og[t] = nil
			end
			if D.loops[t] then D.loops[t]:Disconnect() D.loops[t]=nil end
			if D.perModelAdded[t] then D.perModelAdded[t]:Disconnect() D.perModelAdded[t]=nil end
		end
		for mdl,conn in pairs(D.perModelAdded) do
			if conn then conn:Disconnect() end
			D.perModelAdded[mdl]=nil
		end
		for key,lp in pairs(D.loops) do
			if lp then lp:Disconnect() end
			D.loops[key]=nil
		end
		if D.descConn then D.descConn:Disconnect() D.descConn=nil end
		if D.scanConn then D.scanConn:Disconnect() D.scanConn=nil end
		return
	end

	do
		local D = NAStuff.HB.P
		for _,t in ipairs(targets) do
			if D.og[t] then
				for bp,props in pairs(D.og[t]) do
					if bp and bp.Parent then
						bp.Size = props.Size
						bp.Transparency = props.Transparency
						bp.BrickColor = props.BrickColor
						bp.Material = props.Material
						bp.CanCollide = props.CanCollide
						bp.Massless = props.Massless
					end
				end
				D.og[t] = nil
			end
			if D.loops[t] then D.loops[t]:Disconnect() D.loops[t]=nil end
			if D.charAdded[t] then D.charAdded[t]:Disconnect() D.charAdded[t]=nil end
		end
		if global then
			if D.addConn then D.addConn:Disconnect() D.addConn=nil end
			if D.remConn then D.remConn:Disconnect() D.remConn=nil end
		end
	end
end,true)

local PST = {
	orig   = {},
	exact  = {},
	partial= {},
	sizeE  = {},
	sizeP  = {},
}

NAmanage.cachePart = function(p)
	PST.orig[p] = {
		Size         = p.Size,
		Transparency = p.Transparency,
		CanCollide   = p.CanCollide,
	}
end

NAmanage.resizePart = function(p, sizeVec, store)
	if not PST.orig[p] then NAmanage.cachePart(p) end
	p.Size         = sizeVec
	p.Transparency = 0.5
	p.CanCollide   = false
	Insert(store, p)
end

cmd.add({"partsize","psize","sizepart"},{"partsize {name} {size}", "Grow a part or model named exactly <name> to the cube size you choose."},function(nameArg, sizeArg)
	local term, n = Lower(nameArg), tonumber(sizeArg)
	if not n then DoNotif("Invalid size",2) return end
	local sizeVec = Vector3.new(n,n,n)
	PST.sizeE[term] = sizeVec

	local parts, elser = {}, {}
	for _, obj in ipairs(workspace:GetDescendants()) do
		local nm = Lower(obj.Name)
		if obj:IsA("BasePart") and nm == term then
			Insert(parts, obj)
		elseif nm == term then
			Insert(elser, obj)
		end
	end

	for _, p in ipairs(parts) do
		NAmanage.resizePart(p, sizeVec, PST.exact)
	end
	for _, m in ipairs(elser) do
		for _, d in ipairs(m:GetDescendants()) do
			if d:IsA("BasePart") then
				NAmanage.resizePart(d, sizeVec, PST.exact)
			end
		end
	end

	if not NAlib.isConnected("partsizeExact") then
		NAlib.connect("partsizeExact", workspace.DescendantAdded:Connect(function(obj)
			if obj:IsA("BasePart") then
				local nm = Lower(obj.Name)
				local sz = PST.sizeE[nm]
				if sz then
					NAmanage.resizePart(obj, sz, PST.exact)
					return
				end
			else
				local sz = PST.sizeE[Lower(obj.Name)]
				if sz then
					for _, d in ipairs(obj:GetDescendants()) do
						if d:IsA("BasePart") then
							NAmanage.resizePart(d, sz, PST.exact)
						end
					end
				end
			end
		end))
	end
end, true)

cmd.add({"partsizefind","psizefind","sizefind","partsizef"},{"partsizefind {term} {size}", "Grow every part or model whose name contains <term> to the cube size you choose."},function(termArg, sizeArg)
	local term, n = Lower(termArg), tonumber(sizeArg)
	if not n then DoNotif("Invalid size",2) return end
	local sizeVec = Vector3.new(n,n,n)
	PST.sizeP[term] = sizeVec

	local parts, elser = {}, {}
	for _, obj in ipairs(workspace:GetDescendants()) do
		local nm = Lower(obj.Name)
		if obj:IsA("BasePart") and nm:find(term) then
			Insert(parts, obj)
		elseif nm:find(term) then
			Insert(elser, obj)
		end
	end

	for _, p in ipairs(parts) do
		NAmanage.resizePart(p, sizeVec, PST.partial)
	end
	for _, m in ipairs(elser) do
		for _, d in ipairs(m:GetDescendants()) do
			if d:IsA("BasePart") then
				NAmanage.resizePart(d, sizeVec, PST.partial)
			end
		end
	end

	if not NAlib.isConnected("partsizeFind") then
		NAlib.connect("partsizeFind", workspace.DescendantAdded:Connect(function(obj)
			if obj:IsA("BasePart") then
				local nm = Lower(obj.Name)
				for t, sz in pairs(PST.sizeP) do
					if nm:find(t) then
						NAmanage.resizePart(obj, sz, PST.partial)
						return
					end
				end
			else
				for t, sz in pairs(PST.sizeP) do
					if Lower(obj.Name):find(t) then
						for _, d in ipairs(obj:GetDescendants()) do
							if d:IsA("BasePart") then
								NAmanage.resizePart(d, sz, PST.partial)
							end
						end
						return
					end
				end
			end
		end))
	end
end, true)

cmd.add({"unpartsize","unsizepart","unpsize"},{"unpartsize", "Undo partsize—return those parts back to their original size and collision."},function()
	for _, p in ipairs(PST.exact) do
		local pr = PST.orig[p]
		if pr then
			p.Size         = pr.Size
			p.Transparency = pr.Transparency
			p.CanCollide   = pr.CanCollide
			PST.orig[p] = nil
		end
	end
	table.clear(PST.exact)
	table.clear(PST.sizeE)
	NAlib.disconnect("partsizeExact")
end, true)

cmd.add({"unpartsizefind","unsizefind","unpsizefind"},{"unpartsizefind", "Undo partsizefind—return those resized parts back to their original size and collision."},function()
	for _, p in ipairs(PST.partial) do
		local pr = PST.orig[p]
		if pr then
			p.Size         = pr.Size
			p.Transparency = pr.Transparency
			p.CanCollide   = pr.CanCollide
			PST.orig[p] = nil
		end
	end
	table.clear(PST.partial)
	table.clear(PST.sizeP)
	NAlib.disconnect("partsizeFind")
end, true)

cmd.add({"breakcars", "bcars"}, {"breakcars (bcars)", "Breaks any car"}, function()
	DebugNotif("Car breaker loaded, sit on a vehicle and be the driver")

	local Player = Players.LocalPlayer
	local Mouse = Player:GetMouse()

	local Folder = InstanceNew("Folder")
	Folder.Parent = workspace

	local Part = InstanceNew("Part")
	Part.Anchored = true
	Part.CanCollide = false
	Part.Transparency = 1
	Part.Size = Vector3.new(1, 1, 1)
	Part.Parent = Folder

	local Attachment1 = InstanceNew("Attachment")
	Attachment1.Parent = Part

	local UpdatedPosition = Mouse.Hit + Vector3.new(0, 5, 0)

	SpawnCall(function()
		while Wait() do
			for _, player in ipairs(Players:GetPlayers()) do
				if player ~= Player then
					player.MaximumSimulationRadius = 0
					opt.hiddenprop(player, "SimulationRadius", 0)
				end
			end
			Player.MaximumSimulationRadius = math.pow(math.huge, math.huge)
			setsimulationradius(math.huge)
		end
	end)

	local function applyForceToPart(part)
		if not part:IsA("BasePart") or part.Anchored then return end
		if part.Name == "Handle" then return end
		local parent = part.Parent
		if getPlrHum(parent) or getHead(parent) then return end

		Mouse.TargetFilter = part

		for _, v in ipairs(part:GetChildren()) do
			if v:IsA("BodyAngularVelocity") or v:IsA("BodyForce") or v:IsA("BodyGyro")
				or v:IsA("BodyPosition") or v:IsA("BodyThrust") or v:IsA("BodyVelocity")
				or v:IsA("RocketPropulsion") or v:IsA("Torque") or v:IsA("AlignPosition")
				or v:IsA("Attachment") then
				v:Destroy()
			end
		end

		part.CanCollide = false

		local torque = InstanceNew("Torque")
		torque.Torque = Vector3.new(100000, 100000, 100000)
		torque.Parent = part

		local alignPosition = InstanceNew("AlignPosition")
		alignPosition.MaxForce = math.huge
		alignPosition.MaxVelocity = math.huge
		alignPosition.Responsiveness = 200
		alignPosition.Parent = part

		local attachment2 = InstanceNew("Attachment")
		attachment2.Parent = part

		torque.Attachment0 = attachment2
		alignPosition.Attachment0 = attachment2
		alignPosition.Attachment1 = Attachment1
	end

	for _, descendant in ipairs(workspace:GetDescendants()) do
		applyForceToPart(descendant)
	end

	workspace.DescendantAdded:Connect(applyForceToPart)

	UserInputService.InputBegan:Connect(function(input, isChatting)
		if input.KeyCode == Enum.KeyCode.E and not isChatting then
			UpdatedPosition = Mouse.Hit + Vector3.new(0, 5, 0)
		end
	end)

	SpawnCall(function()
		while Wait() do
			Attachment1.WorldCFrame = UpdatedPosition
		end
	end)
end)

cmd.add({"setsimradius", "ssr", "simrad"},{"setsimradius <number>","Set sim radius using available methods. Usage: setsimradius <radius>"},function(...)
	local r = tonumber(...)
	if not r then
		return DoNotif("Invalid input. Usage: setsimradius <number>")
	end

	local ok = false

	if setsimulationradius then
		NACaller(function()
			setsimulationradius(r)
			ok = true
			DebugNotif("SimRadius set with setsimulationradius: "..r)
		end)
	end

	if not ok and opt.hiddenprop then
		if NACaller(function()
				opt.hiddenprop(LocalPlayer, "SimulationRadius", r)
			end) then
			ok = true
			DebugNotif("SimRadius set with sethiddenproperty: "..r)
		end
	end

	if not ok then
		if NACaller(function()
				LocalPlayer.SimulationRadius = r
			end) then
			ok = true
			DebugNotif("SimRadius set directly: "..r)
		end
	end

	if not ok then
		DebugNotif("No supported method to set sim radius.")
	end
end,true)

cmd.add({"infjump", "infinitejump"}, {"infjump (infinitejump)", "Enables infinite jumping"}, function()
	Wait()
	DebugNotif("Infinite Jump Enabled", 2)

	local function doINFJUMPY()
		NAlib.disconnect("infjump_jump")

		local debounce = false
		local humanoid = nil

		while not humanoid do Wait(.1) humanoid = getHum() end

		NAlib.connect("infjump_jump", UserInputService.JumpRequest:Connect(function()
			if not debounce and humanoid:GetState() ~= Enum.HumanoidStateType.Dead then
				debounce = true
				humanoid:ChangeState(Enum.HumanoidStateType.Jumping)

				Delay(0.25, function()
					debounce = false
				end)
			end
		end))
	end

	NAlib.disconnect("infjump_char")
	NAlib.connect("infjump_char", plr.CharacterAdded:Connect(function()
		doINFJUMPY()
	end))

	doINFJUMPY()
end)

cmd.add({"uninfjump", "uninfinitejump"}, {"uninfjump (uninfinitejump)", "Disables infinite jumping"}, function()
	Wait()
	DebugNotif("Infinite Jump Disabled", 2)

	NAlib.disconnect("infjump_jump")
	NAlib.disconnect("infjump_char")
end)

cmd.add({"flyjump"},{"flyjump","Allows you to hold space to fly up"},function()
	Wait()
	DebugNotif("FlyJump Enabled", 3)

	NAlib.disconnect("flyjump")
	NAlib.connect("flyjump", UserInputService.JumpRequest:Connect(function()
		getHum():ChangeState(Enum.HumanoidStateType.Jumping)
	end))
end)

cmd.add({"unflyjump","noflyjump"},{"unflyjump (noflyjump)","Disables flyjump"},function()
	Wait()
	DebugNotif("FlyJump Disabled", 3)

	NAlib.disconnect("flyjump")
end)

cmd.add({"xray", "xrayon"}, {"xray (xrayon)", "Enables X-ray vision to see through walls"}, function()
	Wait()
	DebugNotif("X-ray enabled")
	togXray(true)
end)

cmd.add({"unxray", "xrayoff"}, {"unxray (xrayoff)", "Disables X-ray vision"}, function()
	Wait()
	DebugNotif("X-ray disabled")
	togXray(false)
end)

NAmanage._ensureL=function()
	local st = getgenv()._LState or {}
	getgenv()._LState = st
	st.safeGet = st.safeGet or function(inst, prop) local ok,v=pcall(function() return inst[prop] end) if ok then return v end end
	st.safeSet = st.safeSet or function(inst, prop, v) return NAlib.setProperty(inst, prop, v) end
	if not st._utils then
		st._utils = true
		st.hook = function(name, fn) if not NAlib.isConnected(name) then NAlib.connect(name, fn()) end end
		st.disableTimeLoops = function()
			NAlib.disconnect("time_day")
			NAlib.disconnect("time_night")
		end
		st.disableNF = function(force)
			local nf = st.nf
			if not nf then return end
			if not force and nf.sticky then return end
			local wasEnabled = nf.enabled
			if wasEnabled then
				nf.enabled = false
			end
			if force then nf.sticky = false end
			if not wasEnabled then return end
			if not ((st.fb and st.fb.enabled) or (st.nb and st.nb.enabled)) then
				if st.safeSet then
					if nf.baselineFogEnd~=nil then st.safeSet(Lighting,"FogEnd",nf.baselineFogEnd) end
					if st.safeGet(Lighting,"FogStart")~=nil and nf.baselineFogStart~=nil then st.safeSet(Lighting,"FogStart",nf.baselineFogStart) end
				end
			end
			for inst,saved in pairs(nf.cache or {}) do
				if inst and inst.Parent and saved then
					for p,v in pairs(saved) do st.safeSet(inst,p,v) end
				end
			end
		end
		st.disableFB = function()
			if st.fb and st.fb.enabled then
				if st.restoreFB then st.restoreFB() end
				st.fb.enabled = false
				getgenv().FullBrightEnabled = false
			end
		end
		st.disableNB = function()
			if st.nb and st.nb.enabled then
				if st.restoreNB then st.restoreNB() end
				st.nb.enabled = false
			end
		end
		st.cancelFor = function(mode)
			if mode=="fb" then
				st.disableTimeLoops()
				st.disableNF()
				st.disableNB()
				if st.disableNM then st.disableNM() end
			elseif mode=="day" then
				st.disableFB()
				st.disableNB()
				if st.disableNM then st.disableNM() end
			elseif mode=="night" then
				st.disableTimeLoops()
				st.disableFB()
				if st.disableNM then st.disableNM() end
			elseif mode=="nf" then
				st.disableFB()
				st.disableNB()
				if st.disableNM then st.disableNM() end
			end
		end
	end
	return st
end

cmd.add({"fullbright","fullb","fb"},{"fullbright (fullb,fb)","makes dark games bright without destroying effects"},function()
	if not Lighting then return end
	local st = NAmanage._ensureL()
	local function ensureFB()
		st.fb = st.fb or {init=false,enabled=false,baseline={},target={Brightness=1,ClockTime=12,FogEnd=786543,GlobalShadows=false,Ambient=Color3.fromRGB(178,178,178)}}
		if st.fb.baseline.Brightness == nil then st.fb.baseline.Brightness = st.safeGet(Lighting,"Brightness") or 2 end
		if st.fb.baseline.ClockTime == nil then st.fb.baseline.ClockTime = st.safeGet(Lighting,"ClockTime") or 12 end
		if st.fb.baseline.FogEnd == nil then st.fb.baseline.FogEnd = st.safeGet(Lighting,"FogEnd") or 100000 end
		if st.fb.baseline.GlobalShadows == nil then local v=st.safeGet(Lighting,"GlobalShadows") st.fb.baseline.GlobalShadows = v~=nil and v or true end
		if st.fb.baseline.Ambient == nil then st.fb.baseline.Ambient = st.safeGet(Lighting,"Ambient") or Color3.fromRGB(128,128,128) end
		if not st.initFB then
			st.initFB = function()
				st.hook("fb_brightness", function() return Lighting:GetPropertyChangedSignal("Brightness"):Connect(function()
						if st.fb and st.fb.enabled then
							if st.safeGet(Lighting,"Brightness") ~= st.fb.target.Brightness then st.safeSet(Lighting,"Brightness",st.fb.target.Brightness) end
						else
							st.fb.baseline.Brightness = st.safeGet(Lighting,"Brightness") or st.fb.baseline.Brightness
						end
					end) end)
				st.hook("fb_clocktime", function() return Lighting:GetPropertyChangedSignal("ClockTime"):Connect(function()
						if st.fb and st.fb.enabled then
							if st.safeGet(Lighting,"ClockTime") ~= st.fb.target.ClockTime then st.safeSet(Lighting,"ClockTime",st.fb.target.ClockTime) end
						else
							st.fb.baseline.ClockTime = st.safeGet(Lighting,"ClockTime") or st.fb.baseline.ClockTime
						end
					end) end)
				st.hook("fb_fogend", function() return Lighting:GetPropertyChangedSignal("FogEnd"):Connect(function()
						if st.fb and st.fb.enabled then
							if st.safeGet(Lighting,"FogEnd") ~= st.fb.target.FogEnd then st.safeSet(Lighting,"FogEnd",st.fb.target.FogEnd) end
						else
							st.fb.baseline.FogEnd = st.safeGet(Lighting,"FogEnd") or st.fb.baseline.FogEnd
						end
					end) end)
				st.hook("fb_shadows", function() return Lighting:GetPropertyChangedSignal("GlobalShadows"):Connect(function()
						if st.fb and st.fb.enabled then
							if st.safeGet(Lighting,"GlobalShadows") ~= st.fb.target.GlobalShadows then st.safeSet(Lighting,"GlobalShadows",st.fb.target.GlobalShadows) end
						else
							local v=st.safeGet(Lighting,"GlobalShadows") if v~=nil then st.fb.baseline.GlobalShadows=v end
						end
					end) end)
				st.hook("fb_ambient", function() return Lighting:GetPropertyChangedSignal("Ambient"):Connect(function()
						if st.fb and st.fb.enabled then
							if st.safeGet(Lighting,"Ambient") ~= st.fb.target.Ambient then st.safeSet(Lighting,"Ambient",st.fb.target.Ambient) end
						else
							st.fb.baseline.Ambient = st.safeGet(Lighting,"Ambient") or st.fb.baseline.Ambient
						end
					end) end)
				st.hook("fb_loop", function() return RunService.RenderStepped:Connect(function()
						if not (st.fb and st.fb.enabled) then return end
						if st.safeGet(Lighting,"Brightness") ~= st.fb.target.Brightness then st.safeSet(Lighting,"Brightness",st.fb.target.Brightness) end
						if st.safeGet(Lighting,"ClockTime") ~= st.fb.target.ClockTime then st.safeSet(Lighting,"ClockTime",st.fb.target.ClockTime) end
						if st.safeGet(Lighting,"FogEnd") ~= st.fb.target.FogEnd then st.safeSet(Lighting,"FogEnd",st.fb.target.FogEnd) end
						local gs = st.safeGet(Lighting,"GlobalShadows")
						if gs~=nil and gs ~= st.fb.target.GlobalShadows then st.safeSet(Lighting,"GlobalShadows",st.fb.target.GlobalShadows) end
						if st.safeGet(Lighting,"Ambient") ~= st.fb.target.Ambient then st.safeSet(Lighting,"Ambient",st.fb.target.Ambient) end
					end) end)
			end
		end
		if not st.applyFB then
			st.applyFB = function()
				st.safeSet(Lighting,"Brightness",st.fb.target.Brightness)
				st.safeSet(Lighting,"ClockTime",st.fb.target.ClockTime)
				st.safeSet(Lighting,"FogEnd",st.fb.target.FogEnd)
				st.safeSet(Lighting,"GlobalShadows",st.fb.target.GlobalShadows)
				st.safeSet(Lighting,"Ambient",st.fb.target.Ambient)
			end
		end
		if not st.restoreFB then
			st.restoreFB = function()
				st.safeSet(Lighting,"Brightness",st.fb.baseline.Brightness)
				st.safeSet(Lighting,"ClockTime",st.fb.baseline.ClockTime)
				st.safeSet(Lighting,"FogEnd",st.fb.baseline.FogEnd)
				st.safeSet(Lighting,"GlobalShadows",st.fb.baseline.GlobalShadows)
				st.safeSet(Lighting,"Ambient",st.fb.baseline.Ambient)
			end
		end
		if not st.toggleFB then
			st.toggleFB = function(on)
				st.initFB()
				st.fb.enabled = on
				if on then st.applyFB() else st.restoreFB() end
				getgenv().FullBrightExecuted = true
				getgenv().FullBrightEnabled = st.fb.enabled
			end
		end
	end
	ensureFB()
	if not st.fb.enabled then st.cancelFor("fb") end
	st.toggleFB(not st.fb.enabled)
end)

cmd.add({"loopday","lday"},{"loopday (lday)","Sunshiiiine!"},function()
	if not Lighting then return end
	local st = NAmanage._ensureL()
	st.fb = st.fb or {enabled=false,baseline={},target={Brightness=1,ClockTime=12,FogEnd=786543,GlobalShadows=false,Ambient=Color3.fromRGB(178,178,178)}}
	st.fb.baseline.ClockTime = st.safeGet(Lighting,"ClockTime") or 12
	st.cancelFor("day")
	NAlib.disconnect("time_day")
	st.safeSet(Lighting,"ClockTime",14)
	NAlib.connect("time_day", Lighting:GetPropertyChangedSignal("ClockTime"):Connect(function()
		if st.safeGet(Lighting,"ClockTime") ~= 14 then st.safeSet(Lighting,"ClockTime",14) end
	end))
end)

cmd.add({"unloopday","unlday"},{"unloopday (unlday)","No more sunshine"},function()
	if not Lighting then return end
	local st = getgenv()._LState
	if not st then return end
	NAlib.disconnect("time_day")
	local target = (st.fb and st.fb.enabled) and ((st.fb.target and st.fb.target.ClockTime) or 12) or ((st.fb and st.fb.baseline and st.fb.baseline.ClockTime) or (st.safeGet and st.safeGet(Lighting,"ClockTime")) or 12)
	if st.safeSet then st.safeSet(Lighting,"ClockTime",target) else Lighting.ClockTime = target end
end)

cmd.add({"loopfullbright","loopfb","lfb"},{"loopfullbright (loopfb,lfb)","Sunshiiiine!"},function()
	if not Lighting then return end
	local st = NAmanage._ensureL()
	local function ensureFB()
		st.fb = st.fb or {init=false,enabled=false,baseline={},target={Brightness=1,ClockTime=12,FogEnd=786543,GlobalShadows=false,Ambient=Color3.fromRGB(178,178,178)}}
		if st.fb.baseline.Brightness == nil then st.fb.baseline.Brightness = st.safeGet(Lighting,"Brightness") or 2 end
		if st.fb.baseline.ClockTime == nil then st.fb.baseline.ClockTime = st.safeGet(Lighting,"ClockTime") or 12 end
		if st.fb.baseline.FogEnd == nil then st.fb.baseline.FogEnd = st.safeGet(Lighting,"FogEnd") or 100000 end
		if st.fb.baseline.GlobalShadows == nil then local v=st.safeGet(Lighting,"GlobalShadows") st.fb.baseline.GlobalShadows = v~=nil and v or true end
		if st.fb.baseline.Ambient == nil then st.fb.baseline.Ambient = st.safeGet(Lighting,"Ambient") or Color3.fromRGB(128,128,128) end
		if not st.initFB then
			st.initFB = function()
				st.hook("fb_brightness", function() return Lighting:GetPropertyChangedSignal("Brightness"):Connect(function()
						if st.fb and st.fb.enabled then
							if st.safeGet(Lighting,"Brightness") ~= st.fb.target.Brightness then st.safeSet(Lighting,"Brightness",st.fb.target.Brightness) end
						else
							st.fb.baseline.Brightness = st.safeGet(Lighting,"Brightness") or st.fb.baseline.Brightness
						end
					end) end)
				st.hook("fb_clocktime", function() return Lighting:GetPropertyChangedSignal("ClockTime"):Connect(function()
						if st.fb and st.fb.enabled then
							if st.safeGet(Lighting,"ClockTime") ~= st.fb.target.ClockTime then st.safeSet(Lighting,"ClockTime",st.fb.target.ClockTime) end
						else
							st.fb.baseline.ClockTime = st.safeGet(Lighting,"ClockTime") or st.fb.baseline.ClockTime
						end
					end) end)
				st.hook("fb_fogend", function() return Lighting:GetPropertyChangedSignal("FogEnd"):Connect(function()
						if st.fb and st.fb.enabled then
							if st.safeGet(Lighting,"FogEnd") ~= st.fb.target.FogEnd then st.safeSet(Lighting,"FogEnd",st.fb.target.FogEnd) end
						else
							st.fb.baseline.FogEnd = st.safeGet(Lighting,"FogEnd") or st.fb.baseline.FogEnd
						end
					end) end)
				st.hook("fb_shadows", function() return Lighting:GetPropertyChangedSignal("GlobalShadows"):Connect(function()
						if st.fb and st.fb.enabled then
							if st.safeGet(Lighting,"GlobalShadows") ~= st.fb.target.GlobalShadows then st.safeSet(Lighting,"GlobalShadows",st.fb.target.GlobalShadows) end
						else
							local v=st.safeGet(Lighting,"GlobalShadows") if v~=nil then st.fb.baseline.GlobalShadows=v end
						end
					end) end)
				st.hook("fb_ambient", function() return Lighting:GetPropertyChangedSignal("Ambient"):Connect(function()
						if st.fb and st.fb.enabled then
							if st.safeGet(Lighting,"Ambient") ~= st.fb.target.Ambient then st.safeSet(Lighting,"Ambient",st.fb.target.Ambient) end
						else
							st.fb.baseline.Ambient = st.safeGet(Lighting,"Ambient") or st.fb.baseline.Ambient
						end
					end) end)
				st.hook("fb_loop", function() return RunService.RenderStepped:Connect(function()
						if not (st.fb and st.fb.enabled) then return end
						if st.safeGet(Lighting,"Brightness") ~= st.fb.target.Brightness then st.safeSet(Lighting,"Brightness",st.fb.target.Brightness) end
						if st.safeGet(Lighting,"ClockTime") ~= st.fb.target.ClockTime then st.safeSet(Lighting,"ClockTime",st.fb.target.ClockTime) end
						if st.safeGet(Lighting,"FogEnd") ~= st.fb.target.FogEnd then st.safeSet(Lighting,"FogEnd",st.fb.target.FogEnd) end
						local gs = st.safeGet(Lighting,"GlobalShadows")
						if gs~=nil and gs ~= st.fb.target.GlobalShadows then st.safeSet(Lighting,"GlobalShadows",st.fb.target.GlobalShadows) end
						if st.safeGet(Lighting,"Ambient") ~= st.fb.target.Ambient then st.safeSet(Lighting,"Ambient",st.fb.target.Ambient) end
					end) end)
			end
		end
		if not st.applyFB then
			st.applyFB = function()
				st.safeSet(Lighting,"Brightness",st.fb.target.Brightness)
				st.safeSet(Lighting,"ClockTime",st.fb.target.ClockTime)
				st.safeSet(Lighting,"FogEnd",st.fb.target.FogEnd)
				st.safeSet(Lighting,"GlobalShadows",st.fb.target.GlobalShadows)
				st.safeSet(Lighting,"Ambient",st.fb.target.Ambient)
			end
		end
		if not st.restoreFB then
			st.restoreFB = function()
				st.safeSet(Lighting,"Brightness",st.fb.baseline.Brightness)
				st.safeSet(Lighting,"ClockTime",st.fb.baseline.ClockTime)
				st.safeSet(Lighting,"FogEnd",st.fb.baseline.FogEnd)
				st.safeSet(Lighting,"GlobalShadows",st.fb.baseline.GlobalShadows)
				st.safeSet(Lighting,"Ambient",st.fb.baseline.Ambient)
			end
		end
		if not st.toggleFB then
			st.toggleFB = function(on)
				st.initFB()
				st.fb.enabled = on
				if on then st.applyFB() else st.restoreFB() end
				getgenv().FullBrightExecuted = true
				getgenv().FullBrightEnabled = st.fb.enabled
			end
		end
	end
	ensureFB()
	st.cancelFor("fb")
	st.toggleFB(true)
end)

cmd.add({"unloopfullbright","unloopfb","unlfb"},{"unloopfullbright (unloopfb,unlfb)","No more sunshine"},function()
	if not Lighting then return end
	local st = NAmanage._ensureL()
	local function ensureFB()
		st.fb = st.fb or {init=false,enabled=false,baseline={},target={Brightness=1,ClockTime=12,FogEnd=786543,GlobalShadows=false,Ambient=Color3.fromRGB(178,178,178)}}
		if st.fb.baseline.Brightness == nil then st.fb.baseline.Brightness = st.safeGet(Lighting,"Brightness") or 2 end
		if st.fb.baseline.ClockTime == nil then st.fb.baseline.ClockTime = st.safeGet(Lighting,"ClockTime") or 12 end
		if st.fb.baseline.FogEnd == nil then st.fb.baseline.FogEnd = st.safeGet(Lighting,"FogEnd") or 100000 end
		if st.fb.baseline.GlobalShadows == nil then local v=st.safeGet(Lighting,"GlobalShadows") st.fb.baseline.GlobalShadows = v~=nil and v or true end
		if st.fb.baseline.Ambient == nil then st.fb.baseline.Ambient = st.safeGet(Lighting,"Ambient") or Color3.fromRGB(128,128,128) end
		if not st.applyFB then
			st.applyFB = function()
				st.safeSet(Lighting,"Brightness",st.fb.target.Brightness)
				st.safeSet(Lighting,"ClockTime",st.fb.target.ClockTime)
				st.safeSet(Lighting,"FogEnd",st.fb.target.FogEnd)
				st.safeSet(Lighting,"GlobalShadows",st.fb.target.GlobalShadows)
				st.safeSet(Lighting,"Ambient",st.fb.target.Ambient)
			end
		end
		if not st.restoreFB then
			st.restoreFB = function()
				st.safeSet(Lighting,"Brightness",st.fb.baseline.Brightness)
				st.safeSet(Lighting,"ClockTime",st.fb.baseline.ClockTime)
				st.safeSet(Lighting,"FogEnd",st.fb.baseline.FogEnd)
				st.safeSet(Lighting,"GlobalShadows",st.fb.baseline.GlobalShadows)
				st.safeSet(Lighting,"Ambient",st.fb.baseline.Ambient)
			end
		end
	end
	ensureFB()
	if st.fb and st.fb.enabled then
		st.toggleFB(false)
	end
end)

cmd.add({"loopnight","loopn","ln"},{"loopnight (loopn,ln)","Moonlight."},function()
	if not Lighting then return end
	local st = NAmanage._ensureL()
	st.cancelFor("night")
	local function ensureNB()
		st.nb = st.nb or {init=false,enabled=false,baseline={},target={Brightness=1,ClockTime=0,FogEnd=786543,GlobalShadows=false,Ambient=Color3.fromRGB(178,178,178)}}
		if st.nb.baseline.Brightness == nil then st.nb.baseline.Brightness = st.safeGet(Lighting,"Brightness") or 2 end
		if st.nb.baseline.ClockTime == nil then st.nb.baseline.ClockTime = st.safeGet(Lighting,"ClockTime") or 12 end
		if st.nb.baseline.FogEnd == nil then st.nb.baseline.FogEnd = st.safeGet(Lighting,"FogEnd") or 100000 end
		if st.nb.baseline.GlobalShadows == nil then local v=st.safeGet(Lighting,"GlobalShadows") st.nb.baseline.GlobalShadows = v~=nil and v or true end
		if st.nb.baseline.Ambient == nil then st.nb.baseline.Ambient = st.safeGet(Lighting,"Ambient") or Color3.fromRGB(128,128,128) end
		if not st.initNB then
			st.initNB = function()
				st.hook("nb_brightness", function() return Lighting:GetPropertyChangedSignal("Brightness"):Connect(function()
						if st.nb and st.nb.enabled then
							if st.safeGet(Lighting,"Brightness") ~= st.nb.target.Brightness then st.safeSet(Lighting,"Brightness",st.nb.target.Brightness) end
						else
							st.nb.baseline.Brightness = st.safeGet(Lighting,"Brightness") or st.nb.baseline.Brightness
						end
					end) end)
				st.hook("nb_clocktime", function() return Lighting:GetPropertyChangedSignal("ClockTime"):Connect(function()
						if st.nb and st.nb.enabled then
							if st.safeGet(Lighting,"ClockTime") ~= st.nb.target.ClockTime then st.safeSet(Lighting,"ClockTime",st.nb.target.ClockTime) end
						else
							st.nb.baseline.ClockTime = st.safeGet(Lighting,"ClockTime") or st.nb.baseline.ClockTime
						end
					end) end)
				st.hook("nb_fogend", function() return Lighting:GetPropertyChangedSignal("FogEnd"):Connect(function()
						if st.nb and st.nb.enabled then
							if st.safeGet(Lighting,"FogEnd") ~= st.nb.target.FogEnd then st.safeSet(Lighting,"FogEnd",st.nb.target.FogEnd) end
						else
							st.nb.baseline.FogEnd = st.safeGet(Lighting,"FogEnd") or st.nb.baseline.FogEnd
						end
					end) end)
				st.hook("nb_shadows", function() return Lighting:GetPropertyChangedSignal("GlobalShadows"):Connect(function()
						if st.nb and st.nb.enabled then
							if st.safeGet(Lighting,"GlobalShadows") ~= st.nb.target.GlobalShadows then st.safeSet(Lighting,"GlobalShadows",st.nb.target.GlobalShadows) end
						else
							local v=st.safeGet(Lighting,"GlobalShadows") if v~=nil then st.nb.baseline.GlobalShadows=v end
						end
					end) end)
				st.hook("nb_ambient", function() return Lighting:GetPropertyChangedSignal("Ambient"):Connect(function()
						if st.nb and st.nb.enabled then
							if st.safeGet(Lighting,"Ambient") ~= st.nb.target.Ambient then st.safeSet(Lighting,"Ambient",st.nb.target.Ambient) end
						else
							st.nb.baseline.Ambient = st.safeGet(Lighting,"Ambient") or st.nb.baseline.Ambient
						end
					end) end)
				st.hook("nb_loop", function() return RunService.RenderStepped:Connect(function()
						if not (st.nb and st.nb.enabled) then return end
						if st.safeGet(Lighting,"Brightness") ~= st.nb.target.Brightness then st.safeSet(Lighting,"Brightness",st.nb.target.Brightness) end
						if st.safeGet(Lighting,"ClockTime") ~= st.nb.target.ClockTime then st.safeSet(Lighting,"ClockTime",st.nb.target.ClockTime) end
						if st.safeGet(Lighting,"FogEnd") ~= st.nb.target.FogEnd then st.safeSet(Lighting,"FogEnd",st.nb.target.FogEnd) end
						local gs = st.safeGet(Lighting,"GlobalShadows")
						if gs~=nil and gs ~= st.nb.target.GlobalShadows then st.safeSet(Lighting,"GlobalShadows",st.nb.target.GlobalShadows) end
						if st.safeGet(Lighting,"Ambient") ~= st.nb.target.Ambient then st.safeSet(Lighting,"Ambient",st.nb.target.Ambient) end
					end) end)
			end
		end
		if not st.applyNB then
			st.applyNB = function()
				st.safeSet(Lighting,"Brightness",st.nb.target.Brightness)
				st.safeSet(Lighting,"ClockTime",st.nb.target.ClockTime)
				st.safeSet(Lighting,"FogEnd",st.nb.target.FogEnd)
				st.safeSet(Lighting,"GlobalShadows",st.nb.target.GlobalShadows)
				st.safeSet(Lighting,"Ambient",st.nb.target.Ambient)
			end
		end
		if not st.restoreNB then
			st.restoreNB = function()
				st.safeSet(Lighting,"Brightness",st.nb.baseline.Brightness)
				st.safeSet(Lighting,"ClockTime",st.nb.baseline.ClockTime)
				st.safeSet(Lighting,"FogEnd",st.nb.baseline.FogEnd)
				st.safeSet(Lighting,"GlobalShadows",st.nb.baseline.GlobalShadows)
				st.safeSet(Lighting,"Ambient",st.nb.baseline.Ambient)
			end
		end
		if not st.toggleNB then
			st.toggleNB = function(on)
				st.initNB()
				st.nb.enabled = on
				if on then st.applyNB() else st.restoreNB() end
			end
		end
	end
	ensureNB()
	st.toggleNB(true)
end)

cmd.add({"unloopnight","unloopn","unln"},{"unloopnight (unloopn,unln)","No more moonlight."},function()
	if not Lighting then return end
	local st = NAmanage._ensureL()
	local function ensureNB()
		st.nb = st.nb or {init=false,enabled=false,baseline={},target={Brightness=1,ClockTime=0,FogEnd=786543,GlobalShadows=false,Ambient=Color3.fromRGB(178,178,178)}}
		if not st.restoreNB then
			st.restoreNB = function()
				st.safeSet(Lighting,"Brightness",st.nb.baseline.Brightness)
				st.safeSet(Lighting,"ClockTime",st.nb.baseline.ClockTime)
				st.safeSet(Lighting,"FogEnd",st.nb.baseline.FogEnd)
				st.safeSet(Lighting,"GlobalShadows",st.nb.baseline.GlobalShadows)
				st.safeSet(Lighting,"Ambient",st.nb.baseline.Ambient)
			end
		end
	end
	ensureNB()
	if st.nb and st.nb.enabled then
		st.toggleNB(false)
	end
end)

cmd.add({"loopnoeffect","lnoeffect","loopne","lne"},{"loopnoeffect","Keeps Lighting and CurrentCamera effects disabled"},function()
	if not Lighting then return end
	local st = NAmanage._ensureL()
	local w = workspace
	st.ne = st.ne or {init=false,enabled=false,cache=setmetatable({},{__mode="k"}),sticky=false}
	local ne = st.ne
	ne.cache = ne.cache or setmetatable({},{__mode="k"})
	local function cacheProperty(inst,prop,value)
		if not inst then return end
		local saved = ne.cache[inst]
		if not saved then
			saved={}
			ne.cache[inst]=saved
		end
		if saved[prop]==nil then
			local v=value
			if v==nil then v=st.safeGet(inst,prop) end
			if v~=nil then saved[prop]=v end
		end
	end
	local function disableEffect(inst)
		if not inst or not inst.Parent then return end
		if inst:IsA("PostEffect") then
			local enabled=st.safeGet(inst,"Enabled")
			if enabled~=nil then
				cacheProperty(inst,"Enabled",enabled)
				if enabled~=false then st.safeSet(inst,"Enabled",false) end
			end
		end
		if inst:IsA("Atmosphere") then
			local density=st.safeGet(inst,"Density")
			if density~=nil then cacheProperty(inst,"Density",density); if density~=0 then st.safeSet(inst,"Density",0) end end
			local haze=st.safeGet(inst,"Haze")
			if haze~=nil then cacheProperty(inst,"Haze",haze); if haze~=0 then st.safeSet(inst,"Haze",0) end end
			local glare=st.safeGet(inst,"Glare")
			if glare~=nil then cacheProperty(inst,"Glare",glare); if glare~=0 then st.safeSet(inst,"Glare",0) end end
		end
	end
	local function processLighting()
		for _,inst in ipairs(Lighting:GetDescendants()) do disableEffect(inst) end
	end
	local function processCamera()
		local cam = w.CurrentCamera
		if not cam then
			ne.lastCamera=nil
			return
		end
		if ne.lastCamera~=cam then
			ne.lastCamera=cam
		end
		for _,inst in ipairs(cam:GetDescendants()) do disableEffect(inst) end
	end
	local function attachCameraWatcher()
		if ne.camDescConn then
			pcall(function() ne.camDescConn:Disconnect() end)
			ne.camDescConn=nil
		end
		local cam = w.CurrentCamera
		if not cam then
			ne.lastCamera=nil
			return
		end
		ne.lastCamera = cam
		processCamera()
		local ok,conn=pcall(function()
			return cam.DescendantAdded:Connect(function(child)
				if not (st.ne and st.ne.enabled) then return end
				if not ne.lastCamera or (child and not child:IsDescendantOf(ne.lastCamera)) then return end
				disableEffect(child)
			end)
		end)
		if ok and conn then
			ne.camDescConn=conn
		end
	end
	if not ne.init then
		ne.init=true
		st.hook("ne_camera_changed", function() return w:GetPropertyChangedSignal("CurrentCamera"):Connect(function()
				if not (st.ne and st.ne.enabled) then return end
				attachCameraWatcher()
			end) end)
		st.hook("ne_loop", function() return RunService.RenderStepped:Connect(function()
				if not (st.ne and st.ne.enabled) then return end
				processLighting()
				processCamera()
			end) end)
	end
	ne.enabled=true
	ne.sticky=true
	processLighting()
	processCamera()
	attachCameraWatcher()
end)

cmd.add({"unloopnoeffect","unlnoeffect","unloopne","unlne"},{"unloopnoeffect","Restores Lighting and CurrentCamera effects"},function()
	if not Lighting then return end
	local st = getgenv()._LState
	if not st or not st.ne then return end
	local ne = st.ne
	ne.sticky=false
	ne.enabled=false
	if ne.camDescConn then
		pcall(function() ne.camDescConn:Disconnect() end)
		ne.camDescConn=nil
	end
	for inst,saved in pairs(ne.cache or {}) do
		if inst and inst.Parent and saved then
			for prop,value in pairs(saved) do
				if st.safeSet then st.safeSet(inst,prop,value) else pcall(function() inst[prop]=value end) end
			end
		end
	end
end)

cmd.add({"noeffect","cleareffects","disableeffects"},{"noeffect","Disables Lighting and CurrentCamera effects"},function()
	if not Lighting then return end
	local st = NAmanage._ensureL()
	local function disableEffect(inst)
		if not inst then return end
		if inst:IsA("PostEffect") then
			local enabled=st.safeGet(inst,"Enabled")
			if enabled~=nil and enabled~=false then st.safeSet(inst,"Enabled",false) end
		end
		if inst:IsA("Atmosphere") then
			local density=st.safeGet(inst,"Density")
			if density~=nil and density~=0 then st.safeSet(inst,"Density",0) end
			local haze=st.safeGet(inst,"Haze")
			if haze~=nil and haze~=0 then st.safeSet(inst,"Haze",0) end
			local glare=st.safeGet(inst,"Glare")
			if glare~=nil and glare~=0 then st.safeSet(inst,"Glare",0) end
		end
	end
	for _,inst in ipairs(Lighting:GetDescendants()) do disableEffect(inst) end
	local cam = workspace.CurrentCamera
	if cam then
		for _,inst in ipairs(cam:GetDescendants()) do disableEffect(inst) end
	end
end)

cmd.add({"loopnofog","lnofog","lnf","loopnf"},{"loopnofog (lnofog,lnf,loopnf,nofog,nf)","See clearly forever!"},function()
	if not Lighting then return end
	local st = NAmanage._ensureL()
	if st.disableNM then st.disableNM() end
	st.nf = st.nf or {init=false,enabled=false,baselineFogEnd=st.safeGet(Lighting,"FogEnd") or 100000,baselineFogStart=st.safeGet(Lighting,"FogStart") or 0,cache=setmetatable({},{__mode="k"}),sticky=false}
	local nf = st.nf
	local function cacheOnce(inst, props)
		if nf.cache[inst] then return end
		local saved = {}
		for _,p in ipairs(props) do local v = st.safeGet(inst,p); if v~=nil then saved[p]=v end end
		nf.cache[inst]=saved
	end
	local function disableEffect(inst)
		if inst and inst:IsA("PostEffect") then cacheOnce(inst,{"Enabled"}); st.safeSet(inst,"Enabled",false) end
		if inst and inst:IsA("Atmosphere") then cacheOnce(inst,{"Density","Haze","Glare"}); st.safeSet(inst,"Density",0); st.safeSet(inst,"Haze",0); st.safeSet(inst,"Glare",0) end
	end
	local function enforceNoFog()
		if not (st.nf and st.nf.enabled) then return end
		st.safeSet(Lighting,"FogEnd",786543)
		if st.safeGet(Lighting,"FogStart") ~= nil then
			st.safeSet(Lighting,"FogStart",0)
		end
		for inst,_ in pairs(nf.cache) do
			if inst and inst.Parent then
				disableEffect(inst)
			end
		end
	end
	if not nf.init then
		nf.init = true
		local scanAccumulator = 0
		st.hook("nf_prop_end", function() return Lighting:GetPropertyChangedSignal("FogEnd"):Connect(function()
				if st.nf and st.nf.enabled then
					if st.safeGet(Lighting,"FogEnd") ~= 786543 then st.safeSet(Lighting,"FogEnd",786543) end
				end
			end) end)
		st.hook("nf_prop_start", function() return Lighting:GetPropertyChangedSignal("FogStart"):Connect(function()
				if st.nf and st.nf.enabled then
					if st.safeGet(Lighting,"FogStart") ~= 0 then st.safeSet(Lighting,"FogStart",0) end
				end
			end) end)
		st.hook("nf_added", function() return Lighting.DescendantAdded:Connect(function(inst)
				if not (st.nf and st.nf.enabled) then return end
				disableEffect(inst)
			end) end)
		st.hook("nf_loop", function() return RunService.RenderStepped:Connect(function(dt)
				if not (st.nf and st.nf.enabled) then return end
				enforceNoFog()
				scanAccumulator = scanAccumulator + dt
				if scanAccumulator >= 0.5 then
					scanAccumulator = 0
					for _, inst in ipairs(Lighting:GetDescendants()) do
						disableEffect(inst)
					end
				end
			end) end)
	end
	nf.enabled = true
	enforceNoFog()
	nf.sticky = true
	nf.baselineFogEnd = st.safeGet(Lighting,"FogEnd") or nf.baselineFogEnd
	nf.baselineFogStart = st.safeGet(Lighting,"FogStart") or nf.baselineFogStart
	st.safeSet(Lighting,"FogEnd",786543)
	st.safeSet(Lighting,"FogStart",0)
	for _,v in ipairs(Lighting:GetDescendants()) do disableEffect(v) end
end)

cmd.add({"unloopnofog","unlnofog","unlnf","unloopnf","unnf"},{"unloopnofog (unlnofog,unlnf,unloopnf,unnf)","No more sight."},function()
	if not Lighting then return end
	local st = getgenv()._LState
	if not st or not st.nf then return end
	st.nf.sticky = false
	st.nf.enabled = false
	if not ((st.fb and st.fb.enabled) or (st.nb and st.nb.enabled)) then
		if st.safeSet then
			st.safeSet(Lighting,"FogEnd",st.nf.baselineFogEnd or 100000)
			if st.safeGet(Lighting,"FogStart")~=nil then st.safeSet(Lighting,"FogStart",st.nf.baselineFogStart or 0) end
		end
	end
	for inst,saved in pairs(st.nf.cache) do
		if inst and inst.Parent and saved then
			for p,v in pairs(saved) do st.safeSet(inst,p,v) end
		end
	end
end)

cmd.add({"nofog"},{"nofog","Removes all fog from the game"},function()
	if not Lighting then return end
	local st = NAmanage._ensureL()
	local function disableEffect(inst)
		if inst and inst:IsA("PostEffect") then st.safeSet(inst,"Enabled",false) end
		if inst and inst:IsA("Atmosphere") then
			if st.safeGet(inst,"Density")~=nil then st.safeSet(inst,"Density",0) end
			if st.safeGet(inst,"Haze")~=nil then st.safeSet(inst,"Haze",0) end
			if st.safeGet(inst,"Glare")~=nil then st.safeSet(inst,"Glare",0) end
		end
	end
	st.safeSet(Lighting,"FogEnd",786543)
	if st.safeGet(Lighting,"FogStart")~=nil then st.safeSet(Lighting,"FogStart",0) end
	for _,v in ipairs(Lighting:GetDescendants()) do disableEffect(v) end
end)

cmd.add({"nightmare","nm"},{"nightmare (nm)","Make it dark and spooky"},function()
	if not Lighting then return end
	local st = NAmanage._ensureL()
	if not st.disableNM then
		local prevCancel = st.cancelFor
		st.disableNM = function()
			NAlib.disconnect("nm_brightness")
			NAlib.disconnect("nm_clocktime")
			NAlib.disconnect("nm_fogstart")
			NAlib.disconnect("nm_fogend")
			NAlib.disconnect("nm_shadows")
			NAlib.disconnect("nm_ambient")
			NAlib.disconnect("nm_loop")
			if st.nm and st.nm.enabled then
				if st.restoreNM then st.restoreNM() end
				st.nm.enabled = false
			end
		end
		st.cancelFor = function(mode)
			if prevCancel then prevCancel(mode) end
			if mode=="nm" then
				st.disableTimeLoops()
				if st.disableNB then st.disableNB() end
				st.disableFB()
				st.disableNF(true)
				st.disableNM()
			end
		end
	end
	st.cancelFor("nm")
	st.nm = st.nm or {enabled=false,baseline={},target={Brightness=0.4,ClockTime=0,FogStart=0,FogEnd=28,GlobalShadows=true,Ambient=Color3.fromRGB(50,50,65)},effects={}}
	local function ensureEffect(className, key)
		local name = "NA_nm_"..key
		local inst = Lighting:FindFirstChild(name)
		if not inst then inst = InstanceNew(className); inst.Name = name; inst.Parent = Lighting end
		st.nm.effects[key] = inst
		return inst
	end
	if not st.captureNM then
		st.captureNM = function()
			st.nm.baseline = {
				Brightness = st.safeGet(Lighting,"Brightness") or 2,
				ClockTime = st.safeGet(Lighting,"ClockTime") or 12,
				FogStart = st.safeGet(Lighting,"FogStart"),
				FogEnd = st.safeGet(Lighting,"FogEnd") or 100000,
				GlobalShadows = st.safeGet(Lighting,"GlobalShadows"),
				Ambient = st.safeGet(Lighting,"Ambient") or Color3.fromRGB(128,128,128)
			}
		end
	end
	if not st.applyNM then
		st.applyNM = function()
			st.captureNM()
			st.safeSet(Lighting,"Brightness",st.nm.target.Brightness)
			st.safeSet(Lighting,"ClockTime",st.nm.target.ClockTime)
			if st.safeGet(Lighting,"FogStart")~=nil then st.safeSet(Lighting,"FogStart",st.nm.target.FogStart) end
			st.safeSet(Lighting,"FogEnd",st.nm.target.FogEnd)
			local gs = st.safeGet(Lighting,"GlobalShadows"); if gs~=nil then st.safeSet(Lighting,"GlobalShadows",st.nm.target.GlobalShadows) end
			st.safeSet(Lighting,"Ambient",st.nm.target.Ambient)
			local cc = ensureEffect("ColorCorrectionEffect","cc")
			st.safeSet(cc,"Enabled",true)
			st.safeSet(cc,"Brightness",-0.05)
			st.safeSet(cc,"Contrast",0.2)
			st.safeSet(cc,"Saturation",-0.25)
			st.safeSet(cc,"TintColor",Color3.fromRGB(180,170,255))
			local bloom = ensureEffect("BloomEffect","bloom")
			st.safeSet(bloom,"Enabled",true)
			st.safeSet(bloom,"Intensity",0.15)
			st.safeSet(bloom,"Size",20)
			local dof = ensureEffect("DepthOfFieldEffect","dof")
			st.safeSet(dof,"Enabled",true)
			st.safeSet(dof,"NearIntensity",0.15)
			st.safeSet(dof,"FarIntensity",0.6)
			st.safeSet(dof,"FocusDistance",25)
			st.safeSet(dof,"InFocusRadius",14)
			local blur = ensureEffect("BlurEffect","blur")
			st.safeSet(blur,"Enabled",true)
			st.safeSet(blur,"Size",1)
		end
	end
	if not st.restoreNM then
		st.restoreNM = function()
			st.safeSet(Lighting,"Brightness",st.nm.baseline.Brightness)
			st.safeSet(Lighting,"ClockTime",st.nm.baseline.ClockTime)
			if st.nm.baseline.FogStart~=nil then st.safeSet(Lighting,"FogStart",st.nm.baseline.FogStart) end
			st.safeSet(Lighting,"FogEnd",st.nm.baseline.FogEnd)
			if st.nm.baseline.GlobalShadows~=nil then st.safeSet(Lighting,"GlobalShadows",st.nm.baseline.GlobalShadows) end
			st.safeSet(Lighting,"Ambient",st.nm.baseline.Ambient)
			for _,inst in pairs(st.nm.effects) do if inst and inst.Parent then inst:Destroy() end end
			st.nm.effects = {}
		end
	end
	local function rehookNM()
		NAlib.disconnect("nm_brightness")
		NAlib.disconnect("nm_clocktime")
		NAlib.disconnect("nm_fogstart")
		NAlib.disconnect("nm_fogend")
		NAlib.disconnect("nm_shadows")
		NAlib.disconnect("nm_ambient")
		NAlib.disconnect("nm_loop")
		NAlib.connect("nm_brightness", Lighting:GetPropertyChangedSignal("Brightness"):Connect(function()
			if st.nm and st.nm.enabled and st.safeGet(Lighting,"Brightness") ~= st.nm.target.Brightness then st.safeSet(Lighting,"Brightness",st.nm.target.Brightness) end
		end))
		NAlib.connect("nm_clocktime", Lighting:GetPropertyChangedSignal("ClockTime"):Connect(function()
			if st.nm and st.nm.enabled and st.safeGet(Lighting,"ClockTime") ~= st.nm.target.ClockTime then st.safeSet(Lighting,"ClockTime",st.nm.target.ClockTime) end
		end))
		NAlib.connect("nm_fogstart", Lighting:GetPropertyChangedSignal("FogStart"):Connect(function()
			if st.nm and st.nm.enabled then local fs = st.safeGet(Lighting,"FogStart"); if fs==nil or fs ~= st.nm.target.FogStart then st.safeSet(Lighting,"FogStart",st.nm.target.FogStart) end end
		end))
		NAlib.connect("nm_fogend", Lighting:GetPropertyChangedSignal("FogEnd"):Connect(function()
			if st.nm and st.nm.enabled and st.safeGet(Lighting,"FogEnd") ~= st.nm.target.FogEnd then st.safeSet(Lighting,"FogEnd",st.nm.target.FogEnd) end
		end))
		NAlib.connect("nm_shadows", Lighting:GetPropertyChangedSignal("GlobalShadows"):Connect(function()
			if st.nm and st.nm.enabled then local gs = st.safeGet(Lighting,"GlobalShadows"); if gs==nil or gs ~= st.nm.target.GlobalShadows then st.safeSet(Lighting,"GlobalShadows",st.nm.target.GlobalShadows) end end
		end))
		NAlib.connect("nm_ambient", Lighting:GetPropertyChangedSignal("Ambient"):Connect(function()
			if st.nm and st.nm.enabled and st.safeGet(Lighting,"Ambient") ~= st.nm.target.Ambient then st.safeSet(Lighting,"Ambient",st.nm.target.Ambient) end
		end))
		NAlib.connect("nm_loop", RunService.RenderStepped:Connect(function()
			if not (st.nm and st.nm.enabled) then return end
			if st.safeGet(Lighting,"Brightness") ~= st.nm.target.Brightness then st.safeSet(Lighting,"Brightness",st.nm.target.Brightness) end
			if st.safeGet(Lighting,"ClockTime") ~= st.nm.target.ClockTime then st.safeSet(Lighting,"ClockTime",st.nm.target.ClockTime) end
			local fs = st.safeGet(Lighting,"FogStart"); if fs==nil or fs ~= st.nm.target.FogStart then st.safeSet(Lighting,"FogStart",st.nm.target.FogStart) end
			if st.safeGet(Lighting,"FogEnd") ~= st.nm.target.FogEnd then st.safeSet(Lighting,"FogEnd",st.nm.target.FogEnd) end
			local gs = st.safeGet(Lighting,"GlobalShadows"); if gs==nil or gs ~= st.nm.target.GlobalShadows then st.safeSet(Lighting,"GlobalShadows",st.nm.target.GlobalShadows) end
			if st.safeGet(Lighting,"Ambient") ~= st.nm.target.Ambient then st.safeSet(Lighting,"Ambient",st.nm.target.Ambient) end
			ensureEffect("ColorCorrectionEffect","cc")
			ensureEffect("BloomEffect","bloom")
			ensureEffect("DepthOfFieldEffect","dof")
			ensureEffect("BlurEffect","blur")
			local cc = st.nm.effects.cc
			if cc then
				if st.safeGet(cc,"Enabled") ~= true then st.safeSet(cc,"Enabled",true) end
				if st.safeGet(cc,"Brightness") ~= -0.05 then st.safeSet(cc,"Brightness",-0.05) end
				if st.safeGet(cc,"Contrast") ~= 0.2 then st.safeSet(cc,"Contrast",0.2) end
				if st.safeGet(cc,"Saturation") ~= -0.25 then st.safeSet(cc,"Saturation",-0.25) end
				if st.safeGet(cc,"TintColor") ~= Color3.fromRGB(180,170,255) then st.safeSet(cc,"TintColor",Color3.fromRGB(180,170,255)) end
			end
			local bloom = st.nm.effects.bloom
			if bloom then
				if st.safeGet(bloom,"Enabled") ~= true then st.safeSet(bloom,"Enabled",true) end
				if st.safeGet(bloom,"Intensity") ~= 0.15 then st.safeSet(bloom,"Intensity",0.15) end
				if st.safeGet(bloom,"Size") ~= 20 then st.safeSet(bloom,"Size",20) end
			end
			local dof = st.nm.effects.dof
			if dof then
				if st.safeGet(dof,"Enabled") ~= true then st.safeSet(dof,"Enabled",true) end
				if st.safeGet(dof,"NearIntensity") ~= 0.15 then st.safeSet(dof,"NearIntensity",0.15) end
				if st.safeGet(dof,"FarIntensity") ~= 0.6 then st.safeSet(dof,"FarIntensity",0.6) end
				if st.safeGet(dof,"FocusDistance") ~= 25 then st.safeSet(dof,"FocusDistance",25) end
				if st.safeGet(dof,"InFocusRadius") ~= 14 then st.safeSet(dof,"InFocusRadius",14) end
			end
			local blur = st.nm.effects.blur
			if blur then
				if st.safeGet(blur,"Enabled") ~= true then st.safeSet(blur,"Enabled",true) end
				if st.safeGet(blur,"Size") ~= 1 then st.safeSet(blur,"Size",1) end
			end
		end))
	end
	st.nm.enabled = true
	st.applyNM()
	rehookNM()
end)

cmd.add({"unnightmare","unnm"},{"unnightmare (unnm)","Disable nightmare mode"},function()
	if not Lighting then return end
	local st = NAmanage._ensureL()
	if st.disableNM then st.disableNM() end
end)

cmd.add({"brightness"},{"brightness","Changes the brightness lighting property"},function(...)
	Lighting.Brightness=(...)
end,true)

cmd.add({"globalshadows","gshadows"},{"globalshadows (gshadows)","Enables global shadows"},function()
	Lighting.GlobalShadows=true
end)

cmd.add({"unglobalshadows","nogshadows","ungshadows","noglobalshadows"},{"unglobalshadows (nogshadows,ungshadows,noglobalshadows)","Disables global shadows"},function()
	Lighting.GlobalShadows=false
end)

cmd.add({"gamma", "exposure"},{"gamma (exposure)","gamma vision (real)"},function(num)
	expose = tonumber(num) or 0
	Lighting.ExposureCompensation = expose
end,true)

cmd.add({"loopgamma", "loopexposure"},{"loopgamma (loopexposure)","loop gamma vision (mega real)"},function(num)
	expose = tonumber(num) or 0
	NAlib.disconnect("loopgamma")

	Lighting.ExposureCompensation = expose

	NAlib.connect("loopgamma", Lighting:GetPropertyChangedSignal("ExposureCompensation"):Connect(function()
		if Lighting.ExposureCompensation ~= expose then
			Lighting.ExposureCompensation = expose
		end
	end))
end, true)

cmd.add({"unloopgamma", "unlgamma", "unloopexposure", "unlexposure"},{"unloopgamma (unlgamma, unloopexposure, unlexposure)","stop gamma vision (real)"},function()
	NAlib.disconnect("loopgamma")
end)

--[[cmd.add({"iy"},{"iy {command}","Executes infinite yield scripts"},function(...)
	if IYLOADED==false then
		function copytable(tbl) local copy={} for i,v in pairs(tbl) do copy[i]=v end return copy end
		local sandbox_env=copytable(getfenv())
		setmetatable(sandbox_env,{
			__index=function(self,i)
				if rawget(sandbox_env,i) then
					return rawget(sandbox_env,i)
				elseif getfenv()[i] then
					return getfenv()[i]
				end
			end
		})
		sandbox_env.game=nil
		iy,_=game:HttpGet("https://raw.githubusercontent.com/EdgeIY/infiniteyield/master/source"):gsub("local Main","Main"):gsub("Players.LocalPlayer.Chatted","Funny=Players.LocalPlayer.Chatted"):gsub("local lastMessage","notify=getgenv().notify\nlocal lastMessage")
		setfenv(loadstring(iy),sandbox_env)()
		iy_cmds_table=sandbox_env.CMDs
		iy_gui=sandbox_env.Main
		iy_chathandler=sandbox_env.Funny
		execCmd=sandbox_env.execCmd
		iy_gui:Destroy()
		NACaller(function()
			iy_chathandler:Disconnect()
		end)
		IYLOADED=true
	end
	execCmd((...))
end,true)]]

cmd.add({"firstp","1stp","firstperson","fp"},{"firstperson (1stp,firstp,fp)","Makes you go in first person mode"},function()
	Player.CameraMode="LockFirstPerson"
end)

cmd.add({"thirdp","3rdp","thirdperson"},{"thirdperson (3rdp,thirdp)","Makes you go in third person mode"},function()
	Player.CameraMaxZoomDistance=math.huge
	Player.CameraMode="Classic"
end)

cmd.add({"maxzoom"},{"maxzoom <amount>","Set your maximum camera distance"},function(num)
	local num=tonumber(num) or 128
	Players.LocalPlayer.CameraMaxZoomDistance=num
end,true)

cmd.add({"minzoom"},{"minzoom <amount>","Set your minimum camera distance"},function(...)
	local args={...}
	local num=args[1]

	if num==nil then
		num=0
	else
		num=tonumber(num)
	end
	Players.LocalPlayer.CameraMinZoomDistance=num
end,true)

cmd.add({"cameranoclip","camnoclip","cnoclip","nccam"},{"cameranoclip (camnoclip,cnoclip,nccam)","Makes your camera clip through walls"}, function()
	local player = Players.LocalPlayer
	local camera = workspace.CurrentCamera

	local SetConstant = (debug and debug.setconstant) or setconstant
	local GetConstants = (debug and debug.getconstants) or getconstants
	local HasAdvancedAccess = (getgc and SetConstant and GetConstants)

	if HasAdvancedAccess then
		local PlayerModule = player:FindFirstChild("PlayerScripts") and player.PlayerScripts:FindFirstChild("PlayerModule")
		local Popper = PlayerModule and PlayerModule:FindFirstChild("CameraModule") and PlayerModule.CameraModule:FindFirstChild("ZoomController") and PlayerModule.CameraModule.ZoomController:FindFirstChild("Popper")

		if Popper then
			for i, v in pairs(getgc()) do
				if type(v) == "function" and getfenv(v).script == Popper then
					for i2, v2 in pairs(GetConstants(v)) do
						if tonumber(v2) == 0.25 then
							SetConstant(v, i2, 0)
						elseif tonumber(v2) == 0 then
							SetConstant(v, i2, 0.25)
						end
					end
				end
			end
		end
	else
		--[[if _G._noclipConnection then _G._noclipConnection:Disconnect() end
		if _G._noclipInput then _G._noclipInput:Disconnect() end
		if _G._noclipZoom then _G._noclipZoom:Disconnect() end
		if _G._noclipBegin then _G._noclipBegin:Disconnect() end
		if _G._noclipEnd then _G._noclipEnd:Disconnect() end

		local rootPart = (player.Character or player.CharacterAdded:Wait()):WaitForChild("HumanoidRootPart")
		local zoom = (camera.CFrame.Position - rootPart.Position).Magnitude
		local minZoom = player.CameraMinZoomDistance
		local maxZoom = player.CameraMaxZoomDistance
		local rotationX, rotationY = 0, 0
		local sensitivity = 0.2
		local rotating = false

		camera.CameraType = Enum.CameraType.Scriptable
		UserInputService.MouseBehavior = Enum.MouseBehavior.Default

		_G._noclipBegin = UserInputService.InputBegan:Connect(function(input)
			if input.UserInputType == Enum.UserInputType.MouseButton2 then
				rotating = true
				UserInputService.MouseBehavior = Enum.MouseBehavior.LockCurrentPosition
			end
		end)

		_G._noclipEnd = UserInputService.InputEnded:Connect(function(input)
			if input.UserInputType == Enum.UserInputType.MouseButton2 then
				rotating = false
				UserInputService.MouseBehavior = Enum.MouseBehavior.Default
			end
		end)

		_G._noclipInput = UserInputService.InputChanged:Connect(function(input)
			if input.UserInputType == Enum.UserInputType.MouseMovement and rotating then
				rotationX=rotationX - input.Delta.X * sensitivity
				rotationY = math.clamp(rotationY + input.Delta.Y * sensitivity, -80, 80)
			end
		end)

		_G._noclipZoom = UserInputService.InputChanged:Connect(function(input)
			if input.UserInputType == Enum.UserInputType.MouseWheel then
				zoom = math.clamp(zoom - input.Position.Z * 2, minZoom, maxZoom)
			end
		end)

		_G._noclipConnection = RunService.RenderStepped:Connect(function()
			local targetPos = rootPart.Position + Vector3.new(0, 2, 0)
			local rot = CFrame.Angles(0, math.rad(rotationX), 0) * CFrame.Angles(math.rad(rotationY), 0, 0)
			local camPos = targetPos + rot:VectorToWorldSpace(Vector3.new(0, 0, -zoom))
			camera.CFrame = CFrame.new(camPos, targetPos)
		end)]]
		if NAlib.isConnected("ilovesolara") then NAlib.disconnect("ilovesolara") player.DevCameraOcclusionMode=Enum.DevCameraOcclusionMode.Zoom return end
		NAlib.connect("ilovesolara",player:GetPropertyChangedSignal("DevCameraOcclusionMode"):Connect(function()
			if player.DevCameraOcclusionMode~=Enum.DevCameraOcclusionMode.Invisicam then
				player.DevCameraOcclusionMode=Enum.DevCameraOcclusionMode.Invisicam
			end
		end))
		player.DevCameraOcclusionMode=Enum.DevCameraOcclusionMode.Invisicam
	end
end)

cmd.add({"uncameranoclip","uncamnoclip","uncnoclip","unnccam"},{"uncameranoclip (uncamnoclip,uncnoclip,unnccam)","Restores normal camera"}, function()
	local player = Players.LocalPlayer
	local camera = workspace.CurrentCamera

	local SetConstant = (debug and debug.setconstant) or setconstant
	local GetConstants = (debug and debug.getconstants) or getconstants
	local HasAdvancedAccess = (getgc and SetConstant and GetConstants)

	if HasAdvancedAccess then
		local PlayerModule = player:FindFirstChild("PlayerScripts") and player.PlayerScripts:FindFirstChild("PlayerModule")
		local Popper = PlayerModule and PlayerModule:FindFirstChild("CameraModule") and PlayerModule.CameraModule:FindFirstChild("ZoomController") and PlayerModule.CameraModule.ZoomController:FindFirstChild("Popper")

		if Popper then
			for i, v in pairs(getgc()) do
				if type(v) == "function" and getfenv(v).script == Popper then
					for i2, v2 in pairs(GetConstants(v)) do
						if tonumber(v2) == 0.25 then
							SetConstant(v, i2, 0)
						elseif tonumber(v2) == 0 then
							SetConstant(v, i2, 0.25)
						end
					end
				end
			end
		end
	else
		--[[if _G._noclipConnection then _G._noclipConnection:Disconnect() _G._noclipConnection = nil end
		if _G._noclipInput then _G._noclipInput:Disconnect() _G._noclipInput = nil end
		if _G._noclipZoom then _G._noclipZoom:Disconnect() _G._noclipZoom = nil end
		if _G._noclipBegin then _G._noclipBegin:Disconnect() _G._noclipBegin = nil end
		if _G._noclipEnd then _G._noclipEnd:Disconnect() _G._noclipEnd = nil end

		UserInputService.MouseBehavior = Enum.MouseBehavior.Default
		camera.CameraType = Enum.CameraType.Custom

		local scripts = player:FindFirstChild("PlayerScripts")
		if scripts then
			local existingModule = scripts:FindFirstChild("PlayerModule")
			if existingModule then existingModule:Destroy() end

			local starterModule = SafeGetService("StarterPlayer"):FindFirstChild("StarterPlayerScripts"):FindFirstChild("PlayerModule")
			if starterModule then
				local newModule = starterModule:Clone()
				newModule.Parent = scripts
			end
		end]]
		NAlib.disconnect("ilovesolara")
		LocalPlayer.DevCameraOcclusionMode = Enum.DevCameraOcclusionMode.Zoom
	end
end)

cmd.add({"oganims"},{"oganims","Old animations from 2007"},function()
	Wait();
	DebugNotif("OG animations set")
	loadstring(game:HttpGet(('https://pastebin.com/raw/6GNkQUu6'),true))()
end)

cmd.add({"fakechat"},{"fakechat","Fake a chat gui"},function()
	loadstring(game:HttpGet("https://raw.githubusercontent.com/ltseverydayyou/Nameless-Admin/main/fake%20chatte"))()
end)

cmd.add({"fpscap"},{"fpscap <number>","Sets the fps cap to whatever you want"},function(arg)
	local cap = tonumber(arg)
	if cap then
		setfpscap(math.clamp(cap, 1, 999))
	else
		DoNotif("invalid input",1.3)
	end
end,true)

cmd.add({"toolinvisible", "tinvis"}, {"toolinvisible (tinvis)", "Be invisible while still being able to use tools"}, function()
	local offset = 1100
	invisible = false
	local grips = {}
	local heldTool
	local gripChanged
	local handle
	local weld
	HH = getHum().HipHeight

	function setDisplayDistance(distance)
		for _, player in pairs(Players:GetPlayers()) do
			if getPlrChar(player) and getPlrHum(player) then
				getPlrHum(player).NameDisplayDistance = distance
				getPlrHum(player).HealthDisplayDistance = distance
			end
		end
	end

	local tool = InstanceNew("Tool", Players.LocalPlayer.Backpack)
	tool.Name = "Turn Invisible"
	tool.RequiresHandle = false
	tool.CanBeDropped = false

	tool.Equipped:Connect(function()
		Wait()
		if not invisible then
			invisible = true
			tool.Name = "Visible Enabled"

			if handle then
				handle:Destroy()
			end
			if weld then
				weld:Destroy()
			end

			handle = InstanceNew("Part", workspace)
			handle.Name = "Handle"
			handle.Transparency = 1
			handle.CanCollide = false
			handle.Size = Vector3.new(2, 1, 1)

			weld = InstanceNew("Weld", handle)
			weld.Part0 = handle
			weld.Part1 = getRoot(getChar())
			weld.C0 = CFrame.new(0, offset - 1.5, 0)

			setDisplayDistance(offset + 100)
			workspace.CurrentCamera.CameraSubject = handle
			getRoot(getChar()).CFrame = getRoot(getChar()).CFrame * CFrame.new(0, offset, 0)
			getHum().HipHeight = offset
			getHum():ChangeState(11)

			for _, child in pairs(Players.LocalPlayer.Backpack:GetChildren()) do
				if child:IsA("Tool") and child ~= tool then
					grips[child] = child.Grip
				end
			end
			if getHum() then
				getHum():SetStateEnabled("Seated", false)
				getHum().Sit = true
			end
		else
			invisible = false
			tool.Name = "Visible Disabled"

			if handle then
				handle:Destroy()
			end
			if weld then
				weld:Destroy()
			end

			for _, child in pairs(getChar():GetChildren()) do
				if child:IsA("Tool") then
					child.Parent = Players.LocalPlayer.Backpack
				end
			end

			for tool, grip in pairs(grips) do
				if tool then
					tool.Grip = grip
				end
			end

			heldTool = nil
			setDisplayDistance(100)
			workspace.CurrentCamera.CameraSubject = getHum()
			getRoot(getChar()).CFrame = getRoot(getChar()).CFrame * CFrame.new(0, -offset, 0)
			getHum().HipHeight = HH

			if getHum() then
				getHum():SetStateEnabled("Seated", true)
				getHum().Sit = false
			end
		end

		tool.Parent = Players.LocalPlayer.Backpack
	end)

	getChar().ChildAdded:Connect(function(child)
		Wait()
		if invisible and child:IsA("Tool") and child ~= heldTool and child ~= tool then
			heldTool = child
			local lastGrip = heldTool.Grip

			if not grips[heldTool] then
				grips[heldTool] = lastGrip
			end

			for _, track in pairs(getHum():GetPlayingAnimationTracks()) do
				track:Stop()
			end

			getChar().Animate.Disabled = true
			heldTool.Grip = heldTool.Grip * (CFrame.new(0, offset - 1.5, 1.5) * CFrame.Angles(math.rad(-90), 0, 0))
			heldTool.Parent = Players.LocalPlayer.Backpack
			heldTool.Parent = getChar()

			if gripChanged then
				gripChanged:Disconnect()
			end

			gripChanged = heldTool:GetPropertyChangedSignal("Grip"):Connect(function()
				Wait()
				if not invisible then
					gripChanged:Disconnect()
				end

				if heldTool.Grip ~= lastGrip then
					lastGrip = heldTool.Grip * (CFrame.new(0, offset - 1.5, 1.5) * CFrame.Angles(math.rad(-90), 0, 0))
					heldTool.Grip = lastGrip
					heldTool.Parent = Players.LocalPlayer.Backpack
					heldTool.Parent = getChar()
				end
			end)
		end
	end)
end)

invisBtnlol = nil
invisKeybindConnection = nil
IsInvis = false
InvisibleCharacter = nil
OriginalPosition = nil
InvisBindLol = Enum.KeyCode.E

cmd.add({"invisible", "invis"},{"invisible (invis)", "Sets invisibility to scare people or something"}, function()
	if invisKeybindConnection then
		DebugNotif("Invisibility is already loaded!")
		return
	end

	local Character = Players.LocalPlayer.Character or Players.LocalPlayer.CharacterAdded:Wait()
	Character.Archivable = true
	OriginalPosition = getRoot(Character).CFrame

	local function TurnVisible()
		if not IsInvis then return end
		IsInvis = false
		OriginalPosition = getRoot(InvisibleCharacter).CFrame
		if InvisibleCharacter then
			InvisibleCharacter:Destroy()
			InvisibleCharacter = nil
		end
		Players.LocalPlayer.Character = Character
		Character.Parent = workspace
		RunService.Heartbeat:Wait()
		local root = getRoot(Character)
		if root then
			root.CFrame = OriginalPosition
		end
		DebugNotif("Invisibility turned off.")
		StarterGui:SetCore("ResetButtonCallback", true)
	end

	local function ToggleInvisibility()
		if not IsInvis then
			IsInvis = true
			InvisibleCharacter = Character:Clone()
			InvisibleCharacter.Parent = workspace
			for _, v in ipairs(InvisibleCharacter:GetDescendants()) do
				if v:IsA("BasePart") then
					v.Transparency = v.Name:lower() == "humanoidrootpart" and 1 or 0.5
				end
			end
			local root = getRoot(Character)
			if root then
				OriginalPosition = root.CFrame
				root.CFrame = CFrame.new(0, math.pi * 1000000, 0)
			end
			Wait(0.1)
			Character.Parent = ReplicatedStorage
			local invisRoot = getRoot(InvisibleCharacter)
			if invisRoot then
				invisRoot.CFrame = OriginalPosition
			end
			Players.LocalPlayer.Character = InvisibleCharacter
			workspace.CurrentCamera.CameraSubject = getPlrHum(InvisibleCharacter)
			DebugNotif("You are now invisible.")
			StarterGui:SetCore("ResetButtonCallback", false)
		else
			TurnVisible()
		end
	end

	if invisKeybindConnection then
		invisKeybindConnection:Disconnect()
		invisKeybindConnection = nil
	end

	invisKeybindConnection = UserInputService.InputBegan:Connect(function(input, gameProcessed)
		if input.UserInputType == Enum.UserInputType.Keyboard and input.KeyCode == InvisBindLol and not gameProcessed then
			ToggleInvisibility()
		end
	end)

	local humanoid = getPlrHum(Character)
	if humanoid then
		humanoid.Died:Connect(function()
			cmd.run({"vis"})
		end)
	end

	if IsOnMobile then
		if invisBtnlol then invisBtnlol:Destroy() invisBtnlol = nil end
		invisBtnlol = InstanceNew("ScreenGui")
		local TextButton = InstanceNew("TextButton")
		local UICorner = InstanceNew("UICorner")
		local UIAspectRatioConstraint = InstanceNew("UIAspectRatioConstraint")
		NaProtectUI(invisBtnlol)
		invisBtnlol.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
		TextButton.Parent = invisBtnlol
		TextButton.BackgroundColor3 = Color3.fromRGB(12, 4, 20)
		TextButton.BackgroundTransparency = 0.14
		TextButton.Position = UDim2.new(0.9, 0, 0.8, 0)
		TextButton.Size = UDim2.new(0.1, 0, 0.1, 0)
		TextButton.Font = Enum.Font.SourceSansBold
		TextButton.Text = "Invisible"
		TextButton.TextColor3 = Color3.new(1, 1, 1)
		TextButton.TextSize = 15
		TextButton.TextWrapped = true
		TextButton.TextScaled = true
		TextButton.Active = true
		UICorner.Parent = TextButton
		UIAspectRatioConstraint.Parent = TextButton
		UIAspectRatioConstraint.AspectRatio = 1
		NAgui.draggerV2(TextButton)
		MouseButtonFix(TextButton, function()
			ToggleInvisibility()
			TextButton.Text = IsInvis and "Visible" or "Invisible"
		end)
	end

	Wait()
	DebugNotif("Invisible loaded. Press "..InvisBindLol.Name.." or use the mobile button",2.5)
end)

cmd.add({"visible", "vis"}, {"visible", "turn visible"}, function()
	if invisKeybindConnection then
		invisKeybindConnection:Disconnect()
		invisKeybindConnection = nil
	end
	if invisBtnlol then
		invisBtnlol:Destroy()
		invisBtnlol = nil
	end
	local Character = Players.LocalPlayer.Character or Players.LocalPlayer.CharacterAdded:Wait()
	if IsInvis then
		IsInvis = false
		if InvisibleCharacter then InvisibleCharacter:Destroy() InvisibleCharacter = nil end
		Players.LocalPlayer.Character = Character
		Character.Parent = workspace
	end
	DebugNotif("Invisibility Disabled",2)
end)

cmd.add({"invisbind", "invisiblebind","bindinvis"}, {"invisbind (invisiblebind, bindinvis)", "set a custom keybind for the 'Invisible' command"}, function(...)
	local args = {...}
	if args[1] then
		InvisBindLol = Enum.KeyCode[args[1]] or Enum.KeyCode[args[1]:upper()]
		if InvisBindLol then
			DebugNotif("Invis bind set to "..InvisBindLol.Name)
		else
			DebugNotif("Invalid keybind, defaulting to E")
			InvisBindLol = Enum.KeyCode.E
		end
	else
		DebugNotif("No keybind provided")
	end
end,true)

cmd.add({"fireremotes", "fremotes", "frem"}, {"fireremotes (fremotes, frem)", "Fires every remote with arguments"}, function()
	local remoteCount = 0
	local failedCount = 0

	for _, obj in ipairs(game:GetDescendants()) do
		if not obj:IsDescendantOf(COREGUI) and (obj:IsA("RemoteEvent") or obj:IsA("RemoteFunction")) then
			SpawnCall(function()
				local ok
				if obj:IsA("RemoteEvent") then
					ok = pcall(function() obj:FireServer() end)
				elseif obj:IsA("RemoteFunction") then
					ok = pcall(function() obj:InvokeServer() end)
				end

				if ok then
					remoteCount=remoteCount + 1
				else
					failedCount=failedCount + 1
				end
			end)
		end
	end

	Delay(2, function()
		DebugNotif("Fired "..remoteCount.." remotes\nFailed: "..failedCount.." remotes")
	end)
end)

cmd.add({"keepna"}, {"keepna", "keep executing "..adminName.." every time you teleport"}, function()
	NAQoTEnabled = true
	NAmanage.NASettingsSet("queueOnTeleport", true)
	DoNotif(adminName.." will now auto-load after teleport (QueueOnTeleport enabled)")
end)

cmd.add({"unkeepna"}, {"unkeepna", "Stop executing "..adminName.." every time you teleport"}, function()
	NAQoTEnabled = false
	NAmanage.NASettingsSet("queueOnTeleport", false)
	DoNotif("QueueOnTeleport has been disabled. "..adminName.." will no longer auto-run after teleport")
end)

do
	local FOVhandler = {mem={o=nil,r=nil,u=nil,base={}}, loop=false, cam=nil}

	originalIO.FOVstep=function()
		local parent = NAmanage.guiCHECKINGAHHHHH(); if not parent then return end
		FOVhandler.mem.o = (FOVhandler.mem.o and FOVhandler.mem.o.Parent) and FOVhandler.mem.o or InstanceNew("NumberValue", parent)
		FOVhandler.mem.r = (FOVhandler.mem.r and FOVhandler.mem.r.Parent) and FOVhandler.mem.r or InstanceNew("Vector3Value", parent)
		FOVhandler.mem.u = (FOVhandler.mem.u and FOVhandler.mem.u.Parent) and FOVhandler.mem.u or InstanceNew("Vector3Value", parent)

		local o = FOVhandler.mem.o.Value or 0
		local sum = 0
		for i=1,#FOVhandler.mem.base do
			local v = FOVhandler.mem.base[i]
			if not v or not v.Parent then v = InstanceNew("NumberValue", parent); FOVhandler.mem.base[i] = v end
			sum += (v.Value or 0)
		end
		local target = (o ~= 0 and o) or sum
		local cam = workspace.CurrentCamera; if not cam then return end

		if cam ~= FOVhandler.cam then
			FOVhandler.cam = cam
			NAlib.disconnect("fov_refresh")
			NAlib.connect("fov_refresh", cam:GetPropertyChangedSignal("FieldOfView"):Connect(function()
				if not FOVhandler.loop then return end
				local t = (FOVhandler.mem.o and FOVhandler.mem.o.Value) or 0
				if t > 0 then
					local vis = math.clamp(t, 25, 120)
					if cam.FieldOfView ~= vis then cam.FieldOfView = vis end
				end
			end))
		end

		if FOVhandler.loop and target > 0 then
			local vis = math.clamp(target, 25, 120)
			if cam.FieldOfView ~= vis then cam.FieldOfView = vis end
		end

		if target <= 120 or target == 0 then
			if FOVhandler.mem.r.Value.Magnitude > 0 then FOVhandler.mem.r.Value = Vector3.new() end
			if FOVhandler.mem.u.Value.Magnitude > 0 then FOVhandler.mem.u.Value = Vector3.new() end
			return
		end

		local f = math.clamp((target - 120) * 0.005, 0, 0.9)
		local v = Vector3.new(f,f,f)
		if FOVhandler.mem.r.Value ~= v then FOVhandler.mem.r.Value = v end
		if FOVhandler.mem.u.Value ~= v then FOVhandler.mem.u.Value = v end

		local c = cam.CFrame
		local p = c.Position
		local r = c.RightVector
		local u = c.UpVector
		local l = -c.LookVector
		local rs = Vector3.new(1,1,1) - FOVhandler.mem.r.Value
		local us = Vector3.new(1,1,1) - FOVhandler.mem.u.Value
		cam.CFrame = CFrame.fromMatrix(p, Vector3.new(r.X*rs.X, r.Y*rs.Y, r.Z*rs.Z), Vector3.new(u.X*us.X, u.Y*us.Y, u.Z*us.Z), l)
	end

	pcall(function() RunService:UnbindFromRenderStep("FOV_SYS") end)
	RunService:BindToRenderStep("FOV_SYS", Enum.RenderPriority.Camera.Value+1, originalIO.FOVstep)

	NAlib.disconnect("fov_watch_cc")
	NAlib.connect("fov_watch_cc", workspace:GetPropertyChangedSignal("CurrentCamera"):Connect(function()
		FOVhandler.cam = workspace.CurrentCamera
	end))

	cmd.add({"fov"}, {"fov <number>", "Sets your FOV to a custom value (1–300)"}, function(num)
		local t = math.clamp(tonumber(num) or 70, 1, 300)
		local parent = NAmanage.guiCHECKINGAHHHHH(); if not parent then return end
		if FOVhandler.loop then
			FOVhandler.mem.o = (FOVhandler.mem.o and FOVhandler.mem.o.Parent) and FOVhandler.mem.o or InstanceNew("NumberValue", parent)
			FOVhandler.mem.o.Value = t
		else
			FOVhandler.mem.base[1] = (FOVhandler.mem.base[1] and FOVhandler.mem.base[1].Parent) and FOVhandler.mem.base[1] or InstanceNew("NumberValue", parent)
			FOVhandler.mem.base[1].Value = t
		end
		local cam = workspace.CurrentCamera
		if cam then
			local vis = math.clamp(t, 25, 120)
			TweenService:Create(cam, TweenInfo.new(0.2, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut), {FieldOfView = vis}):Play()
		end
	end, true)

	cmd.add({"loopfov","lfov"}, {"loopfov <number> (lfov)", "Locks your FOV target (1–300)"}, function(num)
		local t = math.clamp(tonumber(num) or 70, 1, 300)
		local parent = NAmanage.guiCHECKINGAHHHHH(); if not parent then return end
		FOVhandler.mem.o = (FOVhandler.mem.o and FOVhandler.mem.o.Parent) and FOVhandler.mem.o or InstanceNew("NumberValue", parent)
		FOVhandler.mem.o.Value = t
		FOVhandler.loop = true
		NAlib.disconnect("fov_loop_hold")
		NAlib.connect("fov_loop_hold", RunService.RenderStepped:Connect(function()
			local p = NAmanage.guiCHECKINGAHHHHH()
			if not FOVhandler.mem.o or not FOVhandler.mem.o.Parent then FOVhandler.mem.o = InstanceNew("NumberValue", p) end
		end))
		local cam = workspace.CurrentCamera
		if cam then
			local vis = math.clamp(t, 25, 120)
			if cam.FieldOfView ~= vis then cam.FieldOfView = vis end
		end
	end, true)

	cmd.add({"unloopfov","unlfov"}, {"unloopfov (unlfov)", "Stops FOV loop"}, function()
		FOVhandler.loop = false
		NAlib.disconnect("fov_loop_hold")
		NAlib.disconnect("fov_refresh")
		if FOVhandler.mem.o and FOVhandler.mem.o.Parent then FOVhandler.mem.o.Value = 0 end
		if FOVhandler.mem.r and FOVhandler.mem.r.Parent then FOVhandler.mem.r.Value = Vector3.new() end
		if FOVhandler.mem.u and FOVhandler.mem.u.Parent then FOVhandler.mem.u.Value = Vector3.new() end
	end)
end

cmd.add({"homebrew"},{"homebrew","Executes homebrew admin"},function()
	getgenv().CustomUI=false
	loadstring(game:HttpGet(('https://raw.githubusercontent.com/mgamingpro/HomebrewAdmin/master/Main'),true))()
end)

cmd.add({"fatesadmin"},{"fatesadmin","Executes fates admin"},function()
	loadstring(game:HttpGet("https://raw.githubusercontent.com/fatesc/fates-admin/main/main.lua"))();
end)

storedTools = {}

cmd.add({"savetools", "stools"}, {"savetools (stools)", "Saves your tools to memory"}, function()
	storedTools = {}

	for _, tool in pairs(LocalPlayer.Backpack:GetChildren()) do
		if tool:IsA("Tool") then
			local clonedTool = tool:Clone()
			Insert(storedTools, clonedTool)
		end
	end

	for _, tool in pairs(LocalPlayer.Character:GetChildren()) do
		if tool:IsA("Tool") then
			local clonedTool = tool:Clone()
			Insert(storedTools, clonedTool)
		end
	end

	DebugNotif("Tools saved: "..#storedTools,2)
end)

cmd.add({"loadtools", "ltools"}, {"loadtools (ltools)", "Restores your saved tools to your backpack"}, function()
	for _, tool in pairs(storedTools) do
		if not LocalPlayer.Backpack:FindFirstChild(tool.Name) then
			local clonedTool = tool:Clone()
			clonedTool.Parent = LocalPlayer.Backpack
		end
	end

	DebugNotif("Tools loaded: "..#storedTools,2)
end)

cmd.add({"preventtools", "noequip", "antiequip"}, {"preventtools (noequip,antiequip)", "Prevents any item from being equipped"}, function()
	local p = Players.LocalPlayer
	local c = p.Character

	NAlib.disconnect("noequip_char")
	NAlib.disconnect("noequip_hum")

	local h = getHum()
	if not h then return end

	h:UnequipTools()

	local function onTool(t)
		if t:IsA("Tool") then
			t.Enabled = false
			Defer(function()
				h:UnequipTools()
				DebugNotif("Tool "..t.Name.." blocked", 2)
			end)
		end
	end

	NAlib.connect("noequip_char", c.ChildAdded:Connect(onTool))
	NAlib.connect("noequip_hum", h.ChildAdded:Connect(onTool))

	DebugNotif("Tool prevention on", 3)
end)

cmd.add({"unpreventtools", "unnoequip", "unantiequip"}, {"unpreventtools (unnoequip,unantiequip)", "Self-explanatory"}, function()
	NAlib.disconnect("noequip_char")
	NAlib.disconnect("noequip_hum")
	DebugNotif("Tool prevention off", 2)
end)

cmd.add({"ws", "speed", "walkspeed"}, {"walkspeed <number> (speed,ws)", "Sets your WalkSpeed"}, function(...)
	local a = {...}
	local s = tonumber(a[2] or a[1]) or 16
	local h = getHum()
	if s and h then
		h.WalkSpeed = s
	end
end, true)

cmd.add({"jp", "jumppower"}, {"jumppower <number> (jp)", "Sets your JumpPower"}, function(...)
	local a = {...}
	local j = tonumber(a[1]) or 50
	local h = getHum()
	if j and h then
		if h.UseJumpPower then
			h.JumpPower = j
		else
			h.JumpHeight = j
		end
	end
end, true)

NAmanage.isCoreFunc=function(fn)
	local ok, env = pcall(getfenv, fn)
	if not ok or type(env) ~= "table" then return false end
	local sc = rawget(env, "script")
	return typeof(sc) == "Instance" and sc:IsDescendantOf(COREGUI)
end

NAmanage.BlockRemote = function(remote, mode)
	mode = mode or "fakeok"
	if not Discover(NAStuff.BlockedRemotes, remote) then
		Insert(NAStuff.BlockedRemotes, remote)
	end
	NAStuff.BlockedRemoteModes[remote] = mode
	if remote:IsA("RemoteEvent") then
		NAStuff.BlockedSignals[remote.OnClientEvent] = true
		if typeof(getconnections) == "function" then
			local saved = {funcs = {}}
			for _, c in ipairs(getconnections(remote.OnClientEvent)) do
				local ok, f = pcall(function() return c.Function end)
				if ok and type(f) == "function" and not NAmanage.isCoreFunc(f) then
					Insert(saved.funcs, f)
					pcall(function() c:Disconnect() end)
				end
			end
			NAStuff.BlockedEventSaved[remote] = saved
		end
	elseif remote:IsA("RemoteFunction") then
		if NAStuff.BlockedInvokeSaved[remote] == nil then
			local ok, current = pcall(function() return remote.OnClientInvoke end)
			NAStuff.BlockedInvokeSaved[remote] = ok and type(current)=="function" and current or NAStuff.NIL_SENTINEL
		end
		remote.OnClientInvoke = function(...)
			local m = NAStuff.BlockedRemoteModes[remote] or "fakeok"
			if m == "error" then
				error("Blocked remote: "..remote:GetFullName().." [OnClientInvoke]", 0)
			else
				local ret = NAStuff.BlockedRemoteReturns[remote]
				if ret == nil then ret = NAStuff.RemoteFakeReturn end
				return ret
			end
		end
	end
	DebugNotif(("Blocked: %s (%s)"):format(remote:GetFullName(), NAStuff.BlockedRemoteModes[remote]), 3, "Remote Block")
end

NAmanage.UnblockRemote = function(remote)
	local idx = Discover(NAStuff.BlockedRemotes, remote)
	if idx then
		local name = NAStuff.BlockedRemotes[idx]:GetFullName()
		table.remove(NAStuff.BlockedRemotes, idx)
		NAStuff.BlockedRemoteModes[remote] = nil
		NAStuff.BlockedRemoteReturns[remote] = nil
		if remote:IsA("RemoteEvent") then
			NAStuff.BlockedSignals[remote.OnClientEvent] = nil
			local saved = NAStuff.BlockedEventSaved[remote]
			if saved and saved.funcs then
				for _, f in ipairs(saved.funcs) do
					pcall(function() remote.OnClientEvent:Connect(f) end)
				end
			end
			NAStuff.BlockedEventSaved[remote] = nil
		elseif remote:IsA("RemoteFunction") then
			local saved = NAStuff.BlockedInvokeSaved[remote]
			if saved == NAStuff.NIL_SENTINEL then
				remote.OnClientInvoke = nil
			elseif type(saved) == "function" then
				remote.OnClientInvoke = saved
			else
				remote.OnClientInvoke = nil
			end
			NAStuff.BlockedInvokeSaved[remote] = nil
		end
		DebugNotif(("Unblocked: %s"):format(name), 3, "Remote Block")
	end
end

NAmanage.EnsureHook = function()
	if getgenv().NA_BlockHooked then return end
	local mt = getrawmetatable(game)
	local oldNamecall = mt.__namecall
	setreadonly(mt, false)
	mt.__namecall = newcclosure(function(self, ...)
		local method = getnamecallmethod()
		if (method == "FireServer" or method == "InvokeServer") and Discover(NAStuff.BlockedRemotes, self) then
			local m = NAStuff.BlockedRemoteModes[self] or "fakeok"
			if NAStuff.nuhuhNotifs then Defer(DebugNotif, ("Blocked -> %s (%s) [%s]"):format(self:GetFullName(), method, m == "error" and "ERROR" or "FAKEOK"), 2, "Remote Block") end
			if m == "error" then error("Blocked remote: "..self:GetFullName().." ["..method.."]", 0) end
			if method == "InvokeServer" then
				local ret = NAStuff.BlockedRemoteReturns[self]
				if ret == nil then ret = NAStuff.RemoteFakeReturn end
				return ret
			end
			return
		end
		if NAStuff.BlockedSignals[self] then
			if method == "Connect" or method == "Once" then
				local cb = select(1, ...)
				if type(cb) == "function" and NAmanage.isCoreFunc(cb) then
					return oldNamecall(self, ...)
				end
				if NAStuff.nuhuhNotifs then Defer(DebugNotif, "Blocked OnClientEvent:"..method.."()", 2, "Remote Block") end
				local conn = oldNamecall(self, function() end)
				pcall(function() conn:Disconnect() end)
				return conn
			elseif method == "Wait" then
				local mode = "fakeok"
				for r,_ in pairs(NAStuff.BlockedRemotes) do
					if typeof(r)=="Instance" and r:IsA("RemoteEvent") and self==r.OnClientEvent then
						mode = NAStuff.BlockedRemoteModes[r] or "fakeok"
						break
					end
				end
				if NAStuff.nuhuhNotifs then Defer(DebugNotif, "Blocked OnClientEvent:Wait()", 2, "Remote Block") end
				if mode == "error" then error("Blocked OnClientEvent:Wait()", 0) end
				return nil
			end
		end
		return oldNamecall(self, ...)
	end)
	setreadonly(mt, true)
	getgenv().NA_BlockHooked = true
end

cmd.add({"blockremote","br"},{"blockremote [name]","Block a remote event/function by name (or pick from list)"},function(name)
	local function scanAll()
		local list, seen = {}, {}
		local function scan(parent)
			for _, obj in ipairs(parent:GetDescendants()) do
				if (obj:IsA("RemoteEvent") or obj:IsA("RemoteFunction")) and not seen[obj] then
					seen[obj] = true
					Insert(list, obj)
				end
			end
		end
		scan(ReplicatedStorage)
		local plr = Players.LocalPlayer
		local pg = PlrGui or plr:FindFirstChildOfClass("PlayerGui")
		if pg then scan(pg) else scan(plr) end
		return list
	end
	local function exactByName(q)
		local out, lq = {}, Lower(q)
		for _, r in ipairs(scanAll()) do
			if Lower(r.Name) == lq then Insert(out, r) end
		end
		return out
	end
	local function fuzzyByName(q)
		local out, lq = {}, Lower(q)
		for _, r in ipairs(scanAll()) do
			if Find(Lower(r.Name), lq, 1, true) then Insert(out, r) end
		end
		return out
	end
	local function openPicker(list, titleText, modeSel)
		if #list == 0 then DebugNotif("No remotes found.", 3, "Remote Block") return end
		local buttons = {}
		for _, r in ipairs(list) do
			Insert(buttons, {
				Text = ("%s | %s"):format(r.Name, r:GetFullName()),
				Callback = function()
					NAmanage.EnsureHook()
					NAmanage.BlockRemote(r, modeSel)
				end
			})
		end
		Window({ Title = titleText, Buttons = buttons })
	end
	local function afterMode(modeSel)
		local q = tostring(name or ""):gsub("^%s+",""):gsub("%s+$","")
		if q ~= "" then
			local exact = exactByName(q)
			if #exact >= 1 then
				NAmanage.EnsureHook()
				for _, r in ipairs(exact) do
					NAmanage.BlockRemote(r, modeSel)
				end
				return
			end
			local fuzzy = fuzzyByName(q)
			if #fuzzy == 1 then
				NAmanage.EnsureHook()
				NAmanage.BlockRemote(fuzzy[1], modeSel)
				return
			end
			openPicker(fuzzy, ("Select remote(s) to BLOCK for '%s'"):format(q), modeSel)
			return
		end
		openPicker(scanAll(), "Select remote(s) to BLOCK", modeSel)
	end
	Window({
		Title = "Remote Block Mode",
		Buttons = {
			{ Text = "Fake Success", Callback = function() afterMode("fakeok") end },
			{ Text = "Error",        Callback = function() afterMode("error")  end }
		}
	})
end,true)

cmd.add({"unblockremote","ubr"},{"unblockremote [name|all]","Unblock a remote by name, or pick from blocked list"},function(name)
	if not name or name == "" then
		local blocked = NAStuff.BlockedRemotes
		if #blocked == 0 then
			DebugNotif("No remotes are currently blocked.", 3, "Remote Block")
			return
		end
		local buttons = {}
		for _, r in ipairs(blocked) do
			Insert(buttons, {
				Text = ("%s | %s"):format(r.Name, r:GetFullName()),
				Callback = function() NAmanage.UnblockRemote(r) end
			})
		end
		Insert(buttons, {
			Text = "[ Unblock ALL ]",
			Callback = function()
				for i = #blocked, 1, -1 do
					NAmanage.UnblockRemote(blocked[i])
				end
			end
		})
		Window({ Title = "Blocked Remotes", Buttons = buttons })
		return
	end
	if Lower(name) == "all" or name == "*" then
		for i = #NAStuff.BlockedRemotes, 1, -1 do
			NAmanage.UnblockRemote(NAStuff.BlockedRemotes[i])
		end
		return
	end
	local lname = Lower(name)
	local exact, suggestions = {}, {}
	for _, r in ipairs(NAStuff.BlockedRemotes) do
		if Lower(r.Name) == lname then
			Insert(exact, r)
		elseif Find(Lower(r.Name), lname, 1, true) then
			Insert(suggestions, r)
		end
	end
	if #exact > 0 then
		for _, r in ipairs(exact) do
			NAmanage.UnblockRemote(r)
		end
		return
	end
	if #suggestions == 0 then
		DebugNotif(("No BLOCKED remotes match '%s'"):format(name), 3, "Remote Block")
		return
	end
	local buttons = {}
	for _, r in ipairs(suggestions) do
		Insert(buttons, {
			Text = ("%s | %s"):format(r.Name, r:GetFullName()),
			Callback = function() NAmanage.UnblockRemote(r) end
		})
	end
	Window({ Title = ("Select remote to UNBLOCK for '%s'"):format(name), Buttons = buttons })
end,true)

NAmanage.EnsureWalkSpeedBypassHook = function()
	if getgenv().NA_WSBP_Hooked then return end
	local mt = getrawmetatable(game)
	local oldIndex = mt.__index
	setreadonly(mt, false)
	mt.__index = newcclosure(function(self, key)
		if key == "WalkSpeed" then
			return 16
		end
		return oldIndex(self, key)
	end)
	setreadonly(mt, true)
	getgenv().NA_WSBP_Hooked = true
	DebugNotif("WalkSpeed bypass installed", 2, "Bypass Speed")
end

NAmanage.ApplyBypassSpeedOnce = function(val)
	local hum = getHum()
	if hum and val and val > 0 then
		hum.WalkSpeed = val
		DebugNotif(("BypassSpeed set to %s"):format(val), 2, "Bypass Speed")
	end
end

NAmanage.StartBypassSpeedLoop = function(val)
	if not val or val <= 0 then return end
	getgenv().NA_BPS_Enabled = true
	getgenv().NA_BPS_Val = val
	NAlib.disconnect("na_bps_apply")
	NAlib.disconnect("na_bps_char")
	local plr = Players.LocalPlayer
	NAmanage.ApplyBypassSpeedOnce(val)
	NAlib.connect("na_bps_apply", RunService.Heartbeat:Connect(function()
		if not getgenv().NA_BPS_Enabled then return end
		local hum = getHum()
		if hum and hum.WalkSpeed ~= getgenv().NA_BPS_Val then
			hum.WalkSpeed = getgenv().NA_BPS_Val
		end
	end))
	NAlib.connect("na_bps_char", plr.CharacterAdded:Connect(function(char)
		NAmanage.EnsureWalkSpeedBypassHook()
		while not getHum() do Wait(.05) end
		if getgenv().NA_BPS_Enabled then
			NAmanage.ApplyBypassSpeedOnce(getgenv().NA_BPS_Val)
		end
	end))
	DebugNotif(("LoopBypassSpeed: %s"):format(val), 2, "Bypass Speed")
end

NAmanage.StopBypassSpeedLoop = function()
	getgenv().NA_BPS_Enabled = false
	NAlib.disconnect("na_bps_apply")
	NAlib.disconnect("na_bps_char")
	DebugNotif("LoopBypassSpeed: OFF", 2, "Bypass Speed")
end

cmd.add({"bypassspeed","bps","bypasswalkspeed","bpws"},{"bypassspeed <number> (bps,bpws)","Set WalkSpeed (bypass variant)"},function(...)
	local a = {...}
	local arg = tostring(a[2] or a[1] or "")
	if arg == "" then return end
	if Lower(arg) == "off" then
		NAmanage.StopBypassSpeedLoop()
		return
	end
	local val = tonumber(arg)
	if not val or val <= 0 then return end
	NAmanage.EnsureWalkSpeedBypassHook()
	NAmanage.ApplyBypassSpeedOnce(val)
end, true)

cmd.add({"loopbypassspeed","lbps","loopbypasswalkspeed","lbws"},{"loopbypassspeed <number|off> (lbps,lbws)","Loop WalkSpeed (bypass variant)"},function(...)
	local arg = tostring((...) or "")
	if arg == "" then return end
	if Lower(arg) == "off" then
		NAmanage.StopBypassSpeedLoop()
		return
	end
	local val = tonumber(arg)
	if not val or val <= 0 then return end
	NAmanage.EnsureWalkSpeedBypassHook()
	NAmanage.StartBypassSpeedLoop(val)
end, true)

cmd.add({"unloopbypassspeed","unlbps","unloopbypasswalkspeed","unlbws"},{"unloopbypassspeed (unlbps,unlbws)","Disable loop WalkSpeed (bypass variant)"},function()
	NAmanage.StopBypassSpeedLoop()
end)

cmd.add({"oofspam"},{"oofspam","Spams oof"},function()
	getgenv().enabled = true
	getgenv().speed = 100
	local HRP = Humanoid.RootPart or getRoot(Humanoid.Parent)
	if not Humanoid or not getgenv().enabled then
		if Humanoid and Humanoid.Health <= 0 then
			Humanoid:Destroy()
		end
		return
	end
	Humanoid:SetStateEnabled(Enum.HumanoidStateType.Dead, false)
	Humanoid.BreakJointsOnDeath = false
	Humanoid.RequiresNeck = false

	NAlib.connect("oofspam_forcerun", RunService.Stepped:Connect(function()
		if not Humanoid then return NAlib.disconnect("oofspam_forcerun") end
		Humanoid:ChangeState(Enum.HumanoidStateType.Running)
	end))

	LocalPlayer.Character = nil
	LocalPlayer.Character = Character
	Wait(Players.RespawnTime + 0.1)

	NAlib.connect("oofspam_loop", RunService.Heartbeat:Connect(function()
		if not getgenv().enabled then
			NAlib.disconnect("oofspam_loop")
			return
		end
		Humanoid:ChangeState(Enum.HumanoidStateType.Dead)
	end))
end)

cmd.add({"httpspy"},{"httpspy","HTTP Spy"},function()
	loadstring(game:HttpGet('https://raw.githubusercontent.com/ltseverydayyou/Nameless-Admin/main/httpspy.lua'))()
end)

cmd.add({"keystroke"},{"keystroke","Executes a keystroke ui script"},function()
	loadstring(game:HttpGet("https://system-exodus.com/scripts/misc-releases/Keystrokes.lua",true))()
end)

cmd.add({"errorchat"},{"errorchat","Makes the chat error appear when roblox chat is slow"},function()
	for i=1,3 do
		NAlib.LocalPlayerChat("\0","All")
	end
end)

cmd.add({"clearerror", "noerror"}, {"clearerror", "Clears any current error or disconnected UI immediately"}, function()
	SafeGetService("GuiService"):ClearError()
end)

cmd.add({"antierror"}, {"antierror", "Continuously blocks and clears any future error or disconnected UI"}, function()
	NAlib.disconnect("antierror")
	NAlib.connect("antierror", SafeGetService("GuiService").ErrorMessageChanged:Connect(function()
		SafeGetService("GuiService"):ClearError()
	end))
	DebugNotif("Anti Error is now enabled!", 2)
end)

cmd.add({"unantierror", "noantierror"}, {"unantierror", "Disables Anti Error"}, function()
	NAlib.disconnect("antierror")
	DebugNotif("Anti Error is now disabled!",2)
end)

-- [[ Body Mods Section ]] --
do
	originalIO.bodyModsState = originalIO.bodyModsState or {
		boobs = { active = false, size = 1, conn = nil, ox = 0.5, oy = -0.4, oz = nil, sy = 0, vy = 0, sz = 0, vz = 0, sx = 0, vx = 0, rx = 0, vrx = 0, ry = 0, rv = 0, yw = 0, vyw = 0, llv = Vector3.zero, hcf = nil, ccf = nil },
		ass = { active = false, size = 1, conn = nil, ox = 0.48, oy = nil, oz = nil, sy = 0, vy = 0, sz = 0, vz = 0, sx = 0, vx = 0, rx = 0, vrx = 0, ry = 0, rv = 0, yw = 0, vyw = 0, llv = Vector3.zero, hcf = nil },
		pp = { active = false, len = 1, animConn = nil, wS = nil, wTip = nil, sh = nil, dr = nil },
		colorConn = nil,
		spawnConn = nil,
		apConn = nil
	}

	local state = originalIO.bodyModsState
	local pinkColor = Color3.fromRGB(255, 100, 150)
	local ringColor = Color3.fromRGB(225, 80, 120)

	originalIO.bodyModsSpring = originalIO.bodyModsSpring or function(u, v, target, stiffness, damping, dt)
		local accel = -stiffness * u - damping * v + stiffness * target
		v = v + accel * dt
		u = u + v * dt
		return u, v
	end

	originalIO.bodyModsDisconnectConnection = function(conn)
		if conn and conn.Connected then
			conn:Disconnect()
		end
		return nil
	end

	originalIO.bodyModsConnectAppearanceLoaded = originalIO.bodyModsConnectAppearanceLoaded or function(object, callback)
		if not object or type(callback) ~= 'function' then
			return nil
		end
		local ok, signal = pcall(function()
			return object.CharacterAppearanceLoaded
		end)
		if ok and typeof(signal) == 'RBXScriptSignal' then
			return signal:Connect(callback)
		end
		Defer(callback)
		return nil
	end

	originalIO.bodyModsGetCharacter = function(waitFor)
		local character = LocalPlayer.Character
		if character or not waitFor then
			return character
		end
		local ok, result = pcall(function()
			return LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
		end)
		return ok and result or nil
	end

	originalIO.bodyModsGetHumanoid = function(waitFor)
		local character = originalIO.bodyModsGetCharacter(waitFor)
		if not character then
			return nil
		end
		local humanoid = character:FindFirstChildOfClass('Humanoid')
		if humanoid or not waitFor then
			return humanoid
		end
		local ok, result = pcall(function()
			return character:WaitForChild('Humanoid', 10)
		end)
		return ok and result or nil
	end

	originalIO.bodyModsWaitFor = function(partNames, timeout)
		local deadline = os.clock() + (timeout or 10)
		while os.clock() < deadline do
			local character = LocalPlayer.Character
			if character then
				for _, name in ipairs(partNames) do
					local part = character:FindFirstChild(name)
					if part then
						return part
					end
				end
			end
			Wait(0.05)
		end
		return nil
	end

	originalIO.bodyModsGetTorso = function(forBoobs)
		local character = originalIO.bodyModsGetCharacter(true)
		local humanoid = originalIO.bodyModsGetHumanoid(true)
		if not character or not humanoid then
			return nil
		end
		if forBoobs then
			return character:FindFirstChild('UpperTorso')
				or character:FindFirstChild('Torso')
				or originalIO.bodyModsWaitFor({ 'UpperTorso', 'Torso' }, 5)
		end
		if humanoid.RigType == Enum.HumanoidRigType.R15 then
			return character:FindFirstChild('LowerTorso') or originalIO.bodyModsWaitFor({ 'LowerTorso' }, 5)
		end
		return character:FindFirstChild('Torso') or originalIO.bodyModsWaitFor({ 'Torso' }, 5)
	end

	originalIO.bodyModsGetSkinColor = function()
		local character = LocalPlayer.Character
		if not character then
			return Color3.new(1, 0.8, 0.6)
		end
		local part =
			character:FindFirstChild('LeftUpperArm') or
			character:FindFirstChild('Left Arm') or
			character:FindFirstChild('RightUpperArm') or
			character:FindFirstChild('Right Arm') or
			character:FindFirstChild('LeftUpperLeg') or
			character:FindFirstChild('Left Leg') or
			character:FindFirstChild('UpperTorso') or
			character:FindFirstChild('Torso')
		return (part and part.Color) or Color3.new(1, 0.8, 0.6)
	end

	originalIO.bodyModsAnyActive = function()
		return state.boobs.active or state.ass.active or state.pp.active
	end

	originalIO.bodyModsDisconnectColorWatcher = function()
		state.colorConn = originalIO.bodyModsDisconnectConnection(state.colorConn)
	end

	originalIO.bodyModsEnsureColorWatcher = function()
		if not originalIO.bodyModsAnyActive() then
			originalIO.bodyModsDisconnectColorWatcher()
			return
		end
		if state.colorConn and state.colorConn.Connected then
			return
		end
		state.colorConn = RunService.Heartbeat:Connect(function()
			if not originalIO.bodyModsAnyActive() then
				originalIO.bodyModsDisconnectColorWatcher()
				return
			end
			local character = LocalPlayer.Character
			if not character then
				return
			end
			local skin = originalIO.bodyModsGetSkinColor()
			for _, part in ipairs(character:GetChildren()) do
				if part:IsA('BasePart') then
					if part.Name == 'Boob' or part.Name == 'Cheek' or part.Name == 'Balls' or (part.Name == 'penis' and part.Shape == Enum.PartType.Cylinder) then
						if part.Color ~= skin then
							part.Color = skin
						end
					elseif part.Name == 'Nipple' or (part.Name == 'penis' and part.Shape == Enum.PartType.Ball) then
						if part.Color ~= pinkColor then
							part.Color = pinkColor
						end
					elseif part.Name == 'Areola' then
						if part.Color ~= ringColor then
							part.Color = ringColor
						end
					end
				end
			end
		end)
	end

	originalIO.bodyModsOnAppearanceLoaded = function()
		Defer(function()
			local character = LocalPlayer.Character
			if not character then
				return
			end
			local skin = originalIO.bodyModsGetSkinColor()
			for _, part in ipairs(character:GetChildren()) do
				if part:IsA('BasePart') then
					if part.Name == 'Boob' or part.Name == 'Cheek' or part.Name == 'Balls' or (part.Name == 'penis' and part.Shape == Enum.PartType.Cylinder) then
						part.Color = skin
					end
				end
			end
		end)
	end

	originalIO.bodyModsAppear = function(parts, scale, time)
		local tweenInfo = TweenInfo.new(time or 0.25, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
		for _, part in ipairs(parts) do
			if part and part:IsA('BasePart') then
				local target = part.Size
				part.Transparency = 1
				part.Size = target * (scale or 0.2)
				TweenService:Create(part, tweenInfo, { Transparency = 0, Size = target }):Play()
			end
		end
	end

	originalIO.bodyModsApplyBoobs = function(size)
		local character = originalIO.bodyModsGetCharacter(true)
		local humanoid = originalIO.bodyModsGetHumanoid(true)
		if not character or not humanoid then
			return
		end
		local torso = originalIO.bodyModsGetTorso(true)
		if not torso then
			return
		end

		for _, part in ipairs(character:GetChildren()) do
			if part:IsA('BasePart') and (part.Name == 'Boob' or part.Name == 'Nipple' or part.Name == 'Areola') then
				part:Destroy()
			end
		end

		local skin = originalIO.bodyModsGetSkinColor()
		local baseSize = Vector3.new(1.2, 1.2, 1.2)
		local baseNipple = Vector3.new(0.32, 0.32, 0.32)
		local boobSize = baseSize * size
		local nippleSize = baseNipple * size
		local areolaSize = nippleSize * 2
		local popForward = 0.02
		local backGap = math.max(0.03, nippleSize.Z * 0.45)
		local nudge = 0.02
		local radius = boobSize.Z * 0.5
		local torsoFront = torso.Size.Z * 0.5
		state.boobs.oz = torsoFront + math.max(0.12, radius * 0.75) - 0.06

		local function offsetToFront(sphereSize, attachSize)
			local sphereRadius = (sphereSize and sphereSize.Z or baseSize.Z) * 0.5
			local attachRadius = (attachSize and attachSize.Z or baseNipple.Z) * 0.5
			local offset = sphereRadius - (attachRadius * 0.5) - 0.005
			if offset < 0 then
				offset = 0
			end
			return offset
		end

		local function createHalf(side)
			local boob = Instance.new('Part')
			boob.Shape = Enum.PartType.Ball
			boob.Size = boobSize
			boob.Color = skin
			boob.Material = Enum.Material.SmoothPlastic
			boob.Anchored = false
			boob.CanCollide = false
			boob.CanTouch = false
			boob.CanQuery = false
			boob.Name = 'Boob'
			boob.Parent = character

			local nipple = Instance.new('Part')
			nipple.Shape = Enum.PartType.Ball
			nipple.Size = nippleSize
			nipple.Color = pinkColor
			nipple.Material = Enum.Material.SmoothPlastic
			nipple.Anchored = false
			nipple.CanCollide = false
			nipple.CanTouch = false
			nipple.CanQuery = false
			nipple.Name = 'Nipple'
			nipple.Parent = boob

			local areola = Instance.new('Part')
			areola.Shape = Enum.PartType.Ball
			areola.Size = areolaSize
			areola.Color = ringColor
			areola.Material = Enum.Material.SmoothPlastic
			areola.Anchored = false
			areola.CanCollide = false
			areola.CanTouch = false
			areola.CanQuery = false
			areola.Name = 'Areola'
			areola.Parent = boob

			local nippleWeld = Instance.new('Weld')
			nippleWeld.Part0 = nipple
			nippleWeld.Part1 = boob
			nippleWeld.C0 = CFrame.new(0, 0, offsetToFront(boob.Size, nipple.Size) + popForward)
			nippleWeld.Parent = nipple

			local areolaWeld = Instance.new('Weld')
			areolaWeld.Part0 = areola
			areolaWeld.Part1 = boob
			areolaWeld.C0 = CFrame.new(0, 0, offsetToFront(boob.Size, areola.Size) - (backGap - nudge))
			areolaWeld.Parent = areola

			local weld = Instance.new('Weld')
			weld.Part0 = boob
			weld.Part1 = torso
			weld.C0 = CFrame.new(side * state.boobs.ox, state.boobs.oy, state.boobs.oz)
			weld.Parent = boob

			return boob, nipple, areola, weld, nippleWeld, areolaWeld
		end

		local left, leftNipple, leftAreola, leftWeld, leftNippleWeld, leftAreolaWeld = createHalf(-1)
		local right, rightNipple, rightAreola, rightWeld, rightNippleWeld, rightAreolaWeld = createHalf(1)

		state.boobs.size = size
		state.boobs.active = true
		state.boobs.conn = originalIO.bodyModsDisconnectConnection(state.boobs.conn)
		state.boobs.sy = state.boobs.sy or 0
		state.boobs.vy = state.boobs.vy or 0
		state.boobs.sz = state.boobs.sz or 0
		state.boobs.vz = state.boobs.vz or 0
		state.boobs.sx = state.boobs.sx or 0
		state.boobs.vx = state.boobs.vx or 0
		state.boobs.rx = state.boobs.rx or 0
		state.boobs.vrx = state.boobs.vrx or 0
		state.boobs.ry = state.boobs.ry or 0
		state.boobs.rv = state.boobs.rv or 0
		state.boobs.yw = state.boobs.yw or 0
		state.boobs.vyw = state.boobs.vyw or 0
		state.boobs.llv = state.boobs.llv or Vector3.zero
		state.boobs.ccf = nil
		state.boobs.hcf = nil

		state.boobs.conn = RunService.RenderStepped:Connect(function(dt)
			local currentChar = originalIO.bodyModsGetCharacter()
			if not currentChar or not currentChar.Parent then
				return
			end
			local hrp = currentChar:FindFirstChild('HumanoidRootPart')
			if not hrp then
				return
			end
			local camera = workspace.CurrentCamera
			local velocity = hrp.AssemblyLinearVelocity or hrp.Velocity
			local localVel = hrp.CFrame:VectorToObjectSpace(velocity)
			local angular = hrp.AssemblyAngularVelocity or Vector3.zero
			local localAng = hrp.CFrame:VectorToObjectSpace(angular)
			local camAng = Vector3.zero
			if camera and state.boobs.ccf then
				local rel = state.boobs.ccf:toObjectSpace(camera.CFrame)
				local x, y, z = rel:ToEulerAnglesXYZ()
				camAng = Vector3.new(x, y, z) / math.max(dt, 1/240)
			end
			state.boobs.ccf = camera and camera.CFrame or nil
			local useCam = (LocalPlayer.CameraMode == Enum.CameraMode.LockFirstPerson) or (UserInputService.MouseBehavior == Enum.MouseBehavior.LockCenter)
			local angInput = useCam and camAng or localAng
			local accel = (localVel - state.boobs.llv) / math.max(dt, 1/240)
			state.boobs.llv = localVel

			local targetY = math.clamp((-localVel.Y * 0.015) - accel.Y * 0.006, -0.08, 0.08)
			local targetZ = math.clamp((-localVel.Z * 0.020) - accel.Z * 0.006, -0.10, 0.10)
			local targetX = math.clamp((-localVel.X * 0.016), -0.08, 0.08)
			local targetPitch = math.clamp(((-localVel.Y * 0.015) - accel.Y * 0.006) + angInput.X * 0.60, -0.38, 0.38)
			local targetRoll = math.clamp((-localVel.X * 0.06) + (-angInput.Y * 0.70), -0.42, 0.42)
			local targetYaw = math.clamp((localVel.X * 0.06) + (angInput.Z * 0.70), -0.42, 0.42)

			local stiffness, damping = 82, 4.4
			state.boobs.sy, state.boobs.vy = originalIO.bodyModsSpring(state.boobs.sy, state.boobs.vy, targetY, stiffness, damping, dt)
			state.boobs.sz, state.boobs.vz = originalIO.bodyModsSpring(state.boobs.sz, state.boobs.vz, targetZ, stiffness, damping, dt)
			state.boobs.sx, state.boobs.vx = originalIO.bodyModsSpring(state.boobs.sx, state.boobs.vx, targetX, stiffness, damping, dt)
			state.boobs.rx, state.boobs.vrx = originalIO.bodyModsSpring(state.boobs.rx, state.boobs.vrx, targetPitch, stiffness, 4.0, dt)
			state.boobs.ry, state.boobs.rv = originalIO.bodyModsSpring(state.boobs.ry, state.boobs.rv, targetRoll, stiffness, 4.0, dt)
			state.boobs.yw, state.boobs.vyw = originalIO.bodyModsSpring(state.boobs.yw, state.boobs.vyw, targetYaw, stiffness, 4.0, dt)

			state.boobs.sy = math.clamp(state.boobs.sy, -0.50, 0.50)
			state.boobs.sz = math.clamp(state.boobs.sz, -0.40, 0.40)
			state.boobs.sx = math.clamp(state.boobs.sx, -0.40, 0.40)
			state.boobs.ry = math.clamp(state.boobs.ry, -0.42, 0.42)

			local sxCap = math.clamp(state.boobs.sx, -state.boobs.ox * 0.35, state.boobs.ox * 0.35)
			local forwardZ = state.boobs.oz + state.boobs.sz * 0.08
			local leftOffset = CFrame.new(-state.boobs.ox + (-sxCap), state.boobs.oy + state.boobs.sy, forwardZ) * CFrame.Angles(state.boobs.rx, state.boobs.yw, state.boobs.ry)
			local rightOffset = CFrame.new(state.boobs.ox + sxCap, state.boobs.oy + state.boobs.sy, forwardZ) * CFrame.Angles(state.boobs.rx, -state.boobs.yw, -state.boobs.ry)

			if leftWeld then leftWeld.C0 = leftOffset end
			if rightWeld then rightWeld.C0 = rightOffset end
			if leftNippleWeld and left then leftNippleWeld.C0 = CFrame.new(0, 0, offsetToFront(left.Size, leftNipple.Size) + popForward) end
			if rightNippleWeld and right then rightNippleWeld.C0 = CFrame.new(0, 0, offsetToFront(right.Size, rightNipple.Size) + popForward) end
			if leftAreolaWeld and left then leftAreolaWeld.C0 = CFrame.new(0, 0, offsetToFront(left.Size, leftAreola.Size) - (backGap - nudge)) end
			if rightAreolaWeld and right then rightAreolaWeld.C0 = CFrame.new(0, 0, offsetToFront(right.Size, rightAreola.Size) - (backGap - nudge)) end
		end)

		originalIO.bodyModsEnsureColorWatcher()
		originalIO.bodyModsConnectAppearanceLoaded(humanoid, function()
			Defer(function()
				local refreshed = originalIO.bodyModsGetSkinColor()
				for _, part in ipairs({ left, right }) do
					if part and part.Parent then
						part.Color = refreshed
					end
				end
			end)
		end)

		originalIO.bodyModsEnsureSpawnConnection()
		DebugNotif('Boobs '..tostring(size),1.5)
	end

	originalIO.bodyModsRemoveBoobs = function()
		local character = originalIO.bodyModsGetCharacter()
		if not character then
			return
		end

		state.boobs.conn = originalIO.bodyModsDisconnectConnection(state.boobs.conn)
		state.boobs.active = false

		local toRemove = {}
		for _, part in ipairs(character:GetChildren()) do
			if part:IsA('BasePart') and (part.Name == 'Boob' or part.Name == 'Nipple' or part.Name == 'Areola') then
				Insert(toRemove, part)
			end
		end
		for _, part in ipairs(toRemove) do
			part.CanCollide = false
			part.CanTouch = false
			part.CanQuery = false
			TweenService:Create(part, TweenInfo.new(0.28, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), { Transparency = 1 }):Play()
		end
		Delay(0.30, function()
			for _, part in ipairs(toRemove) do
				if part and part.Parent then
					part:Destroy()
				end
			end
		end)

		originalIO.bodyModsEnsureColorWatcher()
		DebugNotif('Boobs Removed',1.5)
	end

	originalIO.bodyModsApplyAss = function(size)
		local character = originalIO.bodyModsGetCharacter(true)
		local humanoid = originalIO.bodyModsGetHumanoid(true)
		if not character or not humanoid then
			return
		end
		local torso = originalIO.bodyModsGetTorso(false)
		if not torso then
			return
		end

		for _, part in ipairs(character:GetChildren()) do
			if part:IsA('BasePart') and part.Name == 'Cheek' then
				part:Destroy()
			end
		end

		local skin = originalIO.bodyModsGetSkinColor()
		local baseSize = Vector3.new(1.1, 1.1, 1.1)
		local cheekSize = baseSize * size
		local radius = cheekSize.Y * 0.5

		state.ass.oy = (humanoid.RigType == Enum.HumanoidRigType.R15) and (-(torso.Size.Y * 0.35)) or 0.75
		state.ass.oz = -(torso.Size.Z * 0.5 + radius * 0.45)

		local function createCheek(side)
			local cheek = Instance.new('Part')
			cheek.Shape = Enum.PartType.Ball
			cheek.Size = cheekSize
			cheek.Color = skin
			cheek.Material = Enum.Material.SmoothPlastic
			cheek.Anchored = false
			cheek.CanCollide = false
			cheek.CanTouch = false
			cheek.CanQuery = false
			cheek.Name = 'Cheek'
			cheek.Parent = character

			local weld = Instance.new('Weld')
			weld.Part0 = cheek
			weld.Part1 = torso
			weld.C0 = CFrame.new(side * state.ass.ox, state.ass.oy, state.ass.oz)
			weld.Parent = cheek

			return cheek, weld
		end

		local left, leftWeld = createCheek(-1)
		local right, rightWeld = createCheek(1)

		state.ass.size = size
		state.ass.active = true
		state.ass.conn = originalIO.bodyModsDisconnectConnection(state.ass.conn)
		state.ass.sy = state.ass.sy or 0
		state.ass.vy = state.ass.vy or 0
		state.ass.sz = state.ass.sz or 0
		state.ass.vz = state.ass.vz or 0
		state.ass.sx = state.ass.sx or 0
		state.ass.vx = state.ass.vx or 0
		state.ass.rx = state.ass.rx or 0
		state.ass.vrx = state.ass.vrx or 0
		state.ass.ry = state.ass.ry or 0
		state.ass.rv = state.ass.rv or 0
		state.ass.yw = state.ass.yw or 0
		state.ass.vyw = state.ass.vyw or 0
		state.ass.llv = state.ass.llv or Vector3.zero
		state.ass.hcf = nil

		state.ass.conn = RunService.RenderStepped:Connect(function(dt)
			local currentChar = originalIO.bodyModsGetCharacter()
			if not currentChar or not currentChar.Parent then
				return
			end
			local hrp = currentChar:FindFirstChild('HumanoidRootPart')
			if not hrp then
				return
			end
			local velocity = hrp.AssemblyLinearVelocity or hrp.Velocity
			local localVel = hrp.CFrame:VectorToObjectSpace(velocity)
			local angular = hrp.AssemblyAngularVelocity or Vector3.zero
			local localAng = hrp.CFrame:VectorToObjectSpace(angular)

			local targetY = math.clamp(-localVel.Y * 0.045, -0.20, 0.20)
			local targetZ = math.clamp(localVel.Z * 0.042, -0.18, 0.18)
			local targetX = math.clamp(localVel.X * 0.045, -0.18, 0.18)
			local targetPitch = math.clamp(localAng.X * 0.70, -0.45, 0.45)
			local targetRoll = math.clamp(-localAng.Y * 0.70, -0.45, 0.45)
			local targetYaw = math.clamp(-localAng.Z * 0.60, -0.40, 0.40)

			local kTrans, dTrans = 48, 2.4
			local kRot, dRot = 44, 2.2
			state.ass.sy, state.ass.vy = originalIO.bodyModsSpring(state.ass.sy, state.ass.vy, targetY, kTrans, dTrans, dt)
			state.ass.sz, state.ass.vz = originalIO.bodyModsSpring(state.ass.sz, state.ass.vz, targetZ, kTrans, dTrans, dt)
			state.ass.sx, state.ass.vx = originalIO.bodyModsSpring(state.ass.sx, state.ass.vx, targetX, kTrans, dTrans, dt)
			state.ass.rx, state.ass.vrx = originalIO.bodyModsSpring(state.ass.rx, state.ass.vrx, targetPitch, kRot, dRot, dt)
			state.ass.ry, state.ass.rv = originalIO.bodyModsSpring(state.ass.ry, state.ass.rv, targetRoll, kRot, dRot, dt)
			state.ass.yw, state.ass.vyw = originalIO.bodyModsSpring(state.ass.yw, state.ass.vyw, targetYaw, kRot, dRot, dt)

			local sxCap = math.clamp(state.ass.sx, -state.ass.ox * 0.5, state.ass.ox * 0.5)
			local tzCap = math.clamp(state.ass.sz, -0.14, 0.14)
			local leftOffset = CFrame.new(-state.ass.ox + (-sxCap), state.ass.oy + state.ass.sy, state.ass.oz + tzCap) * CFrame.Angles(state.ass.rx, state.ass.yw, state.ass.ry)
			local rightOffset = CFrame.new(state.ass.ox + sxCap, state.ass.oy + state.ass.sy, state.ass.oz + tzCap) * CFrame.Angles(state.ass.rx, -state.ass.yw, -state.ass.ry)

			if leftWeld then leftWeld.C0 = leftOffset end
			if rightWeld then rightWeld.C0 = rightOffset end
		end)

		originalIO.bodyModsEnsureColorWatcher()
		originalIO.bodyModsConnectAppearanceLoaded(humanoid, originalIO.bodyModsOnAppearanceLoaded)
		originalIO.bodyModsEnsureSpawnConnection()
		DebugNotif('Ass '..tostring(size),1.5)
	end

	originalIO.bodyModsRemoveAss = function()
		local character = originalIO.bodyModsGetCharacter()
		if not character then
			return
		end

		state.ass.conn = originalIO.bodyModsDisconnectConnection(state.ass.conn)
		state.ass.active = false

		local toRemove = {}
		for _, part in ipairs(character:GetChildren()) do
			if part:IsA('BasePart') and part.Name == 'Cheek' then
				Insert(toRemove, part)
			end
		end
		for _, part in ipairs(toRemove) do
			part.CanCollide = false
			part.CanTouch = false
			part.CanQuery = false
			TweenService:Create(part, TweenInfo.new(0.28, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), { Transparency = 1 }):Play()
		end
		Delay(0.30, function()
			for _, part in ipairs(toRemove) do
				if part and part.Parent then
					part:Destroy()
				end
			end
		end)

		originalIO.bodyModsEnsureColorWatcher()
		DebugNotif('Ass Removed',1.5)
	end

	originalIO.bodyModsApplyPP = function(length)
		local character = originalIO.bodyModsGetCharacter(true)
		local humanoid = originalIO.bodyModsGetHumanoid(true)
		if not character or not humanoid then
			return
		end
		local torso = originalIO.bodyModsGetTorso(false)
		if not torso then
			return
		end

		for _, part in ipairs(character:GetChildren()) do
			if part:IsA('BasePart') and (part.Name == 'Balls' or part.Name == 'penis') then
				part:Destroy()
			end
		end

		local value = tonumber(length) or 1
		value = math.clamp(value, 0.5, 6)
		state.pp.len = value

		local skin = originalIO.bodyModsGetSkinColor()
		local shaftBaseLength = 2.0
		local shaftLength = shaftBaseLength * value

		local function createPart(shape, size, color, name)
			local part = Instance.new('Part')
			part.Shape = shape
			part.Size = size
			part.Color = color
			part.Material = Enum.Material.SmoothPlastic
			part.Anchored = false
			part.CanCollide = false
			part.CanTouch = false
			part.CanQuery = false
			part.Name = name
			part.Parent = character
			return part
		end

		local function weldConstraint(part0, part1)
			local weld = Instance.new('WeldConstraint')
			weld.Part0 = part0
			weld.Part1 = part1
			weld.Parent = part0
		end

		local offsetY = (humanoid.RigType == Enum.HumanoidRigType.R15) and -1.0 or -1.5
		local leftBall = createPart(Enum.PartType.Ball, Vector3.new(1.2, 1.2, 1.2), skin, 'Balls')
		local rightBall = createPart(Enum.PartType.Ball, Vector3.new(1.2, 1.2, 1.2), skin, 'Balls')
		local shaft = createPart(Enum.PartType.Cylinder, Vector3.new(shaftLength, 0.70, 0.70), skin, 'penis')
		local tip = createPart(Enum.PartType.Ball, Vector3.new(0.70, 0.70, 0.70), pinkColor, 'penis')

		leftBall.CFrame = torso.CFrame * CFrame.new(-0.25, offsetY, -0.80)
		rightBall.CFrame = torso.CFrame * CFrame.new(0.25, offsetY, -0.80)
		local forwardShift = (shaftLength - shaftBaseLength) * 0.5
		shaft.CFrame = torso.CFrame * CFrame.new(0.00, offsetY + 0.70, -1.35) * CFrame.Angles(0, math.rad(270), 0) * CFrame.new(-forwardShift, 0, 0)
		tip.CFrame = shaft.CFrame * CFrame.new(-shaftLength * 0.5, 0, 0)

		weldConstraint(leftBall, torso)
		weldConstraint(rightBall, torso)
		weldConstraint(shaft, torso)
		weldConstraint(tip, shaft)

		state.pp.active = true
		state.pp.wS = nil
		state.pp.wTip = nil
		state.pp.sh = shaft
		state.pp.dr = tip

		originalIO.bodyModsEnsureColorWatcher()
		originalIO.bodyModsConnectAppearanceLoaded(humanoid, originalIO.bodyModsOnAppearanceLoaded)
		originalIO.bodyModsEnsureSpawnConnection()
		DebugNotif('penis '..tostring(value),1.5)
	end

	originalIO.bodyModsRemovePP = function()
		local character = originalIO.bodyModsGetCharacter()
		if not character then
			return
		end

		local toRemove = {}
		for _, part in ipairs(character:GetChildren()) do
			if part:IsA('BasePart') and (part.Name == 'Balls' or part.Name == 'penis') then
				Insert(toRemove, part)
			end
		end
		for _, part in ipairs(toRemove) do
			part.CanCollide = false
			part.CanTouch = false
			part.CanQuery = false
			TweenService:Create(part, TweenInfo.new(0.25, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), { Transparency = 1 }):Play()
		end
		Delay(0.27, function()
			for _, part in ipairs(toRemove) do
				if part and part.Parent then
					part:Destroy()
				end
			end
		end)

		state.pp.animConn = originalIO.bodyModsDisconnectConnection(state.pp.animConn)
		state.pp.active = false
		state.pp.wS = nil
		state.pp.wTip = nil
		state.pp.sh = nil
		state.pp.dr = nil
		originalIO.bodyModsEnsureColorWatcher()
		DebugNotif('PP Removed',1.5)
	end

	originalIO.bodyModsReapplyOnSpawn = function(newCharacter)
		Spawn(function()
			local humanoid = newCharacter:WaitForChild('Humanoid', 10)
			if state.boobs.active then
				Spawn(function()
					if originalIO.bodyModsWaitFor({ 'UpperTorso', 'Torso' }, 10) then
						originalIO.bodyModsApplyBoobs(state.boobs.size or 1)
					end
				end)
			end
			if state.ass.active then
				Spawn(function()
					if humanoid and humanoid.RigType == Enum.HumanoidRigType.R15 then
						if originalIO.bodyModsWaitFor({ 'LowerTorso' }, 10) then
							originalIO.bodyModsApplyAss(state.ass.size or 1)
						end
					else
						if originalIO.bodyModsWaitFor({ 'Torso' }, 10) then
							originalIO.bodyModsApplyAss(state.ass.size or 1)
						end
					end
				end)
			end
			if state.pp.active then
				Spawn(function()
					if humanoid and humanoid.RigType == Enum.HumanoidRigType.R15 then
						if originalIO.bodyModsWaitFor({ 'LowerTorso' }, 10) then
							originalIO.bodyModsApplyPP(state.pp.len or 1)
						end
					else
						if originalIO.bodyModsWaitFor({ 'Torso' }, 10) then
							originalIO.bodyModsApplyPP(state.pp.len or 1)
						end
					end
				end)
			end
		end)
	end

	originalIO.bodyModsEnsureSpawnConnection = function()
		if state.spawnConn and state.spawnConn.Connected then
			return
		end
		state.spawnConn = LocalPlayer.CharacterAdded:Connect(originalIO.bodyModsReapplyOnSpawn)
	end

	originalIO.bodyModsEnsurePlayerAppearanceHook = function()
		state.apConn = originalIO.bodyModsDisconnectConnection(state.apConn)
		state.apConn = originalIO.bodyModsConnectAppearanceLoaded(LocalPlayer, originalIO.bodyModsOnAppearanceLoaded)
	end

	originalIO.bodyModsEnsurePlayerAppearanceHook()
	originalIO.bodyModsEnsureSpawnConnection()

	cmd.add({'boobs','boobies'},{'boobs <size> (boobies)','Boobs'},function(arg)
		local value = tonumber(arg) or state.boobs.size or 1
		value = math.clamp(value, 1, 8)
		originalIO.bodyModsApplyBoobs(value)
	end, true)

	cmd.add({'unboobs','unboobies','noboobs','noboobies'},{'unboobs (unboobies,noboobs,noboobies)','Boobs'},function()
		originalIO.bodyModsRemoveBoobs()
	end)

	cmd.add({'ass','booty'},{'ass <size> (booty)','Ass'},function(arg)
		local value = tonumber(arg) or state.ass.size or 1
		value = math.clamp(value, 1, 8)
		originalIO.bodyModsApplyAss(value)
	end, true)

	cmd.add({'unass','noass'},{'unass (noass)','Ass'},function()
		originalIO.bodyModsRemoveAss()
	end)

	cmd.add({'penis','pp'},{'penis <length> (pp)','penis'},function(arg)
		local value = tonumber(arg) or state.pp.len or 1
		value = math.clamp(value, 0.5, 6)
		originalIO.bodyModsApplyPP(value)
	end, true)

	cmd.add({'unpenis','unpp','nopenis','nopp'},{'unpenis (unpp,nopenis,nopp)','penis'},function()
		originalIO.bodyModsRemovePP()
	end)
end


-- [[ NPC SECTION ]] --
cmd.add({"flingnpcs"}, {"flingnpcs", "Flings NPCs"}, function()
	local npcs = {}

	local function disappear(hum)
		if hum:IsA("Humanoid") and CheckIfNPC(hum.Parent) then
			Insert(npcs,{hum,hum.HipHeight})
			hum.HipHeight = 1024
		end
	end
	for _,hum in pairs(workspace:GetDescendants()) do
		disappear(hum)
	end
end)

cmd.add({"npcfollow"}, {"npcfollow", "Makes NPCS follow you"}, function()
	local npcs = {}

	local function disappear(hum)
		if hum:IsA("Humanoid") and CheckIfNPC(hum.Parent) then
			Insert(npcs,{hum,hum.HipHeight})
			local rootPart = getRoot(hum.Parent)
			local targetPos = getRoot(LocalPlayer.Character).Position
			hum:MoveTo(targetPos)
		end
	end
	for _,hum in pairs(workspace:GetDescendants()) do
		disappear(hum)
	end
end)

npcfollowloop = false
cmd.add({"loopnpcfollow"}, {"loopnpcfollow", "Makes NPCS follow you in a loop"}, function()
	npcfollowloop = true

	repeat Wait(0.1)
		local npcs = {}

		local function disappear(hum)
			if hum:IsA("Humanoid") and CheckIfNPC(hum.Parent) then
				Insert(npcs,{hum,hum.HipHeight})
				local rootPart = getRoot(hum.Parent)
				local targetPos = getRoot(LocalPlayer.Character).Position
				hum:MoveTo(targetPos)
			end
		end
		for _,hum in pairs(workspace:GetDescendants()) do
			disappear(hum)
		end
	until npcfollowloop == false
end)

cmd.add({"unloopnpcfollow"}, {"unloopnpcfollow", "Makes NPCS not follow you in a loop"}, function()
	npcfollowloop = false
end)

cmd.add({"sitnpcs"}, {"sitnpcs", "Makes NPCS sit"}, function()
	local npcs = {}

	local function disappear(hum)
		if hum:IsA("Humanoid") and CheckIfNPC(hum.Parent) then
			Insert(npcs,{hum,hum.HipHeight})
			local rootPart = getRoot(hum.Parent)
			if rootPart then
				hum.Sit = true
			end
		end
	end
	for _,hum in pairs(workspace:GetDescendants()) do
		disappear(hum)
	end
end)

cmd.add({"unsitnpcs"}, {"unsitnpcs", "Makes NPCS unsit"}, function()
	local npcs = {}

	local function disappear(hum)
		if hum:IsA("Humanoid") and CheckIfNPC(hum.Parent) then
			Insert(npcs,{hum,hum.HipHeight})
			local rootPart = getRoot(hum.Parent)
			if rootPart then
				hum.Sit = true
			end
		end
	end
	for _,hum in pairs(workspace:GetDescendants()) do
		disappear(hum)
	end
end)

cmd.add({"killnpcs"}, {"killnpcs", "Kills NPCs"}, function()
	local npcs = {}

	local function disappear(hum)
		if hum:IsA("Humanoid") and CheckIfNPC(hum.Parent) then
			Insert(npcs,{hum,hum.HipHeight})
			local rootPart = getRoot(hum.Parent)
			if rootPart then
				hum.Health = 0
			end
		end
	end
	for _,hum in pairs(workspace:GetDescendants()) do
		disappear(hum)
	end
end)

cmd.add({"npcwalkspeed","npcws"},{"npcwalkspeed <speed>","Sets all NPC WalkSpeed to <speed> (default 16)"},function(speedStr)
	local speed = tonumber(speedStr) or 16
	for _, hum in pairs(workspace:GetDescendants()) do
		if hum:IsA("Humanoid") and CheckIfNPC(hum.Parent) then
			local root = getRoot(hum.Parent)
			if root then hum.WalkSpeed = speed end
		end
	end
end,true)

cmd.add({"npcjumppower","npcjp"},{"npcjumppower <power>","Sets all NPC JumpPower to <power> (default 50)"},function(powerStr)
	local power=tonumber(powerStr) or 50
	for _,hum in pairs(workspace:GetDescendants()) do
		if hum:IsA("Humanoid") and CheckIfNPC(hum.Parent) then
			local root=getRoot(hum.Parent)
			if root then hum.JumpPower=power end
		end
	end
end,true)

cmd.add({"bringnpcs"}, {"bringnpcs", "Brings NPCs"}, function()
	local npcs = {}

	local function disappear(hum)
		if hum:IsA("Humanoid") and CheckIfNPC(hum.Parent) then
			Insert(npcs,{hum,hum.HipHeight})
			local rootPart = getRoot(hum.Parent)
			if rootPart then
				rootPart.CFrame = getRoot(LocalPlayer.Character).CFrame
			end
		end
	end
	for _,hum in pairs(workspace:GetDescendants()) do
		disappear(hum)
	end
end)

npcCache = {}
cmd.add({"loopbringnpcs", "lbnpcs"}, {"loopbringnpcs (lbnpcs)", "Loops NPC bringing"}, function()
	if NAlib.isConnected("loopbringnpcs") then NAlib.disconnect("loopbringnpcs") end
	table.clear(npcCache)
	for _, hum in ipairs(workspace:GetDescendants()) do
		if hum:IsA("Humanoid") and CheckIfNPC(hum.Parent) then
			Insert(npcCache, hum)
		end
	end

	NAlib.connect("loopbringnpcs", RunService.Stepped:Connect(function()
		for _, hum in ipairs(npcCache) do
			if hum.Parent and hum.Health > 0 then
				local model = hum.Parent
				local rootPart = getRoot(model)
				local localRoot = LocalPlayer.Character and getRoot(LocalPlayer.Character)
				if rootPart and localRoot then
					rootPart.CFrame = localRoot.CFrame
				end
				SpawnCall(function()
					for _, part in ipairs(model:GetDescendants()) do
						if part:IsA("BasePart") then
							if NAlib.isProperty(part, "CanCollide") then
								NAlib.setProperty(part, "CanCollide", false)
							end
						end
					end
				end)
			end
		end
	end))
end)

cmd.add({"unloopbringnpcs", "unlbnpcs"}, {"unloopbringnpcs (unlbnpcs)", "Stops NPC bring loop"}, function()
	NAlib.disconnect("loopbringnpcs")
end)

cmd.add({"gotonpcs"}, {"gotonpcs", "Teleports to each NPC"}, function()
	local LocalPlayer = Players.LocalPlayer
	local npcs = {}
	for _, d in pairs(workspace:GetDescendants()) do
		if d:IsA("Humanoid") and CheckIfNPC(d.Parent) then
			local root = getRoot(d.Parent)
			if root then
				Insert(npcs, root)
			end
		end
	end
	SpawnCall(function()
		for _, npcRoot in ipairs(npcs) do
			local char = LocalPlayer.Character
			if char and getRoot(char) then
				getRoot(char).CFrame = npcRoot.CFrame + Vector3.new(0, 3, 0)
			end
		end
	end)
end)

local NPCControl = {
	Enabled = false,
	Connection = nil,
	CurrentTarget = nil,
	MoveCooldown = 0
}

cmd.add({"actnpc"}, {"actnpc", "Start acting like an NPC"}, function()
	if NPCControl.Enabled then return end
	NPCControl.Enabled = true

	local function moveToRandom()
		local char = LocalPlayer.Character
		local hum = getHum()
		local root = getRoot(char)
		if not (char and hum and root) then return end

		local randomOffset = Vector3.new(math.random(-30, 30), 0, math.random(-30, 30))
		local targetPos = root.Position + randomOffset

		NPCControl.CurrentTarget = targetPos
		hum:MoveTo(targetPos)

		DebugNotif("Moving to: "..Format("X: %.0f, Y: %.0f, Z: %.0f", targetPos.X, targetPos.Y, targetPos.Z), 1.5)
	end

	NPCControl.Connection = RunService.Heartbeat:Connect(function(dt)
		local char = LocalPlayer.Character
		local hum = getHum()
		local root = getRoot(char)
		if not (char and hum and root) then return end

		NPCControl.MoveCooldown=NPCControl.MoveCooldown - dt
		NPCControl._jumpCooldown = (NPCControl._jumpCooldown or 0) - dt
		NPCControl._moveTimeout = (NPCControl._moveTimeout or 0) + dt

		if hum.Sit then
			DebugNotif("Sitting detected — jumping to escape", 1.5)
			hum.Sit = false
			hum:ChangeState(Enum.HumanoidStateType.Jumping)
			NPCControl._jumpCooldown = 1.5
			return
		end

		if NPCControl.CurrentTarget and (root.Position - NPCControl.CurrentTarget).Magnitude < 2 then
			DebugNotif("Reached target", 1.5)
			NPCControl.CurrentTarget = nil
		end

		if not NPCControl.CurrentTarget or NPCControl._moveTimeout > 5 then
			if NPCControl._moveTimeout > 5 then
				DebugNotif("Stuck — retrying new path", 1.5)
			end
			if NPCControl.MoveCooldown <= 0 then
				moveToRandom()
				NPCControl.MoveCooldown = math.random(2, 4)
				NPCControl._moveTimeout = 0
			end
		end

		local forward = root.CFrame.LookVector
		local origin = root.Position + Vector3.new(0, 2, 0)
		local rayParams = RaycastParams.new()
		rayParams.FilterType = Enum.RaycastFilterType.Blacklist
		rayParams.FilterDescendantsInstances = {char}
		local result = Workspace:Raycast(origin, forward * 3 + Vector3.new(0, -2, 0), rayParams)

		if result and NPCControl._jumpCooldown <= 0 then
			local part = result.Instance
			local model = part:FindFirstAncestorOfClass("Model")
			local isPlayerChar = model and Players:GetPlayerFromCharacter(model)

			if part.CanCollide and not isPlayerChar then
				if hum:GetState() == Enum.HumanoidStateType.Running then
					DebugNotif("Obstacle detected — jumping", 1.5)
					hum:ChangeState(Enum.HumanoidStateType.Jumping)
					NPCControl._jumpCooldown = 1.5
				end
			end
		end
	end)
end)

cmd.add({"unactnpc", "stopnpc"}, {"unactnpc (stopnpc)", "Stop acting like an NPC"}, function()
	if not NPCControl.Enabled then return end
	NPCControl.Enabled = false
	if NPCControl.Connection then
		NPCControl.Connection:Disconnect()
		NPCControl.Connection = nil
	end
end)

clickkillUI = nil
clickkillEnabled = false

cmd.add({"clickkillnpc", "cknpc"}, {"clickkillnpc (cknpc)", "Click on an NPC to kill it"}, function()
	clickkillEnabled = true

	if clickkillUI then clickkillUI:Destroy() end
	NAlib.disconnect("clickkill_mouse")

	local Mouse = player:GetMouse()

	clickkillUI = InstanceNew("ScreenGui")
	NaProtectUI(clickkillUI)

	local toggleButton = InstanceNew("TextButton")
	toggleButton.Size = UDim2.new(0, 120, 0, 40)
	toggleButton.Text = "ClickKill: ON"
	toggleButton.Position = UDim2.new(0.5, -60, 0, 10)
	toggleButton.TextScaled = 16
	toggleButton.TextColor3 = Color3.new(1, 1, 1)
	toggleButton.Font = Enum.Font.GothamBold
	toggleButton.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
	toggleButton.BackgroundTransparency = 0.2
	toggleButton.Parent = clickkillUI

	local uiCorner = InstanceNew("UICorner")
	uiCorner.CornerRadius = UDim.new(0, 8)
	uiCorner.Parent = toggleButton

	NAgui.draggerV2(toggleButton)

	MouseButtonFix(toggleButton, function()
		clickkillEnabled = not clickkillEnabled
		toggleButton.Text = clickkillEnabled and "ClickKill: ON" or "ClickKill: OFF"
	end)

	NAlib.connect("clickkill_mouse", Mouse.Button1Down:Connect(function()
		if not clickkillEnabled then return end

		local Target = Mouse.Target
		if Target and Target.Parent then
			local Character = Target.Parent
			if CheckIfNPC(Character) then
				local Humanoid = getPlrHum(Character)
				if Humanoid then
					Humanoid.Health = 0
				end
			end
		end
	end))
end)

cmd.add({"unclickkillnpc", "uncknpc"}, {"unclickkillnpc (uncknpc)", "Disable clickkillnpc"}, function()
	clickkillEnabled = false
	if clickkillUI then clickkillUI:Destroy() end
	NAlib.disconnect("clickkill_mouse")
end)

cmd.add({"voidnpcs", "vnpcs"}, {"voidnpcs (vnpcs)", "Teleports NPC's to void"}, function()
	for _, d in ipairs(workspace:GetDescendants()) do
		if d:IsA("Humanoid") and CheckIfNPC(d.Parent) then
			local root = getPlrHum(d.Parent)
			if root then
				root.HipHeight = math.huge
			end
		end
	end
end)

clickVoidUI = nil
clickVoidEnabled = false

cmd.add({"clickvoidnpc", "cvnpc"}, {"clickvoidnpc (cvnpc)", "Click to void NPCs"}, function()
	clickVoidEnabled = true

	if clickVoidUI then clickVoidUI:Destroy() end
	NAlib.disconnect("clickvoid_mouse")

	clickVoidUI = InstanceNew("ScreenGui")
	NaProtectUI(clickVoidUI)

	local button = InstanceNew("TextButton")
	button.Size = UDim2.new(0, 120, 0, 40)
	button.Text = "ClickVoid: ON"
	button.Position = UDim2.new(0.5, -60, 0, 10)
	button.TextScaled = true
	button.TextColor3 = Color3.new(1, 1, 1)
	button.Font = Enum.Font.GothamBold
	button.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
	button.BackgroundTransparency = 0.2
	button.Parent = clickVoidUI

	local corner = InstanceNew("UICorner", button)
	corner.CornerRadius = UDim.new(0, 8)
	NAgui.draggerV2(button)

	MouseButtonFix(button, function()
		clickVoidEnabled = not clickVoidEnabled
		button.Text = clickVoidEnabled and "ClickVoid: ON" or "ClickVoid: OFF"
	end)

	local mouse = player:GetMouse()
	NAlib.connect("clickvoid_mouse", mouse.Button1Down:Connect(function()
		if not clickVoidEnabled then return end

		local target = mouse.Target
		if target and target.Parent and CheckIfNPC(target.Parent) then
			local root = getPlrHum(target.Parent)
			if root then
				root.HipHeight = math.huge
			end
		end
	end))
end)

cmd.add({"unclickvoidnpc", "uncvnpc"}, {"unclickvoidnpc (uncvnpc)","Disable click-void"}, function()
	clickVoidEnabled = false
	if clickVoidUI then clickVoidUI:Destroy() end
	NAlib.disconnect("clickvoid_mouse")
end)

clickSpeedUI,clickSpeedEnabled=nil,false

cmd.add({"clicknpcws","cnpcws"},{"clicknpcws","Click on an NPC to set its WalkSpeed"},function()
	clickSpeedEnabled=true
	if clickSpeedUI then clickSpeedUI:Destroy() end
	NAlib.disconnect("clickspeed_mouse")
	local player=Players.LocalPlayer
	local mouse=player:GetMouse()
	clickSpeedUI=InstanceNew("ScreenGui")
	NaProtectUI(clickSpeedUI)
	local btn=InstanceNew("TextButton")
	btn.Size=UDim2.new(0,120,0,40)
	btn.Position=UDim2.new(0.5,-130,0,10)
	btn.Text="SetSpeed: ON"
	btn.TextSize=16
	btn.TextColor3=Color3.new(1,1,1)
	btn.Font=Enum.Font.GothamBold
	btn.BackgroundColor3=Color3.fromRGB(40,40,40)
	btn.BackgroundTransparency=0.2
	btn.Parent=clickSpeedUI
	local cor1=InstanceNew("UICorner")
	cor1.CornerRadius=UDim.new(0,8)
	cor1.Parent=btn
	NAgui.draggerV2(btn)
	local tb=InstanceNew("TextBox")
	tb.Size=UDim2.new(0,120,0,40)
	tb.Position=UDim2.new(0.5,10,0,10)
	tb.Text="16"
	tb.PlaceholderText="Speed"
	tb.TextSize=16
	tb.TextColor3=Color3.new(1,1,1)
	tb.Font=Enum.Font.Gotham
	tb.BackgroundColor3=Color3.fromRGB(50,50,50)
	tb.BackgroundTransparency=0.2
	tb.Parent=clickSpeedUI
	local cor2=InstanceNew("UICorner")
	cor2.CornerRadius=UDim.new(0,8)
	cor2.Parent=tb
	NAgui.draggerV2(tb)
	local speedNumber=16
	tb.FocusLost:Connect(function(enterPressed)
		local n=tonumber(tb.Text)
		if n then speedNumber=n else tb.Text=tostring(speedNumber) end
	end)
	MouseButtonFix(btn,function()
		clickSpeedEnabled=not clickSpeedEnabled
		btn.Text=clickSpeedEnabled and "SetSpeed: ON" or "SetSpeed: OFF"
	end)
	NAlib.connect("clickspeed_mouse",mouse.Button1Down:Connect(function()
		if not clickSpeedEnabled then return end
		local hit=mouse.Target
		if hit and hit.Parent and CheckIfNPC(hit.Parent) then
			local hum=getPlrHum(hit.Parent)
			if hum then hum.WalkSpeed=speedNumber end
		end
	end))
end)

cmd.add({"unclicknpcws","uncnpcws"},{"unclicknpcws","Disable clicknpcws"},function()
	clickSpeedEnabled=false
	if clickSpeedUI then clickSpeedUI:Destroy() end
	NAlib.disconnect("clickspeed_mouse")
end)

clickJumpUI,clickJumpEnabled=nil,false

cmd.add({"clicknpcjp","cnpcjp"},{"clicknpcjp","Click on an NPC to set its JumpPower"},function()
	clickJumpEnabled=true
	if clickJumpUI then clickJumpUI:Destroy() end
	NAlib.disconnect("clickjump_mouse")
	local player=Players.LocalPlayer
	local mouse=player:GetMouse()
	clickJumpUI=InstanceNew("ScreenGui")
	NaProtectUI(clickJumpUI)
	local btn=InstanceNew("TextButton")
	btn.Size=UDim2.new(0,120,0,40)
	btn.Position=UDim2.new(0.5,-130,0,10)
	btn.Text="SetJump: ON"
	btn.TextSize=16
	btn.TextColor3=Color3.new(1,1,1)
	btn.Font=Enum.Font.GothamBold
	btn.BackgroundColor3=Color3.fromRGB(40,40,40)
	btn.BackgroundTransparency=0.2
	btn.Parent=clickJumpUI
	local cor1=InstanceNew("UICorner")
	cor1.CornerRadius=UDim.new(0,8)
	cor1.Parent=btn
	NAgui.draggerV2(btn)
	local tb=InstanceNew("TextBox")
	tb.Size=UDim2.new(0,120,0,40)
	tb.Position=UDim2.new(0.5,10,0,10)
	tb.Text="50"
	tb.PlaceholderText="JumpPower"
	tb.TextSize=16
	tb.TextColor3=Color3.new(1,1,1)
	tb.Font=Enum.Font.Gotham
	tb.BackgroundColor3=Color3.fromRGB(50,50,50)
	tb.BackgroundTransparency=0.2
	tb.Parent=clickJumpUI
	local cor2=InstanceNew("UICorner")
	cor2.CornerRadius=UDim.new(0,8)
	cor2.Parent=tb
	NAgui.draggerV2(tb)
	local jumpPowerNumber=50
	tb.FocusLost:Connect(function(enterPressed)
		local n=tonumber(tb.Text)
		if n then jumpPowerNumber=n else tb.Text=tostring(jumpPowerNumber) end
	end)
	MouseButtonFix(btn,function()
		clickJumpEnabled=not clickJumpEnabled
		btn.Text=clickJumpEnabled and "SetJump: ON" or "SetJump: OFF"
	end)
	NAlib.connect("clickjump_mouse",mouse.Button1Down:Connect(function()
		if not clickJumpEnabled then return end
		local hit=mouse.Target
		if hit and hit.Parent and CheckIfNPC(hit.Parent) then
			local hum=getPlrHum(hit.Parent)
			if hum then hum.JumpPower=jumpPowerNumber end
		end
	end))
end)

cmd.add({"unclicknpcjp","uncnpcjp"},{"unclicknpcjp","Disable clicknpcjp"},function()
	clickJumpEnabled=false
	if clickJumpUI then clickJumpUI:Destroy() end
	NAlib.disconnect("clickjump_mouse")
end)

--[[ FUNCTIONALITY ]]--
LocalPlayer.Chatted:Connect(function(str)
	NAlib.parseCommand(str)
	NAmanage.ExecuteBindings("OnChatted", LocalPlayer, str)
end)

--[[ Admin Player]]
function IsAdminAndRun(Message, Player)
	if Admin[Player.UserId] or isRelAdmin(Player) then
		NAlib.parseCommand(Message, Player)
	end
end

function CheckPermissions(Player)
	Player.Chatted:Connect(function(Message)
		IsAdminAndRun(Message,Player)
	end)
end

--[[function Getmodel(id)
	local ob23e232323=nil
	s,r=NACaller(function()
		ob23e232323=game:GetObjects(id)[1]
	end)
	if s and ob23e232323 then
		return ob23e232323
	end
	Wait(1)
	warn("retrying")
	return Getmodel(id)
end]]

--[[ GUI VARIABLES ]]--
repeat
	local NASUC, resexy = pcall(function()
		return loadstring(game:HttpGet(opt.NAUILOADER))()
	end)

	if NASUC then
		NAStuff.NASCREENGUI = resexy
	else
		warn(math.random(1,999999).." | Failed to load UI module: "..resexy.." | retrying...")
		Wait(.3)
	end
until NAStuff.NASCREENGUI
local rPlayer=Players:FindFirstChildWhichIsA("Player")
local coreGuiProtection={}
if not RunService:IsStudio() then
else
	repeat Wait() until player:FindFirstChild("AdminUI",true)
	NAStuff.NASCREENGUI=player:FindFirstChild("AdminUI",true)
end
--repeat Wait() until ScreenGui~=nil -- if it loads late then I'll just add this here

NaProtectUI(NAStuff.NASCREENGUI)

local NAUIMANAGER = {
	description          = NAStuff.NASCREENGUI:FindFirstChild("Description");
	AUTOSCALER           = NAStuff.NASCREENGUI:FindFirstChild("AutoScale");
	cmdBar               = NAStuff.NASCREENGUI:FindFirstChild("CmdBar");
	centerBar            = NAStuff.NASCREENGUI:FindFirstChild("CmdBar")
		and NAStuff.NASCREENGUI:FindFirstChild("CmdBar"):FindFirstChild("CenterBar");
	cmdInput             = NAStuff.NASCREENGUI:FindFirstChild("CmdBar")
		and NAStuff.NASCREENGUI:FindFirstChild("CmdBar"):FindFirstChild("CenterBar")
		and NAStuff.NASCREENGUI:FindFirstChild("CmdBar"):FindFirstChild("CenterBar"):FindFirstChild("Input");
	cmdAutofill          = NAStuff.NASCREENGUI:FindFirstChild("CmdBar")
		and NAStuff.NASCREENGUI:FindFirstChild("CmdBar"):FindFirstChild("Autofill");
	cmdExample           = NAStuff.NASCREENGUI:FindFirstChild("CmdBar")
		and NAStuff.NASCREENGUI:FindFirstChild("CmdBar"):FindFirstChild("Autofill")
		and NAStuff.NASCREENGUI:FindFirstChild("CmdBar"):FindFirstChild("Autofill"):FindFirstChildWhichIsA("Frame");
	leftFill             = NAStuff.NASCREENGUI:FindFirstChild("CmdBar")
		and NAStuff.NASCREENGUI:FindFirstChild("CmdBar"):FindFirstChild("LeftFill");
	rightFill            = NAStuff.NASCREENGUI:FindFirstChild("CmdBar")
		and NAStuff.NASCREENGUI:FindFirstChild("CmdBar"):FindFirstChild("RightFill");

	chatLogsFrame        = NAStuff.NASCREENGUI:FindFirstChild("ChatLogs");
	chatLogs             = NAStuff.NASCREENGUI:FindFirstChild("ChatLogs")
		and NAStuff.NASCREENGUI:FindFirstChild("ChatLogs"):FindFirstChild("Container")
		and NAStuff.NASCREENGUI:FindFirstChild("ChatLogs"):FindFirstChild("Container"):FindFirstChild("Logs");
	chatExample          = NAStuff.NASCREENGUI:FindFirstChild("ChatLogs")
		and NAStuff.NASCREENGUI:FindFirstChild("ChatLogs"):FindFirstChild("Container")
		and NAStuff.NASCREENGUI:FindFirstChild("ChatLogs"):FindFirstChild("Container"):FindFirstChild("Logs")
		and NAStuff.NASCREENGUI:FindFirstChild("ChatLogs"):FindFirstChild("Container"):FindFirstChild("Logs"):FindFirstChildWhichIsA("TextLabel");

	NAconsoleFrame       = NAStuff.NASCREENGUI:FindFirstChild("soRealConsole");
	NAconsoleLogs        = NAStuff.NASCREENGUI:FindFirstChild("soRealConsole")
		and NAStuff.NASCREENGUI:FindFirstChild("soRealConsole"):FindFirstChild("Container")
		and NAStuff.NASCREENGUI:FindFirstChild("soRealConsole"):FindFirstChild("Container"):FindFirstChild("Logs");
	NAconsoleExample     = NAStuff.NASCREENGUI:FindFirstChild("soRealConsole")
		and NAStuff.NASCREENGUI:FindFirstChild("soRealConsole"):FindFirstChild("Container")
		and NAStuff.NASCREENGUI:FindFirstChild("soRealConsole"):FindFirstChild("Container"):FindFirstChild("Logs")
		and NAStuff.NASCREENGUI:FindFirstChild("soRealConsole"):FindFirstChild("Container"):FindFirstChild("Logs"):FindFirstChildWhichIsA("TextLabel");
	NAcontainer          = NAStuff.NASCREENGUI:FindFirstChild("soRealConsole")
		and NAStuff.NASCREENGUI:FindFirstChild("soRealConsole"):FindFirstChild("Container");
	NAfilter             = NAStuff.NASCREENGUI:FindFirstChild("soRealConsole")
		and NAStuff.NASCREENGUI:FindFirstChild("soRealConsole"):FindFirstChild("Container")
		and NAStuff.NASCREENGUI:FindFirstChild("soRealConsole"):FindFirstChild("Container"):FindFirstChild("Filter");

	commandsFrame        = NAStuff.NASCREENGUI:FindFirstChild("Commands");
	commandsFilter       = NAStuff.NASCREENGUI:FindFirstChild("Commands")
		and NAStuff.NASCREENGUI:FindFirstChild("Commands"):FindFirstChild("Container")
		and NAStuff.NASCREENGUI:FindFirstChild("Commands"):FindFirstChild("Container"):FindFirstChild("Filter");
	commandsList         = NAStuff.NASCREENGUI:FindFirstChild("Commands")
		and NAStuff.NASCREENGUI:FindFirstChild("Commands"):FindFirstChild("Container")
		and NAStuff.NASCREENGUI:FindFirstChild("Commands"):FindFirstChild("Container"):FindFirstChild("List");
	commandExample       = NAStuff.NASCREENGUI:FindFirstChild("Commands")
		and NAStuff.NASCREENGUI:FindFirstChild("Commands"):FindFirstChild("Container")
		and NAStuff.NASCREENGUI:FindFirstChild("Commands"):FindFirstChild("Container"):FindFirstChild("List")
		and NAStuff.NASCREENGUI:FindFirstChild("Commands"):FindFirstChild("Container"):FindFirstChild("List"):FindFirstChild("TextLabel");

	resizeFrame          = NAStuff.NASCREENGUI:FindFirstChild("Resizeable");
	ModalFixer           = NAStuff.NASCREENGUI:FindFirstChildWhichIsA("ImageButton");

	SettingsFrame        = NAStuff.NASCREENGUI:FindFirstChild("setsettings");
	SettingsContainer    = NAStuff.NASCREENGUI:FindFirstChild("setsettings")
		and NAStuff.NASCREENGUI:FindFirstChild("setsettings"):FindFirstChild("Container");
	SettingsTabContainer = NAStuff.NASCREENGUI:FindFirstChild("setsettings")
		and NAStuff.NASCREENGUI:FindFirstChild("setsettings"):FindFirstChild("Container")
		and NAStuff.NASCREENGUI:FindFirstChild("setsettings"):FindFirstChild("Container"):FindFirstChild("TabContainer");
	SettingsTabs         = NAStuff.NASCREENGUI:FindFirstChild("setsettings")
		and NAStuff.NASCREENGUI:FindFirstChild("setsettings"):FindFirstChild("Container")
		and NAStuff.NASCREENGUI:FindFirstChild("setsettings"):FindFirstChild("Container"):FindFirstChild("TabContainer")
		and NAStuff.NASCREENGUI:FindFirstChild("setsettings"):FindFirstChild("Container"):FindFirstChild("TabContainer"):FindFirstChild("TabList");
	SettingsPages        = NAStuff.NASCREENGUI:FindFirstChild("setsettings")
		and NAStuff.NASCREENGUI:FindFirstChild("setsettings"):FindFirstChild("Container")
		and NAStuff.NASCREENGUI:FindFirstChild("setsettings"):FindFirstChild("Container"):FindFirstChild("TabContainer")
		and NAStuff.NASCREENGUI:FindFirstChild("setsettings"):FindFirstChild("Container"):FindFirstChild("TabContainer"):FindFirstChild("Pages");
	SettingsList         = NAStuff.NASCREENGUI:FindFirstChild("setsettings")
		and NAStuff.NASCREENGUI:FindFirstChild("setsettings"):FindFirstChild("Container")
		and NAStuff.NASCREENGUI:FindFirstChild("setsettings"):FindFirstChild("Container"):FindFirstChild("TabContainer")
		and NAStuff.NASCREENGUI:FindFirstChild("setsettings"):FindFirstChild("Container"):FindFirstChild("TabContainer"):FindFirstChild("Pages")
		and NAStuff.NASCREENGUI:FindFirstChild("setsettings"):FindFirstChild("Container"):FindFirstChild("TabContainer"):FindFirstChild("Pages"):FindFirstChild("List");
	SettingsTabButton    = NAStuff.NASCREENGUI:FindFirstChild("setsettings")
		and NAStuff.NASCREENGUI:FindFirstChild("setsettings"):FindFirstChild("Container")
		and NAStuff.NASCREENGUI:FindFirstChild("setsettings"):FindFirstChild("Container"):FindFirstChild("TabContainer")
		and NAStuff.NASCREENGUI:FindFirstChild("setsettings"):FindFirstChild("Container"):FindFirstChild("TabContainer"):FindFirstChild("TabList")
		and NAStuff.NASCREENGUI:FindFirstChild("setsettings"):FindFirstChild("Container"):FindFirstChild("TabContainer"):FindFirstChild("TabList"):FindFirstChild("TabButton");
	SettingsButton       = NAStuff.NASCREENGUI:FindFirstChild("setsettings")
		and NAStuff.NASCREENGUI:FindFirstChild("setsettings"):FindFirstChild("Container")
		and NAStuff.NASCREENGUI:FindFirstChild("setsettings"):FindFirstChild("Container"):FindFirstChild("TabContainer")
		and NAStuff.NASCREENGUI:FindFirstChild("setsettings"):FindFirstChild("Container"):FindFirstChild("TabContainer"):FindFirstChild("Pages")
		and NAStuff.NASCREENGUI:FindFirstChild("setsettings"):FindFirstChild("Container"):FindFirstChild("TabContainer"):FindFirstChild("Pages"):FindFirstChild("List")
		and NAStuff.NASCREENGUI:FindFirstChild("setsettings"):FindFirstChild("Container"):FindFirstChild("TabContainer"):FindFirstChild("Pages"):FindFirstChild("List"):FindFirstChild("Button");
	SettingsColorPicker  = NAStuff.NASCREENGUI:FindFirstChild("setsettings")
		and NAStuff.NASCREENGUI:FindFirstChild("setsettings"):FindFirstChild("Container")
		and NAStuff.NASCREENGUI:FindFirstChild("setsettings"):FindFirstChild("Container"):FindFirstChild("TabContainer")
		and NAStuff.NASCREENGUI:FindFirstChild("setsettings"):FindFirstChild("Container"):FindFirstChild("TabContainer"):FindFirstChild("Pages")
		and NAStuff.NASCREENGUI:FindFirstChild("setsettings"):FindFirstChild("Container"):FindFirstChild("TabContainer"):FindFirstChild("Pages"):FindFirstChild("List")
		and NAStuff.NASCREENGUI:FindFirstChild("setsettings"):FindFirstChild("Container"):FindFirstChild("TabContainer"):FindFirstChild("Pages"):FindFirstChild("List"):FindFirstChild("ColorPicker");
	SettingsSectionTitle = NAStuff.NASCREENGUI:FindFirstChild("setsettings")
		and NAStuff.NASCREENGUI:FindFirstChild("setsettings"):FindFirstChild("Container")
		and NAStuff.NASCREENGUI:FindFirstChild("setsettings"):FindFirstChild("Container"):FindFirstChild("TabContainer")
		and NAStuff.NASCREENGUI:FindFirstChild("setsettings"):FindFirstChild("Container"):FindFirstChild("TabContainer"):FindFirstChild("Pages")
		and NAStuff.NASCREENGUI:FindFirstChild("setsettings"):FindFirstChild("Container"):FindFirstChild("TabContainer"):FindFirstChild("Pages"):FindFirstChild("List")
		and NAStuff.NASCREENGUI:FindFirstChild("setsettings"):FindFirstChild("Container"):FindFirstChild("TabContainer"):FindFirstChild("Pages"):FindFirstChild("List"):FindFirstChild("SectionTitle");
	SettingsToggle       = NAStuff.NASCREENGUI:FindFirstChild("setsettings")
		and NAStuff.NASCREENGUI:FindFirstChild("setsettings"):FindFirstChild("Container")
		and NAStuff.NASCREENGUI:FindFirstChild("setsettings"):FindFirstChild("Container"):FindFirstChild("TabContainer")
		and NAStuff.NASCREENGUI:FindFirstChild("setsettings"):FindFirstChild("Container"):FindFirstChild("TabContainer"):FindFirstChild("Pages")
		and NAStuff.NASCREENGUI:FindFirstChild("setsettings"):FindFirstChild("Container"):FindFirstChild("TabContainer"):FindFirstChild("Pages"):FindFirstChild("List")
		and NAStuff.NASCREENGUI:FindFirstChild("setsettings"):FindFirstChild("Container"):FindFirstChild("TabContainer"):FindFirstChild("Pages"):FindFirstChild("List"):FindFirstChild("Toggle");
	SettingsInput        = NAStuff.NASCREENGUI:FindFirstChild("setsettings")
		and NAStuff.NASCREENGUI:FindFirstChild("setsettings"):FindFirstChild("Container")
		and NAStuff.NASCREENGUI:FindFirstChild("setsettings"):FindFirstChild("Container"):FindFirstChild("TabContainer")
		and NAStuff.NASCREENGUI:FindFirstChild("setsettings"):FindFirstChild("Container"):FindFirstChild("TabContainer"):FindFirstChild("Pages")
		and NAStuff.NASCREENGUI:FindFirstChild("setsettings"):FindFirstChild("Container"):FindFirstChild("TabContainer"):FindFirstChild("Pages"):FindFirstChild("List")
		and NAStuff.NASCREENGUI:FindFirstChild("setsettings"):FindFirstChild("Container"):FindFirstChild("TabContainer"):FindFirstChild("Pages"):FindFirstChild("List"):FindFirstChild("Input");
	SettingsKeybind      = NAStuff.NASCREENGUI:FindFirstChild("setsettings")
		and NAStuff.NASCREENGUI:FindFirstChild("setsettings"):FindFirstChild("Container")
		and NAStuff.NASCREENGUI:FindFirstChild("setsettings"):FindFirstChild("Container"):FindFirstChild("TabContainer")
		and NAStuff.NASCREENGUI:FindFirstChild("setsettings"):FindFirstChild("Container"):FindFirstChild("TabContainer"):FindFirstChild("Pages")
		and NAStuff.NASCREENGUI:FindFirstChild("setsettings"):FindFirstChild("Container"):FindFirstChild("TabContainer"):FindFirstChild("Pages"):FindFirstChild("List")
		and NAStuff.NASCREENGUI:FindFirstChild("setsettings"):FindFirstChild("Container"):FindFirstChild("TabContainer"):FindFirstChild("Pages"):FindFirstChild("List"):FindFirstChild("Keybind");
	SettingsSlider       = NAStuff.NASCREENGUI:FindFirstChild("setsettings")
		and NAStuff.NASCREENGUI:FindFirstChild("setsettings"):FindFirstChild("Container")
		and NAStuff.NASCREENGUI:FindFirstChild("setsettings"):FindFirstChild("Container"):FindFirstChild("TabContainer")
		and NAStuff.NASCREENGUI:FindFirstChild("setsettings"):FindFirstChild("Container"):FindFirstChild("TabContainer"):FindFirstChild("Pages")
		and NAStuff.NASCREENGUI:FindFirstChild("setsettings"):FindFirstChild("Container"):FindFirstChild("TabContainer"):FindFirstChild("Pages"):FindFirstChild("List")
		and NAStuff.NASCREENGUI:FindFirstChild("setsettings"):FindFirstChild("Container"):FindFirstChild("TabContainer"):FindFirstChild("Pages"):FindFirstChild("List"):FindFirstChild("Slider");
	WaypointFrame        = NAStuff.NASCREENGUI:FindFirstChild("SuchWaypoint");
	WaypointContainer    = NAStuff.NASCREENGUI:FindFirstChild("SuchWaypoint")
		and NAStuff.NASCREENGUI:FindFirstChild("SuchWaypoint"):FindFirstChild("Container");
	WaypointList         = NAStuff.NASCREENGUI:FindFirstChild("SuchWaypoint")
		and NAStuff.NASCREENGUI:FindFirstChild("SuchWaypoint"):FindFirstChild("Container")
		and NAStuff.NASCREENGUI:FindFirstChild("SuchWaypoint"):FindFirstChild("Container"):FindFirstChild("List");
	filterBox             = NAStuff.NASCREENGUI:FindFirstChild("SuchWaypoint")
		and NAStuff.NASCREENGUI:FindFirstChild("SuchWaypoint"):FindFirstChild("Container")
		and NAStuff.NASCREENGUI:FindFirstChild("SuchWaypoint"):FindFirstChild("Container"):FindFirstChildWhichIsA("TextBox");
	WPFrame       = NAStuff.NASCREENGUI:FindFirstChild("SuchWaypoint")
		and NAStuff.NASCREENGUI:FindFirstChild("SuchWaypoint"):FindFirstChild("Container")
		and NAStuff.NASCREENGUI:FindFirstChild("SuchWaypoint"):FindFirstChild("Container"):FindFirstChild("List")
		and NAStuff.NASCREENGUI:FindFirstChild("SuchWaypoint"):FindFirstChild("Container"):FindFirstChild("List"):FindFirstChild("WP");
	BindersFrame        = NAStuff.NASCREENGUI:FindFirstChild("binders");
	BindersContainer    = NAStuff.NASCREENGUI:FindFirstChild("binders")
		and NAStuff.NASCREENGUI:FindFirstChild("binders"):FindFirstChild("Container");
	BindersList         = NAStuff.NASCREENGUI:FindFirstChild("binders")
		and NAStuff.NASCREENGUI:FindFirstChild("binders"):FindFirstChild("Container")
		and NAStuff.NASCREENGUI:FindFirstChild("binders"):FindFirstChild("Container"):FindFirstChild("List");
}

originalIO.resizeCursors=function(key, fallback)
	if type(getcustomasset) ~= "function" then
		return fallback
	end

	if not (NAfiles and NAfiles.NAASSETSFILEPATH and NAImageAssets and NAImageAssets[key]) then
		return fallback
	end

	local suc, res = pcall(getcustomasset, NAfiles.NAASSETSFILEPATH.."/"..NAImageAssets[key])
	if suc and res then
		return res
	end

	return fallback
end

NAStuff.resizeVerticalAsset = originalIO.resizeCursors("ResizeVertical", "rbxassetid://2911850935")
NAStuff.resizeHorizontalAsset = originalIO.resizeCursors("ResizeHorizontal", "rbxassetid://2911851464")
NAStuff.resizeDiagonal1Asset = originalIO.resizeCursors("ResizeDiagonal1", "rbxassetid://2911851859")
NAStuff.resizeDiagonal2Asset = originalIO.resizeCursors("ResizeDiagonal2", "rbxassetid://2911852219")

local resizeXY={
	Top = {Vector2.new(0,-1),    Vector2.new(0,-1),    NAStuff.resizeVerticalAsset}, -- Vertical16x16.png
	Bottom = {Vector2.new(0,1),    Vector2.new(0,0),    NAStuff.resizeVerticalAsset}, -- Vertical16x16.png
	Left = {Vector2.new(-1,0),    Vector2.new(1,0),    NAStuff.resizeHorizontalAsset}, -- Horizontal16x16.png
	Right = {Vector2.new(1,0),    Vector2.new(0,0),    NAStuff.resizeHorizontalAsset}, -- Horizontal16x16.png

	TopLeft = {Vector2.new(-1,-1),    Vector2.new(1,-1),    NAStuff.resizeDiagonal2Asset}, -- Diagonal216x16.png
	TopRight = {Vector2.new(1,-1),    Vector2.new(0,-1),    NAStuff.resizeDiagonal1Asset}, -- Diagonal116x16.png
	BottomLeft = {Vector2.new(-1,1),    Vector2.new(1,0),    NAStuff.resizeDiagonal1Asset}, -- Diagonal116x16.png
	BottomRight = {Vector2.new(1,1),    Vector2.new(0,0),    NAStuff.resizeDiagonal2Asset}, -- Diagonal216x16.png
}

local fillSizes={
	right=NAUIMANAGER.rightFill.Size,
	left=NAUIMANAGER.leftFill.Size,
}

if NAUIMANAGER.cmdExample then
	NAUIMANAGER.cmdExample.Parent = nil
end

if NAUIMANAGER.chatExample then
	NAUIMANAGER.chatExample.Parent = nil
end

if NAUIMANAGER.NAconsoleExample then
	NAUIMANAGER.NAconsoleExample.Parent = nil
end

if NAUIMANAGER.commandExample then
	NAUIMANAGER.commandExample.Parent = nil
end

if NAUIMANAGER.resizeFrame then
	NAUIMANAGER.resizeFrame.Parent = nil
end

if NAUIMANAGER.SettingsButton then
	NAUIMANAGER.SettingsButton.Parent = nil
end

if NAUIMANAGER.SettingsColorPicker then
	NAUIMANAGER.SettingsColorPicker.Parent = nil
end

if NAUIMANAGER.SettingsSectionTitle then
	NAUIMANAGER.SettingsSectionTitle.Parent = nil
end

if NAUIMANAGER.SettingsToggle then
	NAUIMANAGER.SettingsToggle.Parent = nil
end

if NAUIMANAGER.SettingsInput then
	NAUIMANAGER.SettingsInput.Parent = nil
end

if NAUIMANAGER.SettingsKeybind then
	NAUIMANAGER.SettingsKeybind.Parent = nil
end

if NAUIMANAGER.SettingsSlider then
	NAUIMANAGER.SettingsSlider.Parent = nil
end

if NAUIMANAGER.SettingsTabButton then
	NAUIMANAGER.SettingsTabButton.Parent = nil
end

if NAUIMANAGER.WPFrame then
	NAUIMANAGER.WPFrame.Parent = nil
end

local templates = {
	Button = NAUIMANAGER.SettingsButton;
	ColorPicker = NAUIMANAGER.SettingsColorPicker;
	SectionTitle = NAUIMANAGER.SettingsSectionTitle;
	Toggle = NAUIMANAGER.SettingsToggle;
	Input = NAUIMANAGER.SettingsInput;
	Keybind = NAUIMANAGER.SettingsKeybind;
	Slider = NAUIMANAGER.SettingsSlider;
	WaypointerFrame = NAUIMANAGER.WPFrame;
}

local TabManager = {
	holder = NAUIMANAGER.SettingsTabs;
	container = NAUIMANAGER.SettingsPages;
	template = NAUIMANAGER.SettingsTabButton;
	defaultPage = NAUIMANAGER.SettingsList;
	tabs = {};
	order = {};
	current = nil;
	fallback = nil;
	fallbackIndex = 0;
}

local tabsLayout = TabManager.holder and (TabManager.holder:FindFirstChildWhichIsA("UIListLayout") or TabManager.holder:FindFirstChildWhichIsA("UIGridLayout"))
if tabsLayout and tabsLayout.SortOrder ~= Enum.SortOrder.LayoutOrder then
	pcall(function()
		tabsLayout.SortOrder = Enum.SortOrder.LayoutOrder
	end)
end

if TabManager.template then
	TabManager.template.Visible = false
end

if TabManager.defaultPage then
	local maxOrder = 0
	for _, child in ipairs(TabManager.defaultPage:GetChildren()) do
		if child:IsA("GuiObject") and child.Name ~= "UIListLayout" then
			maxOrder = math.max(maxOrder, child.LayoutOrder or 0)
		end
	end

	TabManager.pageTemplate = TabManager.defaultPage:Clone()
	TabManager.pageTemplate.Name = "TabPageTemplate"
	TabManager.pageTemplate.CanvasPosition = Vector2.new(0, 0)
	TabManager.pageTemplate.Parent = nil

	TabManager.fallback = {
		page = TabManager.defaultPage;
		layoutIndex = maxOrder;
	}
	TabManager.fallbackIndex = maxOrder
	TabManager.defaultPage.Visible = true
end

NAmanage.registerElementForCurrentTab=function(instance)
	if not instance then
		return
	end
	local currentName = TabManager.current
	if not currentName or (TAB_ALL and currentName == TAB_ALL) then
		return
	end
	if not NAStuff.elementOriginalParent[instance] then
		NAStuff.elementOriginalParent[instance] = instance.Parent
	end
	pcall(function()
		instance:SetAttribute("NAOriginalTab", currentName)
	end)
end

NAmanage.clearAllTabWrappers=function(page)
	if not page then return end
	for _, child in ipairs(page:GetChildren()) do
		if child:IsA("GuiObject") and child:GetAttribute("NAAllWrapper") then
			for _, element in ipairs(child:GetChildren()) do
				if element:IsA("GuiObject") then
					local originalParent = NAStuff.elementOriginalParent[element]
					if not originalParent then
						local originalTab = element:GetAttribute("NAOriginalTab")
						if originalTab and TabManager.tabs then
							local info = TabManager.tabs[originalTab]
							originalParent = info and info.page
						end
					end
					originalParent = originalParent or page
					local origOrder = element:GetAttribute("NAOrigOrder")
					if typeof(origOrder) == "number" then
						element.LayoutOrder = origOrder
					end
					if element.Parent ~= originalParent then
						element.Parent = originalParent
					end
				end
			end
			child:Destroy()
		end
	end
end

NAmanage.restoreAllTabElements=function()
	local allInfo = (TabManager.tabs and TAB_ALL) and TabManager.tabs[TAB_ALL] or nil
	if allInfo and allInfo.page then
		NAmanage.clearAllTabWrappers(allInfo.page)
	end
end

NAmanage.collectTabElements=function(tabInfo, tabName)
	local elements = {}
	if not tabInfo or not tabInfo.page then
		return elements
	end
	for _, child in ipairs(tabInfo.page:GetChildren()) do
		if child:IsA("GuiObject")
			and not child:GetAttribute("NAAllWrapper")
			and not child:IsA("UIListLayout")
			and not child:IsA("UIPadding")
			and not child:IsA("UIPageLayout") then
			Insert(elements, child)
		end
	end
	table.sort(elements, function(a, b)
		return (a.LayoutOrder or 0) < (b.LayoutOrder or 0)
	end)
	tabInfo.elements = elements
	for _, element in ipairs(elements) do
		if not NAStuff.elementOriginalParent[element] then
			NAStuff.elementOriginalParent[element] = tabInfo.page
		end
		pcall(function()
			element:SetAttribute("NAOriginalTab", tabName)
		end)
	end
	return elements
end

NAmanage.prepareAllTabDisplay=function(allInfo)
	if not allInfo or not allInfo.page then return end
	NAmanage.clearAllTabWrappers(allInfo.page)

	local page = allInfo.page
	local layout = page:FindFirstChildWhichIsA("UIListLayout")
	if not layout then
		layout = InstanceNew("UIListLayout")
		layout.FillDirection = Enum.FillDirection.Vertical
		layout.SortOrder = Enum.SortOrder.LayoutOrder
		layout.Padding = UDim.new(0, 10)
		layout.Parent = page
	else
		layout.SortOrder = Enum.SortOrder.LayoutOrder
	end
	if page:IsA("ScrollingFrame") then
		page.AutomaticCanvasSize = Enum.AutomaticSize.Y
		page.CanvasPosition = Vector2.new(0, 0)
	end

	local merged = InstanceNew("Frame")
	merged.Name = "NAAllMerged"
	merged.BackgroundTransparency = 1
	merged.Size = UDim2.new(1, 0, 0, 0)
	merged.AutomaticSize = Enum.AutomaticSize.Y
	merged.LayoutOrder = -1
	merged:SetAttribute("NAAllWrapper", true)
	merged.Parent = page

	local ml = InstanceNew("UIListLayout")
	ml.FillDirection = Enum.FillDirection.Vertical
	ml.SortOrder = Enum.SortOrder.LayoutOrder
	ml.Padding = UDim.new(0, 6)
	ml.Parent = merged

	local cursor = 0
	for _, tabName in ipairs(TabManager.order) do
		if tabName ~= TAB_ALL then
			local tabInfo = TabManager.tabs[tabName]
			if tabInfo and tabInfo.page then
				local elements = NAmanage.collectTabElements(tabInfo, tabName)
				for _, element in ipairs(elements) do
					if element:GetAttribute("NAOrigOrder") == nil then
						element:SetAttribute("NAOrigOrder", element.LayoutOrder or 0)
					end
					element.LayoutOrder = cursor
					cursor += 1
					if element.Parent ~= merged then
						element.Parent = merged
					end
				end
			end
		end
	end
end

NAmanage.updateTabVisual=function(tabInfo, isActive)
	if not tabInfo or not tabInfo.button then
		return
	end
	local btn = tabInfo.button
	btn.BackgroundTransparency = isActive and 0.1 or 0.25
	local stroke = btn:FindFirstChildWhichIsA("UIStroke", true)
	if stroke then
		NAgui.RegisterColoredStroke(stroke)
		local computeColor = NAmanage.getTabStrokeColor
		if typeof(computeColor) == "function" then
			stroke.Color = computeColor(isActive)
		else
			stroke.Color = NAUISTROKER or DEFAULT_UI_STROKE_COLOR
		end
	end
	local title = btn:FindFirstChild("Title")
	if title then
		title.TextColor3 = isActive and Color3.fromRGB(255, 255, 255) or Color3.fromRGB(234, 234, 244)
		if tabInfo.displayName then
			title.Text = tabInfo.displayName
		end
	end
end

NAgui.getActiveTab=function()
	return TabManager.current
end

NAgui._nextLayoutOrder=function()
	local active = TabManager.current and TabManager.tabs[TabManager.current]
	if active then
		active.layoutIndex = (active.layoutIndex or 0) + 1
		return active.layoutIndex
	elseif TabManager.fallback then
		TabManager.fallback.layoutIndex = (TabManager.fallback.layoutIndex or 0) + 1
		TabManager.fallbackIndex = TabManager.fallback.layoutIndex
		return TabManager.fallback.layoutIndex
	else
		TabManager.fallbackIndex = (TabManager.fallbackIndex or 0) + 1
		return TabManager.fallbackIndex
	end
end

NAgui.setTab=function(name)
	local info = name and TabManager.tabs[name]
	if not info then
		return nil
	end

	local previousTab = TabManager.current
	if previousTab == TAB_ALL and name ~= TAB_ALL then
		NAmanage.restoreAllTabElements()
	end

	TabManager.current = name
	if name == TAB_BASIC_INFO and NAgui.RefreshBasicInfo then
		pcall(NAgui.RefreshBasicInfo)
	end
	if info.page then
		NAUIMANAGER.SettingsList = info.page
	end

	for tabName, tabInfo in pairs(TabManager.tabs) do
		local isActive = tabName == name
		if tabInfo.page then
			tabInfo.page.Visible = isActive
		end
		NAmanage.updateTabVisual(tabInfo, isActive)
	end

	if name == TAB_ALL then
		NAmanage.prepareAllTabDisplay(info)
	end

	return info.page
end

NAgui.addTab=function(name, options)
	if type(name) ~= "string" or name == "" then
		return nil
	end
	if TabManager.tabs[name] then
		if options and options.default then
			NAgui.setTab(name)
		end
		return TabManager.tabs[name]
	end

	local displayName = (options and options.displayText) or name
	local button
	local layoutOrder = options and options.order or (#TabManager.order + 1)
	if TabManager.holder then
		local holderLayout = TabManager.holder:FindFirstChildWhichIsA("UIListLayout") or TabManager.holder:FindFirstChildWhichIsA("UIGridLayout")
		if holderLayout then
			pcall(function() holderLayout.SortOrder = Enum.SortOrder.LayoutOrder end)
		end
	end
	if TabManager.template and TabManager.holder then
		button = TabManager.template:Clone()
		button.Visible = true
		button.Name = name.."Tab"
		local title = button:FindFirstChild("Title")
		if title then
			title.Text = displayName
		end
		button.LayoutOrder = layoutOrder
		button.Parent = TabManager.holder
		NAgui.RegisterStrokesFrom(button)
		local interact = button:FindFirstChild("Interact") or button
		MouseButtonFix(interact, function()
			NAgui.setTab(name)
		end)
	end

	local info
	if TabManager.fallback and TabManager.fallback.page then
		info = {
			name = name;
			displayName = displayName;
			page = TabManager.fallback.page;
			button = button;
			layoutIndex = TabManager.fallback.layoutIndex or 0;
		}
		TabManager.fallback = nil
	else
		local pageTemplate = TabManager.pageTemplate
		local page = pageTemplate and pageTemplate:Clone() or (TabManager.defaultPage and TabManager.defaultPage:Clone()) or InstanceNew("ScrollingFrame")
		page.Name = name.."Page"
		page.Visible = false
		page.CanvasPosition = Vector2.new(0, 0)
		if not page:FindFirstChildWhichIsA("UIListLayout") and TabManager.defaultPage then
			local layout = TabManager.defaultPage:FindFirstChildWhichIsA("UIListLayout")
			if layout then
				layout:Clone().Parent = page
			end
		end
		page.Parent = TabManager.container or (TabManager.defaultPage and TabManager.defaultPage.Parent)
		info = {
			name = name;
			displayName = displayName;
			page = page;
			button = button;
			layoutIndex = 0;
		}
	end

	if info.page then
		NAgui.RegisterStrokesFrom(info.page)
	end

	info.order = layoutOrder
	info.elements = info.elements or {}
	TabManager.tabs[name] = info
	Insert(TabManager.order, name)
	table.sort(TabManager.order, function(a, b)
		local infoA = TabManager.tabs[a]
		local infoB = TabManager.tabs[b]
		local orderA = infoA and infoA.order or math.huge
		local orderB = infoB and infoB.order or math.huge
		if orderA == orderB then
			return tostring(a) < tostring(b)
		end
		return orderA < orderB
	end)
	for _, orderedName in ipairs(TabManager.order) do
		local tab = TabManager.tabs[orderedName]
		if tab and tab.button then
			tab.button.LayoutOrder = tab.order or layoutOrder
		end
	end

	local shouldSet = (options and options.default) or not TabManager.current
	if shouldSet then
		NAgui.setTab(name)
	else
		if info.page then
			info.page.Visible = false
		end
		NAmanage.updateTabVisual(info, false)
	end

	return info
end

SpawnCall(function()
	for _,v in ipairs(NAStuff.NASCREENGUI:GetDescendants()) do
		if v:IsA("UIStroke") then
			NAgui.RegisterColoredStroke(v)
		end
	end
end)

local predictionInput = NAUIMANAGER.cmdInput:Clone()
predictionInput.Name = "predictionInput"
predictionInput.TextEditable = false
predictionInput.TextTransparency = 1
predictionInput.TextColor3 = Color3.fromRGB(180, 180, 180)
predictionInput.BackgroundTransparency = 1
predictionInput.ZIndex = NAUIMANAGER.cmdInput.ZIndex + 1
predictionInput.Parent = NAUIMANAGER.cmdInput.Parent
predictionInput.PlaceholderText = ""

opt.NAAUTOSCALER = NAUIMANAGER.AUTOSCALER

	--[[NACaller(function()
		for i,v in pairs(NAStuff.NASCREENGUI:GetDescendants()) do
			coreGuiProtection[v]=rPlayer.Name
		end
		NAStuff.NASCREENGUI.DescendantAdded:Connect(function(v)
			coreGuiProtection[v]=rPlayer.Name
		end)
		coreGuiProtection[NAStuff.NASCREENGUI]=rPlayer.Name
	
		local meta=getrawmetatable(game)
		local tostr=meta.__tostring
		setreadonly(meta,false)
		meta.__tostring=newcclosure(function(t)
			if coreGuiProtection[t] and not checkcaller() then
				return coreGuiProtection[t]
			end
			return tostr(t)
		end)
	end)
	if not RunService:IsStudio() then
		local newGui=COREGUI:FindFirstChildWhichIsA("NAStuff.NASCREENGUI")
		newGui.DescendantAdded:Connect(function(v)
			coreGuiProtection[v]=rPlayer.Name
		end)
		for i,v in pairs(NAStuff.NASCREENGUI:GetChildren()) do
			v.Parent=newGui
		end
		NAStuff.NASCREENGUI=newGui
	end]]

cmd.add({"rename"}, {"rename <text>", "Renames the admin UI placeholder to the given name"}, function(...)
	local newName = Concat({...}, " ")
	adminName = newName
	if NAUIMANAGER.cmdInput and NAUIMANAGER.cmdInput.PlaceholderText then
		NAUIMANAGER.cmdInput.PlaceholderText = newName
	end
	if NAmanage.UpdateAdminInfoTabDisplayName then
		NAmanage.UpdateAdminInfoTabDisplayName()
	end
end, true)

cmd.add({"unname"}, {"unname", "Resets the admin UI placeholder name to default"}, function()
	adminName = getgenv().NATestingVer and "NA Testing" or "Nameless Admin"
	if NAUIMANAGER.cmdInput and NAUIMANAGER.cmdInput.PlaceholderText then
		NAUIMANAGER.cmdInput.PlaceholderText = isAprilFools() and '🤡 '..adminName..curVer..' 🤡' or getSeasonEmoji()..' '..adminName..curVer..' '..getSeasonEmoji()
	end
	if NAmanage.UpdateAdminInfoTabDisplayName then
		NAmanage.UpdateAdminInfoTabDisplayName()
	end
end)

--[[ GUI FUNCTIONS ]]--
NAgui.txtSize=function(ui,x,y)
	local textService=TextService
	return textService:GetTextSize(ui.Text,ui.TextSize,ui.Font,Vector2.new(x,y))
end
NAgui.commands = function()
	local cFrame, cList = NAUIMANAGER.commandsFrame, NAUIMANAGER.commandsList

	if not cFrame.Visible then
		cFrame.Visible = true
		cList.CanvasSize = UDim2.new(0, 0, 0, 0)
	end

	for _, v in ipairs(cList:GetChildren()) do
		if v:IsA("TextLabel") then v:Destroy() end
	end

	local yOffset = 5
	for cmdName, tbl in pairs(cmds.Commands) do
		local Cmd = NAUIMANAGER.commandExample:Clone()
		Cmd.Parent = cList
		Cmd.Name = cmdName
		local displayText = fixStupidSearchGoober(cmdName, tbl)
		if displayText and displayText ~= "" then
			if type(tbl[2]) == "table" then
				tbl[2][1] = displayText
			end
		else
			displayText = (type(tbl[2]) == "table" and tbl[2][1]) or cmdName
		end
		Cmd.Text = " "..displayText
		Cmd.Position = UDim2.new(0, 0, 0, yOffset)

		Cmd.MouseEnter:Connect(function()
			NAUIMANAGER.description.Visible = true
			NAUIMANAGER.description.Text = tbl[2][2]
		end)

		Cmd.MouseLeave:Connect(function()
			if NAUIMANAGER.description.Text == tbl[2][2] then
				NAUIMANAGER.description.Visible = false
				NAUIMANAGER.description.Text = ""
			end
		end)

		yOffset = yOffset + 20
	end

	cList.CanvasSize = UDim2.new(0, 0, 0, yOffset)
	--cFrame.Position = UDim2.new(0.43, 0, 0.4, 0)
	NAmanage.centerFrame(cFrame)
	if NAgui.filterCommandList then
		NAgui.filterCommandList(NAUIMANAGER.commandsFilter and NAUIMANAGER.commandsFilter.Text or "")
	end
end
NAgui.chatlogs = function()
	if NAUIMANAGER.chatLogsFrame then
		if not NAUIMANAGER.chatLogsFrame.Visible then
			NAUIMANAGER.chatLogsFrame.Visible = true
		end
		--NAUIMANAGER.chatLogsFrame.Position = UDim2.new(0.43, 0, 0.4, 0)
		NAmanage.centerFrame(NAUIMANAGER.chatLogsFrame)
	end
end
NAgui.doModal = function(v)
	NAUIMANAGER.ModalFixer.Modal = v
end
NAgui.consoleeee = function()
	if NAUIMANAGER.NAconsoleFrame then
		if not NAUIMANAGER.NAconsoleFrame.Visible then
			NAUIMANAGER.NAconsoleFrame.Visible = true
		end
		--NAUIMANAGER.NAconsoleFrame.Position = UDim2.new(0.43, 0, 0.4, 0)
		NAmanage.centerFrame(NAUIMANAGER.NAconsoleFrame)
	end
end
NAgui.settingss = function()
	if NAUIMANAGER.SettingsFrame then
		if not NAUIMANAGER.SettingsFrame.Visible then
			NAUIMANAGER.SettingsFrame.Visible = true
		end
		--NAUIMANAGER.SettingsFrame.Position = UDim2.new(0.43, 0, 0.4, 0)
		NAmanage.centerFrame(NAUIMANAGER.SettingsFrame)
	end
end
NAgui.waypointers = function()
	if NAUIMANAGER.WaypointFrame then
		if not NAUIMANAGER.WaypointFrame.Visible then
			NAUIMANAGER.WaypointFrame.Visible = true
		end
		--NAUIMANAGER.WaypointFrame.Position = UDim2.new(0.43, 0, 0.4, 0)
		NAmanage.centerFrame(NAUIMANAGER.WaypointFrame)
	end
end
NAgui.eventbinders = function()
	if NAUIMANAGER.BindersFrame then
		if not NAUIMANAGER.BindersFrame.Visible then
			NAUIMANAGER.BindersFrame.Visible = true
		end
		--NAUIMANAGER.BindersFrame.Position = UDim2.new(0.43, 0, 0.4, 0)
		NAmanage.centerFrame(NAUIMANAGER.BindersFrame)
	end
end
NAgui.tween = function(obj, style, direction, duration, goal, callback)
	style = style or "Sine"
	direction = direction or "Out"
	local tweenInfo = TweenInfo.new(duration, Enum.EasingStyle[style], Enum.EasingDirection[direction])
	local tween = TweenService:Create(obj, tweenInfo, goal)
	if callback then tween.Completed:Connect(callback) end
	tween:Play()
	return tween
end
NAgui.resizeable = function(ui, min, max)
	if not ui or not ui:IsA("GuiObject") then return function() end end
	min = min or Vector2.new(ui.AbsoluteSize.X, ui.AbsoluteSize.Y)
	max = max or Vector2.new(5000, 5000)

	local screenGui = ui:FindFirstAncestorWhichIsA("ScreenGui") or ui:FindFirstAncestorWhichIsA("LayerCollector") or ui.Parent
	local scale = (NAUIMANAGER.AUTOSCALER and NAUIMANAGER.AUTOSCALER.Scale) or 1

	local rgui = NAUIMANAGER.resizeFrame and NAUIMANAGER.resizeFrame:Clone()
	if not rgui then return function() end end
	rgui.Parent = ui

	local dragging = false
	local mode
	local UIPos
	local lastSize
	local lastPos = Vector2.new()
	local dragInput
	local dragEndedConn

	local function updateResize(currentPos)
		local ok, err = pcall(function()
			if not dragging or not mode or not screenGui or not screenGui.AbsoluteSize then return end
			local map = resizeXY and resizeXY[mode.Name]
			if not map then return end

			local parentSize = screenGui.AbsoluteSize
			local delta = (currentPos - lastPos) / scale

			local resizeDelta = Vector2.new(delta.X * map[1].X, delta.Y * map[1].Y)
			local newSize = Vector2.new(
				math.clamp(lastSize.X + resizeDelta.X, min.X, max.X),
				math.clamp(lastSize.Y + resizeDelta.Y, min.Y, max.Y)
			)

			ui.Size = UDim2.new(0, newSize.X, 0, newSize.Y)

			local dx = (lastSize.X - newSize.X) / parentSize.X
			local dy = (lastSize.Y - newSize.Y) / parentSize.Y

			local sx = UIPos.X.Scale
			local sy = UIPos.Y.Scale
			if map[1].X < 0 then sx = sx + dx end
			if map[1].Y < 0 then sy = sy + dy end

			ui.Position = UDim2.new(sx, 0, sy, 0)
		end)
		if not ok then warn("Resize update failed:", err) end
	end

	pcall(function()
		UserInputService.InputChanged:Connect(function(input)
			pcall(function()
				if dragging and (input == dragInput or input.UserInputType == Enum.UserInputType.MouseMovement) then
					updateResize(Vector2.new(input.Position.X, input.Position.Y))
				end
			end)
		end)
	end)

	pcall(function()
		UserInputService.InputEnded:Connect(function(input)
			pcall(function()
				if dragging and input == dragInput then
					dragging = false
					mode = nil
					dragInput = nil
					if dragEndedConn then dragEndedConn:Disconnect() dragEndedConn = nil end
					if mouse and mouse.Icon ~= "" then mouse.Icon = "" end
				end
			end)
		end)
	end)

	for _, button in ipairs(rgui:GetChildren()) do
		if button:IsA("GuiObject") then
			button.Active = true
			pcall(function()
				button.InputBegan:Connect(function(input)
					pcall(function()
						if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
							mode = button
							dragging = true
							local p = input.Position
							lastPos = Vector2.new(p.X, p.Y)
							lastSize = ui.AbsoluteSize
							UIPos = ui.Position
							dragInput = input
							if dragEndedConn then dragEndedConn:Disconnect() end
							dragEndedConn = input.Changed:Connect(function()
								if input.UserInputState == Enum.UserInputState.End then
									dragging = false
									mode = nil
									dragInput = nil
									if dragEndedConn then dragEndedConn:Disconnect() dragEndedConn = nil end
									if mouse and resizeXY and resizeXY[button.Name] and mouse.Icon == resizeXY[button.Name][3] then
										mouse.Icon = ""
									end
								end
							end)
						end
					end)
				end)
			end)

			pcall(function()
				button.InputChanged:Connect(function(input)
					pcall(function()
						if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
							dragInput = input
						end
					end)
				end)
			end)

			pcall(function()
				button.InputEnded:Connect(function(input)
					pcall(function()
						if input == dragInput and mode == button and input.UserInputState == Enum.UserInputState.End then
							dragging = false
							mode = nil
							dragInput = nil
							if dragEndedConn then dragEndedConn:Disconnect() dragEndedConn = nil end
							if mouse and resizeXY and resizeXY[button.Name] and mouse.Icon == resizeXY[button.Name][3] then
								mouse.Icon = ""
							end
						end
					end)
				end)
			end)

			pcall(function()
				button.MouseEnter:Connect(function()
					pcall(function()
						if resizeXY and resizeXY[button.Name] and mouse then
							mouse.Icon = resizeXY[button.Name][3]
						end
					end)
				end)
			end)

			pcall(function()
				button.MouseLeave:Connect(function()
					pcall(function()
						if not dragging and resizeXY and resizeXY[button.Name] and mouse and mouse.Icon == resizeXY[button.Name][3] then
							mouse.Icon = ""
						end
					end)
				end)
			end)
		end
	end

	return function()
		pcall(function() if dragEndedConn then dragEndedConn:Disconnect() end end)
		pcall(function() rgui:Destroy() end)
	end
end
NAmanage.UpdateWaypointList=function()
	local list = NAUIMANAGER.WaypointList
	local rawFilter = NAUIMANAGER.filterBox and NAUIMANAGER.filterBox.Text or ""
	local filterText = rawFilter:lower()
	for _, child in ipairs(list:GetChildren()) do
		if not child:IsA("UIListLayout") then
			child:Destroy()
		end
	end
	for name, entry in pairs(Waypoints) do
		if filterText == "" or name:lower():find(filterText, 1, true) then
			local row = NAUIMANAGER.WPFrame:Clone()
			row.Name = name
			row.Parent = list
			local nameBtn = row:FindFirstChildWhichIsA("TextButton")
			if nameBtn then nameBtn.Text = name end
			local actionFrame = row:FindFirstChildWhichIsA("Frame")
			if actionFrame then
				local copyBtn = actionFrame:FindFirstChild("CopyBtn")
				local delBtn = actionFrame:FindFirstChild("DelBtn")
				local tpBtn = actionFrame:FindFirstChild("TPBtn")
				if copyBtn then
					copyBtn.MouseButton1Click:Connect(function()
						local comps = entry.Components
						if type(comps) ~= "table" then
							return DebugNotif("Waypoint data missing", 3)
						end
						local posX, posY, posZ = comps[1], comps[2], comps[3]
						if type(posX) ~= "number" or type(posY) ~= "number" or type(posZ) ~= "number" then
							return DebugNotif("Waypoint position is invalid", 3)
						end
						local copyText = Format("%f, %f, %f", posX, posY, posZ)
						if setclipboard then
							pcall(setclipboard, copyText)
							DebugNotif("Copied "..name)
						else
							DebugNotif("Copy not supported")
						end
					end)
				end
				if delBtn then
					delBtn.MouseButton1Click:Connect(function()
						Waypoints[name] = nil
						NAmanage.SaveWaypoints()
						NAmanage.UpdateWaypointList()
						DebugNotif("Removed '"..name.."'")
					end)
				end
				if tpBtn then
					tpBtn.MouseButton1Click:Connect(function()
						local comps = entry.Components
						local cf = CFrame.new(unpack(comps))
						local char = getChar()
						if char then
							char:PivotTo(cf)
						end
					end)
				end
			end
		end
	end
end

NAgui.addButton = function(label, callback)
	if not NAUIMANAGER.SettingsList then return end
	local button = templates.Button:Clone()
	button.Title.Text = label
	button.Parent = NAUIMANAGER.SettingsList
	button.LayoutOrder = NAgui._nextLayoutOrder()
	NAmanage.registerElementForCurrentTab(button)
	if NAgui.RegisterStrokesFrom then
		NAgui.RegisterStrokesFrom(button)
	end

	MouseButtonFix(button.Interact,function()
		pcall(callback)
	end)
end

NAgui.addSection = function(titleText)
	if not NAUIMANAGER.SettingsList then return end
	local section = templates.SectionTitle:Clone()
	section.Title.Text = titleText
	section.Parent = NAUIMANAGER.SettingsList
	section.LayoutOrder = NAgui._nextLayoutOrder()
	NAmanage.registerElementForCurrentTab(section)
	if NAgui.RegisterStrokesFrom then
		NAgui.RegisterStrokesFrom(section)
	end
end

NAgui.addInfo = function(label, value)
	if not NAUIMANAGER.SettingsList then return nil end
	local info = templates.Input:Clone()
	info.Title.Text = label
	info.Parent = NAUIMANAGER.SettingsList
	info.LayoutOrder = NAgui._nextLayoutOrder()
	NAmanage.registerElementForCurrentTab(info)
	if NAgui.RegisterStrokesFrom then
		NAgui.RegisterStrokesFrom(info)
	end

	local frame = info.InputFrame
	if not frame then
		return nil
	end

	local box = frame.InputBox
	if not box then
		return nil
	end

	local baseSize = frame.Size

	box.Text = value or ""
	box.PlaceholderText = ""
	box.ClearTextOnFocus = false
	box.TextEditable = false
	box.Active = false
	box.Selectable = false
	box.CursorPosition = -1

	box.Focused:Connect(function()
		box:ReleaseFocus()
	end)

	local updateSize = function()
		if frame:GetAttribute("NASkipAutoSize") then
			frame.Size = baseSize
			return
		end

		local width = box.TextBounds.X + 24
		if width <= 24 then
			local prev = frame:GetAttribute("NALastWidth")
			if typeof(prev) == "number" and prev > 0 then
				width = prev
			end
		end
		local minWidth = frame:GetAttribute("NAMinWidth")
		if typeof(minWidth) == "number" then
			width = math.max(width, minWidth)
		end

		frame.Size = UDim2.new(0, width, 0, 30)
		frame:SetAttribute("NALastWidth", width)
	end

	box:GetPropertyChangedSignal("Text"):Connect(updateSize)
	frame:SetAttribute("NALastWidth", frame.AbsoluteSize.X > 0 and frame.AbsoluteSize.X or nil)
	updateSize()

	local interact = frame:FindFirstChild("Interact")
	if interact then
		interact.Visible = false
	end

	return box, info
end

NAgui._toggleRegistry = NAgui._toggleRegistry or {}
NAgui._colorPickerRegistry = NAgui._colorPickerRegistry or {}
NAgui._sliderRegistry = NAgui._sliderRegistry or {}
NAgui._inputRegistry = NAgui._inputRegistry or {}

NAgui.addToggle = function(label, defaultValue, callback)
	if not NAUIMANAGER.SettingsList then return end
	local toggle = templates.Toggle:Clone()
	local switch = toggle:FindFirstChild("Switch")
	local indicator = switch and switch:FindFirstChild("Indicator")
	local stroke = indicator and indicator:FindFirstChild("UIStroke")

	toggle.Title.Text = label
	toggle.Parent = NAUIMANAGER.SettingsList
	toggle.LayoutOrder = NAgui._nextLayoutOrder()
	NAmanage.registerElementForCurrentTab(toggle)

	local state = defaultValue and true or false

	local function updateVisual()
		if state then
			indicator.Position = UDim2.new(1, -20, 0.5, 0)
			indicator.BackgroundColor3 = Color3.fromRGB(60, 200, 80)
			stroke.Color = Color3.fromRGB(50, 255, 80)
		else
			indicator.Position = UDim2.new(1, -40, 0.5, 0)
			indicator.BackgroundColor3 = Color3.fromRGB(111, 111, 121)
			stroke.Color = Color3.fromRGB(80, 80, 80)
		end
	end

	local function setState(newValue, opts)
		opts = opts or {}
		local desired = newValue and true or false
		if not opts.force and state == desired then
			if opts.fire then
				pcall(callback, state)
			end
			return
		end
		state = desired
		updateVisual()
		if opts.fire ~= false then
			pcall(callback, state)
		end
	end

	setState(state, { force = true, fire = false })

	MouseButtonFix(toggle.Interact,function()
		setState(not state, { force = true, fire = true })
	end)

	local entry = {
		button = toggle;
		get = function()
			return state
		end;
		set = function(value, opts)
			opts = opts or {}
			if opts.force == nil then opts.force = true end
			setState(value, opts)
		end;
	}
	NAgui._toggleRegistry[label] = entry

	toggle:GetPropertyChangedSignal("Parent"):Connect(function()
		if not toggle.Parent and NAgui._toggleRegistry[label] == entry then
			NAgui._toggleRegistry[label] = nil
		end
	end)

	return toggle
end

NAgui.setToggleState = function(label, value, opts)
	local entry = NAgui._toggleRegistry and NAgui._toggleRegistry[label]
	if not entry then return end
	entry.set(value, opts)
end

NAgui.addColorPicker = function(label, defaultColor, callback)
	if not NAUIMANAGER.SettingsList then return end
	local picker = templates.ColorPicker:Clone()
	picker.Title.Text = label
	picker.Parent = NAUIMANAGER.SettingsList
	picker.LayoutOrder = NAgui._nextLayoutOrder()
	NAmanage.registerElementForCurrentTab(picker)

	local background = picker.CPBackground
	local display = background.Display
	local main = background.MainCP
	local slider = picker.ColorSlider
	local rgb = picker.RGB
	local hex = picker.HexInput

	if typeof(defaultColor) ~= "Color3" then
		defaultColor = Color3.fromRGB(255, 255, 255)
	end

	local h, s, v = defaultColor:ToHSV()
	local draggingMain = false
	local draggingSlider = false

	main.MainPoint.AnchorPoint = Vector2.new(0.5, 0.5)
	slider.SliderPoint.AnchorPoint = Vector2.new(0.5, 0.5)

	local function updateUI(pushToInputs, opts)
		opts = opts or {}
		local color = Color3.fromHSV(h, s, v)
		display.BackgroundColor3 = color
		background.BackgroundColor3 = Color3.fromHSV(h, 1, 1)
		main.MainPoint.Position = UDim2.new(s, 0, 1 - v, 0)
		slider.SliderPoint.Position = UDim2.new(h, 0, 0.5, 0)

		local r = math.floor(color.R * 255 + 0.5)
		local g = math.floor(color.G * 255 + 0.5)
		local b = math.floor(color.B * 255 + 0.5)

		if pushToInputs then
			rgb.RInput.InputBox.Text = tostring(r)
			rgb.GInput.InputBox.Text = tostring(g)
			rgb.BInput.InputBox.Text = tostring(b)
			hex.InputBox.Text = Format("#%02X%02X%02X", r, g, b)
		end

		if opts.fire ~= false then
			pcall(function()
				callback(color)
			end)
		end
	end

	local function parseRGBInputs()
		local r = tonumber(rgb.RInput.InputBox.Text) or 0
		local g = tonumber(rgb.GInput.InputBox.Text) or 0
		local b = tonumber(rgb.BInput.InputBox.Text) or 0

		r = math.clamp(r, 0, 255)
		g = math.clamp(g, 0, 255)
		b = math.clamp(b, 0, 255)

		h, s, v = Color3.fromRGB(r, g, b):ToHSV()
		updateUI(false)
	end

	rgb.RInput.InputBox.FocusLost:Connect(parseRGBInputs)
	rgb.GInput.InputBox.FocusLost:Connect(parseRGBInputs)
	rgb.BInput.InputBox.FocusLost:Connect(parseRGBInputs)

	hex.InputBox.FocusLost:Connect(function()
		local text = hex.InputBox.Text:gsub("#", ""):upper()
		if text:match("^[0-9A-F]+$") and #text == 6 then
			local r = tonumber(text:sub(1, 2), 16)
			local g = tonumber(text:sub(3, 4), 16)
			local b = tonumber(text:sub(5, 6), 16)
			if r and g and b then
				h, s, v = Color3.fromRGB(r, g, b):ToHSV()
				updateUI(true)
			end
		else
			hex.InputBox.Text = Format("#%02X%02X%02X", math.floor(Color3.fromHSV(h,s,v).R * 255 + 0.5), math.floor(Color3.fromHSV(h,s,v).G * 255 + 0.5), math.floor(Color3.fromHSV(h,s,v).B * 255 + 0.5))
		end
	end)

	local mouse = lp:GetMouse()

	local function setupDragDetection(obj, dragType)
		obj.InputBegan:Connect(function(input)
			if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
				if dragType == "main" then
					draggingMain = true
				elseif dragType == "slider" then
					draggingSlider = true
				end
			end
		end)
	end

	setupDragDetection(main, "main")
	setupDragDetection(main.MainPoint, "main")
	setupDragDetection(slider, "slider")
	setupDragDetection(slider.SliderPoint, "slider")

	SafeGetService("UserInputService").InputEnded:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
			draggingMain = false
			draggingSlider = false
		end
	end)

	SafeGetService("RunService").RenderStepped:Connect(function()
		if draggingMain then
			local relX = math.clamp(mouse.X - main.AbsolutePosition.X, 0, main.AbsoluteSize.X)
			local relY = math.clamp(mouse.Y - main.AbsolutePosition.Y, 0, main.AbsoluteSize.Y)
			s = relX / main.AbsoluteSize.X
			v = 1 - (relY / main.AbsoluteSize.Y)
			updateUI(true)
		end
		if draggingSlider then
			local relX = math.clamp(mouse.X - slider.AbsolutePosition.X, 0, slider.AbsoluteSize.X)
			h = relX / slider.AbsoluteSize.X
			updateUI(true)
		end
	end)

	local entry = {
		get = function()
			return Color3.fromHSV(h, s, v)
		end;
		set = function(color, opts)
			if typeof(color) ~= "Color3" then return end
			h, s, v = color:ToHSV()
			updateUI(true, opts or {})
		end;
	}
	NAgui._colorPickerRegistry[label] = entry

	picker:GetPropertyChangedSignal("Parent"):Connect(function()
		if not picker.Parent and NAgui._colorPickerRegistry[label] == entry then
			NAgui._colorPickerRegistry[label] = nil
		end
	end)

	updateUI(true)

	return picker
end

NAgui.setColorPickerValue = function(label, color, opts)
	local entry = NAgui._colorPickerRegistry and NAgui._colorPickerRegistry[label]
	if not entry then return end
	entry.set(color, opts or { fire = false })
end

NAgui.addInput = function(label, placeholder, defaultText, callback)
	local input = templates.Input:Clone()
	local frame = input.InputFrame
	local inputBox = frame.InputBox

	input.Title.Text = label
	inputBox.Text = defaultText or ""
	inputBox.PlaceholderText = placeholder or ""

	input.LayoutOrder = NAgui._nextLayoutOrder()
	input.Parent = NAUIMANAGER.SettingsList
	NAmanage.registerElementForCurrentTab(input)

	local function resize()
		frame:TweenSize(
			UDim2.new(0, inputBox.TextBounds.X + 24, 0, 30),
			Enum.EasingDirection.Out,
			Enum.EasingStyle.Exponential,
			0.2,
			true
		)
	end

	inputBox.FocusLost:Connect(function()
		pcall(callback, inputBox.Text)
	end)

	inputBox:GetPropertyChangedSignal("Text"):Connect(resize)

	local function setText(newValue, opts)
		opts = opts or {}
		local text = tostring(newValue or "")
		if not opts.force and inputBox.Text == text then
			if opts.fire then
				pcall(callback, text)
			end
			return
		end
		inputBox.Text = text
		if opts.fire then
			pcall(callback, text)
		end
	end

	local entry = {
		input = input;
		get = function()
			return inputBox.Text
		end;
		set = function(value, opts)
			setText(value, opts)
		end;
	}

	NAgui._inputRegistry[label] = entry

	input:GetPropertyChangedSignal("Parent"):Connect(function()
		if not input.Parent and NAgui._inputRegistry[label] == entry then
			NAgui._inputRegistry[label] = nil
		end
	end)

	resize()

	return input
end

NAgui.setInputValue = function(label, value, opts)
	local entry = NAgui._inputRegistry and NAgui._inputRegistry[label]
	if not entry then return end
	entry.set(value, opts or { fire = false })
end

NAmanage.SyncPrefixUI = function(opts)
	if not (NAgui and NAgui.setInputValue) then return end
	local prefixValue = opt and tostring(opt.prefix or "") or ""
	if prefixValue == "" then
		prefixValue = ";"
	end
	opts = opts or {}
	local setterOpts = {
		force = opts.force ~= false,
		fire = opts.fire == true,
	}
	NAgui.setInputValue("Prefix", prefixValue, setterOpts)
end

NAmanage._uiAutoSync = NAmanage._uiAutoSync or { toggles = {} }

NAmanage.RegisterToggleAutoSync = function(label, getter, opts)
	if type(label) ~= "string" or type(getter) ~= "function" then return end
	local store = NAmanage._uiAutoSync
	local entry = store.toggles[label]
	if not entry then
		entry = { getter = getter, last = nil, opts = opts }
		store.toggles[label] = entry
	else
		entry.getter = getter
		entry.opts = opts or entry.opts
	end
end

NAmanage.RunUIAutoSync = function()
	local store = NAmanage._uiAutoSync
	if not store then return end
	local toggleStore = store.toggles
	if toggleStore and NAgui and NAgui.setToggleState then
		for label, watcher in pairs(toggleStore) do
			local success, rawValue = pcall(watcher.getter)
			if success then
				local normalized = nil
				if watcher.opts and type(watcher.opts.normalize) == "function" then
					local ok, result = pcall(watcher.opts.normalize, rawValue)
					if ok then
						normalized = result
					end
				end
				if normalized == nil then
					normalized = rawValue and true or false
				end
				local registry = NAgui._toggleRegistry
				if registry and registry[label] then
					if watcher.last == nil or watcher.last ~= normalized then
						watcher.last = normalized
						local fireCallback = watcher.opts and watcher.opts.fire == true
						NAgui.setToggleState(label, normalized, {
							force = true,
							fire = fireCallback and true or false,
						})
					end
				else
					watcher.last = nil
				end
			end
		end
	end
end

NAmanage.StartUIAutoSyncLoop = function()
	if NAmanage._uiAutoSyncLoopStarted then return end
	NAmanage._uiAutoSyncLoopStarted = true
	task.spawn(function()
		while true do
			task.wait(0.25)
			local ok, err = pcall(NAmanage.RunUIAutoSync)
			if not ok then
				warn("[NA] UI auto-sync failed:", err)
			end
		end
	end)
end

NAmanage.StartUIAutoSyncLoop()

NAgui.addKeybind = function(label, defaultKey, callback)
	local keybind = templates.Keybind:Clone()
	keybind.Title.Text = label
	keybind.KeybindFrame.KeybindBox.Text = defaultKey

	keybind.LayoutOrder = NAgui._nextLayoutOrder()
	keybind.Parent = NAUIMANAGER.SettingsList
	NAmanage.registerElementForCurrentTab(keybind)

	local capturing = false

	keybind.KeybindFrame.KeybindBox.Focused:Connect(function()
		capturing = true
		keybind.KeybindFrame.KeybindBox.Text = ""
	end)

	keybind.KeybindFrame.KeybindBox.FocusLost:Connect(function()
		capturing = false
		if keybind.KeybindFrame.KeybindBox.Text == "" then
			keybind.KeybindFrame.KeybindBox.Text = defaultKey
		end
	end)

	UserInputService.InputBegan:Connect(function(input, processed)
		if capturing and input.KeyCode ~= Enum.KeyCode.Unknown then
			local keyName = tostring(input.KeyCode):split(".")[3]
			keybind.KeybindFrame.KeybindBox:ReleaseFocus()
			keybind.KeybindFrame.KeybindBox.Text = keyName
			capturing = false
			pcall(callback, keyName)
		elseif not capturing and keybind.KeybindFrame.KeybindBox.Text ~= "" then
			if tostring(input.KeyCode) == "Enum.KeyCode."..keybind.KeybindFrame.KeybindBox.Text and not processed then
				pcall(callback)
			end
		end
	end)

	keybind.KeybindFrame.KeybindBox:GetPropertyChangedSignal("Text"):Connect(function()
		keybind.KeybindFrame:TweenSize(
			UDim2.new(0, keybind.KeybindFrame.KeybindBox.TextBounds.X + 24, 0, 30),
			Enum.EasingDirection.Out,
			Enum.EasingStyle.Exponential,
			0.2,
			true
		)
	end)
end

NAgui.addSlider = function(label, min, max, defaultValue, increment, suffix, callback)
	local slider = templates.Slider:Clone()
	slider.Title.Text = label

	slider.LayoutOrder = NAgui._nextLayoutOrder()
	slider.Parent = NAUIMANAGER.SettingsList
	NAmanage.registerElementForCurrentTab(slider)

	local interact = slider.Main.Interact
	local progress = slider.Main.Progress
	local infoText = slider.Main.Information

	local dragging = false
	local currentValue = defaultValue
	local step = tonumber(increment) or 0
	local range = max - min

	local function quantize(value)
		if step == 0 then
			return math.clamp(value, min, max)
		end
		local scaled = (value - min) / step
		local rounded = math.floor(scaled + 0.5)
		local quantized = min + rounded * step
		if quantized < min then quantized = min end
		if quantized > max then quantized = max end
		return quantized
	end

	local function applyValue(value, opts)
		opts = opts or {}
		local quantized = quantize(value)
		currentValue = quantized
		local percent = (range ~= 0) and ((quantized - min) / range) or 0
		progress.Size = UDim2.new(percent, 0, 1, 0)
		infoText.Text = Format("%.14g", quantized)..(suffix or "")
		if opts.fire ~= false then
			pcall(callback, quantized)
		end
	end

	local function updateSliderValueFromPos(x)
		local relX = math.clamp(x - interact.AbsolutePosition.X, 0, interact.AbsoluteSize.X)
		local percent = relX / interact.AbsoluteSize.X
		local value = min + range * percent
		applyValue(value)
	end

	interact.InputBegan:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
			dragging = true
		end
	end)

	interact.InputEnded:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
			dragging = false
		end
	end)

	RunService.RenderStepped:Connect(function()
		if dragging then
			updateSliderValueFromPos(UserInputService:GetMouseLocation().X)
		end
	end)

	applyValue(defaultValue, { fire = false })

	local entry = {
		get = function()
			return currentValue
		end;
		set = function(value, opts)
			applyValue(value, opts or {})
		end;
	}
	NAgui._sliderRegistry[label] = entry

	slider:GetPropertyChangedSignal("Parent"):Connect(function()
		if not slider.Parent and NAgui._sliderRegistry[label] == entry then
			NAgui._sliderRegistry[label] = nil
		end
	end)

	return slider
end

NAgui.setSliderValue = function(label, value, opts)
	local entry = NAgui._sliderRegistry and NAgui._sliderRegistry[label]
	if not entry then return end
	entry.set(value, opts or { fire = false })
end

NAmanage.Topbar_PlayTween=function(key,instance,info,props)
	NAmanage._tweens=NAmanage._tweens or {}
	if NAmanage._tweens[key] then NAmanage._tweens[key]:Cancel() end
	local t=TweenService:Create(instance,info,props)
	NAmanage._tweens[key]=t
	t:Play()
	return t
end

NAmanage.Topbar_ButtonCount=function()
	local n=0
	for _ in ipairs(TopBarApp.buttonDefs) do n+=1 end
	return n
end

NAmanage.Topbar_ComputedSize=function()
	local pad=8
	local count=NAmanage.Topbar_ButtonCount()
	local cam=workspace.CurrentCamera
	local vpX=cam and cam.ViewportSize.X or 1280
	local margin=8
	if TopBarApp.mode=="bottom" then
		local tile=44
		local cols=math.max(1, math.min(5, count))
		local rows=math.max(1, math.min(5, math.ceil(count/5)))
		local w=cols*tile+(cols-1)*pad+12
		local h=rows*tile+(rows-1)*pad+12
		w=math.min(w, vpX - margin*2)
		return w,h
	else
		local tile=48
		local visible=5
		local w=visible*tile+(visible-1)*pad+12
		local h=tile+12
		w=math.min(w, vpX - margin*2)
		return w,h
	end
end

NAmanage.Topbar_ChooseSide=function()
	local cam=workspace.CurrentCamera
	if not cam then return end
	local vp=cam.ViewportSize
	local ap,sz=TopBarApp.toggle.AbsolutePosition,TopBarApp.toggle.AbsoluteSize
	local w=NAmanage.Topbar_ComputedSize()
	local canRight=(ap.X+sz.X+8+w)<= (vp.X-8)
	local canLeft=(ap.X-8-w)>=8
	if TopBarApp.sidePref=="right" and not canRight and canLeft then
		TopBarApp.sidePref="left"
	elseif TopBarApp.sidePref=="left" and not canLeft and canRight then
		TopBarApp.sidePref="right"
	elseif not canRight and canLeft then
		TopBarApp.sidePref="left"
	elseif canRight and not canLeft then
		TopBarApp.sidePref="right"
	end
end

NAmanage.Topbar_PositionPanel=function()
	if not (TopBarApp.panel and TopBarApp.toggle) then return end
	local cam=workspace.CurrentCamera if not cam then return end
	local vp=cam.ViewportSize
	local tap,tsz=TopBarApp.toggle.AbsolutePosition,TopBarApp.toggle.AbsoluteSize
	local w,h=NAmanage.Topbar_ComputedSize()
	local margin,gap=8,10
	if TopBarApp.mode=="bottom" then
		TopBarApp.panel.Parent=TopBarApp.toggle
		TopBarApp.panel.Size=UDim2.new(0,w,0,TopBarApp.isOpen and h or 0)
		TopBarApp.panel.AnchorPoint=Vector2.new(0.5,0)
		TopBarApp.panel.Position=UDim2.new(0.5,0,1,gap)
		local ap=TopBarApp.panel.AbsolutePosition
		local aw=TopBarApp.panel.AbsoluteSize.X
		local dx=0
		if ap.X<margin then dx=margin-ap.X end
		if ap.X+aw>vp.X-margin then dx=(vp.X-margin)-(ap.X+aw) end
		if dx~=0 then TopBarApp.panel.Position=UDim2.new(0.5,dx,1,gap) end
	else
		TopBarApp.panel.Parent=TopBarApp.top
		TopBarApp.panel.Size=UDim2.new(0,w,0,TopBarApp.isOpen and h or 0)
		local canRight=(tap.X+tsz.X+gap+w)<=vp.X-margin
		local canLeft=(tap.X-gap-w)>=margin
		if TopBarApp.sidePref=="right" and not canRight and canLeft then TopBarApp.sidePref="left" end
		if TopBarApp.sidePref=="left" and not canLeft and canRight then TopBarApp.sidePref="right" end
		if not canRight and not canLeft then TopBarApp.sidePref=((vp.X-(tap.X+tsz.X))>=tap.X) and "right" or "left" end
		local y=math.clamp(tap.Y+tsz.Y*0.5, h*0.5+margin, vp.Y-h*0.5-margin)
		if TopBarApp.sidePref=="right" then
			TopBarApp.panel.AnchorPoint=Vector2.new(0,0.5)
			local x=math.min(tap.X+tsz.X+gap, vp.X-margin-w)
			TopBarApp.panel.Position=UDim2.new(0,x,0,y)
		else
			TopBarApp.panel.AnchorPoint=Vector2.new(1,0.5)
			local x=math.max(tap.X-gap, margin+w)
			TopBarApp.panel.Position=UDim2.new(0,x,0,y)
		end
	end
end

NAmanage.Topbar_AnimateIcon=function(img,off,size)
	local ti=TweenInfo.new(0.12,Enum.EasingStyle.Sine,Enum.EasingDirection.Out)
	local ti2=TweenInfo.new(0.14,Enum.EasingStyle.Sine,Enum.EasingDirection.InOut)
	NAmanage.Topbar_PlayTween("icon_shrink",TopBarApp.icon,ti,{Size=UDim2.new(0,0,0,0)}).Completed:Wait()
	TopBarApp.icon.Image=img
	if off then TopBarApp.icon.ImageRectOffset=off else TopBarApp.icon.ImageRectOffset=Vector2.new(0,0) end
	if size then TopBarApp.icon.ImageRectSize=size else TopBarApp.icon.ImageRectSize=Vector2.new(0,0) end
	NAmanage.Topbar_PlayTween("icon_grow",TopBarApp.icon,ti2,{Size=UDim2.new(0.8,0,0.8,0)})
end

NAmanage.Topbar_UpdateToggleVisual=function(open)
	local ti=TweenInfo.new(0.14,Enum.EasingStyle.Sine,Enum.EasingDirection.InOut)
	local bgTarget=open and 0.06 or 0.12
	local strokeT=open and 0.05 or 0.15
	NAmanage.Topbar_PlayTween("tglass_bg",TopBarApp.tGlass,ti,{BackgroundTransparency=bgTarget})
	if TopBarApp.tStroke then NAmanage.Topbar_PlayTween("tglass_stroke",TopBarApp.tStroke,ti,{Transparency=strokeT}) end
	local CLOSED_IMG="rbxasset://LuaPackages/Packages/_Index/FoundationImages/FoundationImages/SpriteSheets/img_set_1x_6.png"
	local CLOSED_OFF=Vector2.new(456,440)
	local CLOSED_SIZE=Vector2.new(36,36)
	local OPENED_IMG="rbxasset://LuaPackages/Packages/_Index/FoundationImages/FoundationImages/SpriteSheets/img_set_1x_5.png"
	local OPENED_OFF=Vector2.new(474,258)
	local OPENED_SIZE=Vector2.new(36,36)
	if open then
		NAmanage.Topbar_AnimateIcon(OPENED_IMG,OPENED_OFF,OPENED_SIZE)
	else
		NAmanage.Topbar_AnimateIcon(CLOSED_IMG,CLOSED_OFF,CLOSED_SIZE)
	end
end

NAmanage.Topbar_SetOpen=function(state)
	if not TopBarApp.panel then return end
	TopBarApp.isOpen=state
	local w,h=NAmanage.Topbar_ComputedSize()
	TopBarApp.panel.Visible=true
	TopBarApp.underlay.Visible = state
	TopBarApp.scroll.Visible = state
	TopBarApp.underlay.ZIndex=201
	TopBarApp.scroll.ZIndex=202
	NAlib.disconnect("tb_follow")
	TopBarApp.animating=true
	NAmanage.Topbar_PositionPanel()
	local ts=TweenService
	local dur=0.18
	local ease=TweenInfo.new(dur,Enum.EasingStyle.Sine,Enum.EasingDirection.InOut)
	if state then
		TopBarApp.panel.Size=UDim2.new(0,w,0,0)
		local tween=ts:Create(TopBarApp.panel,ease,{Size=UDim2.new(0,w,0,h)})
		tween:Play()
		tween.Completed:Connect(function()
			TopBarApp.animating=false
		end)
		NAlib.connect("tb_follow",RunService.RenderStepped:Connect(function()
			NAmanage.Topbar_PositionPanel()
		end))
	else
		local tween=ts:Create(TopBarApp.panel,ease,{Size=UDim2.new(0,w,0,0)})
		tween:Play()
		tween.Completed:Connect(function()
			if not TopBarApp.isOpen then TopBarApp.panel.Visible=false end
			TopBarApp.animating=false
		end)
	end
	NAmanage.Topbar_UpdateToggleVisual(state)
end

NAmanage.Topbar_Toggle=function()
	NAmanage.Topbar_SetOpen(not TopBarApp.isOpen)
end

NAmanage.Topbar_Rebuild=function()
	if TopBarApp.scroll then TopBarApp.scroll:Destroy() TopBarApp.scroll=nil end
	TopBarApp.scroll=InstanceNew("ScrollingFrame",TopBarApp.panel)
	TopBarApp.scroll.BackgroundTransparency=1
	TopBarApp.scroll.BorderSizePixel=0
	TopBarApp.scroll.Size=UDim2.new(1,0,1,0)
	TopBarApp.scroll.ZIndex=202
	TopBarApp.scroll.ScrollBarThickness=4
	for _,c in ipairs(TopBarApp.scroll:GetChildren()) do c:Destroy() end
	for btn,_ in pairs(TopBarApp.childButtons) do TopBarApp.childButtons[btn]=nil end
	local pad=InstanceNew("UIPadding",TopBarApp.scroll)
	pad.PaddingTop=UDim.new(0,6)
	pad.PaddingBottom=UDim.new(0,6)
	pad.PaddingLeft=UDim.new(0,6)
	pad.PaddingRight=UDim.new(0,6)
	if TopBarApp.layout then TopBarApp.layout:Destroy() TopBarApp.layout=nil end
	local tileBottom=44
	local tileSide=48
	if TopBarApp.mode=="bottom" then
		TopBarApp.scroll.ScrollingDirection=Enum.ScrollingDirection.Y
		local grid=InstanceNew("UIGridLayout",TopBarApp.scroll)
		grid.CellSize=UDim2.new(0,tileBottom,0,tileBottom)
		grid.CellPadding=UDim2.new(0,8,0,8)
		grid.HorizontalAlignment=Enum.HorizontalAlignment.Center
		grid.VerticalAlignment=Enum.VerticalAlignment.Top
		grid.SortOrder=Enum.SortOrder.LayoutOrder
		TopBarApp.layout=grid
	else
		TopBarApp.scroll.ScrollingDirection=Enum.ScrollingDirection.X
		local list=InstanceNew("UIListLayout",TopBarApp.scroll)
		list.FillDirection=Enum.FillDirection.Horizontal
		list.HorizontalAlignment=Enum.HorizontalAlignment.Left
		list.VerticalAlignment=Enum.VerticalAlignment.Center
		list.Padding=UDim.new(0,8)
		list.SortOrder=Enum.SortOrder.LayoutOrder
		TopBarApp.layout=list
	end
	local i=0
	for _,def in ipairs(TopBarApp.buttonDefs) do
		i+=1
		local btn=InstanceNew("ImageButton",TopBarApp.scroll)
		btn.Name=def.name.."Btn"
		btn.Size=UDim2.new(0, TopBarApp.mode=="bottom" and tileBottom or tileSide, 0, TopBarApp.mode=="bottom" and tileBottom or tileSide)
		btn.BackgroundTransparency=1
		btn.BorderSizePixel=0
		btn.LayoutOrder=i
		local bg=InstanceNew("Frame",btn)
		bg.ZIndex=203
		bg.Size=UDim2.new(1,0,1,0)
		bg.BackgroundColor3=Color3.fromRGB(25,25,28)
		bg.BackgroundTransparency=0.18
		bg.BorderSizePixel=0
		local cr=InstanceNew("UICorner",bg); cr.CornerRadius=UDim.new(0,12)
		local stroke=InstanceNew("UIStroke",bg)
		stroke.Thickness=1
		stroke.Color=NAUISTROKER or Color3.fromRGB(148,93,255)
		stroke.Transparency=0.15
		NAgui.RegisterColoredStroke(stroke)
		local ic=InstanceNew("ImageLabel",bg)
		ic.ZIndex=204
		ic.BackgroundTransparency=1
		ic.Size=UDim2.new(0.65,0,0.65,0)
		ic.Position=UDim2.new(0.5,0,0.5,0)
		ic.AnchorPoint=Vector2.new(0.5,0.5)
		ic.Image=def.image
		if def.ImageRectOffset then ic.ImageRectOffset=def.ImageRectOffset end
		if def.ImageRectSize then ic.ImageRectSize=def.ImageRectSize end
		TopBarApp.childButtons[btn]=def.func
		MouseButtonFix(btn,def.func)
	end
	local function updateCanvas()
		if TopBarApp.mode=="bottom" then
			TopBarApp.scroll.CanvasSize=UDim2.new(0,0,0,TopBarApp.layout.AbsoluteContentSize.Y+12)
		else
			TopBarApp.scroll.CanvasSize=UDim2.new(0,TopBarApp.layout.AbsoluteContentSize.X+12,0,0)
		end
		if not TopBarApp.animating then
			NAmanage.Topbar_PositionPanel()
		end
	end
	NAlib.disconnect("tb_canvas")
	NAlib.connect("tb_canvas",TopBarApp.layout:GetPropertyChangedSignal("AbsoluteContentSize"):Connect(updateCanvas))
	updateCanvas()
end

NAmanage.Topbar_AddButton=function(def)
	TopBarApp.buttonDefs[#TopBarApp.buttonDefs+1]=def
	NAmanage.Topbar_Rebuild()
	if TopBarApp.isOpen then NAmanage.Topbar_PositionPanel() end
end

NAmanage.Topbar_ClampToggle=function()
	local fw=TopBarApp.frame.AbsoluteSize.X
	local bw=TopBarApp.toggle.AbsoluteSize.X
	local off=math.clamp(TopBarApp.toggle.Position.X.Offset,-(fw-bw)/2,(fw-bw)/2)
	TopBarApp.toggle.Position=UDim2.new(0.5,off,TopBarApp.toggle.Position.Y.Scale,TopBarApp.toggle.Position.Y.Offset)
end

NAmanage.Topbar_MakeDraggableHorizontal=function(ui)
	local dragging=false
	local dragInput,dragStart,startPos
	ui.InputBegan:Connect(function(input)
		if input.UserInputType==Enum.UserInputType.MouseButton1 or input.UserInputType==Enum.UserInputType.Touch then
			dragging=true
			dragStart=input.Position
			startPos=ui.Position
			input.Changed:Connect(function()
				if input.UserInputState==Enum.UserInputState.End then dragging=false end
			end)
		end
	end)
	ui.InputChanged:Connect(function(input)
		if input.UserInputType==Enum.UserInputType.MouseMovement or input.UserInputType==Enum.UserInputType.Touch then
			dragInput=input
		end
	end)
	local lastStep=0
	UserInputService.InputChanged:Connect(function(input)
		if input==dragInput and dragging then
			local now=os.clock()
			if now-lastStep<(1/60) then return end
			lastStep=now
			local delta=input.Position-dragStart
			local fw=TopBarApp.frame.AbsoluteSize.X
			local bw=ui.AbsoluteSize.X
			local base=startPos.X.Offset
			local newX=math.clamp(base+delta.X,-(fw-bw)/2,(fw-bw)/2)
			ui.Position=UDim2.new(0.5,newX,startPos.Y.Scale,startPos.Y.Offset)
			if TopBarApp.isOpen then NAmanage.Topbar_PositionPanel() end
		end
	end)
	ui.Active=true
end

NAmanage.Topbar_SetMode=function(mode)
	if mode~="bottom" and mode~="side" then return end
	TopBarApp.mode=mode
	NAmanage.topbar_writeMode(mode)
	NAmanage.Topbar_Rebuild()
	if TopBarApp.isOpen then NAmanage.Topbar_PositionPanel() end
end

NAmanage.Topbar_Init=function()
	if TopBarApp.top and TopBarApp.top.Parent then TopBarApp.top:Destroy() end
	TopBarApp.top=InstanceNew("ScreenGui")
	TopBarApp.top.Name="NA_Topbar_Styled"
	TopBarApp.top.ZIndexBehavior=Enum.ZIndexBehavior.Global
	TopBarApp.top.DisplayOrder=9999
	TopBarApp.top.IgnoreGuiInset=true
	NaProtectUI(TopBarApp.top)
	TopBarApp.top.Enabled=NATOPBARVISIBLE
	TopBarApp.frame=InstanceNew("Frame")
	TopBarApp.frame.Size=UDim2.new(1,0,0,36)
	TopBarApp.frame.Position=UDim2.new(0,0,0,0)
	TopBarApp.frame.BackgroundTransparency=1
	TopBarApp.frame.Parent=TopBarApp.top
	TopBarApp.toggle=InstanceNew("ImageButton",TopBarApp.frame)
	TopBarApp.toggle.Name="TopbarToggle"
	TopBarApp.toggle.Size=UDim2.new(0,42,0,42)
	TopBarApp.toggle.Position=UDim2.new(0.5,0,0,10)
	TopBarApp.toggle.AnchorPoint=Vector2.new(0.5,0)
	TopBarApp.toggle.BackgroundTransparency=1
	TopBarApp.toggle.BorderSizePixel=0
	TopBarApp.toggle.ClipsDescendants=false
	TopBarApp.toggle.ZIndex=110
	TopBarApp.tGlass=InstanceNew("Frame",TopBarApp.toggle)
	TopBarApp.tGlass.Size=UDim2.new(1,0,1,0)
	TopBarApp.tGlass.BackgroundColor3=Color3.fromRGB(20,20,24)
	TopBarApp.tGlass.BackgroundTransparency=0.12
	TopBarApp.tGlass.ZIndex=111
	local tCorner=InstanceNew("UICorner",TopBarApp.tGlass); tCorner.CornerRadius=UDim.new(0.5,0)
	TopBarApp.tStroke=InstanceNew("UIStroke",TopBarApp.tGlass)
	TopBarApp.tStroke.Thickness=1.25
	TopBarApp.tStroke.Color=NAUISTROKER or Color3.fromRGB(148,93,255)
	TopBarApp.tStroke.Transparency=0.15
	NAgui.RegisterColoredStroke(TopBarApp.tStroke)
	TopBarApp.icon=InstanceNew("ImageLabel",TopBarApp.toggle)
	TopBarApp.icon.AnchorPoint=Vector2.new(0.5,0.5)
	TopBarApp.icon.Position=UDim2.new(0.5,0,0.5,0)
	TopBarApp.icon.Size=UDim2.new(0.8,0,0.8,0)
	TopBarApp.icon.BackgroundTransparency=1
	TopBarApp.icon.ScaleType=Enum.ScaleType.Fit
	TopBarApp.icon.Image="rbxasset://LuaPackages/Packages/_Index/FoundationImages/FoundationImages/SpriteSheets/img_set_1x_6.png"
	TopBarApp.icon.ImageRectOffset=Vector2.new(456,440)
	TopBarApp.icon.ImageRectSize=Vector2.new(36,36)
	TopBarApp.icon.ZIndex=112
	TopBarApp.panel=InstanceNew("Frame",TopBarApp.top)
	TopBarApp.panel.Visible=false
	TopBarApp.panel.ClipsDescendants=true
	TopBarApp.panel.BackgroundTransparency=1
	TopBarApp.panel.ZIndex=200
	TopBarApp.underlay=InstanceNew("Frame",TopBarApp.panel)
	TopBarApp.underlay.Size=UDim2.new(1,0,1,0)
	TopBarApp.underlay.BackgroundColor3=Color3.fromRGB(18,18,22)
	TopBarApp.underlay.BackgroundTransparency=0.1
	TopBarApp.underlay.ZIndex=201
	local pCorner=InstanceNew("UICorner",TopBarApp.underlay); pCorner.CornerRadius=UDim.new(0,12)
	local pStroke=InstanceNew("UIStroke",TopBarApp.underlay)
	pStroke.Thickness=1
	pStroke.Color=NAUISTROKER or Color3.fromRGB(148,93,255)
	pStroke.Transparency=0.2
	NAgui.RegisterColoredStroke(pStroke)
	TopBarApp.buttonDefs={
		{name="settings",image="rbxasset://LuaPackages/Packages/_Index/FoundationImages/FoundationImages/SpriteSheets/img_set_1x_8.png",ImageRectOffset=Vector2.new(416,464),ImageRectSize=Vector2.new(36,36),func=function()
			if NAUIMANAGER.SettingsFrame then
				NAUIMANAGER.SettingsFrame.Visible=not NAUIMANAGER.SettingsFrame.Visible
				NAmanage.centerFrame(NAUIMANAGER.SettingsFrame)
			end
		end},
		{name="cmds",image="rbxasset://textures/ui/TopBar/moreOff@2x.png",func=NAgui.commands},
		{name="chatlogs",image="rbxasset://textures/ui/Chat/ToggleChat@2x.png",func=function()
			if NAUIMANAGER.chatLogsFrame then
				NAUIMANAGER.chatLogsFrame.Visible=not NAUIMANAGER.chatLogsFrame.Visible
				NAmanage.centerFrame(NAUIMANAGER.chatLogsFrame)
			end
		end},
		{name="console",image="rbxasset://textures/Icon_Stream_Off.png",func=function()
			if NAUIMANAGER.NAconsoleFrame then
				NAUIMANAGER.NAconsoleFrame.Visible=not NAUIMANAGER.NAconsoleFrame.Visible
				NAmanage.centerFrame(NAUIMANAGER.NAconsoleFrame)
			end
		end},
		{name="waypp",image="rbxasset://textures/ui/waypoint.png",func=function()
			if NAUIMANAGER.WaypointFrame then
				NAUIMANAGER.WaypointFrame.Visible=not NAUIMANAGER.WaypointFrame.Visible
				NAmanage.centerFrame(NAUIMANAGER.WaypointFrame)
			end
		end},
		{name="bindd",image="rbxasset://textures/ui/PlayerList/developer@2x.png",func=function()
			if NAUIMANAGER.BindersFrame then
				NAUIMANAGER.BindersFrame.Visible=not NAUIMANAGER.BindersFrame.Visible
				NAmanage.centerFrame(NAUIMANAGER.BindersFrame)
			end
		end},
	}
	NAmanage.Topbar_Rebuild()
	NAmanage.Topbar_SetOpen(false)
	MouseButtonFix(TopBarApp.toggle,NAmanage.Topbar_Toggle)
	NAmanage.Topbar_MakeDraggableHorizontal(TopBarApp.toggle)
	NAlib.connect("tb_repos_frame",TopBarApp.frame:GetPropertyChangedSignal("AbsoluteSize"):Connect(function()
		NAmanage.Topbar_ClampToggle()
		if TopBarApp.isOpen then NAmanage.Topbar_PositionPanel() end
	end))
	if workspace.CurrentCamera then
		NAlib.connect("tb_repos_vp",workspace.CurrentCamera:GetPropertyChangedSignal("ViewportSize"):Connect(function()
			NAmanage.Topbar_ClampToggle()
			if TopBarApp.isOpen then NAmanage.Topbar_PositionPanel() end
		end))
	end
end

NAmanage.Topbar_Destroy=function()
	NAlib.disconnect("tb_canvas")
	NAlib.disconnect("tb_repos_frame")
	NAlib.disconnect("tb_repos_vp")
	NAlib.disconnect("tb_follow")
	if TopBarApp and TopBarApp.top then TopBarApp.top:Destroy() end
	TopBarApp={ top=nil; frame=nil; toggle=nil; tGlass=nil; tStroke=nil; icon=nil; panel=nil; underlay=nil; scroll=nil; layout=nil; isOpen=false; childButtons={}; buttonDefs={}, mode=NAmanage.topbar_readMode(), sidePref="right" }
end

NAgui.menu = function(menu)
	if menu:IsA("Frame") then menu.AnchorPoint = Vector2.new(0, 0) end
	local exitButton = menu:FindFirstChild("Exit", true)
	local minimizeButton = menu:FindFirstChild("Minimize", true)
	local minimized = false
	local isAnimating = false
	local sizeX = InstanceNew("IntValue", menu)
	local sizeY = InstanceNew("IntValue", menu)

	local function toggleMinimize()
		if isAnimating then return end
		minimized = not minimized
		isAnimating = true

		if minimized then
			sizeX.Value = menu.Size.X.Offset
			sizeY.Value = menu.Size.Y.Offset
			NAgui.tween(menu, "Quart", "Out", 0.5, {Size = UDim2.new(0, sizeX.Value, 0, 35)})
				.Completed:Connect(function()
					isAnimating = false
				end)
		else
			NAgui.tween(menu, "Quart", "Out", 0.5, {Size = UDim2.new(0, sizeX.Value, 0, sizeY.Value)})
				.Completed:Connect(function()
					isAnimating = false
				end)
		end
	end

	MouseButtonFix(minimizeButton, toggleMinimize)
	MouseButtonFix(exitButton, function()
		menu.Visible = false
	end)
	NAgui.draggerV2(menu, menu.Topbar)
	menu.Visible = false
end

NAgui.menuv2 = function(menu)
	NACaller(function()
		if menu:IsA("Frame") then
			menu.AnchorPoint = Vector2.new(0, 0)
		end
	end)

	local exitButton = menu:FindFirstChild("Exit", true)
	local minimizeButton = menu:FindFirstChild("Minimize", true)
	local clearButton = menu:FindFirstChild("Clear", true)

	local minimized = false
	local isAnimating = false
	local sizeX = InstanceNew("IntValue", menu)
	local sizeY = InstanceNew("IntValue", menu)

	local function toggleMinimize()
		local success, err = NACaller(function()
			if isAnimating then return end
			minimized = not minimized
			isAnimating = true

			if minimized then
				sizeX.Value = menu.Size.X.Offset
				sizeY.Value = menu.Size.Y.Offset
				NAgui.tween(menu, "Quart", "Out", 0.5, {
					Size = UDim2.new(0, sizeX.Value, 0, 35)
				}).Completed:Connect(function()
					isAnimating = false
				end)
			else
				NAgui.tween(menu, "Quart", "Out", 0.5, {
					Size = UDim2.new(0, sizeX.Value, 0, sizeY.Value)
				}).Completed:Connect(function()
					isAnimating = false
				end)
			end
		end)
		if not success then warn("menuv2 toggleMinimize error:", err) end
	end

	NACaller(function()
		MouseButtonFix(minimizeButton, toggleMinimize)
	end)

	NACaller(function()
		MouseButtonFix(exitButton, function()
			local ok, err = NACaller(function()
				menu.Visible = false
			end)
			if not ok then warn("menuv2 exit button error:", err) end
		end)
	end)

	if clearButton then
		NACaller(function()
			clearButton.Visible = true
			MouseButtonFix(clearButton, function()
				local ok, err = NACaller(function()
					local container = menu:FindFirstChild("Container", true)
					if container then
						local scrollingFrame = container:FindFirstChildOfClass("ScrollingFrame")
						if scrollingFrame then
							local layout = scrollingFrame:FindFirstChildOfClass("UIListLayout", true)
							if layout then
								for _, v in ipairs(layout.Parent:GetChildren()) do
									if v:IsA("TextLabel") then
										v:Destroy()
									end
								end
							end
						end
					end
				end)
				if not ok then warn("menuv2 clear button error:", err) end
			end)
		end)
	end

	if translateButton and NAStuff.ChatTranslator then
		NACaller(function()
			NAStuff.ChatTranslator:registerButton(translateButton)
		end)
	end

	NACaller(function()
		NAgui.draggerV2(menu, menu.Topbar)
	end)

	NACaller(function()
		menu.Visible = false
	end)
end

NAgui.menuv3 = function(menu)
	if not menu then return end
	NAgui.menuv2(menu)
	local translator = NAStuff.ChatTranslator
	local translateButton = menu:FindFirstChild("Translate", true)
	local translateInput = menu:FindFirstChild("TranslateInput", true)

	if translator then
		translator:attachControls(translateButton, translateInput)
	end
end

NAgui.hideFill = function()
	for i, v in ipairs(CMDAUTOFILL) do
		if v:IsA("Frame") then
			v.Visible = false
		end
	end
end

NAgui.loadCMDS = function()
	for _, v in pairs(NAUIMANAGER.cmdAutofill:GetChildren()) do
		if v:IsA("GuiObject") and v.Name ~= "UIListLayout" then
			v:Destroy()
		end
	end
	local layout = NAUIMANAGER.cmdAutofill and NAUIMANAGER.cmdAutofill:FindFirstChildOfClass("UIListLayout")
	if layout then
		layout.SortOrder = Enum.SortOrder.LayoutOrder
	end
	CMDAUTOFILL = {}
	local names = {}
	for name in pairs(cmds.Commands) do
		Insert(names, name)
	end
	table.sort(names, function(a, b)
		local la = a:lower()
		local lb = b:lower()
		if la == lb then
			return a < b
		end
		return la < lb
	end)

	local i = 0
	for _, name in ipairs(names) do
		local cmdData = cmds.Commands[name]
		local displayText = fixStupidSearchGoober(name, cmdData)
		if displayText and displayText ~= "" then
			if type(cmdData[2]) == "table" then
				cmdData[2][1] = displayText
			end
		else
			displayText = (type(cmdData[2]) == "table" and cmdData[2][1]) or name
		end
		local btn = NAUIMANAGER.cmdExample:Clone()
		btn.Parent = NAUIMANAGER.cmdAutofill
		btn.Name = name
		btn.Input.Text = displayText
		i += 1
		btn.LayoutOrder = i
		Insert(CMDAUTOFILL, btn)
	end
	cmdNAnum = i
	NAgui.hideFill()
	NAmanage.rebuildIndex()
end

SpawnCall(function() -- plugin tester
	while Wait(2) do
		if countDictNA(cmds.Commands) ~= cmdNAnum then
			NAgui.loadCMDS()
		end
	end
end)

SpawnCall(function()
	NAmanage.Topbar_Init()
end)

NAgui.barSelect = function(speed)
	speed = speed or 0.4

	NAUIMANAGER.centerBar.Size = UDim2.new(0, 0, 0, 0)

	NAgui.tween(NAUIMANAGER.centerBar, "Back", "Out", speed, {
		Size = UDim2.new(0, 280, 1, 10)
	})

	NAUIMANAGER.leftFill.Position = UDim2.new(0.5, 0, 0.5, 0)
	NAUIMANAGER.rightFill.Position = UDim2.new(0.5, 0, 0.5, 0)
	NAUIMANAGER.leftFill.Size = UDim2.new(0, 0, fillSizes.left.Y.Scale, fillSizes.left.Y.Offset)
	NAUIMANAGER.rightFill.Size = UDim2.new(0, 0, fillSizes.right.Y.Scale, fillSizes.right.Y.Offset)

	Wait(speed * 0.1)
	NAgui.tween(NAUIMANAGER.leftFill, "Quart", "Out", speed * 1.2, {
		Position = UDim2.new(0, 0, 0.5, 0),
		Size = fillSizes.left
	})
	NAgui.tween(NAUIMANAGER.rightFill, "Quart", "Out", speed * 1.2, {
		Position = UDim2.new(1, 0, 0.5, 0),
		Size = fillSizes.right
	})
end

NAgui.barDeselect = function(speed)
	speed = speed or 0.4

	NAgui.tween(NAUIMANAGER.centerBar, "Back", "InOut", speed, {
		Size = UDim2.new(0, 0, 0, 0)
	})

	NAgui.tween(NAUIMANAGER.leftFill, "Quart", "In", speed * 0.9, {
		Position = UDim2.new(-0.5, -125, 0.5, 0),
		Size = UDim2.new(0, 0, fillSizes.left.Y.Scale, fillSizes.left.Y.Offset)
	})
	NAgui.tween(NAUIMANAGER.rightFill, "Quart", "In", speed * 0.9, {
		Position = UDim2.new(1.5, 125, 0.5, 0),
		Size = UDim2.new(0, 0, fillSizes.right.Y.Scale, fillSizes.right.Y.Offset)
	})

	for i, v in ipairs(NAUIMANAGER.cmdAutofill:GetChildren()) do
		if v:IsA("Frame") then
			wrap(function()
				Wait(math.random(50, 120) / 1000)
				NAgui.tween(v, "Exponential", "In", 0.25, {
					Size = UDim2.new(0, 0, 0, 25)
				})
			end)
		end
	end
end

--[[ AUTOFILL SEARCHER ]]--
function fixStupidSearchGoober(cmdName, command)
	local dInfo = command and command[2] and command[2][1] or ""
	local func = command and command[1]

	local aliasSet = {}
	for alias, data in pairs(cmds.Aliases) do
		if data[1] == func then
			aliasSet[Lower(alias)] = true
		end
	end

	local main = cmdName and Lower(cmdName)
	local existingAliases = {}
	local prefix, aliasBlock = dInfo:match("^(.-)%s*%((.-)%)$")

	if aliasBlock then
		for a in aliasBlock:gmatch("[^,%s]+") do
			aliasSet[Lower(a)] = true
		end
	end

	local final = {}
	for alias in pairs(aliasSet) do
		if alias ~= main then
			Insert(final, alias)
		end
	end
	table.sort(final)

	local updTxt
	if prefix then
		updTxt = prefix.." ("..Concat(final, ", ")..")"
	else
		updTxt = dInfo
		if #final > 0 then
			updTxt = updTxt.." ("..Concat(final, ", ")..")"
		end
	end

	return updTxt, final
end

NAmanage.computeScore=function(entry,term,len)
	if entry.lowerName == term then return 1,entry.name end
	if Sub(entry.lowerName,1,len) == term then return 2,entry.name end
	if cmds.Aliases[term] and cmds.Aliases[term][1] == cmds.Commands[entry.name][1] then return 3,term end
	if cmds.NASAVEDALIASES[term] == entry.name then return 3,term end
	for alias,real in pairs(cmds.Aliases) do
		if real[1] == cmds.Commands[entry.name][1] and Sub(alias,1,len) == term then
			return 4,alias
		end
	end
	for alias,real in pairs(cmds.NASAVEDALIASES) do
		if real == entry.name and Sub(alias,1,len) == term then
			return 4,alias
		end
	end
	for _,a in ipairs(entry.extraAliases) do
		if a == term then return 3,entry.name end
		if Sub(a,1,len) == term then return 4,entry.name end
		if Find(a,term,1,true) then return 5,entry.name end
	end
	if len >= 2 then
		if Find(entry.lowerName,term,1,true) then return 6,entry.name end
		if Find(entry.searchable,term,1,true) then
			return 7,(cmds.Commands[entry.name][2] and cmds.Commands[entry.name][2][1] or entry.name)
		end
	end
end

NAmanage.performSearch=function(term)
	for _,f in ipairs(prevVisible) do f.Visible = false end
	table.clear(prevVisible)
	table.clear(results)
	local function revealFrame(frame,index)
		if not frame then return end
		Insert(prevVisible,frame)
		frame.Visible=true
		local w=math.sqrt(index)*125
		local y=(index-1)*28
		local pos=UDim2.new(0.5,w,0,y)
		local size=UDim2.new(0.5,w,0,25)
		if canTween then
			NAgui.tween(frame,"Quint","Out",0.2,{Size=size,Position=pos})
		else
			frame.Size=size
			frame.Position=pos
		end
	end
	if term == "" or Match(term,"^%s*$") then
		predictionInput.Text = ""
		for i=1,math.min(5,#searchIndex) do
			local entry=searchIndex[i]
			if entry then
				revealFrame(entry.frame,i)
			end
		end
		return
	end
	if Match(term,"%s") then
		predictionInput.Text = ""
		return
	end
	local len = #term
	for _,entry in ipairs(searchIndex) do
		local sc,txt = NAmanage.computeScore(entry,term,len)
		if sc then
			Insert(results,{frame=entry.frame,score=sc,text=txt,name=entry.name})
		end
	end
	table.sort(results,function(a,b)
		if a.score==b.score then return a.name<b.name end
		return a.score<b.score
	end)
	predictionInput.Text = (results[1] and results[1].text) or ""
	for i=1,math.min(5,#results)do
		local r=results[i]
		revealFrame(r.frame,i)
	end
end

NAgui.searchCommands = function()
	if NAlib.isConnected("SearchInput") then NAlib.disconnect("SearchInput") end
	NAlib.connect("SearchInput",NAUIMANAGER.cmdInput:GetPropertyChangedSignal("Text"):Connect(function()
		local cleaned = Lower(GSub(NAUIMANAGER.cmdInput.Text,";",""))
		local isBlank = cleaned == "" or cleaned:match("^%s*$")
		if cleaned==lastSearchText and not isBlank then return end
		lastSearchText=cleaned
		gen+=1
		local thisGen=gen
		Delay(0.08,function()
			if thisGen~=gen then return end
			NAmanage.performSearch(cleaned)
		end)
	end))
end

NAgui.loadCMDS()
NAgui.searchCommands()

NAgui.autoFILLLL=function()
	if not NAUIMANAGER.cmdInput then return end
	local current = NAUIMANAGER.cmdInput.Text or ""
	local cleaned = Lower(GSub(current, ";", ""))
	lastSearchText = cleaned
	gen += 1
	NAmanage.performSearch(cleaned)
end

if NAUIMANAGER.cmdInput then
	NAUIMANAGER.cmdInput.Focused:Connect(function()
		Delay(0, NAgui.autoFILLLL)
	end)
end

--[[ OPEN THE COMMAND BAR ]]--
--[[mouse.KeyDown:Connect(function(k)
	if k:lower()==opt.prefix then
		Wait();
		NAgui.barSelect()
		cmdInput.Text=''
		cmdInput:CaptureFocus()
	end
end)]]
UserInputService.InputBegan:Connect(function(i, g)
	if g then return end
	local c = tostring(opt.prefix):sub(1,1)
	local k
	for _, v in pairs(Enum.KeyCode:GetEnumItems()) do
		if v.Name:lower() == c:lower() or v.Value == string.byte(c) then
			k = v
			break
		end
	end
	if i.KeyCode == k then
		Wait()
		if NAUIMANAGER.cmdInput then
			NAgui.barSelect()
			NAUIMANAGER.cmdInput.Text = ''

			while true do
				NAUIMANAGER.cmdInput:CaptureFocus()
				Wait(.00005)
				NAUIMANAGER.cmdInput.Text = ''
				if NAUIMANAGER.cmdInput:IsFocused() then break end
			end
		end
	end
end)

--[[ CLOSE THE COMMAND BAR ]]--
NAUIMANAGER.cmdInput.FocusLost:Connect(function(enter)
	if enter then
		local txt = NAUIMANAGER.cmdInput.Text
		if txt and #txt > 0 then
			wrap(function()
				NAlib.parseCommand(opt.prefix..txt)
			end)
		end
	end
	if predictionInput then
		predictionInput.Text = ""
	end
	Wait(.05)
	if not NAUIMANAGER.cmdInput:IsFocused() then NAgui.barDeselect() end
end)

NAUIMANAGER.cmdInput:GetPropertyChangedSignal("Text"):Connect(function()
	NAgui.searchCommands()
end)

if NAUIMANAGER.filterBox then
	NAUIMANAGER.filterBox:GetPropertyChangedSignal("Text"):Connect(NAmanage.UpdateWaypointList)
end

UserInputService.InputBegan:Connect(function(input)
	if input.KeyCode == Enum.KeyCode.Tab
		and UserInputService:GetFocusedTextBox() == NAUIMANAGER.cmdInput then
		local predictionText = predictionInput and predictionInput.Text or ""
		if predictionText ~= "" then
			Wait()
			NAUIMANAGER.cmdInput.Text = predictionText
			NAUIMANAGER.cmdInput.CursorPosition = #predictionText + 1
			predictionInput.Text = ""
		end
	end
end)

NAgui.barDeselect(0)
NAUIMANAGER.cmdBar.Visible=true
if NAUIMANAGER.chatLogsFrame then
	NAgui.menuv3(NAUIMANAGER.chatLogsFrame)
end

if NAUIMANAGER.NAconsoleFrame then
	NAgui.menuv2(NAUIMANAGER.NAconsoleFrame)
end

if NAUIMANAGER.commandsFrame then
	NAgui.menu(NAUIMANAGER.commandsFrame)
end

if NAUIMANAGER.SettingsFrame then
	NAgui.menu(NAUIMANAGER.SettingsFrame)
end

if NAUIMANAGER.WaypointFrame then
	NAgui.menu(NAUIMANAGER.WaypointFrame)
end

if NAUIMANAGER.BindersFrame then
	NAgui.menu(NAUIMANAGER.BindersFrame)
end

--[[ GUI RESIZE FUNCTION ]]--

if NAUIMANAGER.chatLogsFrame then NAgui.resizeable(NAUIMANAGER.chatLogsFrame) end
if NAUIMANAGER.NAconsoleFrame then NAgui.resizeable(NAUIMANAGER.NAconsoleFrame) end
if NAUIMANAGER.commandsFrame then NAgui.resizeable(NAUIMANAGER.commandsFrame) end
if NAUIMANAGER.SettingsFrame then NAgui.resizeable(NAUIMANAGER.SettingsFrame) end
if NAUIMANAGER.WaypointFrame then NAgui.resizeable(NAUIMANAGER.WaypointFrame) end
if NAUIMANAGER.BindersFrame then NAgui.resizeable(NAUIMANAGER.BindersFrame) end

--[[ CMDS COMMANDS SEARCH FUNCTION ]]--
NAgui.normalizeCommandFilter=function(text)
	text = text or ""
	return Lower(GSub(text, ";", ""))
end

NAgui.sanitizeCommandInfo=function(info)
	local searchableInfo = Lower(info or "")
	searchableInfo = GSub(searchableInfo, "<[^>]+>", "")
	searchableInfo = GSub(searchableInfo, "%[[^%]]+%]", "")
	searchableInfo = GSub(searchableInfo, "%([^%)]+%)", "")
	searchableInfo = GSub(searchableInfo, "{[^}]+}", "")
	searchableInfo = GSub(searchableInfo, "【[^】]+】", "")
	searchableInfo = GSub(searchableInfo, "〖[^〗]+〗", "")
	searchableInfo = GSub(searchableInfo, "«[^»]+»", "")
	searchableInfo = GSub(searchableInfo, "‹[^›]+›", "")
	searchableInfo = GSub(searchableInfo, "「[^」]+」", "")
	searchableInfo = GSub(searchableInfo, "『[^』]+』", "")
	searchableInfo = GSub(searchableInfo, "（[^）]+）", "")
	searchableInfo = GSub(searchableInfo, "〔[^〕]+〕", "")
	searchableInfo = GSub(searchableInfo, "‖[^‖]+‖", "")
	searchableInfo = GSub(searchableInfo, "%s+", " ")
	searchableInfo = GSub(searchableInfo, "^%s*(.-)%s*$", "%1")
	return searchableInfo
end

NAgui.filterCommandList = function(rawText)
	if not NAUIMANAGER.commandsList then return end
	local searchText = NAgui.normalizeCommandFilter(rawText)
	for _, label in ipairs(NAUIMANAGER.commandsList:GetChildren()) do
		if label:IsA("TextLabel") then
			local cmdName = Lower(label.Name or "")
			local command = cmds.Commands[cmdName]
			if command then
				local updatedText, aliasList = fixStupidSearchGoober(cmdName, command)
				local displayText = updatedText
				if not displayText or displayText == "" then
					displayText = (type(command[2]) == "table" and command[2][1]) or cmdName
				end
				if type(command[2]) == "table" then
					command[2][1] = displayText
				end
				aliasList = aliasList or {}
				for i = 1, #aliasList do
					aliasList[i] = Lower(aliasList[i])
				end
				local sanitizedInfo = NAgui.sanitizeCommandInfo(displayText)
				local matches
				if searchText == "" then
					matches = true
				else
					if Sub(cmdName, 1, #searchText) == searchText then
						matches = true
					elseif Find(sanitizedInfo, searchText, 1, true) then
						matches = true
					else
						for _, alias in ipairs(aliasList) do
							if Sub(alias, 1, #searchText) == searchText or Find(alias, searchText, 1, true) then
								matches = true
								break
							end
						end
					end
				end
				label.Visible = matches and true or false
				if matches then
					label.Text = " "..displayText
				end
			else
				label.Visible = searchText == ""
			end
		end
	end
end

NAUIMANAGER.commandsFilter:GetPropertyChangedSignal("Text"):Connect(function()
	NAgui.filterCommandList(NAUIMANAGER.commandsFilter.Text)
end)

do
	local Http = HttpService
	local translator = NAStuff.ChatTranslator or {}
	NAStuff.ChatTranslator = translator

	translator.messages = translator.messages or {}
	translator.enabled = opt.chatTranslateEnabled ~= false
	opt.chatTranslateEnabled = translator.enabled

	local function toIso(value)
		if not value then return nil end
		return tostring(value):lower()
	end

	local languages = {
		auto="Automatic",af="Afrikaans",sq="Albanian",am="Amharic",ar="Arabic",hy="Armenian",az="Azerbaijani",eu="Basque",be="Belarusian",bn="Bengali",bs="Bosnian",bg="Bulgarian",ca="Catalan",ceb="Cebuano",ny="Chichewa",
		["zh-cn"]="Chinese Simplified",["zh-tw"]="Chinese Traditional",co="Corsican",hr="Croatian",cs="Czech",da="Danish",nl="Dutch",en="English",eo="Esperanto",et="Estonian",tl="Filipino",fi="Finnish",fr="French",fy="Frisian",
		gl="Galician",ka="Georgian",de="German",el="Greek",gu="Gujarati",ht="Haitian Creole",ha="Hausa",haw="Hawaiian",iw="Hebrew",he="Hebrew",hi="Hindi",hmn="Hmong",hu="Hungarian",is="Icelandic",ig="Igbo",id="Indonesian",ga="Irish",it="Italian",
		ja="Japanese",jw="Javanese",kn="Kannada",kk="Kazakh",km="Khmer",ko="Korean",ku="Kurdish (Kurmanji)",ky="Kyrgyz",lo="Lao",la="Latin",lv="Latvian",lt="Lithuanian",lb="Luxembourgish",mk="Macedonian",mg="Malagasy",ms="Malay",
		ml="Malayalam",mt="Maltese",mi="Maori",mr="Marathi",mn="Mongolian",my="Myanmar (Burmese)",ne="Nepali",no="Norwegian",ps="Pashto",fa="Persian",pl="Polish",pt="Portuguese",pa="Punjabi",ro="Romanian",ru="Russian",sm="Samoan",
		gd="Scots Gaelic",sr="Serbian",st="Sesotho",sn="Shona",sd="Sindhi",si="Sinhala",sk="Slovak",sl="Slovenian",so="Somali",es="Spanish",su="Sundanese",sw="Swahili",sv="Swedish",tg="Tajik",ta="Tamil",te="Telugu",th="Thai",tr="Turkish",
		uk="Ukrainian",ur="Urdu",uz="Uzbek",vi="Vietnamese",cy="Welsh",xh="Xhosa",yi="Yiddish",yo="Yoruba",zu="Zulu"
	}

	local function iso(value)
		local lowered = toIso(value)
		if not lowered then
			return nil
		end
		if languages[lowered] then
			return lowered
		end
		for code, name in pairs(languages) do
			if type(name) == "string" and name:lower() == lowered then
				return code
			end
		end
		return nil
	end

	local function languageName(code)
		return languages[code] or code
	end

	translator.target = iso(opt.chatTranslateTarget) or translator.target or "en"
	opt.chatTranslateTarget = translator.target

	translator._state = translator._state or {
		gv = (isfile and isfile("googlev.txt") and readfile("googlev.txt")) or "";
		fsid = nil;
		bl = nil;
		rid = math.random(1000, 9999);
	}

	local state = translator._state
	local root = "https://translate.google.com/"
	local exec = "https://translate.google.com/_/TranslateWebserverUi/data/batchexecute"
	local rpc = "MkEWBc"

	local function requestAsync(optArgs)
		local fn = opt.NAREQUEST
		if fn then
			local ok, res = pcall(fn, optArgs)
			if ok and res then
				return res
			end
		end
		local ok2, res2 = pcall(function()
			return Http:RequestAsync(optArgs)
		end)
		if ok2 and res2 then
			return res2
		end
		return nil
	end

	local function handleConsent(body)
		local tokens = {}
		for tag in body:gmatch('<input type="hidden" name=".-" value=".-">') do
			local k, v = tag:match('<input type="hidden" name="(.-)" value="(.-)">')
			if k and v then
				tokens[k] = v
			end
		end
		state.gv = tokens.v or state.gv or ""
		if writefile then
			pcall(writefile, "googlev.txt", state.gv)
		end
	end

	local function fetch(url, method, body)
		local res = requestAsync({
			Url = url;
			Method = method or "GET";
			Headers = { cookie = "CONSENT=YES+"..(state.gv or "") };
			Body = body;
		})
		if not res then
			return nil
		end
		local b = res.Body or res.body or ""
		if type(b) ~= "string" then
			b = tostring(b)
		end
		if b:find("https://consent.google.com/s") then
			handleConsent(b)
			res = requestAsync({
				Url = url;
				Method = "GET";
				Headers = { cookie = "CONSENT=YES+"..(state.gv or "") };
			})
			if not res then
				return nil
			end
		end
		return res
	end

	local function ensureSession()
		if state.fsid and state.bl then
			return true
		end
		local res = fetch(root)
		if not res then
			return false
		end
		local body = res.Body or res.body or ""
		if type(body) ~= "string" then
			body = tostring(body)
		end
		state.fsid = body:match('"FdrFJe":"(.-)"')
		state.bl = body:match('"cfb2h":"(.-)"')
		return state.fsid ~= nil and state.bl ~= nil
	end

	local function encodeQuery(data)
		local s = ""
		for k, v in pairs(data) do
			if type(v) == "table" then
				for _, vv in pairs(v) do
					s ..= "&"..Http:UrlEncode(k).."="..Http:UrlEncode(vv)
				end
			else
				s ..= "&"..Http:UrlEncode(k).."="..Http:UrlEncode(v)
			end
		end
		return s:sub(2)
	end

	local jsonEncode = function(x) return Http:JSONEncode(x) end
	local jsonDecode = function(x) return Http:JSONDecode(x) end

	local function translateSimple(text, target, source)
		target = iso(target) or "en"
		source = iso(source) or "auto"
		local url = ("https://translate.googleapis.com/translate_a/single?client=gtx&sl=%s&tl=%s&dt=t&q=%s")
			:format(Http:UrlEncode(source), Http:UrlEncode(target), Http:UrlEncode(text))
		local res = requestAsync({Url = url, Method = "GET"})
		if not res then return nil end
		local body = res.Body or res.body or ""
		local ok, data = pcall(function()
			return Http:JSONDecode(body)
		end)
		if not ok or type(data) ~= "table" then
			return nil
		end
		local segments = data[1]
		local detected = data[3]
		local parts = {}
		if type(segments) == "table" then
			for _, seg in ipairs(segments) do
				if type(seg) == "table" and type(seg[1]) == "string" then
					Insert(parts, seg[1])
				end
			end
		end
		local translated = Concat(parts, "")
		if translated == "" then
			translated = nil
		end
		return translated, detected
	end

	local function translatePayload(text, target, source)
		if not text or text == "" then
			return nil
		end
		local translated, detected = translateSimple(text, target, source)
		if translated and translated ~= "" then
			return translated, detected
		end
		if not ensureSession() then
			return translated, detected
		end
		state.rid += 10000
		target = iso(target) or "en"
		source = iso(source) or "auto"
		local data = { { text, source, target, true }, { nil } }
		local freq = { { { rpc, jsonEncode(data), nil, "generic" } } }
		local url = exec.."?"..encodeQuery({
			rpcids = rpc;
			["f.sid"] = state.fsid;
			bl = state.bl;
			hl = "en";
			_reqid = state.rid - 10000;
			rt = "c";
		})
		local body = encodeQuery({ ["f.req"] = jsonEncode(freq) })
		local res = fetch(url, "POST", body)
		if not res then
			return translated, detected
		end
		local raw = res.Body or res.body or ""
		if type(raw) ~= "string" then
			raw = tostring(raw)
		end
		local ok, parsed = pcall(function()
			local arr = jsonDecode(raw:match("%[.-%]\n"))
			return jsonDecode(arr[1][3])
		end)
		if not ok or type(parsed) ~= "table" then
			return translated, detected
		end
		local fallTranslated = nil
		pcall(function()
			fallTranslated = parsed[2][1][1][6][1][1]
		end)
		if type(fallTranslated) ~= "string" or fallTranslated == "" then
			return translated, detected
		end
		local detectedLang = parsed[3]
		return fallTranslated, detectedLang or detected
	end

	local function resizeLabel(label)
		if not (label and label.Parent and NAgui and NAgui.txtSize) then
			return
		end
		local ok, size = pcall(NAgui.txtSize, label, label.AbsoluteSize.X, 200)
		if ok and size then
			label.Size = UDim2.new(1, -5, 0, size.Y)
		end
	end

	function translator:isEnabled()
		return self.enabled == true
	end

	function translator:updateUI()
		if self.button then
			if self:isEnabled() then
				self.button.Text = "TR: "..string.upper(self.target or "EN")
				self.button.BackgroundColor3 = Color3.fromRGB(68, 108, 68)
				self.button.TextColor3 = Color3.fromRGB(234, 234, 244)
			else
				self.button.Text = "TR: OFF"
				self.button.BackgroundColor3 = Color3.fromRGB(54, 54, 64)
				self.button.TextColor3 = Color3.fromRGB(178, 178, 188)
			end
		end
		if self.input and not self.input:IsFocused() then
			self.input.Text = string.upper(self.target or "EN")
		end
	end

	function translator:updateAllMessages()
		for _, info in pairs(self.messages) do
			if self:isEnabled() then
				self:ensureTranslation(info)
			end
			self:applyDisplay(info)
		end
	end

	function translator:setEnabled(state)
		local newState = state and true or false
		if self.enabled == newState then
			self.enabled = newState
			self:updateUI()
			return
		end
		self.enabled = newState
		opt.chatTranslateEnabled = newState
		pcall(NAmanage.NASettingsSet, "chatTranslate", newState)
		self:updateUI()
		self:updateAllMessages()
	end

	function translator:toggle()
		self:setEnabled(not self:isEnabled())
		return self.enabled
	end

	function translator:applyDisplay(info)
		if not info or not info.label then return end
		local label = info.label
		if not (label and label.Parent) then
			self.messages[label] = nil
			return
		end
		local text = info.base or ""
		if self:isEnabled() and info.translationLine then
			text = text.."\n"..info.translationLine
		end
		label.Text = text
		resizeLabel(label)
	end

	function translator:ensureTranslation(info)
		if not info or info.translating then
			return
		end
		if info.translationLine and info.target == self.target then
			return
		end
		if not info.message or info.message == "" then
			return
		end
		info.translating = true
		info.target = self.target
		Spawn(function()
			local ok, translated, detected = pcall(translatePayload, info.message, self.target, "auto")
			info.translating = false
			if not ok then
				info.translationLine = nil
				self:applyDisplay(info)
				return
			end
			if not translated or translated == "" then
				info.translationLine = nil
				self:applyDisplay(info)
				return
			end
			local code = iso(detected) or detected or "AUTO"
			local tag = tostring(code):upper()
			info.translationLine = ("[%s] %s"):format(self.target:upper(), translated)
			info.detected = tag
			self:applyDisplay(info)
		end)
	end

	function translator:registerMessage(label, baseText, rawMessage)
		if not label then return end
		local info = self.messages[label]
		if not info then
			info = {
				label = label;
				base = baseText or "";
				message = rawMessage or "";
				translationLine = nil;
				translating = false;
				target = nil;
			}
			self.messages[label] = info
			if label.Destroying then
				label.Destroying:Connect(function()
					self.messages[label] = nil
				end)
			end
			label.AncestryChanged:Connect(function(_, parent)
				if not parent then
					self.messages[label] = nil
				end
			end)
		else
			info.base = baseText or info.base
			info.message = rawMessage or info.message
			info.translationLine = nil
			info.target = nil
		end

		self:applyDisplay(info)
		self:ensureTranslation(info)
	end

	function translator:setTarget(lang)
		local code = iso(lang)
		if not code then
			return false
		end
		if self.target == code then
			self:updateUI()
			return true, code, languageName(code)
		end
		self.target = code
		opt.chatTranslateTarget = code
		pcall(NAmanage.NASettingsSet, "chatTranslateTarget", code)
		for _, info in pairs(self.messages) do
			info.translationLine = nil
			info.target = nil
			info.translating = false
			self:applyDisplay(info)
			self:ensureTranslation(info)
		end
		self:updateUI()
		return true, code, languageName(code)
	end

	function translator:attachControls(button, input)
		if button and self.button ~= button then
			self.button = button
			MouseButtonFix(button, function()
				local nowEnabled = self:toggle()
				self:updateUI()
				DebugNotif("Chat translation "..(nowEnabled and "enabled" or "disabled"), 2)
			end)
		end
		if input and self.input ~= input then
			if self._inputConn then
				self._inputConn:Disconnect()
				self._inputConn = nil
			end
			self.input = input
			input.PlaceholderText = "Lang"
			input.ClearTextOnFocus = false
			self._inputConn = input.FocusLost:Connect(function(enterPressed)
				local text = input.Text or ""
				text = text:match("^%s*(.-)%s*$") or ""
				if text == "" then
					self:updateUI()
					return
				end
				local ok, code, name = self:setTarget(text)
				if not ok then
					DoNotif("Invalid language code. Example: en, bg, ja", 1.5)
				else
					DoNotif(("Chat translator target set to %s (%s)"):format(code:upper(), name), 1.5)
				end
				self:updateUI()
				if enterPressed then
					input:ReleaseFocus()
				end
			end)
		end
		self:updateUI()
	end

	function translator:tryAttach()
		local frame = NAUIMANAGER and NAUIMANAGER.chatLogsFrame
		if not frame then return end
		local button = frame:FindFirstChild("Translate", true)
		local input = frame:FindFirstChild("TranslateInput", true)
		if button or input then
			self:attachControls(button, input)
		end
	end

	function translator:showLanguages()
		local entries = {}
		for code, name in pairs(languages) do
			if code ~= "auto" then
				Insert(entries, { code, name })
			end
		end
		table.sort(entries, function(a, b)
			return a[1] < b[1]
		end)
		local lines = {}
		for _, info in ipairs(entries) do
			Insert(lines, info[1]:upper().." - "..info[2])
		end
		local text = Concat(lines, "\n")
		if typeof(DoWindow) == "function" then
			DoWindow("Supported chat translator languages:\n\n"..text)
		else
			print("[ChatTranslator languages]\n"..text)
			DoNotif("Supported languages printed to console output.", 4)
		end
	end

	translator:tryAttach()
	if NAStuff.NASCREENGUI and not translator._hookedWatcher then
		translator._hookedWatcher = true
		NAStuff.NASCREENGUI.DescendantAdded:Connect(function(inst)
			if inst and (inst.Name == "Translate" or inst.Name == "TranslateInput") then
				Defer(function()
					translator:tryAttach()
				end)
			end
		end)
	end
	translator:updateUI()
end

--[[ CHAT TO USE COMMANDS ]]--
function bindToChat(plr, msg)
	local chatMsg = NAUIMANAGER.chatExample:Clone()

	for _, v in pairs(NAUIMANAGER.chatLogs:GetChildren()) do
		if v:IsA("TextLabel") then
			v.LayoutOrder = v.LayoutOrder + 1
		end
	end

	chatMsg.Name = '\0'
	chatMsg.Parent = NAUIMANAGER.chatLogs

	local displayName = plr.DisplayName or "Unknown"
	local userName = plr.Name or "Unknown"

	local isNAadmin = false
	if _G.NAadminsLol then
		for _, id in ipairs(_G.NAadminsLol) do
			if plr.UserId == id then
				isNAadmin = true
				break
			end
		end
	end

	local currentTime = os.date("%Y-%m-%d %H:%M:%S")
	local baseText
	if displayName == userName then
		baseText = ("@%s: %s"):format(userName, msg)
	else
		baseText = ("%s [@%s]: %s"):format(displayName, userName, msg)
	end
	chatMsg.Text = baseText

	if isNAadmin then
		local function rainbowColor()
			local time = tick()
			local r = math.sin(time * 0.5) * 127 + 128
			local g = math.sin(time * 0.5 + 2 * math.pi / 3) * 127 + 128
			local b = math.sin(time * 0.5 + 4 * math.pi / 3) * 127 + 128
			return Color3.fromRGB(r, g, b)
		end
		RunService.Heartbeat:Connect(function()
			if chatMsg and chatMsg.Parent then
				chatMsg.TextColor3 = rainbowColor()
			end
		end)
	else
		if plr == LocalPlayer then
			chatMsg.TextColor3 = Color3.fromRGB(0, 155, 255)
		elseif LocalPlayer:IsFriendsWith(plr.UserId) then
			chatMsg.TextColor3 = Color3.fromRGB(255, 255, 0)
		end
	end

	local translator = NAStuff.ChatTranslator
	if translator then
		translator:registerMessage(chatMsg, baseText, msg)
	end

	pcall(function()
		if FileSupport and appendfile then
			local cEntry = Format(
				"[%s] %s | Game: %s | PlaceId: %s | GameId: %s | JobId: %s\n",
				currentTime,
				chatMsg.Text,
				placeName() or "unknown",
				tostring(PlaceId),
				tostring(GameId),
				tostring(JobId)
			)
			if isfile(NAfiles.NACHATLOGS) then
				appendfile(NAfiles.NACHATLOGS, cEntry)
			else
				writefile(NAfiles.NACHATLOGS, cEntry)
			end
		end
	end)

	local txtSize = NAgui.txtSize(chatMsg, chatMsg.AbsoluteSize.X, 200)
	chatMsg.Size = UDim2.new(1, -5, 0, txtSize.Y)

	local MAX_MESSAGES = 200
	local chatFrames = {}
	for _, v in pairs(NAUIMANAGER.chatLogs:GetChildren()) do
		if v:IsA("TextLabel") then
			Insert(chatFrames, v)
		end
	end

	table.sort(chatFrames, function(a, b)
		return a.LayoutOrder < b.LayoutOrder
	end)

	if #chatFrames > MAX_MESSAGES then
		for i = MAX_MESSAGES + 1, #chatFrames do
			chatFrames[i]:Destroy()
		end
	end
end

NAmanage.bindToDevConsole = function()
	if not NAUIMANAGER.NAconsoleLogs or not NAUIMANAGER.NAconsoleExample then return end

	local activeLogs, pool, pending = {}, {}, {}
	local buttonTypes = { "Output", "Info", "Warn", "Error" }
	local savedFilters
	if NAmanage and NAmanage.NASettingsGet then
		local ok, result = pcall(function()
			return NAmanage.NASettingsGet("devConsoleFilters")
		end)
		if ok and type(result) == "table" then
			savedFilters = result
		end
	end
	local toggles = {}
	for _, logType in ipairs(buttonTypes) do
		local savedValue = savedFilters and savedFilters[logType]
		if type(savedValue) == "boolean" then
			toggles[logType] = savedValue
		else
			toggles[logType] = true
		end
	end

	local SELECTED_COLOR = Color3.fromRGB(0, 255, 0)
	local DESELECTED_COLOR = Color3.fromRGB(255, 255, 255)

	local FilterButtons = InstanceNew("Frame")
	FilterButtons.Name = "FilterButtons"
	FilterButtons.Size = UDim2.new(1, -10, 0, 22)
	FilterButtons.Position = UDim2.new(0.5, 0, 0, 30)
	FilterButtons.AnchorPoint = Vector2.new(0.5, 0)
	FilterButtons.BackgroundTransparency = 1
	FilterButtons.Parent = NAUIMANAGER.NAconsoleLogs.Parent

	local layout = InstanceNew("UIListLayout")
	layout.FillDirection = Enum.FillDirection.Horizontal
	layout.HorizontalAlignment = Enum.HorizontalAlignment.Center
	layout.SortOrder = Enum.SortOrder.LayoutOrder
	layout.Padding = UDim.new(0, 6)
	layout.Parent = FilterButtons

	for _, logType in ipairs(buttonTypes) do
		local btnContainer = InstanceNew("Frame")
		btnContainer.Name = logType
		btnContainer.Size = UDim2.new(0, 90, 1, 0)
		btnContainer.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
		btnContainer.Parent = FilterButtons

		local corner = InstanceNew("UICorner")
		corner.CornerRadius = UDim.new(1, 0)
		corner.Parent = btnContainer

		local checkbox = InstanceNew("Frame")
		checkbox.Name = "Checkbox"
		checkbox.Size = UDim2.new(0, 18, 0, 18)
		checkbox.Position = UDim2.new(0, 5, 0.5, 0)
		checkbox.AnchorPoint = Vector2.new(0, 0.5)
		checkbox.BackgroundColor3 = toggles[logType] and SELECTED_COLOR or DESELECTED_COLOR
		checkbox.BorderSizePixel = 0
		checkbox.Parent = btnContainer

		local boxCorner = InstanceNew("UICorner")
		boxCorner.CornerRadius = UDim.new(0, 4)
		boxCorner.Parent = checkbox

		local label = InstanceNew("TextLabel")
		label.Name = "Label"
		label.Text = logType
		label.Position = UDim2.new(0, 28, 0, 0)
		label.Size = UDim2.new(1, -28, 1, 0)
		label.BackgroundTransparency = 1
		label.Font = Enum.Font.Gotham
		label.TextSize = 14
		label.TextColor3 = Color3.fromRGB(255, 255, 255)
		label.TextXAlignment = Enum.TextXAlignment.Center
		label.Parent = btnContainer

		local clickZone = InstanceNew("TextButton")
		clickZone.Name = "ClickArea"
		clickZone.Size = UDim2.new(1, 0, 1, 0)
		clickZone.BackgroundTransparency = 1
		clickZone.Text = ""
		clickZone.Parent = btnContainer

		MouseButtonFix(clickZone, function()
			toggles[logType] = not toggles[logType]

			if NAmanage and NAmanage.NASettingsSet then
				local ok, saved = pcall(function()
					return NAmanage.NASettingsSet("devConsoleFilters", toggles)
				end)
				if ok and type(saved) == "table" then
					for _, key in ipairs(buttonTypes) do
						local savedValue = saved[key]
						if type(savedValue) == "boolean" then
							toggles[key] = savedValue
						end
					end
				end
			end

			local targetColor = toggles[logType] and SELECTED_COLOR or DESELECTED_COLOR
			local tweenInfo = TweenInfo.new(0.3, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut)
			TweenService:Create(checkbox, tweenInfo, {BackgroundColor3 = targetColor}):Play()

			local query = NAUIMANAGER.NAfilter.Text:lower()
			for i = 1, #activeLogs do
				local lbl = activeLogs[i]
				if lbl and lbl.Parent then
					local tag = lbl:GetAttribute("Tag")
					local matchesSearch = query == "" or Find(lbl.Text:lower(), query)
					lbl.Visible = toggles[tag] and matchesSearch
				end
			end
		end)
	end

	NAUIMANAGER.NAfilter:GetPropertyChangedSignal("Text"):Connect(function()
		local query = NAUIMANAGER.NAfilter.Text:lower()
		for i = 1, #activeLogs do
			local lbl = activeLogs[i]
			if lbl and lbl.Parent then
				local tag = lbl:GetAttribute("Tag")
				local matches = query == "" or Find(lbl.Text:lower(), query)
				lbl.Visible = toggles[tag] and matches
			end
		end
	end)

	local function acquireLabel()
		if not NAUIMANAGER.NAconsoleLogs or not NAUIMANAGER.NAconsoleLogs.Parent then return nil end
		local lbl = table.remove(pool)
		if not lbl then
			lbl = NAUIMANAGER.NAconsoleExample:Clone()
			lbl.RichText = true
			lbl.AutoLocalize = false
			pcall(function() lbl.Active = true end)
			lbl.TextWrapped = true
			lbl.TextScaled = true
		end
		if not pcall(function() lbl.Parent = NAUIMANAGER.NAconsoleLogs end) then return nil end
		return lbl
	end

	local function recycleOldest()
		local oldest = table.remove(activeLogs, 1)
		if oldest then
			oldest.Visible = false
			oldest.Parent = nil
			Insert(pool, oldest)
		end
	end

	local function escape(s)
		return s:gsub("&","&amp;"):gsub("<","&lt;"):gsub(">","&gt;")
	end

	local function measureHeight(lbl, width)
		local plain = lbl.Text:gsub("<.->","")
		local baseSize = NAUIMANAGER.NAconsoleExample.TextSize or 14
		local vec = TextService:GetTextSize(plain, baseSize, lbl.Font, Vector2.new(width, 1e6))
		local h = vec.Y
		if h < 18 then h = 18 end
		return math.floor(h + 0.5)
	end

	local messageCounter = 0
	local MAX_MESSAGES = 200

	RunService.Heartbeat:Connect(function()
		if not NAUIMANAGER.NAconsoleLogs or not NAUIMANAGER.NAconsoleLogs.Parent then return end
		local perStep = 30
		local processed = 0
		while processed < perStep and #pending > 0 do
			local item = table.remove(pending, 1)
			if toggles[item.t] then
				local logLabel = acquireLabel()
				if not logLabel then break end
				messageCounter += 1
				logLabel.Name = "Log_"..tostring(messageCounter)
				logLabel.LayoutOrder = messageCounter
				logLabel.Text = '<font color="'..item.c..'">['..item.t..']</font>: <font color="#ffffff">'..item.m..'</font>'
				logLabel:SetAttribute("Tag", item.t)

				local width = NAUIMANAGER.NAconsoleLogs.AbsoluteSize.X
				local h = measureHeight(logLabel, width)
				logLabel.Size = UDim2.new(1, 0, 0, h)

				activeLogs[#activeLogs + 1] = logLabel
				if #activeLogs > MAX_MESSAGES then
					recycleOldest()
				end

				local query = NAUIMANAGER.NAfilter.Text:lower()
				local matchesSearch = query == "" or Find(logLabel.Text:lower(), query)
				logLabel.Visible = toggles[item.t] and matchesSearch
				processed += 1
			end
		end
	end)

	SafeGetService("LogService").MessageOut:Connect(function(msg, msgTYPE)
		local tagColor = "#cccccc"
		local tagText = "Output"
		if msgTYPE == Enum.MessageType.MessageError then
			tagColor = "#ff6464"
			tagText = "Error"
		elseif msgTYPE == Enum.MessageType.MessageWarning then
			tagColor = "#ffcc00"
			tagText = "Warn"
		elseif msgTYPE == Enum.MessageType.MessageInfo then
			tagColor = "#66ccff"
			tagText = "Info"
		end
		if not toggles[tagText] then return end
		Insert(pending, { m = escape(msg), t = tagText, c = tagColor })
	end)
end

--[[function NAUISCALEUPD()
	if not workspace.CurrentCamera then return end

	local screenHeight = workspace.CurrentCamera.ViewportSize.Y
	local baseHeight = 720
	AUTOSCALER.Scale = math.clamp(screenHeight / baseHeight, 0.75, 1.25)
end]]

local logClrs={
	GREEN   = "#00FF00";
	WHITE   = "#FFFFFF";
	RED     = "#FF0000";
}

binderKillerTags = {
	"creator",
	"Creator",
	"creatorPlayer",
	"creatorTag",
	"killer",
	"Killer",
	"attacker",
	"Attacker",
	"DamageOwner",
	"DamageTag",
	"LastDamager",
	"lastDamager",
}

originalIO.binderResolvePlayerFromValue=function(value)
	if typeof(value) == "Instance" then
		if value:IsA("Player") then
			return value
		end
		return Players:GetPlayerFromCharacter(value)
	end
	if type(value) == "number" then
		local ok, plr = pcall(function()
			return Players:GetPlayerByUserId(value)
		end)
		if ok and plr then
			return plr
		end
	elseif type(value) == "string" then
		return Players:FindFirstChild(value)
	end
	return nil
end

originalIO.binderFindPlayerInTag=function(tag)
	if not tag then
		return nil
	end
	if tag:IsA("ObjectValue") then
		return originalIO.binderResolvePlayerFromValue(tag.Value)
	end
	if tag:IsA("StringValue") then
		return Players:FindFirstChild(tag.Value)
	end
	if tag:IsA("IntValue") or tag:IsA("NumberValue") then
		local ok, plr = pcall(function()
			return Players:GetPlayerByUserId(tag.Value)
		end)
		if ok and plr then
			return plr
		end
	end
	if tag:IsA("ValueBase") then
		return originalIO.binderResolvePlayerFromValue(tag.Value)
	end
	if tag:IsA("Folder") or tag:IsA("Model") then
		for _, child in ipairs(tag:GetChildren()) do
			local result = originalIO.binderFindPlayerInTag(child)
			if result then
				return result
			end
		end
	end
	return originalIO.binderResolvePlayerFromValue(tag)
end

originalIO.binderFindKiller=function(humanoid)
	if not humanoid then
		return nil
	end
	for _, name in ipairs(binderKillerTags) do
		local tag = humanoid:FindFirstChild(name)
		local killer = originalIO.binderFindPlayerInTag(tag)
		if killer then
			return killer
		end
	end
	for _, child in ipairs(humanoid:GetChildren()) do
		local killer = originalIO.binderFindPlayerInTag(child)
		if killer then
			return killer
		end
	end
	return nil
end

originalIO.binderAttachHumanoidListeners=function(plr, hum)
	if not (plr and hum) then
		return
	end
	local lastHP = hum.Health
	hum.Died:Connect(function()
		NAmanage.ExecuteBindings("OnDeath", plr)
		local killer = originalIO.binderFindKiller(hum)
		if killer then
			NAmanage.ExecuteBindings("OnKill", killer, plr)
		end
	end)
	hum.HealthChanged:Connect(function(newHP)
		if newHP < lastHP then
			NAmanage.ExecuteBindings("OnDamage", plr, lastHP, newHP)
		end
		lastHP = newHP
	end)
	hum.StateChanged:Connect(function(_, newState)
		if newState == Enum.HumanoidStateType.Jumping then
			NAmanage.ExecuteBindings("OnJump", plr, hum)
		end
	end)
end

originalIO.binderAttachToolListeners=function(plr, char)
	if not (plr and char) then
		return
	end
	char.ChildAdded:Connect(function(child)
		if child:IsA("Tool") then
			NAmanage.ExecuteBindings("OnEquipItem", plr, child)
		end
	end)
	char.ChildRemoved:Connect(function(child)
		if child:IsA("Tool") then
			NAmanage.ExecuteBindings("OnUnequipItem", plr, child)
		end
	end)
end

originalIO.binderSetupCharacter=function(plr, char)
	if not char then
		return
	end
	originalIO.binderAttachToolListeners(plr, char)
	local hum = getHum(char)
	if hum then
		originalIO.binderAttachHumanoidListeners(plr, hum)
	end
end

function setupPlayer(plr,bruh)
	NAmanage.ExecuteBindings("OnJoin", plr)

	plr.Chatted:Connect(function(msg)
		bindToChat(plr, msg)
		NAmanage.ExecuteBindings("OnChatted", plr, msg)
	end)

	if plr ~= LocalPlayer then
		SpawnCall(function() CheckPermissions(plr) end)
	end

	if ESPenabled and ESPAutoTrackAll then
		SpawnCall(function()
			repeat Wait(.5) until plr.Character
			Wait(.5)
			NAmanage.ESP_Add(plr,true)
		end)
	end

	plr.CharacterAdded:Connect(function(char)
		NAmanage.ExecuteBindings("OnSpawn", plr, char)
		originalIO.binderSetupCharacter(plr, char)
	end)

	if not bruh and plr.Character then
		originalIO.binderSetupCharacter(plr, plr.Character)
	end

	if JoinLeaveConfig.JoinLog and not bruh then
		local joinMsg = nameChecker(plr).." has joined the game."
		local categoryRT = ('<font color="%s">Join</font>/'..'<font color="%s">Leave</font>'):format(logClrs.GREEN, logClrs.WHITE)
		DoNotif(joinMsg, 1, categoryRT)
		NAmanage.LogJoinLeave(joinMsg)
	end
end

for _, plr in pairs(Players:GetPlayers()) do
	setupPlayer(plr, true)
	if plr.Character then
		originalIO.binderSetupCharacter(plr, plr.Character)
	end
end

Players.PlayerAdded:Connect(setupPlayer)

Players.PlayerRemoving:Connect(function(plr)
	NAmanage.ExecuteBindings("OnLeave", plr)
	NAmanage.ESP_Disconnect(plr)
	if JoinLeaveConfig.LeaveLog then
		local leaveMsg = nameChecker(plr).." has left the game."
		local categoryRT = ('<font color="%s">Join</font>/'..'<font color="%s">Leave</font>'):format(logClrs.WHITE, logClrs.RED)
		DoNotif(leaveMsg, 1, categoryRT)
		NAmanage.LogJoinLeave(leaveMsg)
	end
end)

SpawnCall(function()
	NAmanage.UIrenamerFRIEND=function(o)
		if type(o.Text) == "string" then
			o.Text = o.Text:gsub("Connections","Friends"):gsub("Connection","Friend")
		end
	end

	for _, internet in ipairs(workspace:GetDescendants()) do
		if internet:IsA("ClickDetector") then
			Insert(interactTbl.click, internet)
		elseif internet:IsA("ProximityPrompt") then
			Insert(interactTbl.proxy, internet)
		elseif internet:IsA("TouchTransmitter") then
			Insert(interactTbl.touch, internet)
		end
	end

	if CoreGui then
		for _, o in ipairs(CoreGui:GetDescendants()) do
			if o:IsA("TextLabel") or o:IsA("TextButton") or o:IsA("TextBox") then
				NAmanage.UIrenamerFRIEND(o)
			end
		end
		CoreGui.DescendantAdded:Connect(function(o)
			if o:IsA("TextLabel") or o:IsA("TextButton") or o:IsA("TextBox") then
				NAmanage.UIrenamerFRIEND(o)
			end
			for _, c in ipairs(o:GetDescendants()) do
				if c:IsA("TextLabel") or c:IsA("TextButton") or c:IsA("TextBox") then
					NAmanage.UIrenamerFRIEND(c)
				end
			end
		end)
	end

	workspace.DescendantAdded:Connect(function(internet)
		if internet:IsA("ClickDetector") then
			Insert(interactTbl.click, internet)
		elseif internet:IsA("ProximityPrompt") then
			Insert(interactTbl.proxy, internet)
		elseif internet:IsA("TouchTransmitter") then
			Insert(interactTbl.touch, internet)
		end
	end)

	workspace.DescendantRemoving:Connect(function(internet)
		if internet:IsA("ClickDetector") then
			local i = Discover(interactTbl.click, internet)
			if i then table.remove(interactTbl.click, i) end
		elseif internet:IsA("ProximityPrompt") then
			local i = Discover(interactTbl.proxy, internet)
			if i then table.remove(interactTbl.proxy, i) end
		elseif internet:IsA("TouchTransmitter") then
			local i = Discover(interactTbl.touch, internet)
			if i then table.remove(interactTbl.touch, i) end
		end
	end)
end)

SpawnCall(function()
	local function setupFLASHBACK(c)
		if not c then return end
		local hum=getHum()
		while not hum do Wait(.1) hum=getHum() end
		hum.Died:Connect(function()
			local root=getRoot(c)
			if root then
				deathCFrame=root.CFrame
			end
			NAmanage._persist.lastMode=NAmanage._state and NAmanage._state.mode or "none"
			NAmanage._persist.wasFlying=(FLYING==true)
			if FLYING then
				NAmanage.pauseCurrent()
			end
			NAmanage._clearPhysics(true)
			NAmanage._persist.resumeAfterSpawn=false
		end)
	end

	setupFLASHBACK(LocalPlayer.Character)

	LocalPlayer.CharacterAdded:Connect(function(c)
		setupFLASHBACK(c)
		NAmanage.ExecuteBindings("OnSpawn", LocalPlayer, c)
		Wait(.5)
		local humanoid=getHum()
		if humanoid then
			local lastHP=humanoid.Health
			humanoid.Died:Connect(function() NAmanage.ExecuteBindings("OnDeath") end)
			humanoid.HealthChanged:Connect(function(newHP)
				if newHP<lastHP then
					NAmanage.ExecuteBindings("OnDamage", lastHP, newHP)
				end
				lastHP=newHP
			end)
		end
		NAmanage.connectFlyKey()
		NAmanage.connectVFlyKey()
		NAmanage.connectCFlyKey()
		NAmanage.connectTFlyKey()
		NAmanage.startWatcher()

		SpawnCall(function()
			if not NAmanage._persist or NAmanage._persist.resumeAfterSpawn then
				return
			end
			if not NAmanage._persist.wasFlying then
				return
			end
			local desired=NAmanage._persist.lastMode
			if not desired or desired=="none" then
				NAmanage._persist.wasFlying=false
				return
			end
			if not NAmanage._modeEnabled(desired) then
				NAmanage._persist.wasFlying=false
				return
			end
			local elapsed=0
			while elapsed<5 and (not getChar() or not getRoot(getChar()) or not getHum()) do
				elapsed+=(Wait() or 0.03)
			end
			if not getChar() or not getRoot(getChar()) or not getHum() then
				return
			end
			NAmanage._clearPhysics(true)
			NAmanage._applyMode(desired,true)
			NAmanage._persist.wasFlying=false
		end)
	end)

	if LocalPlayer.Character then
		local humanoid=getHum()
		if humanoid then
			local lastHP=humanoid.Health
			humanoid.Died:Connect(function() NAmanage.ExecuteBindings("OnDeath") end)
			humanoid.HealthChanged:Connect(function(newHP)
				if newHP<lastHP then
					NAmanage.ExecuteBindings("OnDamage", lastHP, newHP)
				end
				lastHP=newHP
			end)
		end
	end

	NAmanage.startWatcher()
end)

SpawnCall(function()
	if flyVariables._watchConn then pcall(function() flyVariables._watchConn:Disconnect() end) end
	NAmanage.startWatcher()
end)

mouse.Move:Connect(function()
	local viewportSize = workspace.CurrentCamera and workspace.CurrentCamera.ViewportSize or Vector2.new(1920, 1080)

	local xScale = mouse.X / viewportSize.X
	local yScale = mouse.Y / viewportSize.Y

	NAUIMANAGER.description.Position = UDim2.new(xScale, 0, yScale, 0)

	local newSize = NAgui.txtSize(NAUIMANAGER.description, 200, 100)
	NAUIMANAGER.description.Size = UDim2.new(0, newSize.X, 0, newSize.Y)
end)

function updateCanvasSize(frame, scale)
	local layout = frame:FindFirstChildOfClass("UIListLayout")
	if layout then
		local adjustedHeight = layout.AbsoluteContentSize.Y / scale
		frame.CanvasSize = UDim2.new(0, 0, 0, adjustedHeight)
	end
end

RunService.RenderStepped:Connect(function()
	if NAUIMANAGER.chatLogs then updateCanvasSize(NAUIMANAGER.chatLogs, NAUIMANAGER.AUTOSCALER.Scale) end
	if NAUIMANAGER.NAconsoleLogs then updateCanvasSize(NAUIMANAGER.NAconsoleLogs, NAUIMANAGER.AUTOSCALER.Scale) end
	if NAUIMANAGER.commandsList then updateCanvasSize(NAUIMANAGER.commandsList, NAUIMANAGER.AUTOSCALER.Scale) end
	if NAUIMANAGER.SettingsList then updateCanvasSize(NAUIMANAGER.SettingsList, NAUIMANAGER.AUTOSCALER.Scale) end
	if NAUIMANAGER.WaypointList then updateCanvasSize(NAUIMANAGER.WaypointList, NAUIMANAGER.AUTOSCALER.Scale) end
	if NAUIMANAGER.BindersList then updateCanvasSize(NAUIMANAGER.BindersList, NAUIMANAGER.AUTOSCALER.Scale) end
end)

RunService.RenderStepped:Connect(function()
	local p = opt.prefix

	local function isInvalid(prefix)
		return not prefix
			or utf8.len(prefix) ~= 1
			or prefix:match("[%w]")
			or prefix:match("[%[%]%(%)%*%^%$%%{}<>]")
			or prefix:match("&amp;") or prefix:match("&lt;") or prefix:match("&gt;")
			or prefix:match("&quot;") or prefix:match("&#x27;") or prefix:match("&#x60;")
	end

	if isInvalid(p) then
		if opt.prefix ~= ";" then
			opt.prefix = ";"
			DoNotif("Invalid prefix detected. Resetting to default ';'")
			lastPrefix = ";"
			if NAmanage.SyncPrefixUI then
				NAmanage.SyncPrefixUI()
			end

			local storedPrefix = NAmanage.NASettingsGet("prefix")
			if isInvalid(storedPrefix) then
				NAmanage.NASettingsSet("prefix", ";")
			end
		end
	else
		lastPrefix = p
	end
end)

--RunService.RenderStepped:Connect(NAUISCALEUPD)

NACaller(function()
	if NAStuff.NAjson and NAStuff.NAjson.annc and NAStuff.NAjson.annc ~= "" then
		DoPopup(NAStuff.NAjson.annc, adminName.." Announcement")
	end
end)

--[[ COMMAND BAR BUTTON ]]--
local TextLabel = InstanceNew("TextLabel")
local UICorner = InstanceNew("UICorner")
local UIStroke = InstanceNew("UIStroke")
local TextButton
local UICorner2 = InstanceNew("UICorner")

NAICONASSET = nil

pcall(function() NAICONASSET=(getcustomasset and (isAprilFools() and getcustomasset(NAfiles.NAASSETSFILEPATH.."/"..NAImageAssets.sWare) or getcustomasset(NAfiles.NAASSETSFILEPATH.."/"..NAImageAssets.Icon))) or nil end)

if NAICONASSET then
	TextButton = InstanceNew("ImageButton")
	TextButton.Image = NAICONASSET
else
	TextButton = InstanceNew("TextButton")
	TextButton.Font = Enum.Font.SourceSansBold
	TextButton.TextColor3 = Color3.fromRGB(241, 241, 241)
	TextButton.TextSize = 22
	if isAprilFools() then
		cringyahhnamesidk = { "IY", "FE", "F3X", "HD", "CMD", "Ω", "R6", "Ø", "NA", "CMDX" }
		TextButton.Text = cringyahhnamesidk[math.random(1, #cringyahhnamesidk)]
	else
		TextButton.Text = "NA"
	end
end

TextLabel.Parent = NAStuff.NASCREENGUI
TextLabel.BackgroundColor3 = Color3.fromRGB(25, 26, 30)
TextLabel.BackgroundTransparency = 0.1
TextLabel.AnchorPoint = Vector2.new(0.5, 0.5)
TextLabel.Position = UDim2.new(0.5, 0, 0.5, 0)
TextLabel.Size = UDim2.new(0, 0, 0, 0)
TextLabel.Font = Enum.Font.FredokaOne
TextLabel.Text = getSeasonEmoji().." "..adminName..curVer.." "..getSeasonEmoji()
TextLabel.TextColor3 = Color3.fromRGB(241, 241, 241)
TextLabel.TextSize = 22
TextLabel.TextWrapped = true
TextLabel.TextStrokeTransparency = 0.7
TextLabel.TextTransparency = 1
TextLabel.ZIndex = 9999
TextLabel.Active = true
TextLabel.Selectable = false

UICorner2.CornerRadius = UDim.new(0.25, 0)
UICorner2.Parent = TextLabel

UIStroke.Parent = TextLabel
UIStroke.Thickness = 2
UIStroke.Color = NAUISTROKER
UIStroke.Transparency = 0.4
UIStroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border

TextButton.Parent = NAStuff.NASCREENGUI
TextButton.BackgroundTransparency = 0
TextButton.AnchorPoint = Vector2.new(0.5, 0)
TextButton.BorderSizePixel = 0
TextButton.BackgroundColor3 = Color3.fromRGB(25, 26, 30)
TextButton.Position = UDim2.new(0.5, 0, -1, 0)
TextButton.Size = UDim2.new(0, 32 * NAScale, 0, 32 * NAScale)
TextButton.ZIndex = 9999

UICorner.CornerRadius = UDim.new(1, 0)
UICorner.Parent = TextButton

TextButton.MouseEnter:Connect(function()
	TweenService:Create(TextButton, TweenInfo.new(0.25, Enum.EasingStyle.Sine, Enum.EasingDirection.Out), {
		Size = UDim2.new(0, 35 * NAScale, 0, 35 * NAScale)
	}):Play()
end)

TextButton.MouseLeave:Connect(function()
	TweenService:Create(TextButton, TweenInfo.new(0.25, Enum.EasingStyle.Sine, Enum.EasingDirection.Out), {
		Size = UDim2.new(0, 32 * NAScale, 0, 32 * NAScale)
	}):Play()
end)

NAStuff.iconAppearance = NAStuff.iconAppearance or  {
	background = TextButton.BackgroundTransparency;
	text = TextButton:IsA("TextButton") and TextButton.TextTransparency or nil;
	stroke = TextButton:IsA("TextButton") and TextButton.TextStrokeTransparency or nil;
	image = TextButton:IsA("ImageButton") and TextButton.ImageTransparency or nil;
}

NAgui.clampIconPositionUDim=function(pos)
	if typeof(pos) ~= "UDim2" then
		return pos
	end
	if not TextButton or not TextButton.Parent then
		return UDim2.new(math.clamp(pos.X.Scale, 0, 1), 0, math.clamp(pos.Y.Scale, 0, 1), 0)
	end
	local container = TextButton.Parent
	local parentSize = container.AbsoluteSize
	if parentSize.X <= 0 or parentSize.Y <= 0 then
		local cam = workspace and workspace.CurrentCamera
		if cam then
			parentSize = cam.ViewportSize
		end
	end
	if parentSize.X <= 0 or parentSize.Y <= 0 then
		return UDim2.new(math.clamp(pos.X.Scale, 0, 1), 0, math.clamp(pos.Y.Scale, 0, 1), 0)
	end
	local anchor = TextButton.AnchorPoint or Vector2.new(0, 0)
	local buttonSizeX = TextButton.AbsoluteSize.X
	local buttonSizeY = TextButton.AbsoluteSize.Y
	if buttonSizeX <= 0 then buttonSizeX = 32 * NAScale end
	if buttonSizeY <= 0 then buttonSizeY = 32 * NAScale end
	local absX = pos.X.Scale * parentSize.X + pos.X.Offset
	local absY = pos.Y.Scale * parentSize.Y + pos.Y.Offset
	local minX = anchor.X * buttonSizeX
	local maxX = parentSize.X - (1 - anchor.X) * buttonSizeX
	local minY = anchor.Y * buttonSizeY
	local maxY = parentSize.Y - (1 - anchor.Y) * buttonSizeY
	if maxX < minX then maxX = minX end
	if maxY < minY then maxY = minY end
	local clampedX = math.clamp(absX, minX, maxX)
	local clampedY = math.clamp(absY, minY, maxY)
	return UDim2.new(clampedX / parentSize.X, 0, clampedY / parentSize.Y, 0)
end

NAgui.getClampedIconPosition=function()
	if not TextButton then return nil end
	local clamped = NAgui.clampIconPositionUDim(TextButton.Position)
	if clamped and clamped ~= TextButton.Position then
		TextButton.Position = clamped
	end
	return clamped or TextButton.Position
end

NAgui.applyIconVisibility=function(hidden)
	if not TextButton then return end
	if IsOnMobile and not IsOnPC then
		TextButton.Visible = true
		TextButton.BackgroundTransparency = hidden and 1 or NAStuff.iconAppearance.background
		if TextButton:IsA("ImageButton") then
			if hidden then
				TextButton.ImageTransparency = 1
			elseif NAStuff.iconAppearance.image ~= nil then
				TextButton.ImageTransparency = NAStuff.iconAppearance.image
			end
		else
			TextButton.TextTransparency = hidden and 1 or (NAStuff.iconAppearance.text or 0)
			if NAStuff.iconAppearance.stroke ~= nil then
				TextButton.TextStrokeTransparency = hidden and 1 or NAStuff.iconAppearance.stroke
			end
		end
	else
		TextButton.Visible = not hidden
		TextButton.BackgroundTransparency = NAStuff.iconAppearance.background
		if TextButton:IsA("ImageButton") then
			if NAStuff.iconAppearance.image ~= nil then
				TextButton.ImageTransparency = NAStuff.iconAppearance.image
			end
		else
			if NAStuff.iconAppearance.text ~= nil then
				TextButton.TextTransparency = NAStuff.iconAppearance.text
			end
			if NAStuff.iconAppearance.stroke ~= nil then
				TextButton.TextStrokeTransparency = NAStuff.iconAppearance.stroke
			end
		end
	end
end

NAgui.setIconHidden=function(hidden, opts)
	opts = opts or {}
	hidden = hidden and true or false
	if NAStuff.IconInvisible == hidden and not opts.force then
		return
	end
	NAStuff.IconInvisible = hidden
	NAgui.applyIconVisibility(hidden)
	if FileSupport then
		pcall(NAmanage.NASettingsSet, "iconInvisible", hidden)
	end
	if not opts.skipToggle and NAgui.setToggleState then
		NAgui.setToggleState("Hide NA Icon", hidden, { force = true, fire = false })
	end
end

NAmanage.IconSetInvisible = NAgui.setIconHidden

NAgui.setIconHidden(NAStuff.IconInvisible, { force = true, skipToggle = true })

NAStuff.IconLocked = NAStuff.IconLocked or false

NAgui._NAIconConnName=function()
	return TextButton and "DraggerV2_"..TextButton:GetDebugId() or "DraggerV2_ICON"
end

NAgui.applyIconLock=function(locked)
	if not TextButton then return end
	if locked then
		NAlib.disconnect(NAgui._NAIconConnName())
		pcall(function() TextButton.Active=false end)
	else
		NAgui.draggerV2(TextButton)
		pcall(function() TextButton.Active=true end)
	end
end

NAgui.setIconLocked=function(locked, opts)
	opts = opts or {}
	locked = locked and true or false
	if NAStuff.IconLocked == locked and not opts.force then return end
	NAStuff.IconLocked = locked
	NAgui.applyIconLock(locked)
	if FileSupport then
		NAmanage.NASettingsSet("iconLocked", locked)
	end
	if not opts.skipToggle and NAgui.setToggleState then
		NAgui.setToggleState("Lock NA Icon", locked, { force = true, fire = false })
	end
end

NAmanage.IconSetLocked = NAgui.setIconLocked

swooshySWOOSH = false

function Swoosh()
	TweenService:Create(TextButton, TweenInfo.new(1.5, Enum.EasingStyle.Elastic, Enum.EasingDirection.Out), {Rotation = 720}):Play()
	if not NAStuff.IconLocked then
		NAgui.draggerV2(TextButton)
	end
	if swooshySWOOSH then return end
	swooshySWOOSH = true
	TextButton.InputBegan:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
			input.Changed:Connect(function()
				if input.UserInputState == Enum.UserInputState.End then
					if FileSupport and NAiconSaveEnabled then
						local pos = NAgui.getClampedIconPosition() or TextButton.Position
						writefile(NAfiles.NAICONPOSPATH, HttpService:JSONEncode({
							X = pos.X.Scale,
							Y = pos.Y.Scale,
							Save = NAiconSaveEnabled
						}))
					end
				end
			end)
		end
	end)
end

function mainNameless()
	local txtLabel = TextLabel
	local fadeOutStarted = false

	local function fadeOut()
		if fadeOutStarted then return end
		fadeOutStarted = true
		local fadeOutTween = TweenService:Create(txtLabel, TweenInfo.new(0.6, Enum.EasingStyle.Elastic, Enum.EasingDirection.InOut), {
			TextTransparency = 1,
			BackgroundTransparency = 1,
			Position = UDim2.new(0.5, 0, 0.52, 20),
			Size = UDim2.new(0, 0, 0, 0)
		})
		fadeOutTween:Play()
		fadeOutTween.Completed:Once(function()
			txtLabel:Destroy()
		end)
	end

	txtLabel.InputBegan:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
			fadeOut()
		end
	end)

	local textWidth = TextService:GetTextSize(txtLabel.Text, txtLabel.TextSize, txtLabel.Font, Vector2.new(math.huge, math.huge)).X
	local finalSize = UDim2.new(0, textWidth + 80, 0, 40)

	local appearTween = TweenService:Create(txtLabel, TweenInfo.new(0.8, Enum.EasingStyle.Elastic, Enum.EasingDirection.Out), {
		Size = finalSize,
		BackgroundTransparency = 0.1,
		TextTransparency = 0,
	})

	local riseTween = TweenService:Create(txtLabel, TweenInfo.new(0.4, Enum.EasingStyle.Elastic, Enum.EasingDirection.Out), {
		Position = UDim2.new(0.5, 0, 0.48, 0)
	})

	appearTween:Play()
	riseTween:Play()

	TextButton.Size = UDim2.new(0, 0, 0, 0)
	if TextButton:IsA("TextButton") then
		TextButton.TextTransparency = 1
	end

	local targetPos = UDim2.new(0.5, 0, 0.1, 0)

	if FileSupport and isfile(NAfiles.NAICONPOSPATH) then
		local ok, data = pcall(function()
			return HttpService:JSONDecode(readfile(NAfiles.NAICONPOSPATH))
		end)

		if ok and type(data) == "table" and data.X and data.Y then
			targetPos = UDim2.new(data.X, 0, data.Y, 0)
		end
	end

	targetPos = NAgui.clampIconPositionUDim(targetPos)
	if FileSupport and NAiconSaveEnabled then
		pcall(writefile, NAfiles.NAICONPOSPATH, HttpService:JSONEncode({
			X = targetPos.X.Scale,
			Y = targetPos.Y.Scale,
			Save = true
		}))
	end
	local introPos = NAgui.clampIconPositionUDim(UDim2.new(targetPos.X.Scale, 0, targetPos.Y.Scale - 0.15, -20)) or targetPos
	TextButton.Position = introPos

	local tweenProps = {
		Size = UDim2.new(0, 32 * NAScale, 0, 32 * NAScale),
		Position = targetPos
	}

	if TextButton:IsA("TextButton") then
		tweenProps.TextTransparency = 0
	end

	local appearBtnTween = TweenService:Create(TextButton, TweenInfo.new(1, Enum.EasingStyle.Elastic, Enum.EasingDirection.Out), tweenProps)
	appearBtnTween:Play()

	Swoosh()

	Wait(2.5)
	fadeOut()
end

coroutine.wrap(mainNameless)()

NAgui.setIconLocked(NAStuff.IconLocked, { force = true, skipToggle = true })

MouseButtonFix(TextButton,function()
	NAgui.barSelect()
	NAUIMANAGER.cmdInput.Text=''
	NAUIMANAGER.cmdInput:CaptureFocus()
	Wait(.00005)
	NAUIMANAGER.cmdInput.Text=''
end)

--@ltseverydayyou (Aervanix)
--@Cosmella (Viper)

--original by @qipu | loadstring(game:HttpGet("https://raw.githubusercontent.com/FilteringEnabled/NamelessAdmin/main/Source"))();

SpawnCall(function()
	local NAresult = tick() - NAbegin
	local nameCheck = nameChecker(Player)

	Delay(0.3, function()
		local executorName = identifyexecutor and identifyexecutor() or "Unknown"
		local welcomeMessage = "Welcome to "..adminName..curVer

		executorName = maybeMock(executorName)
		welcomeMessage = maybeMock(welcomeMessage)

		local notifBody = welcomeMessage..
			(identifyexecutor and ("\nExecutor: "..executorName) or "")..
			"\nUpdated on: "..opt.NAupdDate..
			"\nTime Taken To Load: "..loadedResults(NAresult)

		DoNotif(notifBody, 6, rngMsg().." "..nameCheck)

		if not FileSupport then
			warn("NAWWW NO FILE SUPPORT???????")
			Window({
				Title = maybeMock("Would you like to enable QueueOnTeleport?"),
				Description = maybeMock("With QueueOnTeleport, "..adminName.." will automatically execute itself upon teleporting to a game or place."),
				Buttons = {
					{Text = "Yes", Callback = function()
						opt.queueteleport(opt.loader)
					end},
					{Text = "No", Callback = function() end}
				}
			})
		elseif not opt.queueteleport then
			warn('your executor is dog shit')
		end

		Wait(1)

		if IsOnPC then
			local keybindMessage = maybeMock("Your Keybind Prefix: "..opt.prefix)
			DoNotif(keybindMessage, 10, adminName.." Keybind Prefix")
		end

		SpawnCall(function() pcall(function() loadstring(game:HttpGet("https://raw.githubusercontent.com/ltseverydayyou/Nameless-Admin/main/SaveInstance.lua"))() end) end) -- it has better SaveInstance support and important functions that are required
		--Spawn(function() pcall(function() loadstring(game:HttpGet("https://raw.githubusercontent.com/ltseverydayyou/uuuuuuu/refs/heads/main/EnableChat.lua"))() end) end) -- better chat

		-- just ignore this section (personal stuff)
		--[[Window({
			Title = adminName.." (Archived)",
			Description = 'This version is no longer maintained.\nCheck the README on GitHub for legacy details.',
			Buttons = {
				{
					Text = "Copy GitHub Repo",
					Callback = function()
						setclipboard("https://github.com/ltseverydayyou/Nameless-Admin")
					end
				},
				{
					Text = "Discord Server",
					Callback = function()
						setclipboard("https://discord.gg/zzjYhtMGFD")
					end
				},
				{
					Text = "Close",
					Callback = function() end
				}
			}
		})]]
	end)
	SpawnCall(function()
		Wait(.5)
		for _, commandName in ipairs(NAEXECDATA.commands) do
			local fullRun = {commandName}
			local argsString = NAEXECDATA.args[commandName]
			if argsString and argsString ~= "" then
				local extraArgs = ParseArguments(argsString)
				for _, v in ipairs(extraArgs) do
					Insert(fullRun, v)
				end
			end
			cmd.run(fullRun)
		end
	end)
	NAUIMANAGER.cmdInput.ZIndex = 10
	NAUIMANAGER.cmdInput.PlaceholderText = isAprilFools() and '🤡 '..adminName..curVer..' 🤡' or getSeasonEmoji()..' '..adminName..curVer..' '..getSeasonEmoji()
end)

NAmanage.hsv2rgb=function(h, s, v)
	local c = v * s
	local x = c * (1 - math.abs((h / 60) % 2 - 1))
	local m = v - c
	local r1, g1, b1
	if h < 60 then
		r1, g1, b1 = c, x, 0
	elseif h < 120 then
		r1, g1, b1 = x, c, 0
	elseif h < 180 then
		r1, g1, b1 = 0, c, x
	elseif h < 240 then
		r1, g1, b1 = 0, x, c
	elseif h < 300 then
		r1, g1, b1 = x, 0, c
	else
		r1, g1, b1 = c, 0, x
	end
	return (r1 + m), (g1 + m), (b1 + m)
end

NAmanage.gradientify=function(text)
	local len = #text
	if len == 0 then return "" end
	local out = {}
	for i = 1, len do
		local frac = (i - 1) / (len - 1)
		local hue = frac * 360
		local r, g, b = NAmanage.hsv2rgb(hue, 1, 1)
		local hex = Format("#%02X%02X%02X", r * 255, g * 255, b * 255)
		local ch = text:sub(i, i)
		out[i] = Format('<font color="%s">%s</font>', hex, ch)
	end
	return Concat(out)
end

NAmanage.grayGradient=function(text)
	local startGray = 0
	local endGray   = 100
	local len = #text
	if len == 0 then return "" end
	local out = {}
	for i = 1, len do
		local frac = (i - 1) / (len - 1)
		local v = startGray + (endGray - startGray) * frac
		local g = math.floor(v)
		local hex = Format("#%02X%02X%02X", g, g, g)
		local ch = text:sub(i, i)
		out[i] = Format('<font color="%s">%s</font>', hex, ch)
	end
	return Concat(out)
end
-- temp disabled for fixing
--[[TextChatService.OnIncomingMessage = function(message)
	local ts = message.TextSource
	if not ts then return end
	local pl = Players:GetPlayerByUserId(ts.UserId)
	if not pl then return end

	local tagText = pl:GetAttribute("CustomNAtaggerText")
	local tagCol = pl:GetAttribute("CustomNAtaggerColor")
	local useRainbow = pl:GetAttribute("CustomNAtaggerRainbow")

	local basePrefix = message.PrefixText
	if not basePrefix or basePrefix == "" then
		local nm = nameChecker(pl)
		basePrefix = Format("%s: ", nm)
	end

	local rainbowApplied = false
	if useRainbow then
		local nmA = ts.Name or ""
		local nmB = pl.DisplayName or ""
		local nmC = pl.Name or ""
		local nmD = nameChecker(pl) or ""
		local gradSrc = nmD ~= "" and nmD or (nmB ~= "" and nmB or nmC)
		local grad = NAmanage.gradientify(gradSrc)
		local seen = {}
		local cands = {}
		local function add(s) if s and s ~= "" and not seen[s] then seen[s] = true; Insert(cands, s) end end
		add(nmA); add(nmB); add(nmC); add(nmD)
		local function esc(s) return (s:gsub("([^%w])","%%%1")) end
		for _, c in ipairs(cands) do
			local rep, n = basePrefix:gsub(esc(c), grad, 1)
			if n > 0 then
				basePrefix = rep
				rainbowApplied = true
				break
			end
		end
		if not rainbowApplied then
			basePrefix = Format("%s: ", grad)
			rainbowApplied = true
		end
	end

	for _, id in ipairs(_G.NAadminsLol or {}) do
		if pl.UserId == id then
			local props = InstanceNew("TextChatMessageProperties")
			local tag = NAmanage.grayGradient("[NA ADMIN]")
			local finalPrefix = basePrefix
			if NAStuff.ForceAdminRainbow then
				local nm = nameChecker(pl)
				local grad = NAmanage.gradientify(nm)
				local esc = nm:gsub("([^%w])","%%%1")
				local rep, n = finalPrefix:gsub(esc, grad, 1)
				finalPrefix = n > 0 and rep or Format("%s: ", grad)
			end
			props.PrefixText = Format("%s %s", tag, finalPrefix)
			props.Text = message.Text
			return props
		end
	end

	if tagText and tagCol then
		local r, g, b = tagCol.R * 255, tagCol.G * 255, tagCol.B * 255
		local hex = Format("#%02X%02X%02X", r, g, b)
		local props = InstanceNew("TextChatMessageProperties")
		props.PrefixText = Format('<font color="%s">[%s]</font> %s', hex, tagText, basePrefix)
		props.Text = message.Text
		return props
	end

	if rainbowApplied then
		local props = InstanceNew("TextChatMessageProperties")
		props.PrefixText = basePrefix
		props.Text = message.Text
		return props
	end
end]]
math.randomseed(os.time())

NAmanage.injectNAConsole = function()
	if NAmanage._naConsoleInitialized then
		return true
	end

	local function ensureCommandHelpers()
		if not NAmanage._naConsoleDispatch then
			local function splitArgs(line)
				local out, buf, quote = {}, "", nil
				for i = 1, #line do
					local ch = Sub(line, i, i)
					if quote then
						if ch == quote then
							quote = nil
						else
							buf = buf..ch
						end
					else
						if ch == "'" or ch == '"' then
							quote = ch
						elseif ch == " " or ch == "\t" then
							if #buf > 0 then
								out[#out+1] = buf
								buf = ""
							end
						else
							buf = buf..ch
						end
					end
				end
				if #buf > 0 then
					out[#out+1] = buf
				end
				return out
			end

			local function dispatchRun(...)
				local runner = cmd and (cmd.run or cmd.Run)
				if not runner then
					return nil, "cmd.run not available"
				end

				local n = select("#", ...)
				local argv
				if n == 1 then
					local a = ...
					if type(a) == "table" then
						argv = a
					elseif type(a) == "string" then
						argv = splitArgs(a)
					else
						return nil, "invalid input to cmdRun"
					end
				else
					argv = {}
					for i = 1, n do
						local v = select(i, ...)
						argv[#argv+1] = type(v) == "string" and v or tostring(v)
					end
				end

				if #argv == 0 then
					return nil, "no command provided"
				end

				local ok1, res1 = NACaller(runner, argv)
				if ok1 then
					return res1
				end

				local ok2, res2 = NACaller(runner, Concat(argv, " "))
				if ok2 then
					return res2
				end

				return nil, res2
			end

			NAmanage._naConsoleDispatch = dispatchRun
		end

		local dispatch = NAmanage._naConsoleDispatch
		local targetEnv = (getgenv and getgenv()) or _G or {}
		targetEnv.cmdRun = dispatch
		targetEnv.RunCommand = dispatch
		targetEnv.runCommand = dispatch
	end

	local commandLine = InstanceNew("Frame")
	commandLine.Name = "NAConsole"
	commandLine.BackgroundColor3 = Color3.fromRGB(45, 45, 45)
	commandLine.BorderColor3 = Color3.fromRGB(184, 184, 184)
	commandLine.Position = UDim2.new(0, 0, 1, -30)
	commandLine.Size = UDim2.new(1, 0, 0, 30)
	commandLine.ZIndex = 1
	commandLine.AutoLocalize = false

	local inputField = InstanceNew("Frame", commandLine)
	inputField.Name = "InputField"
	inputField.BackgroundTransparency = 1
	inputField.ClipsDescendants = true
	inputField.Position = UDim2.new(0, 30, 0, 0)
	inputField.Size = UDim2.new(1, -30, 0, 30)
	inputField.AutoLocalize = false
	inputField.ZIndex = 1

	local textbox = InstanceNew("TextBox", inputField)
	textbox.Name = "TextBox"
	textbox.BackgroundTransparency = 1
	textbox.ClearTextOnFocus = false
	textbox.Font = Enum.Font.Code
	textbox.PlaceholderText = "NA Console Master"
	textbox.Size = UDim2.new(1, 0, 1, 0)
	textbox.Text = ""
	textbox.TextColor3 = Color3.fromRGB(255, 255, 255)
	textbox.TextSize = 15
	textbox.TextXAlignment = Enum.TextXAlignment.Left
	textbox.AutoLocalize = false
	textbox.ZIndex = 2

	local arrow = InstanceNew("TextLabel", commandLine)
	arrow.Name = "Arrow"
	arrow.BackgroundTransparency = 1
	arrow.Font = Enum.Font.Code
	arrow.Size = UDim2.new(0, 30, 1, 0)
	arrow.Text = "> "
	arrow.TextColor3 = Color3.fromRGB(255, 255, 255)
	arrow.TextSize = 15
	arrow.TextXAlignment = Enum.TextXAlignment.Right
	arrow.AutoLocalize = false
	arrow.ZIndex = 2

	local function resetCommandLine()
		if commandLine.Parent then
			commandLine.Parent = nil
		end
		if textbox.Text ~= "" then
			textbox.Text = ""
		end
	end

	resetCommandLine()

	local testService = SafeGetService("TestService")

	local function reportError(message)
		local filtered = tostring(message or "error")
		filtered = filtered:gsub("%[string \"console\"%]:", "console:")
		if testService then
			pcall(function()
				testService:Error(filtered)
			end)
		else
			warn(filtered)
		end
	end

	textbox.FocusLost:Connect(function(enterPressed)
		if not enterPressed then
			return
		end
		local commandText = textbox.Text
		if commandText == "" or commandText:match("^%s*$") then
			textbox.Text = ""
			return
		end
		textbox.Text = ""
		print("> "..commandText)

		local trimmed = commandText:match("^%s*(.-)%s*$")
		local commandLiteral = nil
		if trimmed and trimmed ~= "" then
			local firstChar = trimmed:sub(1, 1)
			if (firstChar == '"' or firstChar == "'") and trimmed:sub(-1) == firstChar then
				local literalChunk = loadstring("return "..trimmed, "console_literal")
				if literalChunk then
					local okLiteral, literalValue = pcall(literalChunk)
					if okLiteral and type(literalValue) == "string" then
						commandLiteral = literalValue
					end
				end
			end
		end

		if commandLiteral then
			ensureCommandHelpers()
			local dispatch = NAmanage._naConsoleDispatch
			if dispatch then
				local okDispatch, dispatchErr = NACaller(dispatch, commandLiteral)
				if not okDispatch then
					reportError(dispatchErr or "command execution failed")
				end
			else
				reportError("Command dispatcher unavailable")
			end
			return
		end

		local chunk, compileErr = loadstring(commandText, "console")
		if not chunk then
			reportError(compileErr or "compile error")
			return
		end

		ensureCommandHelpers()

		local ok, execErr = pcall(function()
			if not cmd or not cmd.run then
				error("cmd.run unavailable")
			end
			cmd.run({"loadstring", commandText})
		end)
		if not ok then
			reportError(execErr or "execution error")
		end
	end)

	local function ensureInjection()
		local coreGui = COREGUI
		if not coreGui then
			resetCommandLine()
			return
		end

		local master = coreGui:FindFirstChild("DevConsoleMaster")
		if not master then
			resetCommandLine()
			return
		end

		local window = master:FindFirstChild("DevConsoleWindow")
		if not window or window.Visible == false then
			resetCommandLine()
			return
		end

		if commandLine.Parent ~= window then
			commandLine.Parent = window
		end
	end

	NAlib.disconnect("naconsole_loop")
	NAlib.connect("naconsole_loop", RunService.Heartbeat:Connect(ensureInjection))
	ensureInjection()

	NAmanage._naConsoleInitialized = true
	NAmanage._naConsoleFrame = commandLine
	NAmanage._naConsoleTextBox = textbox
	NAmanage._naConsoleArrow = arrow
	return true
end

SpawnCall(function()
	SpawnCall(function() Lighting.LightingStyle=Enum.LightingStyle.Soft end)
	while Wait(0.25) and getChar() do
		local hum = getHum()
		if hum and hum.AutoJumpEnabled then
			hum.AutoJumpEnabled = false
		end
	end
end)


SpawnCall(function() -- init
	if NAUIMANAGER.cmdBar then NAProtection(NAUIMANAGER.cmdBar) end
	if NAUIMANAGER.chatLogsFrame then NAProtection(NAUIMANAGER.chatLogsFrame) end
	if NAUIMANAGER.NAconsoleFrame then NAProtection(NAUIMANAGER.NAconsoleFrame) end
	if NAUIMANAGER.commandsFrame then NAProtection(NAUIMANAGER.commandsFrame) end
	if NAUIMANAGER.resizeFrame then NAProtection(NAUIMANAGER.resizeFrame) end
	if NAUIMANAGER.description then NAProtection(NAUIMANAGER.description) end
	if NAUIMANAGER.ModalFixer then NAProtection(NAUIMANAGER.ModalFixer) end
	if NAUIMANAGER.AUTOSCALER then NAProtection(NAUIMANAGER.AUTOSCALER) NAUIMANAGER.AUTOSCALER.Scale = NAUIScale end
	if NAUIMANAGER.SettingsFrame then NAProtection(NAUIMANAGER.SettingsFrame) end
	if NAUIMANAGER.WaypointFrame then NAProtection(NAUIMANAGER.WaypointFrame) end
	if NAUIMANAGER.BindersFrame then NAProtection(NAUIMANAGER.BindersFrame) end
	if not PlrGui then PlrGui=Player:WaitForChild("PlayerGui",math.huge) end
end)

NAmanage.scheduleLoader('BindDevConsole', NAmanage.bindToDevConsole)
NAmanage.scheduleLoader('NAConsole', NAmanage.injectNAConsole)
NAmanage.scheduleLoader('Aliases', NAmanage.loadAliases)
NAmanage.scheduleLoader('UserButtons', function()
	NAmanage.loadButtonIDS()
	return NAmanage.RenderUserButtons()
end, { requiresGui = true, retries = 5, delay = 0.4, retryOnFalse = true })
NAmanage.scheduleLoader('AutoExec', NAmanage.loadAutoExec, { retries = 4, delay = 0.4, retryOnFalse = true })
NAmanage.scheduleLoader('Plugins', function()
	NAmanage.InitPlugs()
	return NAmanage.LoadPlugins()
end, { retries = 4, delay = 0.5, retryOnFalse = true })
NAmanage.scheduleLoader('Waypoints', NAmanage.UpdateWaypointList)
NAmanage.LoadESPSettings()
NAmanage.scheduleLoader('ESPSettings', NAmanage.LoadESPSettings)

OrgDestroyHeight=NAlib.isProperty(workspace, "FallenPartsDestroyHeight") or math.huge

local bindersList      = NAUIMANAGER.BindersList
SpawnCall(function()
	local layoutOrder = 1
	for _, evName in ipairs(events) do
		local ev = evName
		local HEADER_H = 30

		local binderFrame = InstanceNew("Frame")
		binderFrame.Name             = ev.."Binder"
		binderFrame.Parent           = bindersList
		binderFrame.Size             = UDim2.new(1,0,0, HEADER_H)
		binderFrame.LayoutOrder      = layoutOrder
		binderFrame.ClipsDescendants = true
		binderFrame.BackgroundColor3 = Color3.fromRGB(20,20,20)
		local binderCorner = InstanceNew("UICorner", binderFrame)
		binderCorner.CornerRadius    = UDim.new(0,8)
		local binderStroke = InstanceNew("UIStroke", binderFrame)
		binderStroke.Color           = Color3.fromRGB(60,60,60)
		binderStroke.Thickness       = 1

		local header = InstanceNew("TextButton")
		header.Name                   = "Header"
		header.Parent                 = binderFrame
		header.Size                   = UDim2.new(1,-30,0, HEADER_H)
		header.Position               = UDim2.new(0,0,0,0)
		header.BackgroundColor3       = Color3.fromRGB(30,30,30)
		header.AutoButtonColor        = false
		header.Font                   = Enum.Font.SourceSansSemibold
		header.TextSize               = 14
		header.TextColor3             = Color3.fromRGB(255,255,255)
		header.Text                   = ev
		local headerCorner = InstanceNew("UICorner", header)
		headerCorner.CornerRadius     = UDim.new(0,6)
		header.MouseEnter:Connect(function() header.BackgroundColor3 = Color3.fromRGB(50,50,50) end)
		header.MouseLeave:Connect(function() header.BackgroundColor3 = Color3.fromRGB(30,30,30) end)

		local addBtn = InstanceNew("TextButton")
		addBtn.Name                    = "AddBtn"
		addBtn.Parent                  = binderFrame
		addBtn.Size                    = UDim2.new(0,30,0, HEADER_H)
		addBtn.Position                = UDim2.new(1,-30,0,0)
		addBtn.BackgroundColor3        = Color3.fromRGB(30,30,30)
		addBtn.AutoButtonColor         = false
		addBtn.Font                    = Enum.Font.SourceSansBold
		addBtn.TextSize                = 18
		addBtn.TextColor3              = Color3.fromRGB(255,255,255)
		addBtn.Text                    = "+"
		local addCorner = InstanceNew("UICorner", addBtn)
		addCorner.CornerRadius         = UDim.new(0,6)
		addBtn.MouseEnter:Connect(function() addBtn.BackgroundColor3 = Color3.fromRGB(50,50,50) end)
		addBtn.MouseLeave:Connect(function() addBtn.BackgroundColor3 = Color3.fromRGB(30,30,30) end)

		local itemsFrame = InstanceNew("Frame")
		itemsFrame.Name                 = "Items"
		itemsFrame.Parent               = binderFrame
		itemsFrame.Position             = UDim2.new(0,0,0, HEADER_H)
		itemsFrame.Size                 = UDim2.new(1,0,0, 0)
		itemsFrame.BackgroundColor3     = Color3.fromRGB(25,25,25)
		local itemsCorner = InstanceNew("UICorner", itemsFrame)
		itemsCorner.CornerRadius        = UDim.new(0,6)

		local uiLayout = InstanceNew("UIListLayout")
		uiLayout.SortOrder              = Enum.SortOrder.LayoutOrder
		uiLayout.Padding                = UDim.new(0,4)
		uiLayout.Parent                 = itemsFrame
		uiLayout:GetPropertyChangedSignal("AbsoluteContentSize"):Connect(function()
			if binderFrame:GetAttribute("Expanded") then
				local h = uiLayout.AbsoluteContentSize.Y + 8
				itemsFrame:TweenSize(UDim2.new(1,0,0,h), "Out", "Quint", 0.25, true)
				binderFrame:TweenSize(UDim2.new(1,0,0, HEADER_H + h), "Out", "Quint", 0.25, true)
			end
		end)

		header.MouseButton1Click:Connect(function()
			local exp = binderFrame:GetAttribute("Expanded")
			binderFrame:SetAttribute("Expanded", not exp)
			if exp then
				itemsFrame:TweenSize(UDim2.new(1,0,0,0), "Out", "Quint", 0.25, true)
				binderFrame:TweenSize(UDim2.new(1,0,0, HEADER_H), "Out", "Quint", 0.25, true)
			else
				local h = uiLayout.AbsoluteContentSize.Y + 8
				itemsFrame:TweenSize(UDim2.new(1,0,0,h), "Out", "Quint", 0.25, true)
				binderFrame:TweenSize(UDim2.new(1,0,0, HEADER_H + h), "Out", "Quint", 0.25, true)
			end
		end)

		local function refreshItems()
			for _, child in ipairs(itemsFrame:GetChildren()) do
				if child.Name == "BinderItem" then
					child:Destroy()
				end
			end
			local list = Bindings[ev] or {}
			header.Text = ev.." ("..#list..")"
			if #list > 0 then
				binderFrame:SetAttribute("Expanded", true)
				local h = uiLayout.AbsoluteContentSize.Y + 8
				itemsFrame:TweenSize(UDim2.new(1,0,0,h), "Out", "Quint", 0.25, true)
				binderFrame:TweenSize(UDim2.new(1,0,0, HEADER_H + h), "Out", "Quint", 0.25, true)
			else
				binderFrame:SetAttribute("Expanded", false)
				itemsFrame:TweenSize(UDim2.new(1,0,0,0), "Out", "Quint", 0.25, true)
				binderFrame:TweenSize(UDim2.new(1,0,0, HEADER_H), "Out", "Quint", 0.25, true)
			end
			for i, cmdStr in ipairs(list) do
				local item = InstanceNew("Frame")
				item.Name               = "BinderItem"
				item.Parent             = itemsFrame
				item.Size               = UDim2.new(1,0,0,24)
				item.LayoutOrder        = i
				item.BackgroundColor3   = Color3.fromRGB(35,35,35)
				local itemCorner = InstanceNew("UICorner", item)
				itemCorner.CornerRadius  = UDim.new(0,4)

				local lbl = InstanceNew("TextLabel")
				lbl.Parent               = item
				lbl.Size                 = UDim2.new(1,-24,1,0)
				lbl.Position             = UDim2.new(0,8,0,0)
				lbl.BackgroundTransparency = 1
				lbl.Text                 = cmdStr
				lbl.Font                 = Enum.Font.SourceSans
				lbl.TextSize             = 14
				lbl.TextColor3           = Color3.fromRGB(255,255,255)
				lbl.TextXAlignment       = Enum.TextXAlignment.Left

				local rem = InstanceNew("TextButton")
				rem.Parent               = item
				rem.Size                 = UDim2.new(0,20,0,20)
				rem.Position             = UDim2.new(1,-24,0,2)
				rem.BackgroundTransparency = 1
				rem.Text                 = "×"
				rem.Font                 = Enum.Font.SourceSansBold
				rem.TextSize             = 18
				rem.TextColor3           = Color3.fromRGB(255,100,100)
				rem.MouseButton1Click:Connect(function()
					table.remove(list, i)
					NAmanage.SaveBinders()
					refreshItems()
				end)
			end
		end

		addBtn.MouseButton1Click:Connect(function()
			Bindings[ev] = Bindings[ev] or {}
			local allowMe = (ev ~= "OnJoin" and ev ~= "OnLeave")

			Window({
				Title       = ev.." Target",
				Description = "Pick who this binder applies to.",
				Buttons     = (function()
					local B = {}

					Insert(B, {
						Text = "No Selector",
						Callback = function()
							Window({
								Title = ev.." Binders",
								Description = "Enter command",
								InputField = true,
								Buttons = {{
									Text = "Submit",
									Callback = function(input)
										local cmdName = input and input:match("^(%S+)")
										if not (cmdName and (cmds.Commands[Lower(cmdName)] or cmds.Aliases[Lower(cmdName)])) then
											DoNotif("Command '"..tostring(cmdName).."' not found."); return
										end
										Insert(Bindings[ev], input)
										NAmanage.SaveBinders()
										refreshItems()
									end
								}}
							})
						end
					})

					if allowMe then
						Insert(B, {
							Text = "Me",
							Callback = function()
								Window({
									Title = ev.." Binders",
									Description = "Enter command (target: <me>)",
									InputField = true,
									Buttons = {{
										Text = "Submit",
										Callback = function(input)
											local cmdName = input and input:match("^(%S+)")
											if not (cmdName and (cmds.Commands[Lower(cmdName)] or cmds.Aliases[Lower(cmdName)])) then
												DoNotif("Command '"..tostring(cmdName).."' not found."); return
											end
											Insert(Bindings[ev], "<me> "..input)
											NAmanage.SaveBinders()
											refreshItems()
										end
									}}
								})
							end
						})
					end

					Insert(B, {
						Text = "Others",
						Callback = function()
							Window({
								Title = ev.." Binders",
								Description = "Enter command (target: <others>)",
								InputField = true,
								Buttons = {{
									Text = "Submit",
									Callback = function(input)
										local cmdName = input and input:match("^(%S+)")
										if not (cmdName and (cmds.Commands[Lower(cmdName)] or cmds.Aliases[Lower(cmdName)])) then
											DoNotif("Command '"..tostring(cmdName).."' not found."); return
										end
										Insert(Bindings[ev], "<others> "..input)
										NAmanage.SaveBinders()
										refreshItems()
									end
								}}
							})
						end
					})

					Insert(B, {
						Text = "All",
						Callback = function()
							Window({
								Title = ev.." Binders",
								Description = "Enter command (target: <all>)",
								InputField = true,
								Buttons = {{
									Text = "Submit",
									Callback = function(input)
										local cmdName = input and input:match("^(%S+)")
										if not (cmdName and (cmds.Commands[Lower(cmdName)] or cmds.Aliases[Lower(cmdName)])) then
											DoNotif("Command '"..tostring(cmdName).."' not found."); return
										end
										Insert(Bindings[ev], "<all> "..input)
										NAmanage.SaveBinders()
										refreshItems()
									end
								}}
							})
						end
					})

					Insert(B, {
						Text = "Friends",
						Callback = function()
							Window({
								Title = ev.." Binders",
								Description = "Enter command (target: <friends>)",
								InputField = true,
								Buttons = {{
									Text = "Submit",
									Callback = function(input)
										local cmdName = input and input:match("^(%S+)")
										if not (cmdName and (cmds.Commands[Lower(cmdName)] or cmds.Aliases[Lower(cmdName)])) then
											DoNotif("Command '"..tostring(cmdName).."' not found."); return
										end
										Insert(Bindings[ev], "<friends> "..input)
										NAmanage.SaveBinders()
										refreshItems()
									end
								}}
							})
						end
					})

					Insert(B, {
						Text = "NonFriends",
						Callback = function()
							Window({
								Title = ev.." Binders",
								Description = "Enter command (target: <nonfriends>)",
								InputField = true,
								Buttons = {{
									Text = "Submit",
									Callback = function(input)
										local cmdName = input and input:match("^(%S+)")
										if not (cmdName and (cmds.Commands[Lower(cmdName)] or cmds.Aliases[Lower(cmdName)])) then
											DoNotif("Command '"..tostring(cmdName).."' not found."); return
										end
										Insert(Bindings[ev], "<nonfriends> "..input)
										NAmanage.SaveBinders()
										refreshItems()
									end
								}}
							})
						end
					})

					Insert(B, {
						Text = "Team",
						Callback = function()
							Window({
								Title = ev.." Binders",
								Description = "Enter command (target: <team>)",
								InputField = true,
								Buttons = {{
									Text = "Submit",
									Callback = function(input)
										local cmdName = input and input:match("^(%S+)")
										if not (cmdName and (cmds.Commands[Lower(cmdName)] or cmds.Aliases[Lower(cmdName)])) then
											DoNotif("Command '"..tostring(cmdName).."' not found."); return
										end
										Insert(Bindings[ev], "<team> "..input)
										NAmanage.SaveBinders()
										refreshItems()
									end
								}}
							})
						end
					})

					Insert(B, {
						Text = "Nearest",
						Callback = function()
							Window({
								Title = ev.." Binders",
								Description = "Enter command (target: <nearest>)",
								InputField = true,
								Buttons = {{
									Text = "Submit",
									Callback = function(input)
										local cmdName = input and input:match("^(%S+)")
										if not (cmdName and (cmds.Commands[Lower(cmdName)] or cmds.Aliases[Lower(cmdName)])) then
											DoNotif("Command '"..tostring(cmdName).."' not found."); return
										end
										Insert(Bindings[ev], "<nearest> "..input)
										NAmanage.SaveBinders()
										refreshItems()
									end
								}}
							})
						end
					})

					Insert(B, {
						Text = "Farthest",
						Callback = function()
							Window({
								Title = ev.." Binders",
								Description = "Enter command (target: <farthest>)",
								InputField = true,
								Buttons = {{
									Text = "Submit",
									Callback = function(input)
										local cmdName = input and input:match("^(%S+)")
										if not (cmdName and (cmds.Commands[Lower(cmdName)] or cmds.Aliases[Lower(cmdName)])) then
											DoNotif("Command '"..tostring(cmdName).."' not found."); return
										end
										Insert(Bindings[ev], "<farthest> "..input)
										NAmanage.SaveBinders()
										refreshItems()
									end
								}}
							})
						end
					})

					Insert(B, {
						Text = "Random…",
						Callback = function()
							Window({
								Title = "Random Count",
								Description = "How many random players? (e.g. 1, 3, 5)",
								InputField = true,
								Buttons = {{
									Text = "Next",
									Callback = function(n)
										n = tonumber(n) or 1
										n = math.max(1, math.floor(n))
										local prefix = "<#"..tostring(n).."> "
										Window({
											Title = ev.." Binders",
											Description = "Enter command (target: "..prefix..")",
											InputField = true,
											Buttons = {{
												Text = "Submit",
												Callback = function(input)
													local cmdName = input and input:match("^(%S+)")
													if not (cmdName and (cmds.Commands[Lower(cmdName)] or cmds.Aliases[Lower(cmdName)])) then
														DoNotif("Command '"..tostring(cmdName).."' not found."); return
													end
													Insert(Bindings[ev], prefix..input)
													NAmanage.SaveBinders()
													refreshItems()
												end
											}}
										})
									end
								}}
							})
						end
					})

					Insert(B, {
						Text = "Radius…",
						Callback = function()
							Window({
								Title = "Radius (studs)",
								Description = "Players within this radius of you (e.g. 25)",
								InputField = true,
								Buttons = {{
									Text = "Next",
									Callback = function(r)
										r = tonumber(r) or 25
										r = math.max(1, math.floor(r))
										local prefix = "<rad"..tostring(r).."> "
										Window({
											Title = ev.." Binders",
											Description = "Enter command (target: "..prefix..")",
											InputField = true,
											Buttons = {{
												Text = "Submit",
												Callback = function(input)
													local cmdName = input and input:match("^(%S+)")
													if not (cmdName and (cmds.Commands[Lower(cmdName)] or cmds.Aliases[Lower(cmdName)])) then
														DoNotif("Command '"..tostring(cmdName).."' not found."); return
													end
													Insert(Bindings[ev], prefix..input)
													NAmanage.SaveBinders()
													refreshItems()
												end
											}}
										})
									end
								}}
							})
						end
					})

					Insert(B, {
						Text = "Team prefix…",
						Callback = function()
							Window({
								Title = "Team Prefix",
								Description = "e.g. red / blu / gua",
								InputField = true,
								Buttons = {{
									Text = "Next",
									Callback = function(prefix)
										prefix = tostring(prefix or ""):gsub("%s+","")
										if prefix == "" then DoNotif("Team prefix cannot be empty."); return end
										local sel = "<%"..prefix.."> "
										Window({
											Title = ev.." Binders",
											Description = "Enter command (target: "..sel..")",
											InputField = true,
											Buttons = {{
												Text = "Submit",
												Callback = function(input)
													local cmdName = input and input:match("^(%S+)")
													if not (cmdName and (cmds.Commands[Lower(cmdName)] or cmds.Aliases[Lower(cmdName)])) then
														DoNotif("Command '"..tostring(cmdName).."' not found."); return
													end
													Insert(Bindings[ev], sel..input)
													NAmanage.SaveBinders()
													refreshItems()
												end
											}}
										})
									end
								}}
							})
						end
					})

					Insert(B, {
						Text = "Specific player…",
						Callback = function()
							Window({
								Title = "Player Name (prefix ok)",
								Description = "Example: coolguy / coo",
								InputField = true,
								Buttons = {{
									Text = "Next",
									Callback = function(name)
										name = tostring(name or ""):gsub("^%s+",""):gsub("%s+$","")
										if name == "" then DoNotif("Name cannot be empty."); return end
										local sel = "<player:"..name.."> "
										Window({
											Title = ev.." Binders",
											Description = "Enter command (target: "..sel..")",
											InputField = true,
											Buttons = {{
												Text = "Submit",
												Callback = function(input)
													local cmdName = input and input:match("^(%S+)")
													if not (cmdName and (cmds.Commands[Lower(cmdName)] or cmds.Aliases[Lower(cmdName)])) then
														DoNotif("Command '"..tostring(cmdName).."' not found."); return
													end
													Insert(Bindings[ev], sel..input)
													NAmanage.SaveBinders()
													refreshItems()
												end
											}}
										})
									end
								}}
							})
						end
					})

					Insert(B, {
						Text = "UserId…",
						Callback = function()
							Window({
								Title = "UserId",
								Description = "Numbers only",
								InputField = true,
								Buttons = {{
									Text = "Next",
									Callback = function(id)
										id = tonumber(id)
										if not id then DoNotif("Invalid UserId."); return end
										local sel = "<id:"..tostring(id).."> "
										Window({
											Title = ev.." Binders",
											Description = "Enter command (target: "..sel..")",
											InputField = true,
											Buttons = {{
												Text = "Submit",
												Callback = function(input)
													local cmdName = input and input:match("^(%S+)")
													if not (cmdName and (cmds.Commands[Lower(cmdName)] or cmds.Aliases[Lower(cmdName)])) then
														DoNotif("Command '"..tostring(cmdName).."' not found."); return
													end
													Insert(Bindings[ev], sel..input)
													NAmanage.SaveBinders()
													refreshItems()
												end
											}}
										})
									end
								}}
							})
						end
					})

					Insert(B, {
						Text = "Custom term(s)…",
						Callback = function()
							Window({
								Title = "Custom PlayerArgs terms",
								Description = "Comma-separated: nearest,%blu,#3,group123,rad25",
								InputField = true,
								Buttons = {{
									Text = "Next",
									Callback = function(term)
										term = tostring(term or ""):gsub("%s+", "")
										if term == "" then DoNotif("Enter at least one term."); return end
										local sel = "<"..term.."> "
										Window({
											Title = ev.." Binders",
											Description = "Enter command (target: "..sel..")",
											InputField = true,
											Buttons = {{
												Text = "Submit",
												Callback = function(input)
													local cmdName = input and input:match("^(%S+)")
													if not (cmdName and (cmds.Commands[Lower(cmdName)] or cmds.Aliases[Lower(cmdName)])) then
														DoNotif("Command '"..tostring(cmdName).."' not found."); return
													end
													Insert(Bindings[ev], sel..input)
													NAmanage.SaveBinders()
													refreshItems()
												end
											}}
										})
									end
								}}
							})
						end
					})

					return B
				end)()
			})
		end)

		refreshItems()
		layoutOrder = layoutOrder + 1
	end
end)

-- [[ GUI ELEMENTS ]] --

--[[

NAgui.addToggle("Toggle Button", true, function(state)
	print("State:", state)
end)

NAgui.addColorPicker("Color Picker", Color3.fromRGB(200, 50, 100), function(color)
	print("Selected Color:", color)
end)

NAgui.addButton("button", function()
	print'pressed button'
end)

NAgui.addSection("Section Label")

NAgui.addInput("Input Label", "Placeholder", "", function(text)
	print("Input:", text)
end)

NAgui.addKeybind("Toggle Key", "F", function(key)
	print("key triggered:", key)
end)

NAgui.addSlider("Slider", 0, 100, 50, 5, "%", function(val) -- min, max, default, add, suffix
	print("Slider Value:", val)
end)

]]

--[[if Discover(_G.NAadminsLol or {}, LocalPlayer.UserId) then
	if NAgui.addSection then
		NAgui.addSection("NA Admin")
	end
	NAgui.addToggle("Admin RGB Username", NAStuff.ForceAdminRainbow, function(state)
		NAStuff.ForceAdminRainbow = state
	end)
end]]

NAgui.addTab(TAB_ALL, { default = true, order = 0 })
NAgui.addTab(TAB_GENERAL, { order = 1 })
NAgui.setTab(TAB_GENERAL)

NAgui.addSection("Prefix Settings")

NAgui.addInput("Prefix", "Enter a Prefix", opt.prefix, function(text)
	local newPrefix = text
	if not newPrefix or newPrefix == "" then
		DoNotif("Please enter a valid prefix")
	elseif utf8.len(newPrefix) > 1 then
		DoNotif("Prefix must be a single character (e.g. ; . !)")
	elseif newPrefix:match("[%w]") then
		DoNotif("Prefix cannot contain letters or numbers")
	elseif newPrefix:match("[%[%]%(%)%*%^%$%%{}<>]") then
		DoNotif("That symbol is not allowed as a prefix")
	elseif newPrefix:match("&amp;") or newPrefix:match("&lt;") or newPrefix:match("&gt;")
		or newPrefix:match("&quot;") or newPrefix:match("&#x27;") or newPrefix:match("&#x60;") then
		DoNotif("Encoded/HTML characters are not allowed as a prefix")
	else
		opt.prefix = newPrefix
		DoNotif("Prefix set to: "..newPrefix)
		if NAmanage.SyncPrefixUI then
			NAmanage.SyncPrefixUI()
		end
	end
end)

if FileSupport then
	NAgui.addButton("Save Prefix", function()
		NAmanage.NASettingsSet("prefix", opt.prefix)
		DoNotif("Prefix saved to settings file: "..NAfiles.NAMAINSETTINGSPATH)
	end)
end

NAgui.addSection("Admin Utility")

NAgui.addToggle("Keep "..adminName, NAQoTEnabled, function(val)
	NAQoTEnabled = val
	NAmanage.NASettingsSet("queueOnTeleport", val)
	if NAQoTEnabled then
		DoNotif(adminName.." will now auto-load after teleport (QueueOnTeleport enabled)", 3)
	else
		DoNotif("QueueOnTeleport has been disabled. "..adminName.." will no longer auto-run after teleport", 3)
	end
end)
NAmanage.RegisterToggleAutoSync("Keep "..adminName, function()
	return NAQoTEnabled == true
end)

NAgui.addToggle("Hide NA Icon", NAStuff.IconInvisible, function(v)
	NAmanage.IconSetInvisible(v, { skipToggle = true, force = true })
	DoNotif("Icon Visibility is "..(v and "Off" or "On"), 2)
end)
NAmanage.RegisterToggleAutoSync("Hide NA Icon", function()
	return NAStuff.IconInvisible == true
end)

NAgui.addToggle("Lock NA Icon", NAStuff.IconLocked, function(v)
	NAgui.setIconLocked(v, { force = true, skipToggle = true })
	DoNotif("Icon Position is "..(v and "Locked" or "Unlocked"), 2)
end)
NAmanage.RegisterToggleAutoSync("Lock NA Icon", function()
	return NAStuff.IconLocked == true
end)

NAgui.addToggle("Command Predictions Prompt", doPREDICTION, function(v)
	doPREDICTION = v
	DoNotif("Command Predictions "..(v and "Enabled" or "Disabled"), 2)
	NAmanage.NASettingsSet("prediction", v)
end)
NAmanage.RegisterToggleAutoSync("Command Predictions Prompt", function()
	return doPREDICTION == true
end)

NAgui.addToggle("Debug Notifications", NAStuff.nuhuhNotifs, function(v)
	NAStuff.nuhuhNotifs = v
	DoNotif("Debug Notifications "..(v and "Enabled" or "Disabled"), 2)
	NAmanage.NASettingsSet("notifsToggle", v)
end)
NAmanage.RegisterToggleAutoSync("Debug Notifications", function()
	return NAStuff.nuhuhNotifs == true
end)

NAgui.addToggle("Auto Skip Loading Screen", NAmanage.getAutoSkipPreference(), function(v)
	NAmanage.setAutoSkipPreference(v)
	DoNotif("Auto skip loading screen "..(v and "enabled" or "disabled"), 2)
end)
NAmanage.RegisterToggleAutoSync("Auto Skip Loading Screen", function()
	return NAmanage.getAutoSkipPreference() == true
end)

NAgui.addToggle("Keep Icon Position", NAiconSaveEnabled, function(v)
	local pos = NAgui.getClampedIconPosition() or TextButton.Position
	if v then
		TextButton.Position = pos
	else
		pos = NAgui.clampIconPositionUDim(UDim2.new(0.5, 0, 0.1, 0))
	end
	writefile(NAfiles.NAICONPOSPATH, HttpService:JSONEncode({
		X = pos.X.Scale,
		Y = pos.Y.Scale,
		Save = v
	}))
	NAiconSaveEnabled = v
	DoNotif("Icon position "..(v and "will be saved" or "won't be saved").." on exit", 2)
end)
NAmanage.RegisterToggleAutoSync("Keep Icon Position", function()
	return NAiconSaveEnabled == true
end)

if FileSupport then
	NAgui.addSection("Saved Data")
	NAgui.addButton("Delete Saved Settings...", function()
		NAmanage.openSettingsCleanupPopup()
	end)
end

NAgui.addTab(TAB_INTERFACE, { order = 2 })
NAgui.setTab(TAB_INTERFACE)


NAgui.addSection("UI Customization")

NAgui.addSlider("NA Icon Size", 0.5, 3, NAScale, 0.01, "", function(val)
	NAScale = val
	TextButton.Size = UDim2.new(0, 32 * val, 0, 33 * val)
	NAmanage.NASettingsSet("buttonSize", val)
end)

NAgui.addColorPicker("UI Stroke", NAUISTROKER, function(color)
	if typeof(color) == "Color3" then
		NAUISTROKER = color
		for _, element in ipairs(NACOLOREDELEMENTS) do
			if typeof(element) == "Instance" and element:IsA("UIStroke") then
				element.Color = color
			end
		end
		if TabManager and TabManager.tabs then
			for name, info in pairs(TabManager.tabs) do
				local btn = info and info.button
				if btn then
					local stroke = btn:FindFirstChildWhichIsA("UIStroke", true)
					if stroke then
						local computeColor = NAmanage.getTabStrokeColor
						if typeof(computeColor) == "function" then
							stroke.Color = computeColor(TabManager.current == name)
						else
							stroke.Color = color
						end
					end
				end
			end
		end
	end
	SaveUIStroke(color)
end)

NAgui.addSection("Topbar")

NAgui.addToggle("Dropdown Under Toggle", TopBarApp.mode == "bottom", function(state)
	NAmanage.Topbar_SetMode(state and "bottom" or "side")
end)

NAgui.addToggle("TopBar Visibility", NATOPBARVISIBLE, function(v)
	TopBarApp.top.Enabled = v
	NAmanage.NASettingsSet("topbarVisible", v)
end)

if CoreGui then
	local PT = {
		path     = NAfiles.NAFILEPATH.."/plexity_theme.json",
		default  = { enabled = false, start = { h = 0.8, s = 1, v = 1 }, finish = { h = 0, s = 1, v = 1 } },
		cg       = CoreGui,
		images   = {},
		watchers = setmetatable({}, { __mode = "k" }),
	}

	local data = PT.default
	if FileSupport then
		if not isfile(PT.path) then
			writefile(PT.path, HttpService:JSONEncode(PT.default))
		end

		local okRead, raw = pcall(readfile, PT.path)
		if okRead and type(raw) == "string" then
			local okDecode, decoded = pcall(HttpService.JSONDecode, HttpService, raw)
			if okDecode and type(decoded) == "table" then
				data = decoded
			end
		end
	end

	PT.data = data

	local propertyWatchList = {"Image", "Texture", "TextureId"}

	local function getImageId(o)
		for _, prop in ipairs(propertyWatchList) do
			local value = NAlib.isProperty(o, prop)
			if type(value) == "string" and value ~= "" then
				return value
			end
		end
		return nil
	end

	local function clearWatch(o)
		local conns = PT.watchers[o]
		if conns then
			for _, conn in ipairs(conns) do
				conn:Disconnect()
			end
			PT.watchers[o] = nil
		end
	end

	local function applyIfReady(o)
		if not (o and o.Parent) then
			return false
		end

		if PT.images[o] then
			NAmanage.plex_apply(o)
			return true
		end

		if not (o:IsA("ImageLabel") or o:IsA("ImageButton")) then
			return false
		end

		local id = getImageId(o)
		if type(id) == "string" and id:match("img_set_%dx_%d+%.png$") then
			PT.images[o] = true
			NAmanage.plex_apply(o)
			return true
		end

		return false
	end

	local function watchUntilReady(o)
		if PT.watchers[o] or not (o:IsA("ImageLabel") or o:IsA("ImageButton")) then
			return
		end

		local conns = {}
		local function track(conn)
			if conn then
				Insert(conns, conn)
			end
		end

		for _, prop in ipairs(propertyWatchList) do
			local ok, signal = pcall(function()
				return o:GetPropertyChangedSignal(prop)
			end)
			if ok and signal then
				track(signal:Connect(function()
					if applyIfReady(o) then
						clearWatch(o)
					end
				end))
			end
		end

		track(o.AncestryChanged:Connect(function(_, parent)
			if not parent then
				clearWatch(o)
				PT.images[o] = nil
			end
		end))

		if #conns > 0 then
			PT.watchers[o] = conns
		end
	end

	NAmanage.plex_remove = function(o)
		clearWatch(o)
		local g = o:FindFirstChildOfClass("UIGradient")
		if g then g:Destroy() end
	end

	NAmanage.plex_apply = function(o)
		NAmanage.plex_remove(o)
		if PT.data.enabled then
			local seq = ColorSequence.new{
				ColorSequenceKeypoint.new(0, Color3.fromHSV(PT.data.start.h, PT.data.start.s, PT.data.start.v)),
				ColorSequenceKeypoint.new(1, Color3.fromHSV(PT.data.finish.h, PT.data.finish.s, PT.data.finish.v)),
			}
			local ug = InstanceNew("UIGradient", o)
			ug.Color, ug.Rotation = seq, 45
			ug.Transparency = NumberSequence.new{
				NumberSequenceKeypoint.new(0,   0, 0),
				NumberSequenceKeypoint.new(0.5, 0, 0),
				NumberSequenceKeypoint.new(1,   0, 0),
			}
		end
	end

	NAmanage.plex_add = function(o)
		if applyIfReady(o) then
			return
		end
		watchUntilReady(o)
	end

	NAmanage.plex_applyAll = function()
		for o in pairs(PT.images) do
			if o and o.Parent then
				NAmanage.plex_add(o)
			else
				PT.images[o] = nil
			end
		end
	end

	for _, o in ipairs(PT.cg:GetDescendants()) do
		NAmanage.plex_add(o)
	end

	local function onDescendantAdded(o)
		NAmanage.plex_add(o)
		for _, desc in ipairs(o:GetDescendants()) do
			NAmanage.plex_add(desc)
		end
	end

	NAlib.disconnect("PlexyDesc")
	NAlib.connect("PlexyDesc", PT.cg.DescendantAdded:Connect(onDescendantAdded))

	NAgui.addSection("Plexity Theme")
	NAgui.addToggle("Enable Theme", PT.data.enabled, function(v)
		PT.data.enabled = v
		if v then
			for _, o in ipairs(PT.cg:GetDescendants()) do
				NAmanage.plex_add(o)
			end
			NAmanage.plex_applyAll()
		else
			for o in pairs(PT.images) do
				NAmanage.plex_remove(o)
			end
		end
		if FileSupport then
			writefile(PT.path, HttpService:JSONEncode(PT.data))
		end
	end)

	NAgui.addColorPicker("Gradient Start Color", Color3.fromHSV(PT.data.start.h, PT.data.start.s, PT.data.start.v), function(c)
		local h, s, v = c:ToHSV()
		PT.data.start.h, PT.data.start.s, PT.data.start.v = h, s, v
		NAmanage.plex_applyAll()
		if FileSupport then
			writefile(PT.path, HttpService:JSONEncode(PT.data))
		end
	end)

	NAgui.addColorPicker("Gradient End Color", Color3.fromHSV(PT.data.finish.h, PT.data.finish.s, PT.data.finish.v), function(c)
		local h, s, v = c:ToHSV()
		PT.data.finish.h, PT.data.finish.s, PT.data.finish.v = h, s, v
		NAmanage.plex_applyAll()
		if FileSupport then
			writefile(PT.path, HttpService:JSONEncode(PT.data))
		end
	end)
	if previousTab and previousTab ~= TAB_INTERFACE then
		if NAgui.getActiveTab() == TAB_INTERFACE then
			NAgui.setTab(previousTab)
		end
	end
end



local joinLeaveWarned = false
local function persistJoinLeaveConfig()
	if FileSupport then
		writefile(NAfiles.NAJOINLEAVE, HttpService:JSONEncode(JoinLeaveConfig))
	elseif not joinLeaveWarned then
		joinLeaveWarned = true
		DebugNotif("Join/Leave settings will reset after this session (no file support detected).")
	end
end

NAgui.addTab(TAB_LOGGING, { order = 5 })
NAgui.setTab(TAB_LOGGING)

NAgui.addSection("Join/Leave Logging")

NAgui.addToggle("Log Player Joins", JoinLeaveConfig.JoinLog, function(v)
	JoinLeaveConfig.JoinLog = v
	persistJoinLeaveConfig()
	DoNotif("Join logging "..(v and "enabled" or "disabled"), 2)
end)

NAgui.addToggle("Log Player Leaves", JoinLeaveConfig.LeaveLog, function(v)
	JoinLeaveConfig.LeaveLog = v
	persistJoinLeaveConfig()
	DoNotif("Leave logging "..(v and "enabled" or "disabled"), 2)
end)

NAgui.addToggle("Save Join/Leave Logs", JoinLeaveConfig.SaveLog, function(v)
	JoinLeaveConfig.SaveLog = v
	persistJoinLeaveConfig()
	DoNotif("Join/Leave log saving has been "..(v and "enabled" or "disabled"), 2)
end)

NAgui.addTab(TAB_ESP, { order = 4 })
NAgui.setTab(TAB_ESP)

NAgui.isListActive=function(list)
	return type(list) == "table" and next(list) ~= nil
end

NAgui.trimText=function(str)
	return (str or ""):match("^%s*(.-)%s*$")
end

NAgui.addSection("ESP Settings")

NAgui.addToggle("Use Highlight Rendering (Highlight)", NAgui.espUsesHighlight(), function(state)
	NAStuff.ESP_RenderMode = state and "Highlight" or "BoxHandleAdornment"
	NAmanage.SaveESPSettings()
	NAmanage.ESP_RebuildVisuals()
end)

NAgui.addSlider("ESP Transparency", 0, 1, NAgui.sanitizeTransparency(NAStuff.ESP_Transparency or 0.7), 0.05, "", function(v)
	local alpha = NAgui.sanitizeTransparency(v)
	NAStuff.ESP_Transparency = alpha
	for _, data in pairs(espCONS) do
		if data.highlight then
			data.highlight.FillTransparency = alpha
		end
		for _, box in pairs(data.boxTable) do
			if box then box.Transparency = alpha end
		end
	end
	NAmanage.PartESP_UpdateTexts(true)
	NAmanage.SaveESPSettings()
end)

NAgui.addSlider("ESP Box Distance", 0, 2000, NAStuff.ESP_BoxMaxDistance or 120, 5, " studs", function(v)
	NAStuff.ESP_BoxMaxDistance = v
	NAmanage.SaveESPSettings()
end)

NAgui.addSlider("ESP Label Distance", 0, 5000, NAStuff.ESP_LabelMaxDistance or 1000, 25, " studs", function(v)
	NAStuff.ESP_LabelMaxDistance = v
	NAmanage.SaveESPSettings()
end)

NAgui.addSection("Label Styling")

NAgui.addSlider("Label Text Size", 8, 72, NAgui.sanitizeLabelSize(NAStuff.ESP_LabelTextSize), 1, " px", function(v)
	local size = NAgui.sanitizeLabelSize(v)
	NAStuff.ESP_LabelTextSize = size
	NAmanage.SaveESPSettings()
	NAmanage.ESP_ApplyLabelStyles()
end)

NAgui.addToggle("Label Text Scaled", NAStuff.ESP_LabelTextScaled, function(state)
	NAStuff.ESP_LabelTextScaled = state
	NAmanage.SaveESPSettings()
	NAmanage.ESP_ApplyLabelStyles()
end)

NAgui.addSection("Label Content")

NAgui.addToggle("ESP Color By Team", (NAStuff.ESP_ColorByTeam ~= false), function(state)
	NAStuff.ESP_ColorByTeam = state
	NAmanage.SaveESPSettings()
end)

NAgui.addToggle("Show Team In Label", (NAStuff.ESP_ShowTeamText ~= false), function(state)
	NAStuff.ESP_ShowTeamText = state
	NAmanage.SaveESPSettings()
end)

NAgui.addToggle("Show Name In Label", (NAStuff.ESP_ShowName ~= false), function(state)
	NAStuff.ESP_ShowName = state
	NAmanage.SaveESPSettings()
end)

NAgui.addToggle("Show Health In Label", (NAStuff.ESP_ShowHealth ~= false), function(state)
	NAStuff.ESP_ShowHealth = state
	NAmanage.SaveESPSettings()
end)

NAgui.addToggle("Show Distance In Label", (NAStuff.ESP_ShowDistance ~= false), function(state)
	NAStuff.ESP_ShowDistance = state
	NAmanage.SaveESPSettings()
end)

NAgui.addSection("PartEsp Section")

NAgui.addToggle("Show Part Distance", (NAStuff.ESP_ShowPartDistance == true), function(state)
	NAStuff.ESP_ShowPartDistance = state
	NAmanage.SaveESPSettings()
	NAmanage.PartESP_UpdateTexts(true)
end)

NAgui.addToggle("ESP Locator Arrows", NAStuff.ESP_LocatorEnabled == true, function(state)
	NAStuff.ESP_LocatorEnabled = state == true
	if NAStuff.ESP_LocatorEnabled then
		NAmanage.ESP_LocatorEnable(true)
	else
		NAmanage.ESP_LocatorDisable()
	end
	NAmanage.SaveESPSettings()
end)

NAgui.addSlider("Locator Size", 12, 128, math.clamp(tonumber(NAStuff.ESP_LocatorSize) or 26, 12, 128), 1, " px", function(v)
	NAStuff.ESP_LocatorSize = math.clamp(tonumber(v) or 26, 12, 128)
	NAmanage.SaveESPSettings()
	NAmanage.ESP_LocatorEnable(true)
end)

NAgui.addToggle("Locator Show Text", NAStuff.ESP_LocatorShowText == true, function(state)
	NAStuff.ESP_LocatorShowText = state == true
	NAmanage.SaveESPSettings()
	NAmanage.ESP_LocatorEnable(true)
end)

NAgui.addSlider("Locator Text Size", 10, 48, math.clamp(tonumber(NAStuff.ESP_LocatorTextSize) or 14, 10, 48), 1, " px", function(v)
	NAStuff.ESP_LocatorTextSize = math.clamp(tonumber(v) or 14, 10, 48)
	NAmanage.SaveESPSettings()
	NAmanage.ESP_LocatorEnable(true)
end)

NAgui.addSection("Interactable ESP (touchesp/proximityesp/clickesp)")

NAgui.addToggle("Touch ESP", NAgui.isListActive(NAStuff.touchESPList), function(state)
	SpawnCall(function()
		if state then
			cmd.run({"touchesp"})
		else
			cmd.run({"untouchesp"})
		end
	end)
end)

NAgui.addToggle("Proximity Prompt ESP", NAgui.isListActive(NAStuff.proximityESPList), function(state)
	SpawnCall(function()
		if state then
			cmd.run({"proximityesp"})
		else
			cmd.run({"unproximityesp"})
		end
	end)
end)

NAgui.addToggle("Click Detector ESP", NAgui.isListActive(NAStuff.clickESPList), function(state)
	SpawnCall(function()
		if state then
			cmd.run({"clickesp"})
		else
			cmd.run({"unclickesp"})
		end
	end)
end)

NAgui.addSection("Seat ESP")

NAgui.addToggle("Seat ESP", NAgui.isListActive(NAStuff.siteESPList), function(state)
	SpawnCall(function()
		if state then
			cmd.run({"sitesp"})
		else
			cmd.run({"unsitesp"})
		end
	end)
end)

NAgui.addToggle("Vehicle Seat ESP", NAgui.isListActive(NAStuff.vehicleSiteESPList), function(state)
	SpawnCall(function()
		if state then
			cmd.run({"vehiclesitesp"})
		else
			cmd.run({"unvehiclesitesp"})
		end
	end)
end)

NAgui.addSection("Physics ESP | AKA: lag section")

NAgui.addToggle("Unanchored Parts ESP", NAgui.isListActive(NAStuff.unanchoredESPList), function(state)
	SpawnCall(function()
		if state then
			cmd.run({"unanchored"})
		else
			cmd.run({"ununanchored"})
		end
	end)
end)

NAgui.addToggle("Collidable Parts ESP", NAgui.isListActive(NAStuff.collisiontrueESPList), function(state)
	SpawnCall(function()
		if state then
			cmd.run({"collisionesp"})
		else
			cmd.run({"uncollisionesp"})
		end
	end)
end)

NAgui.addToggle("Non-Collidable Parts ESP", NAgui.isListActive(NAStuff.collisionfalseESPList), function(state)
	SpawnCall(function()
		if state then
			cmd.run({"nocollisionesp"})
		else
			cmd.run({"unnocollisionesp"})
		end
	end)
end)

NAgui.addSection("Part ESP")

NAgui.addInput("Exact Part Name", "Exact part name (partesp)", NAStuff.ESP_LastExactPart, function(text)
	NAStuff.ESP_LastExactPart = text
end)

NAgui.addButton("Apply Exact Part ESP", function()
	local name = NAgui.trimText(NAStuff.ESP_LastExactPart)
	if name == "" then
		DoNotif("Enter an exact part name before using partesp.", 2)
		return
	end
	SpawnCall(function() cmd.run({"pesp", name}) end)
end)

NAgui.addButton("Clear Exact Part ESP", function()
	SpawnCall(function() cmd.run({"unpesp"}) end)
end)

NAgui.addInput("Partial Part Name", "Partial part name (pespfind)", NAStuff.ESP_LastPartialPart, function(text)
	NAStuff.ESP_LastPartialPart = text
end)

NAgui.addButton("Apply Partial Part ESP", function()
	local name = NAgui.trimText(NAStuff.ESP_LastPartialPart)
	if name == "" then
		DoNotif("Enter a partial part name before using pespfind.", 2)
		return
	end
	SpawnCall(function() cmd.run({"pespfind", name}) end)
end)

NAgui.addButton("Clear Partial Part ESP", function()
	SpawnCall(function() cmd.run({"unpespfind"}) end)
end)

NAgui.addSection("Folder ESP")

NAgui.addInput("Folder Name", "Folder name to highlight", NAStuff.ESP_LastFolderName, function(text)
	NAStuff.ESP_LastFolderName = text
end)

NAgui.addButton("Apply Folder ESP", function()
	local name = NAgui.trimText(NAStuff.ESP_LastFolderName)
	if name == "" then
		DoNotif("Enter a folder name before using folderesp.", 2)
		return
	end
	SpawnCall(function() cmd.run({"folderesp", name}) end)
end)

NAgui.addButton("Clear Folder ESP", function()
	local name = NAgui.trimText(NAStuff.ESP_LastFolderName)
	SpawnCall(function()
		if name ~= "" then
			cmd.run({"unfolderesp", name})
		else
			cmd.run({"unfolderesp"})
		end
	end)
end)

NAgui.addTab(TAB_CHAT, { order = 3 })
NAgui.setTab(TAB_CHAT)

do
	local function tblToC3(t)
		if typeof(t) == "Color3" then return t end
		local r = (t and (t.R or t[1])) or 255
		local g = (t and (t.G or t[2])) or 255
		local b = (t and (t.B or t[3])) or 255
		return Color3.fromRGB(r, g, b)
	end
	local function c3ToTbl(c)
		return { math.floor(c.R * 255 + 0.5), math.floor(c.G * 255 + 0.5), math.floor(c.B * 255 + 0.5) }
	end

	NAgui.addSection("Text Chat")
	NAgui.addToggle("Enable Custom Chat Styling", NAStuff.ChatSettings.customEnabled, function(v)
		local wasEnabled = NAStuff.ChatSettings.customEnabled == true
		NAStuff.ChatSettings.customEnabled = v

		if wasEnabled and not v then
			originalIO.backupChatSection("bubbles")
			if not originalIO.assignChatSectionFromTemplate("bubbles") then
				originalIO.restoreChatSectionFromBackup("bubbles")
			end
		elseif v and not wasEnabled then
			if not originalIO.restoreChatSectionFromBackup("bubbles") and type(NAStuff.ChatSettings.bubbles) ~= "table" then
				originalIO.assignChatSectionFromTemplate("bubbles")
			end
		end

		NAmanage.SaveTextChatSettings()
		NAmanage.ApplyTextChatSettings()
	end)
	NAgui.addButton("Reset Custom Chat Settings", function()
		local ok, err = pcall(function()
			local template = NAStuff.ChatSettingsTemplate
			if type(template) ~= "table" then
				error("Chat default settings unavailable.")
			end

			local current = NAStuff.ChatSettings
			local preserveCustom = (current and current.customEnabled) or false
			local preserveCoreChat = (current and current.coreGuiChat ~= nil) and current.coreGuiChat or true
			local templateCopy = deepCopyTable(template)

			if type(current) ~= "table" then
				current = {}
				NAStuff.ChatSettings = current
			end

			for key in pairs(current) do
				current[key] = nil
			end
			for key, value in pairs(templateCopy) do
				current[key] = value
			end

			NAStuff.ChatSettingsCustomBackup = nil
			current.customEnabled = preserveCustom
			current.coreGuiChat = preserveCoreChat

			NAStuff.ChatCustomizationActive = nil
			NAmanage.SaveTextChatSettings()
			NAmanage.ApplyTextChatSettings()
		end)

		if ok then
			DoNotif("Chat style options reset to defaults.", 2)
		else
			warn("[NA] Reset Custom Chat Settings failed:", err)
			DoNotif("Failed to reset chat settings. Check console for details.", 3)
		end
	end)

	NAgui.addToggle("Enable Chat (CoreGui)", NAStuff.ChatSettings.coreGuiChat, function(v)
		NAStuff.ChatSettings.coreGuiChat = v; NAmanage.SaveTextChatSettings(); NAmanage.ApplyTextChatSettings()
	end)

	NAgui.addSection("Chat Window")
	NAgui.addToggle("Window Enabled", NAStuff.ChatSettings.window.enabled, function(v)
		NAStuff.ChatSettings.window.enabled = v; NAmanage.SaveTextChatSettings(); NAmanage.ApplyTextChatSettings()
	end)
	NAgui.addSlider("Text Size (Window)", 5, 50, NAStuff.ChatSettings.window.textSize, 1, " px", function(v)
		NAStuff.ChatSettings.window.textSize = v; NAmanage.SaveTextChatSettings(); NAmanage.ApplyTextChatSettings()
	end)
	NAgui.addColorPicker("Text Color", tblToC3(NAStuff.ChatSettings.window.textColor), function(c)
		NAStuff.ChatSettings.window.textColor = c3ToTbl(c); NAmanage.SaveTextChatSettings(); NAmanage.ApplyTextChatSettings()
	end)
	NAgui.addColorPicker("Text Stroke Color", tblToC3(NAStuff.ChatSettings.window.strokeColor), function(c)
		NAStuff.ChatSettings.window.strokeColor = c3ToTbl(c); NAmanage.SaveTextChatSettings(); NAmanage.ApplyTextChatSettings()
	end)
	NAgui.addSlider("Text Stroke Transparency", 0, 1, NAStuff.ChatSettings.window.strokeTransparency, 0.05, "", function(v)
		NAStuff.ChatSettings.window.strokeTransparency = v; NAmanage.SaveTextChatSettings(); NAmanage.ApplyTextChatSettings()
	end)
	NAgui.addColorPicker("Window Background", tblToC3(NAStuff.ChatSettings.window.backgroundColor), function(c)
		NAStuff.ChatSettings.window.backgroundColor = c3ToTbl(c); NAmanage.SaveTextChatSettings(); NAmanage.ApplyTextChatSettings()
	end)
	NAgui.addSlider("Window Background Transparency", 0, 1, NAStuff.ChatSettings.window.backgroundTransparency, 0.05, "", function(v)
		NAStuff.ChatSettings.window.backgroundTransparency = v; NAmanage.SaveTextChatSettings(); NAmanage.ApplyTextChatSettings()
	end)

	NAgui.addSection("Channel Tabs")
	NAgui.addToggle("Tabs Enabled", NAStuff.ChatSettings.tabs.enabled, function(v)
		NAStuff.ChatSettings.tabs.enabled = v; NAmanage.SaveTextChatSettings(); NAmanage.ApplyTextChatSettings()
	end)
	NAgui.addSlider("Text Size (Tabs)", 5, 50, NAStuff.ChatSettings.tabs.textSize, 1, " px", function(v)
		NAStuff.ChatSettings.tabs.textSize = v; NAmanage.SaveTextChatSettings(); NAmanage.ApplyTextChatSettings()
	end)
	NAgui.addSlider("Background Transparency (Tabs)", 0, 1, NAStuff.ChatSettings.tabs.backgroundTransparency, 0.05, "", function(v)
		NAStuff.ChatSettings.tabs.backgroundTransparency = v; NAmanage.SaveTextChatSettings(); NAmanage.ApplyTextChatSettings()
	end)
	NAgui.addColorPicker("Text Color (Tabs)", tblToC3(NAStuff.ChatSettings.tabs.textColor), function(c)
		NAStuff.ChatSettings.tabs.textColor = c3ToTbl(c); NAmanage.SaveTextChatSettings(); NAmanage.ApplyTextChatSettings()
	end)
	NAgui.addColorPicker("Selected Text Color", tblToC3(NAStuff.ChatSettings.tabs.selectedTextColor), function(c)
		NAStuff.ChatSettings.tabs.selectedTextColor = c3ToTbl(c); NAmanage.SaveTextChatSettings(); NAmanage.ApplyTextChatSettings()
	end)
	NAgui.addColorPicker("Unselected Text Color", tblToC3(NAStuff.ChatSettings.tabs.unselectedTextColor), function(c)
		NAStuff.ChatSettings.tabs.unselectedTextColor = c3ToTbl(c); NAmanage.SaveTextChatSettings(); NAmanage.ApplyTextChatSettings()
	end)

	NAgui.addSection("Chat Input")
	NAgui.addToggle("Input Enabled", NAStuff.ChatSettings.input.enabled, function(v)
		NAStuff.ChatSettings.input.enabled = v; NAmanage.SaveTextChatSettings(); NAmanage.ApplyTextChatSettings()
	end)
	NAgui.addToggle("Autocomplete", NAStuff.ChatSettings.input.autocomplete, function(v)
		NAStuff.ChatSettings.input.autocomplete = v; NAmanage.SaveTextChatSettings(); NAmanage.ApplyTextChatSettings()
	end)
	NAgui.addToggle("Target #RBXGeneral", NAStuff.ChatSettings.input.targetGeneral, function(v)
		NAStuff.ChatSettings.input.targetGeneral = v; NAmanage.SaveTextChatSettings(); NAmanage.ApplyTextChatSettings()
	end)
	NAgui.addSlider("Text Size (Input)", 5, 25, NAStuff.ChatSettings.input.textSize, 1, " px", function(v)
		NAStuff.ChatSettings.input.textSize = v; NAmanage.SaveTextChatSettings(); NAmanage.ApplyTextChatSettings()
	end)
	NAgui.addColorPicker("Text Color (Input)", tblToC3(NAStuff.ChatSettings.input.textColor), function(c)
		NAStuff.ChatSettings.input.textColor = c3ToTbl(c); NAmanage.SaveTextChatSettings(); NAmanage.ApplyTextChatSettings()
	end)
	NAgui.addSlider("Text Stroke Transparency (Input)", 0, 1, NAStuff.ChatSettings.input.strokeTransparency, 0.05, "", function(v)
		NAStuff.ChatSettings.input.strokeTransparency = v; NAmanage.SaveTextChatSettings(); NAmanage.ApplyTextChatSettings()
	end)
	NAgui.addSlider("Background Transparency (Input)", 0, 1, NAStuff.ChatSettings.input.backgroundTransparency, 0.05, "", function(v)
		NAStuff.ChatSettings.input.backgroundTransparency = v; NAmanage.SaveTextChatSettings(); NAmanage.ApplyTextChatSettings()
	end)
	if not IsOnMobile then
		NAgui.addKeybind("Chat Key", NAStuff.ChatSettings.input.keyCode or "Slash", function(keyName)
			NAStuff.ChatSettings.input.keyCode = tostring(keyName or "Slash"); NAmanage.SaveTextChatSettings(); NAmanage.ApplyTextChatSettings()
		end)
	end

	NAgui.addSection("Bubble Chat")
	NAgui.addToggle("Bubbles Enabled", NAStuff.ChatSettings.bubbles.enabled, function(v)
		NAStuff.ChatSettings.bubbles.enabled = v; NAmanage.SaveTextChatSettings(); NAmanage.ApplyTextChatSettings()
	end)
	NAgui.addSlider("Max Distance", 10, 500, NAStuff.ChatSettings.bubbles.maxDistance, 5, " u", function(v)
		NAStuff.ChatSettings.bubbles.maxDistance = v; NAmanage.SaveTextChatSettings(); NAmanage.ApplyTextChatSettings()
	end)
	NAgui.addSlider("Minimize Distance", 0, 350, NAStuff.ChatSettings.bubbles.minimizeDistance, 2, " u", function(v)
		NAStuff.ChatSettings.bubbles.minimizeDistance = v; NAmanage.SaveTextChatSettings(); NAmanage.ApplyTextChatSettings()
	end)
	NAgui.addSlider("Text Size (Bubble)", 5, 30, NAStuff.ChatSettings.bubbles.textSize, 1, " px", function(v)
		NAStuff.ChatSettings.bubbles.textSize = v; NAmanage.SaveTextChatSettings(); NAmanage.ApplyTextChatSettings()
	end)
	NAgui.addSlider("Bubble Spacing", 0, 12, NAStuff.ChatSettings.bubbles.spacing, 1, " px", function(v)
		NAStuff.ChatSettings.bubbles.spacing = v; NAmanage.SaveTextChatSettings(); NAmanage.ApplyTextChatSettings()
	end)
	NAgui.addSlider("Background Transparency (Bubble)", 0, 1, NAStuff.ChatSettings.bubbles.backgroundTransparency, 0.05, "", function(v)
		NAStuff.ChatSettings.bubbles.backgroundTransparency = v; NAmanage.SaveTextChatSettings(); NAmanage.ApplyTextChatSettings()
	end)
	NAgui.addToggle("Tail Visible", NAStuff.ChatSettings.bubbles.tailVisible, function(v)
		NAStuff.ChatSettings.bubbles.tailVisible = v; NAmanage.SaveTextChatSettings(); NAmanage.ApplyTextChatSettings()
	end)
end

if not IsOnMobile then
	NAgui.addTab(TAB_KEYBINDS, { order = 6 })
	NAgui.setTab(TAB_KEYBINDS)

	if IsOnPC then
		NAgui.addSection("Control Lock")
		NAgui.addKeybind("Add Shiftlock Key","LeftShift",function(k)
			if k then NAmanage.ControlLock_AddKey(k) end
		end)
		NAgui.addKeybind("Remove Shiftlock Key","RightShift",function(k)
			if k then NAmanage.ControlLock_RemoveKey(k) end
		end)
		NAgui.addButton("Apply Saved Keys",function()
			NAmanage.ControlLock_Apply(NAStuff._ctrlLockKeys)
		end)
		NAgui.addButton("Reset To Default (Shift)",function()
			NAmanage.ControlLock_ClearToDefault()
		end)
		NAgui.addToggle("Reapply On Respawn",NAStuff._ctrlLockPersist,function(state)
			NAStuff._ctrlLockPersist = state and true or false
			NAmanage.ControlLock_Bind()
		end)

		NAgui.addSection("Fly Keybinds")
		local function createFlyKeybindHandler(varField, connField, connectFunc, successTemplate, emptyMessage)
			emptyMessage = emptyMessage or "Please provide a keybind."
			return function(keyName)
				if keyName == nil then
					return
				end
				local newKey = tostring(keyName or ""):lower()
				if newKey == "" then
					DoNotif(emptyMessage)
					return
				end
				flyVariables[varField] = newKey
				local existingConn = flyVariables[connField]
				if existingConn then
					existingConn:Disconnect()
					flyVariables[connField] = nil
				end
				connectFunc()
				DebugNotif(Format(successTemplate, newKey:upper()))
			end
		end

		NAgui.addKeybind("Fly Keybind", string.upper(flyVariables.toggleKey or "F"), createFlyKeybindHandler(
			"toggleKey",
			"keybindConn",
			NAmanage.connectFlyKey,
			"Fly keybind set to '%s'"
			))

		NAgui.addKeybind("vFly Keybind", string.upper(flyVariables.vToggleKey or "V"), createFlyKeybindHandler(
			"vToggleKey",
			"vKeybindConn",
			NAmanage.connectVFlyKey,
			"vFly keybind set to '%s'"
			))

		NAgui.addKeybind("cFly Keybind", string.upper(flyVariables.cToggleKey or "C"), createFlyKeybindHandler(
			"cToggleKey",
			"cKeybindConn",
			NAmanage.connectCFlyKey,
			"CFrame fly keybind set to '%s'"
			))

		NAgui.addKeybind("tFly Keybind", string.upper(flyVariables.tflyToggleKey or "T"), createFlyKeybindHandler(
			"tflyToggleKey",
			"tflyKeyConn",
			NAmanage.connectTFlyKey,
			"TFly keybind set to '%s'",
			"Please provide a key."
			))
	end
end

NAgui.addTab(TAB_CHARACTER, { order = 7 })
NAgui.setTab(TAB_CHARACTER)

NAgui.addSection("Character Morph")
NAgui.addInput("Target User", "UserId or Username", "", function(val)
	morphTarget = val
end)
NAgui.addButton("Morph Character", function()
	if morphTarget ~= "" then
		cmd.run({"char", morphTarget})
	end
end)
NAgui.addButton("Revert Character", function()
	cmd.run({"unchar"})
end)
NAgui.addToggle("Auto Morph", false, function(state)
	if state then
		NAlib.disconnect("autochartoggle")
		NAlib.connect("autochartoggle", Players.LocalPlayer.CharacterAdded:Connect(function()
			if morphTarget ~= "" then
				cmd.run({"char", morphTarget})
			end
		end))
		if morphTarget ~= "" then
			cmd.run({"char", morphTarget})
		end
	else
		NAlib.disconnect("autochartoggle")
	end
end)

NAgui.addSection("Character Light")
NAgui.addSlider("Range",      0,  120, settingsLight.range,      0.1,   "", function(val) settingsLight.range      = val end)
NAgui.addSlider("Brightness", 0,   100, settingsLight.brightness, 0.5,   "", function(val) settingsLight.brightness = val end)
NAgui.addColorPicker("Color",  settingsLight.color, function(col) settingsLight.color = col end)
NAgui.addButton("Apply Light", function()
	local root = getRoot(Player.Character)
	if not root then return end
	local light = settingsLight.LIGHTER
	if not light or not light.Parent then
		light = InstanceNew("PointLight")
		settingsLight.LIGHTER = light
	end
	light.Parent     = root
	light.Range      = settingsLight.range
	light.Brightness = settingsLight.brightness
	light.Color      = settingsLight.color
end)
NAgui.addButton("Remove Light", function()
	if settingsLight.LIGHTER then
		settingsLight.LIGHTER:Destroy()
		settingsLight.LIGHTER = nil
	end
end)

do
	local previousTab = NAgui.getActiveTab()
	NAgui.addTab(TAB_BASIC_INFO, { order = 7.5 })
	NAgui.setTab(TAB_BASIC_INFO)

	local basicInfoConfig = {
		{
			title = "Player";
			fields = {
				{ id = "playerDisplayName", label = "Display Name", path = {"player","displayName"} };
				{ id = "playerUsername", label = "Username", path = {"player","username"} };
				{ id = "playerUserId", label = "UserId", path = {"player","userId"} };
				{ id = "playerAccountAge", label = "Account Age", path = {"player","accountAge"} };
				{ id = "playerMembership", label = "Membership", path = {"player","membership"} };
			};
		},
		{
			title = "Platform";
			fields = {
				{ id = "platformName", label = "Platform", path = {"platform","platform"} };
				{ id = "executorName", label = "Executor", path = {"platform","executor"} };
			};
		},
		{
			title = "Game";
			fields = {
				{ id = "gameName", label = "Game Name", path = {"game","name"} };
				{ id = "gameCreator", label = "Creator", path = {"game","creator"} };
			};
		},
		{
			title = "Identifiers";
			fields = {
				{ id = "placeId", label = "Place ID", path = {"ids","placeId"} };
				{ id = "gameId", label = "Game ID", path = {"ids","gameId"} };
				{ id = "jobId", label = "Job ID", path = {"ids","jobId"} };
			};
		},
		{
			title = "Server";
			fields = {
				{ id = "serverPlayers", label = "Players", path = {"server","playerCount"} };
			};
		},
		{
			title = "System";
			fields = {
				{ id = "robloxLocale", label = "Roblox Locale", path = {"system","robloxLocale"} };
				{ id = "systemLocale", label = "System Locale", path = {"system","systemLocale"} };
				{ id = "qualitySetting", label = "Graphics Quality", path = {"system","quality"} };
				{ id = "voiceStatus", label = "Voice Chat", path = {"system","voice"} };
			};
		},
		{
			title = "Flags";
			fields = {
				{ id = "naVersion", label = "NA Version", path = {"flags","version"} };
				{ id = "aprilMode", label = "April Fools Mode", path = {"flags","aprilFools"} };
				{ id = "timestamp", label = "Timestamp", path = "timestamp" };
			};
		},
	}

	local basicInfoBoxes = {}

	local function resolveValue(snapshot, path)
		local current = snapshot
		if type(path) == "table" then
			for _, key in ipairs(path) do
				if current == nil then
					break
				end
				current = current[key]
			end
		elseif path ~= nil then
			current = current and current[path] or nil
		end
		if current == nil or current == "" then
			return "Unknown"
		end
		return tostring(current)
	end

	for _, section in ipairs(basicInfoConfig) do
		if NAgui.addSection then
			NAgui.addSection(section.title)
		end
		for _, field in ipairs(section.fields) do
			local box = NAgui.addInfo(field.label, "")
			if box then
				box.TextXAlignment = Enum.TextXAlignment.Left
				box.TextYAlignment = Enum.TextYAlignment.Center
				box.TextWrapped = false
				box.TextScaled = false
				box.Selectable = true
				box.Active = true
				local frame = box.Parent
				if frame and frame:IsA("Frame") then
					frame:SetAttribute("NAMinWidth", 180)
				end
			end
			basicInfoBoxes[field.id] = box
		end
	end

	local function refreshBasicInfo()
		local snapshot = NAmanage.GetBasicInfoSnapshot()
		for _, section in ipairs(basicInfoConfig) do
			for _, field in ipairs(section.fields) do
				local box = basicInfoBoxes[field.id]
				if box then
					local value = resolveValue(snapshot, field.path)
					box.Text = value
				end
			end
		end
	end

	NAgui.RefreshBasicInfo = refreshBasicInfo
	refreshBasicInfo()
	NAgui.addButton("Refresh Basic Info", refreshBasicInfo)

	local updateInterval = 1
	if not NAgui.BasicInfoUpdate then
		NAgui.BasicInfoUpdate = { interval = updateInterval, last = 0 }
		NAgui.BasicInfoUpdate.conn = RunService.Heartbeat:Connect(function()
			local data = NAgui.BasicInfoUpdate
			if not data then
				return
			end
			if not TabManager or TabManager.current ~= TAB_BASIC_INFO then
				return
			end
			local now = tick()
			if now - data.last >= data.interval then
				data.last = now
				refreshBasicInfo()
			end
		end)
	else
		NAgui.BasicInfoUpdate.interval = updateInterval
	end

	if previousTab and previousTab ~= TAB_BASIC_INFO then
		NAgui.setTab(previousTab)
	end
end

NAgui.addTab(TAB_ROBLOX_DATA, { order = 8 })
NAgui.setTab(TAB_ROBLOX_DATA)

NAStuff.GitHubLoadingText = "Loading..."
NAStuff.GitHubFailureText = "Failed to load commits"
NAStuff.GitHubEmptyText = "No commits found"
NAStuff.GitHubEndpointField = nil
NAStuff.GitHubCommits = nil
NAStuff.GitHubCommitMessageField = nil
NAStuff.GitHubCommitAuthorField = nil
NAStuff.GitHubCommitDateField = nil
NAStuff.GitHubCommitsLastFetch = 0
NAStuff.GitHubTabInitialized = false
NAStuff.GitHubCommitHeaders = {
	["User-Agent"] = "NamelessAdmin/1.0";
	["Accept"] = "application/vnd.github+json";
	["X-GitHub-Api-Version"] = "2022-11-28";
}

if getgenv and rawget(getgenv(), "GITHUB_TOKEN") then
	local token = tostring(getgenv().GITHUB_TOKEN)
	if token ~= "" then
		NAStuff.GitHubCommitHeaders["Authorization"] = "Bearer "..token
	end
elseif getgenv and rawget(getgenv(), "GITHUB_AUTH") then
	local auth = tostring(getgenv().GITHUB_AUTH)
	if auth ~= "" then
		NAStuff.GitHubCommitHeaders["Authorization"] = auth
	end
end

NAStuff.RobloxVersionEndpoints = {
	"https://weao.xyz/api/versions/current";
	"http://weao.xyz/api/versions/current";
}

if getgenv and rawget(getgenv(), "WEAO_PROXY") and getgenv().WEAO_PROXY ~= "" then
	Insert(NAStuff.RobloxVersionEndpoints, tostring(getgenv().WEAO_PROXY))
end
Insert(NAStuff.RobloxVersionEndpoints, "https://r.jina.ai/http://weao.xyz/api/versions/current")
Insert(NAStuff.RobloxVersionEndpoints, "https://r.jina.ai/http://weao.xyz/api/versions/current?format=json")

NAStuff.RobloxVersionHeaders = {
	["User-Agent"] = "WEAO-3PService";
	["Accept"] = "application/json";
	["Origin"] = "https://weao.xyz";
	["Referer"] = "https://weao.xyz/";
}

if getgenv and rawget(getgenv(), "WEAO_COOKIE") and getgenv().WEAO_COOKIE ~= "" then
	NAStuff.RobloxVersionHeaders["Cookie"] = getgenv().WEAO_COOKIE
end

originalIO.parseRobloxVersionBody=function(body)
	if type(body) ~= "string" then return nil end
	if body:sub(1,3) == "\239\187\191" then body = body:sub(4) end
	local ok, decoded = pcall(HttpService.JSONDecode, HttpService, body)
	if ok and type(decoded) == "table" then return decoded end
	local a,depth,inStr,esc=nil,0,false,false
	for i=1,#body do
		local c=body:sub(i,i)
		if inStr then
			if esc then esc=false elseif c=="\\" then esc=true elseif c=='"' then inStr=false end
		else
			if c=='"' then inStr=true
			elseif c=='{' then depth=depth+1 a=a or i
			elseif c=='}' and depth>0 then
				depth=depth-1
				if depth==0 and a then
					local ok2, j = pcall(HttpService.JSONDecode, HttpService, body:sub(a,i))
					if ok2 and type(j)=="table" then return j end
				end
			end
		end
	end
	return nil
end

originalIO.fetchGitHubCommits = function(forceRefresh)
	local cached = NAStuff.GitHubCommits
	local lastFetch = NAStuff.GitHubCommitsLastFetch or 0
	if cached and not forceRefresh and (tick() - lastFetch) < 300 then
		return true, cached
	end

	local requestFunc = opt and opt.NAREQUEST
	if type(requestFunc) ~= "function" then
		return false, "HTTP request function is unavailable"
	end

	local baseUrl = opt and opt.githubUrl
	if type(baseUrl) ~= "string" or baseUrl == "" then
		return false, "GitHub URL is not configured"
	end

	local endpoints = {}
	local function appendEndpoint(url)
		if url and url ~= "" then
			Insert(endpoints, url)
		end
	end

	appendEndpoint(baseUrl)

	if not baseUrl:lower():find("^https?://r%.jina%.ai/") then
		appendEndpoint("https://r.jina.ai/"..baseUrl)
	end

	if getgenv and rawget(getgenv(), "GITHUB_PROXY") then
		local proxy = tostring(getgenv().GITHUB_PROXY)
		if proxy ~= "" then
			appendEndpoint(proxy)
		end
	end

	local headers = {}
	for key, value in pairs(NAStuff.GitHubCommitHeaders or {}) do
		headers[key] = value
	end

	local lastError
	for _, endpoint in ipairs(endpoints) do
		local sep = endpoint:find("?", 1, true) and "&" or "?"
		local cacheBuster = "_="..tostring(os.time())..tostring(math.random(1, 1e6))
		local url = endpoint..sep..cacheBuster
		local okRequest, response = pcall(requestFunc, {
			Url = url;
			Method = "GET";
			Headers = headers;
			Timeout = 8;
			FollowRedirects = true;
			SslVerify = false;
		})
		if okRequest and response then
			local status = tonumber(response.StatusCode) or tonumber(response.Status)
			local body = response.Body or response.body
			if status == 200 and type(body) == "string" then
				local decodeOk, decoded = pcall(HttpService.JSONDecode, HttpService, body)
				if decodeOk and type(decoded) == "table" then
					NAStuff.GitHubCommits = decoded
					NAStuff.GitHubCommitsLastFetch = tick()
					return true, decoded
				else
					lastError = "Invalid JSON response"
				end
			elseif status == 304 and cached then
				NAStuff.GitHubCommitsLastFetch = tick()
				return true, cached
			else
				local statusText = status and tostring(status) or "unknown"
				lastError = Format("GitHub request failed (HTTP %s)", statusText)
			end
		else
			local err = okRequest and "Unknown response error" or tostring(response)
			lastError = err
		end
	end

	if type(baseUrl) == "string" and baseUrl ~= "" then
		local sep = baseUrl:find("?", 1, true) and "&" or "?"
		local cacheBuster = "_="..tostring(os.time())..tostring(math.random(1, 1e6))
		local directUrl = baseUrl..sep..cacheBuster
		local okDirect, bodyDirect = pcall(function()
			return HttpService:GetAsync(directUrl)
		end)
		if okDirect and type(bodyDirect) == "string" then
			local decodeOk, decoded = pcall(HttpService.JSONDecode, HttpService, bodyDirect)
			if decodeOk and type(decoded) == "table" then
				NAStuff.GitHubCommits = decoded
				NAStuff.GitHubCommitsLastFetch = tick()
				return true, decoded
			end
		end
	end

	return false, lastError or NAStuff.GitHubFailureText
end

originalIO.sanitizeCommitMessage = function(message)
	message = tostring(message or "(no message)")
	message = message:gsub("[%c]", " ")
	message = message:gsub("%s+", " ")
	if #message > 70 then
		message = message:sub(1, 67).."..."
	end
	return message
end

originalIO.formatCommitAuthor = function(commit)
	if type(commit) ~= "table" then
		return "Unknown author"
	end
	local commitInfo = commit.commit or {}
	local authorInfo = commitInfo.author or {}
	local fallbackAuthor = commit.author or {}
	local nickname = authorInfo.name
	local username = fallbackAuthor.login
	if nickname and username then
		if nickname == username then
			return nickname
		else
			return Format("%s (%s)", nickname, username)
		end
	elseif nickname then
		return nickname
	elseif username then
		return username
	end
	return "Unknown author"
end

originalIO.formatCommitDate = function(isoDate)
	if type(isoDate) ~= "string" then
		return "Unknown date", nil
	end
	local year, month, day, hour, minute = isoDate:match("^(%d+)%-(%d+)%-(%d+)T(%d+):(%d+)")
	if year and month and day and hour and minute then
		local display = Format("%02d/%02d/%s %s:%s UTC", tonumber(month), tonumber(day), year, hour, minute)
		local shortDate = Format("%02d/%02d/%s", tonumber(month), tonumber(day), year)
		return display, shortDate
	end
	return isoDate, nil
end

NAmanage.FormatGitHubCommitSummary = function(commit)
	if type(commit) ~= "table" then
		return NAStuff.GitHubFailureText
	end
	local sha = commit.sha and tostring(commit.sha):sub(1, 7) or "unknown"
	local commitInfo = commit.commit or {}
	local message = originalIO.sanitizeCommitMessage(commitInfo.message)
	return Format("%s (%s)", message, sha)
end

NAmanage.UpdateGitHubCommitUI = function(commits, statusMessage)
	commits = commits or NAStuff.GitHubCommits
	local commit = (type(commits) == "table" and commits[1]) or nil
	local messageField = NAStuff.GitHubCommitMessageField
	local authorField = NAStuff.GitHubCommitAuthorField
	local dateField = NAStuff.GitHubCommitDateField

	local endpointField = NAStuff.GitHubEndpointField
	if endpointField then
		endpointField.Text = (type(opt.githubUrl) == "string" and opt.githubUrl ~= "" and opt.githubUrl) or "Unavailable"
	end

	if commit then
		local message = NAmanage.FormatGitHubCommitSummary(commit)
		local authorDisplay = originalIO.formatCommitAuthor(commit)
		local commitInfo = commit.commit or {}
		local authorInfo = commitInfo.author or commitInfo.committer or {}
		local dateDisplay, shortDate = originalIO.formatCommitDate(authorInfo.date)

		if messageField then
			messageField.Text = message or NAStuff.GitHubEmptyText
		end
		if authorField then
			authorField.Text = authorDisplay or NAStuff.GitHubEmptyText
		end
		if dateField then
			dateField.Text = dateDisplay or NAStuff.GitHubEmptyText
		end

		if shortDate then
			opt.NAupdDate = shortDate
		end
	else
		local fallback = statusMessage or NAStuff.GitHubEmptyText
		if messageField then
			messageField.Text = fallback
		end
		if authorField then
			authorField.Text = fallback
		end
		if dateField then
			dateField.Text = fallback
		end
	end
end

NAmanage.RefreshGitHubCommits = function(forceRefresh)
	local ok, result = originalIO.fetchGitHubCommits(forceRefresh)
	if ok then
		NAmanage.UpdateGitHubCommitUI(result)
	else
		local message = result or NAStuff.GitHubFailureText
		if type(message) == "string" and #message > 128 then
			message = message:sub(1, 125).."..."
		end
		warn("[NA] GitHub commit fetch failed:", message)
		NAmanage.UpdateGitHubCommitUI(nil, "Error: "..message)
	end
	return ok
end

NAmanage.UpdateAdminInfoTabDisplayName = function()
	if not TabManager or not TabManager.tabs then return end
	local info = TabManager.tabs[TAB_ADMIN_INFO]
	if not info then return end
	local displayText = (adminName or "Admin").." Info"
	info.displayName = displayText
	if info.button then
		local title = info.button:FindFirstChild("Title")
		if title then
			title.Text = displayText
		end
	end
end

originalIO.fetchRobloxVersionData=function(forceRefresh)
	local cached = NAStuff.RobloxVersionData
	local lastFetch = NAStuff.RobloxVersionLastFetch or 0
	if cached and not forceRefresh and (tick() - lastFetch) < 300 then
		return true, cached
	end

	local requestFunc = opt and opt.NAREQUEST
	for _, baseUrl in ipairs(NAStuff.RobloxVersionEndpoints) do
		if baseUrl and baseUrl ~= "" then
			local url = baseUrl..((Find(baseUrl, "?", 1, true) and "&" or "?").."_="..tostring(os.time())..tostring(math.random(1,1e6)))
			if requestFunc then
				local ok1, response = pcall(requestFunc, { Url = url; Method = "GET"; Headers = NAStuff.RobloxVersionHeaders; Timeout = 6; FollowRedirects = true; SslVerify = false; })
				if ok1 and response then
					local body = response.Body or response.body or response.Data or response.data or response.Text or response.text or response.Content or response.content or response[1]
					body = tostring(body or "")
					local decoded = originalIO.parseRobloxVersionBody(body)
					if decoded then
						NAStuff.RobloxVersionData = decoded
						NAStuff.RobloxVersionLastFetch = tick()
						return true, decoded
					end
				end
				local ok2, response2 = pcall(requestFunc, { Url = url; Method = "GET"; Headers = {["Accept"]="application/json"}; Timeout = 6; FollowRedirects = true; SslVerify = false; })
				if ok2 and response2 then
					local body2 = response2.Body or response2.body or response2.Data or response2.data or response2.Text or response2.text or response2.Content or response2.content or response2[1]
					body2 = tostring(body2 or "")
					local decoded2 = originalIO.parseRobloxVersionBody(body2)
					if decoded2 then
						NAStuff.RobloxVersionData = decoded2
						NAStuff.RobloxVersionLastFetch = tick()
						return true, decoded2
					end
				end
			end
			local ok3, body3 = pcall(function() return game and game.HttpGet and game:HttpGet(url) end)
			if ok3 and type(body3) == "string" then
				local decoded3 = originalIO.parseRobloxVersionBody(body3)
				if decoded3 then
					NAStuff.RobloxVersionData = decoded3
					NAStuff.RobloxVersionLastFetch = tick()
					return true, decoded3
				end
			end
		end
	end

	return false, cached
end

NAStuff.RobloxVersionLoadingText = "Loading..."
NAStuff.RobloxVersionMissingText = "Unavailable"
NAStuff.RobloxVersionFailureText = "Failed to load"

NAStuff.RobloxVersionRows = {}
originalIO.addRobloxVersionSection=function(sectionTitle, versionKey, dateKey)
	NAgui.addSection(sectionTitle)
	local versionField = NAgui.addInfo("Version", NAStuff.RobloxVersionLoadingText)
	local updatedField = NAgui.addInfo("Last Updated", NAStuff.RobloxVersionLoadingText)
	Insert(NAStuff.RobloxVersionRows, {
		versionKey = versionKey;
		dateKey = dateKey;
		versionField = versionField;
		dateField = updatedField;
	})
end

NAgui.addSection("Powered by weao.xyz API")
originalIO.addRobloxVersionSection("Windows", "Windows", "WindowsDate")
originalIO.addRobloxVersionSection("Mac", "Mac", "MacDate")
originalIO.addRobloxVersionSection("Android", "Android", "AndroidDate")
originalIO.addRobloxVersionSection("iOS", "iOS", "iOSDate")

SpawnCall(function()
	local ok, data = originalIO.fetchRobloxVersionData()
	local fallbackText = ok and NAStuff.RobloxVersionMissingText or NAStuff.RobloxVersionFailureText
	for _, entry in ipairs(NAStuff.RobloxVersionRows) do
		if entry.versionField then
			local v = (type(data) == "table" and data[entry.versionKey]) or fallbackText
			entry.versionField.Text = v and tostring(v) or fallbackText
		end
		if entry.dateField then
			local d = (type(data) == "table" and data[entry.dateKey]) or fallbackText
			entry.dateField.Text = d and tostring(d) or fallbackText
		end
	end
end)

NAgui.addTab(TAB_ADMIN_INFO, { order = 9, displayText = adminInfoDisplay })
NAgui.setTab(TAB_ADMIN_INFO)

if NAmanage.UpdateAdminInfoTabDisplayName then
	NAmanage.UpdateAdminInfoTabDisplayName()
end

if not NAStuff.GitHubTabInitialized then
	NAgui.addSection("Latest Commit")
	NAStuff.GitHubCommitMessageField = NAgui.addInfo("Commit", NAStuff.GitHubLoadingText)
	NAStuff.GitHubCommitAuthorField = NAgui.addInfo("Author", NAStuff.GitHubLoadingText)
	NAStuff.GitHubCommitDateField = NAgui.addInfo("Updated", NAStuff.GitHubLoadingText)

	NAgui.addButton("Refresh Commits", function()
		NAmanage.UpdateGitHubCommitUI(nil, NAStuff.GitHubLoadingText)
		SpawnCall(function()
			local ok, result = originalIO.fetchGitHubCommits(true)
			if ok then
				NAmanage.UpdateGitHubCommitUI(result)
				if DoNotif then
					DoNotif("GitHub commits updated.", 2)
				end
			else
				local message = result or NAStuff.GitHubFailureText
				if type(message) == "string" and #message > 128 then
					message = message:sub(1, 125).."..."
				end
				warn("[NA] GitHub commit refresh failed:", message)
				NAmanage.UpdateGitHubCommitUI(nil, "Error: "..tostring(message))
				if DoNotif then
					DoNotif("Failed to refresh GitHub commits.", 3)
				end
			end
		end)
	end)

	NAStuff.GitHubTabInitialized = true
end

NAmanage.UpdateGitHubCommitUI(nil, NAStuff.GitHubLoadingText)

SpawnCall(function()
	NAmanage.RefreshGitHubCommits(false)
end)

NAgui.setTab(NAgui.getActiveTab())

NAgui.setTab(TAB_CHAT)


NAgui.addSection("Chat Tag Customization | disabled for fixing")

--[[NAgui.addInput("Tag Text", "Enter your tag", opt.currentTagText, function(inputText)
	opt.currentTagText = inputText
end)

NAgui.addColorPicker("Tag Color", opt.currentTagColor, function(color)
	opt.currentTagColor = color
end)

NAgui.addToggle("Rainbow Name", opt.currentTagRGB, function(state)
	opt.currentTagRGB = state
end)

NAgui.addButton("Apply Chat Tag", function()
	if opt.currentTagText == "" or not opt.currentTagText then
		DoNotif("Please enter a tag name before applying",2)
		return
	end

	LocalPlayer:SetAttribute("CustomNAtaggerText", opt.currentTagText)
	LocalPlayer:SetAttribute("CustomNAtaggerColor", opt.currentTagColor)
	LocalPlayer:SetAttribute("CustomNAtaggerRainbow", opt.currentTagRGB)

	if FileSupport then
		writefile(NAfiles.NACHATTAG, HttpService:JSONEncode({
			Text = opt.currentTagText;
			Color = {
				R = opt.currentTagColor.R;
				G = opt.currentTagColor.G;
				B = opt.currentTagColor.B;
			};
			RGB = opt.currentTagRGB;
			Save = true;
		}))
	end

	DebugNotif("Custom chat tag applied and saved!",2.5)
end)

NAgui.addButton("Remove Chat Tag", function()
	LocalPlayer:SetAttribute("CustomNAtaggerText", nil)
	LocalPlayer:SetAttribute("CustomNAtaggerColor", nil)
	LocalPlayer:SetAttribute("CustomNAtaggerRainbow", nil)

	if FileSupport and isfile(NAfiles.NACHATTAG) then
		writefile(NAfiles.NACHATTAG, HttpService:JSONEncode({
			Text = opt.currentTagText;
			Color = { R = opt.currentTagColor.R, G = opt.currentTagColor.G, B = opt.currentTagColor.B };
			RGB = opt.currentTagRGB;
			Save = false;
		}))
	end

	DebugNotif("Custom chat tag removed.",2.5)
end)]]

NAgui.setTab(TAB_ALL)

SpawnCall(function()
	Wait()
	if TabManager and TabManager.current ~= TAB_ALL then
		NAgui.setTab(TAB_ALL)
	end
end)

--[[print(
	
███╗░░██╗░█████╗░███╗░░░███╗███████╗██╗░░░░░███████╗░██████╗░██████╗
████╗░██║██╔══██╗████╗░████║██╔════╝██║░░░░░██╔════╝██╔════╝██╔════╝
██╔██╗██║███████║██╔████╔██║█████╗░░██║░░░░░█████╗░░╚█████╗░╚█████╗░
██║╚████║██╔══██║██║╚██╔╝██║██╔══╝░░██║░░░░░██╔══╝░░░╚═══██╗░╚═══██╗
██║░╚███║██║░░██║██║░╚═╝░██║███████╗███████╗███████╗██████╔╝██████╔╝
╚═╝░░╚══╝╚═╝░░╚═╝╚═╝░░░░░╚═╝╚══════╝╚══════╝╚══════╝╚═════╝░╚═════╝░

░█████╗░██████╗░███╗░░░███╗██╗███╗░░██╗
██╔══██╗██╔══██╗████╗░████║██║████╗░██║
███████║██║░░██║██╔████╔██║██║██╔██╗██║
██╔══██║██║░░██║██║╚██╔╝██║██║██║╚████║
██║░░██║██████╔╝██║░╚═╝░██║██║██║░╚███║
╚═╝░░╚═╝╚═════╝░╚═╝░░░░░╚═╝╚═╝╚═╝░░╚══╝

)]]